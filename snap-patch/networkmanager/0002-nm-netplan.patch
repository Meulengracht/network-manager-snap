From 2c8ce0635167a447df9c1cee1c3fbd8bc40b3e48 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Mon, 16 Sep 2019 11:12:57 +0100
Subject: [PATCH 01/78] Import structure based on ifcfg-rh

---
 configure.ac                                  |     7 +
 meson.build                                   |     8 +
 src/settings/plugins/meson.build              |     4 +
 src/settings/plugins/netplan/meson.build      |    48 +
 .../plugins/netplan/nms-netplan-plugin.c      |  1259 ++
 .../plugins/netplan/nms-netplan-plugin.h      |    25 +
 .../plugins/netplan/nms-netplan-reader.c      |  5991 +++++++++
 .../plugins/netplan/nms-netplan-reader.h      |    23 +
 .../plugins/netplan/nms-netplan-utils.c       |   589 +
 .../plugins/netplan/nms-netplan-utils.h       |    90 +
 .../plugins/netplan/nms-netplan-writer.c      |  3464 +++++
 .../plugins/netplan/nms-netplan-writer.h      |    29 +
 .../plugins/netplan/tests/meson.build         |    17 +
 .../plugins/netplan/tests/test-netplan.c      | 10485 ++++++++++++++++
 14 files changed, 22039 insertions(+)
 create mode 100644 src/settings/plugins/netplan/meson.build
 create mode 100644 src/settings/plugins/netplan/nms-netplan-plugin.c
 create mode 100644 src/settings/plugins/netplan/nms-netplan-plugin.h
 create mode 100644 src/settings/plugins/netplan/nms-netplan-reader.c
 create mode 100644 src/settings/plugins/netplan/nms-netplan-reader.h
 create mode 100644 src/settings/plugins/netplan/nms-netplan-utils.c
 create mode 100644 src/settings/plugins/netplan/nms-netplan-utils.h
 create mode 100644 src/settings/plugins/netplan/nms-netplan-writer.c
 create mode 100644 src/settings/plugins/netplan/nms-netplan-writer.h
 create mode 100644 src/settings/plugins/netplan/tests/meson.build
 create mode 100644 src/settings/plugins/netplan/tests/test-netplan.c

diff --git a/configure.ac b/configure.ac
index 4f36e8825fa2f0a08b5bcabe26b11ad8564af27c..66986e52a64a308c41ead80678c80e688ca7fa5b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -143,15 +143,19 @@ AC_CHECK_FUNCS([__secure_getenv secure_getenv])
 
 # Alternative configuration plugins
 AC_ARG_ENABLE(ifcfg-rh, AS_HELP_STRING([--enable-ifcfg-rh], [enable ifcfg-rh configuration plugin (Fedora/RHEL)]))
+AC_ARG_ENABLE(netplan, AS_HELP_STRING([--enable-netplan], [enable netplan configuration plugin (Ubuntu)]))
 AC_ARG_ENABLE(ifupdown, AS_HELP_STRING([--enable-ifupdown], [enable ifupdown configuration plugin (Debian/Ubuntu)]))
 # Default alternative plugins by distribution
 AS_IF([test -z "$enable_ifcfg_rh" -a -d /etc/sysconfig/network-scripts], enable_ifcfg_rh=yes)
+AS_IF([test -z "$enable_netplan" -a -d /etc/netplan], enable_netplan=yes)
 AS_IF([test -z "$enable_ifupdown" -a -f /etc/debian_version],            enable_ifupdown=yes)
 # Otherwise plugins default to "no"
 AS_IF([test -z "$enable_ifcfg_rh"], enable_ifcfg_rh=no)
+AS_IF([test -z "$enable_netplan"], enable_netplan=no)
 AS_IF([test -z "$enable_ifupdown"], enable_ifupdown=no)
 # Create automake conditionals
 AM_CONDITIONAL(CONFIG_PLUGIN_IFCFG_RH, test "$enable_ifcfg_rh" = "yes")
+AM_CONDITIONAL(CONFIG_PLUGIN_NETPLAN, test "$enable_netplan" = "yes")
 AM_CONDITIONAL(CONFIG_PLUGIN_IFUPDOWN, test "$enable_ifupdown" = "yes")
 
 AC_ARG_WITH(config-plugins-default,
@@ -161,11 +165,13 @@ AC_ARG_WITH(config-plugins-default,
 if test -z "$config_plugins_default" -o "$config_plugins_default" = no; then
 	config_plugins_default=''
 	test "$enable_ifcfg_rh" = "yes"           && config_plugins_default="$config_plugins_default,ifcfg-rh"
+	test "$enable_netplan" = "yes"            && config_plugins_default="$config_plugins_default,netplan"
 	test "$enable_ifupdown" = "yes"           && config_plugins_default="$config_plugins_default,ifupdown"
 	config_plugins_default="${config_plugins_default#,}"
 fi
 
 test "$enable_ifcfg_rh" = "yes"           && distro_plugins="$distro_plugins,ifcfg-rh"
+test "$enable_netplan" = "yes"           && distro_plugins="$distro_plugins,netplan"
 test "$enable_ifupdown" = "yes"           && distro_plugins="$distro_plugins,ifupdown"
 distro_plugins="${distro_plugins#,}"
 
@@ -1320,6 +1326,7 @@ echo
 
 echo "Configuration plugins (main.plugins=${config_plugins_default})"
 echo "  ifcfg-rh: ${enable_ifcfg_rh}"
+echo "  netplan: ${enable_netplan}"
 echo "  ifupdown: ${enable_ifupdown}"
 echo
 
diff --git a/meson.build b/meson.build
index 5bd55e6a0884b52a69d7295b3e0d2bbf5f8ae1fe..1d59d95104ac03d33b7c90f384260f394f0225d1 100644
--- a/meson.build
+++ b/meson.build
@@ -279,6 +279,8 @@ glib_dep = declare_dependency(
 
 if run_command('test', '-e', '/etc/sysconfig/network-scripts').returncode() == 0
   distro = 'redhat'
+elif run_command('test', '-e', '/etc/netplan').returncode() == 0
+  distro = 'ubuntu'
 elif run_command('test', '-e', '/etc/SuSE-release').returncode() == 0
   distro = 'suse'
 elif run_command('test', '-e', '/etc/debian_version').returncode() == 0
@@ -290,6 +292,7 @@ else
 endif
 
 enable_ifcfg_rh = get_option('ifcfg_rh') or (distro == 'redhat')
+enable_netplan = get_option('netplan') or (distro == 'ubuntu')
 enable_ifupdown = get_option('ifupdown') or (distro == 'debian')
 
 config_plugins_default = get_option('config_plugins_default')
@@ -300,6 +303,10 @@ if config_plugins_default == ''
     config_plugins += ['ifcfg-rh']
   endif
 
+  if enable_netplan
+    config_plugins += ['netplan']
+  endif
+
   if enable_ifupdown
     config_plugins += ['ifupdown']
   endif
@@ -1006,6 +1013,7 @@ output += '  nmtui: ' + enable_nmtui.to_string() + '\n'
 output += '  nm-cloud-setup: ' + enable_nm_cloud_setup.to_string() + '\n'
 output += '\nConfiguration_plugins (main.plugins=' + config_plugins_default + ')\n'
 output += '  ifcfg-rh: ' + enable_ifcfg_rh.to_string() + '\n'
+output += '  netplan: ' + enable_netplan.to_string() + '\n'
 output += '  ifupdown: ' + enable_ifupdown.to_string() + '\n'
 output += '\nHandlers for /etc/resolv.conf:\n' + resolv_conf_summary
 output += '\n'
diff --git a/src/settings/plugins/meson.build b/src/settings/plugins/meson.build
index 83981aaba77a2fb869191fcc58235664bd729120..c36a69cd35ba342554d4b4924ce9bd4fd8835d55 100644
--- a/src/settings/plugins/meson.build
+++ b/src/settings/plugins/meson.build
@@ -6,6 +6,10 @@ if enable_ifupdown
   subdir('ifupdown')
 endif
 
+if enable_netplan
+  subdir('netplan')
+endif
+
 if enable_tests
   subdir('keyfile/tests')
 endif
diff --git a/src/settings/plugins/netplan/meson.build b/src/settings/plugins/netplan/meson.build
new file mode 100644
index 0000000000000000000000000000000000000000..365ae1a9c50980c1d14d56db9d76dedfb8e9aec7
--- /dev/null
+++ b/src/settings/plugins/netplan/meson.build
@@ -0,0 +1,48 @@
+sources = files(
+  'nms-ifupdown-interface-parser.c',
+  'nms-ifupdown-parser.c',
+)
+
+deps = [
+  libudev_dep,
+  nm_dep,
+]
+
+libnms_ifupdown_core = static_library(
+  'nms-ifupdown-core',
+  sources: sources,
+  dependencies: deps,
+)
+
+sources = files(
+  'nms-ifupdown-plugin.c',
+)
+
+libnm_settings_plugin_ifupdown = shared_module(
+  'nm-settings-plugin-ifupdown',
+  sources: sources,
+  dependencies: deps,
+  link_with: libnms_ifupdown_core,
+  link_args: ldflags_linker_script_settings,
+  link_depends: linker_script_settings,
+  install: true,
+  install_dir: nm_plugindir,
+)
+
+core_plugins += libnm_settings_plugin_ifupdown
+
+# FIXME: check_so_symbols replacement
+'''
+run_target(
+  'check-local-symbols-settings-ifupdown',
+  command: [check_so_symbols, libnm_settings_plugin_ifupdown.full_path()],
+  depends: libnm_settings_plugin_ifupdown,
+)
+
+check-local-symbols-settings-ifupdown: src/settings/plugins/ifupdown/libnm-settings-plugin-ifupdown.la
+  $(call check_so_symbols,$(builddir)/src/settings/plugins/ifupdown/.libs/libnm-settings-plugin-ifupdown.so)
+'''
+
+if enable_tests
+  subdir('tests')
+endif
diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.c b/src/settings/plugins/netplan/nms-netplan-plugin.c
new file mode 100644
index 0000000000000000000000000000000000000000..f438755d98958623d6d0dc06086a83610c0f3072
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.c
@@ -0,0 +1,1259 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * Dan Williams <dcbw@redhat.com>
+ * SÃ¸ren Sandmann <sandmann@daimi.au.dk>
+ *
+ * Copyright (C) 2007 - 2011 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nms-ifcfg-rh-plugin.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "nm-std-aux/c-list-util.h"
+#include "nm-glib-aux/nm-c-list.h"
+#include "nm-glib-aux/nm-io-utils.h"
+#include "nm-std-aux/nm-dbus-compat.h"
+#include "nm-utils.h"
+#include "nm-core-internal.h"
+#include "nm-config.h"
+#include "settings/nm-settings-plugin.h"
+#include "settings/nm-settings-utils.h"
+#include "NetworkManagerUtils.h"
+
+#include "nms-ifcfg-rh-storage.h"
+#include "nms-ifcfg-rh-common.h"
+#include "nms-ifcfg-rh-utils.h"
+#include "nms-ifcfg-rh-reader.h"
+#include "nms-ifcfg-rh-writer.h"
+
+#define IFCFGRH1_BUS_NAME                               "com.redhat.ifcfgrh1"
+#define IFCFGRH1_OBJECT_PATH                            "/com/redhat/ifcfgrh1"
+#define IFCFGRH1_IFACE1_NAME                            "com.redhat.ifcfgrh1"
+#define IFCFGRH1_IFACE1_METHOD_GET_IFCFG_DETAILS        "GetIfcfgDetails"
+
+/*****************************************************************************/
+
+typedef struct {
+	NMConfig *config;
+
+	struct {
+		GDBusConnection *connection;
+		GCancellable *cancellable;
+		gulong signal_id;
+		guint regist_id;
+	} dbus;
+
+	NMSettUtilStorages storages;
+
+	GHashTable *unmanaged_specs;
+	GHashTable *unrecognized_specs;
+
+} NMSIfcfgRHPluginPrivate;
+
+struct _NMSIfcfgRHPlugin {
+	NMSettingsPlugin parent;
+	NMSIfcfgRHPluginPrivate _priv;
+};
+
+struct _NMSIfcfgRHPluginClass {
+	NMSettingsPluginClass parent;
+};
+
+G_DEFINE_TYPE (NMSIfcfgRHPlugin, nms_ifcfg_rh_plugin, NM_TYPE_SETTINGS_PLUGIN)
+
+#define NMS_IFCFG_RH_PLUGIN_GET_PRIVATE(self) _NM_GET_PRIVATE (self, NMSIfcfgRHPlugin, NMS_IS_IFCFG_RH_PLUGIN, NMSettingsPlugin)
+
+/*****************************************************************************/
+
+#define _NMLOG_DOMAIN  LOGD_SETTINGS
+#define _NMLOG(level, ...) \
+    G_STMT_START { \
+        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
+                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
+                "ifcfg-rh: " \
+                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
+    } G_STMT_END
+
+/*****************************************************************************/
+
+static void _unhandled_specs_reset (NMSIfcfgRHPlugin *self);
+
+static void _unhandled_specs_merge_storages (NMSIfcfgRHPlugin *self,
+                                             NMSettUtilStorages *storages);
+
+/*****************************************************************************/
+
+static void
+nm_assert_self (NMSIfcfgRHPlugin *self, gboolean unhandled_specs_consistent)
+{
+	nm_assert (NMS_IS_IFCFG_RH_PLUGIN (self));
+
+#if NM_MORE_ASSERTS > 5
+	{
+		NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+		NMSIfcfgRHStorage *storage;
+		gsize n_uuid;
+		gs_unref_hashtable GHashTable *h_unmanaged = NULL;
+		gs_unref_hashtable GHashTable *h_unrecognized = NULL;
+
+		nm_assert (g_hash_table_size (priv->storages.idx_by_filename) == c_list_length (&priv->storages._storage_lst_head));
+
+		h_unmanaged = g_hash_table_new (nm_str_hash, g_str_equal);
+		h_unrecognized = g_hash_table_new (nm_str_hash, g_str_equal);
+
+		n_uuid = 0;
+
+		c_list_for_each_entry (storage, &priv->storages._storage_lst_head, parent._storage_lst) {
+			const char *uuid;
+			const char *filename;
+
+			filename = nms_ifcfg_rh_storage_get_filename (storage);
+
+			nm_assert (filename && NM_STR_HAS_PREFIX (filename, IFCFG_DIR"/"));
+
+			uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+
+			nm_assert ((!!uuid) + (!!storage->unmanaged_spec) + (!!storage->unrecognized_spec) == 1);
+
+			nm_assert (storage == nm_sett_util_storages_lookup_by_filename (&priv->storages, filename));
+
+			if (uuid) {
+				NMSettUtilStorageByUuidHead *sbuh;
+				NMSettUtilStorageByUuidHead *sbuh2;
+
+				if (storage->connection)
+					nm_assert (nm_streq0 (nm_connection_get_uuid (storage->connection), uuid));
+
+				if (!g_hash_table_lookup_extended (priv->storages.idx_by_uuid, &uuid, (gpointer *) &sbuh, (gpointer *) &sbuh2))
+					nm_assert_not_reached ();
+
+				nm_assert (sbuh);
+				nm_assert (nm_streq (uuid, sbuh->uuid));
+				nm_assert (sbuh == sbuh2);
+				nm_assert (c_list_contains (&sbuh->_storage_by_uuid_lst_head, &storage->parent._storage_by_uuid_lst));
+
+				if (c_list_first (&sbuh->_storage_by_uuid_lst_head) == &storage->parent._storage_by_uuid_lst)
+					n_uuid++;
+			} else if (storage->unmanaged_spec) {
+				nm_assert (strlen (storage->unmanaged_spec) > 0);
+				g_hash_table_add (h_unmanaged, storage->unmanaged_spec);
+			} else if (storage->unrecognized_spec) {
+				nm_assert (strlen (storage->unrecognized_spec) > 0);
+				g_hash_table_add (h_unrecognized, storage->unrecognized_spec);
+			} else
+				nm_assert_not_reached ();
+
+			nm_assert (!storage->connection);
+		}
+
+		nm_assert (g_hash_table_size (priv->storages.idx_by_uuid) == n_uuid);
+
+		if (unhandled_specs_consistent) {
+			nm_assert (nm_utils_hashtable_same_keys (h_unmanaged, priv->unmanaged_specs));
+			nm_assert (nm_utils_hashtable_same_keys (h_unrecognized, priv->unrecognized_specs));
+		}
+	}
+#endif
+}
+
+/*****************************************************************************/
+
+static NMSIfcfgRHStorage *
+_load_file (NMSIfcfgRHPlugin *self,
+            const char *filename,
+            GError **error)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	gs_free_error GError *load_error = NULL;
+	gs_free char *unhandled_spec = NULL;
+	gboolean load_error_ignore;
+	struct stat st;
+
+	if (stat (filename, &st) != 0) {
+		int errsv = errno;
+
+		if (error) {
+			nm_utils_error_set_errno (error, errsv,
+			                          "failure to stat file \%s\": %s",
+			                          filename);
+		} else
+			_LOGT ("load[%s]: failure to stat file: %s", filename, nm_strerror_native (errsv));
+		return NULL;
+	}
+
+	connection = connection_from_file (filename,
+	                                   &unhandled_spec,
+	                                   &load_error,
+	                                   &load_error_ignore);
+	if (load_error) {
+		if (error) {
+			nm_utils_error_set (error, NM_UTILS_ERROR_UNKNOWN,
+			                    "failure to read file \"%s\": %s",
+			                    filename, load_error->message);
+		} else {
+			_NMLOG (load_error_ignore ? LOGL_TRACE : LOGL_WARN,
+			        "load[%s]: failure to read file: %s", filename, load_error->message);
+		}
+		return NULL;
+	}
+
+	if (unhandled_spec) {
+		const char *unmanaged_spec;
+		const char *unrecognized_spec;
+
+		if (!nms_ifcfg_rh_util_parse_unhandled_spec (unhandled_spec,
+		                                             &unmanaged_spec,
+		                                             &unrecognized_spec)) {
+			nm_utils_error_set (error, NM_UTILS_ERROR_UNKNOWN,
+			                    "invalid unhandled spec \"%s\"",
+			                    unhandled_spec);
+			nm_assert_not_reached ();
+			return NULL;
+		}
+		return nms_ifcfg_rh_storage_new_unhandled (self,
+		                                           filename,
+		                                           unmanaged_spec,
+		                                           unrecognized_spec);
+	}
+
+	return nms_ifcfg_rh_storage_new_connection (self,
+	                                            filename,
+	                                            g_steal_pointer (&connection),
+	                                            &st.st_mtim);
+}
+
+static void
+_load_dir (NMSIfcfgRHPlugin *self,
+           NMSettUtilStorages *storages)
+{
+	gs_unref_hashtable GHashTable *dupl_filenames = NULL;
+	gs_free_error GError *local = NULL;
+	const char *f_filename;
+	GDir *dir;
+
+	dir = g_dir_open (IFCFG_DIR, 0, &local);
+	if (!dir) {
+		_LOGT ("Could not read directory '%s': %s", IFCFG_DIR, local->message);
+		return;
+	}
+
+	dupl_filenames = g_hash_table_new_full (nm_str_hash, g_str_equal, NULL, g_free);
+
+	while ((f_filename = g_dir_read_name (dir))) {
+		gs_free char *full_path = NULL;
+		NMSIfcfgRHStorage *storage;
+		char *full_filename;
+
+		full_path = g_build_filename (IFCFG_DIR, f_filename, NULL);
+		full_filename = utils_detect_ifcfg_path (full_path, TRUE);
+		if (!full_filename)
+			continue;
+
+		if (!g_hash_table_add (dupl_filenames, full_filename))
+			continue;
+
+		nm_assert (!nm_sett_util_storages_lookup_by_filename (storages, full_filename));
+
+		storage = _load_file (self,
+		                      full_filename,
+		                      NULL);
+		if (storage)
+			nm_sett_util_storages_add_take (storages, storage);
+	}
+	g_dir_close (dir);
+}
+
+static void
+_storages_consolidate (NMSIfcfgRHPlugin *self,
+                       NMSettUtilStorages *storages_new,
+                       gboolean replace_all,
+                       GHashTable *storages_replaced,
+                       NMSettingsPluginConnectionLoadCallback callback,
+                       gpointer user_data)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	CList lst_conn_info_deleted = C_LIST_INIT (lst_conn_info_deleted);
+	gs_unref_ptrarray GPtrArray *storages_modified = NULL;
+	CList storages_deleted;
+	NMSIfcfgRHStorage *storage_safe;
+	NMSIfcfgRHStorage *storage_new;
+	NMSIfcfgRHStorage *storage_old;
+	NMSIfcfgRHStorage *storage;
+	guint i;
+
+	/* when we reload all files, we must signal add/update/modify of profiles one-by-one.
+	 * NMSettings then goes ahead and emits further signals and a lot of things happen.
+	 *
+	 * So, first, emit an update of the unmanaged/unrecognized specs that contains *all*
+	 * the unmanaged/unrecognized devices from before and after. Since both unmanaged/unrecognized
+	 * specs have the meaning of "not doing something", it makes sense that we temporarily
+	 * disable that action for the sum of before and after. */
+	_unhandled_specs_merge_storages (self, storages_new);
+
+	storages_modified = g_ptr_array_new_with_free_func (g_object_unref);
+	c_list_init (&storages_deleted);
+
+	c_list_for_each_entry (storage_old, &priv->storages._storage_lst_head, parent._storage_lst)
+		storage_old->dirty = TRUE;
+
+	c_list_for_each_entry_safe (storage_new, storage_safe, &storages_new->_storage_lst_head, parent._storage_lst) {
+		storage_old = nm_sett_util_storages_lookup_by_filename (&priv->storages, nms_ifcfg_rh_storage_get_filename (storage_new));
+
+		nm_sett_util_storages_steal (storages_new, storage_new);
+
+		if (   !storage_old
+		    || !nms_ifcfg_rh_storage_equal_type (storage_new, storage_old)) {
+			if (storage_old) {
+				nm_sett_util_storages_steal (&priv->storages, storage_old);
+				if (nms_ifcfg_rh_storage_get_uuid_opt (storage_old))
+					c_list_link_tail (&storages_deleted, &storage_old->parent._storage_lst);
+				else
+					nms_ifcfg_rh_storage_destroy (storage_old);
+			}
+			storage_new->dirty = FALSE;
+			nm_sett_util_storages_add_take (&priv->storages, storage_new);
+			g_ptr_array_add (storages_modified, g_object_ref (storage_new));
+			continue;
+		}
+
+		storage_old->dirty = FALSE;
+		nms_ifcfg_rh_storage_copy_content (storage_old, storage_new);
+		nms_ifcfg_rh_storage_destroy (storage_new);
+		g_ptr_array_add (storages_modified, g_object_ref (storage_old));
+	}
+
+	c_list_for_each_entry_safe (storage_old, storage_safe, &priv->storages._storage_lst_head, parent._storage_lst) {
+		if (!storage_old->dirty)
+			continue;
+		if (   replace_all
+		    || (   storages_replaced
+		        && g_hash_table_contains (storages_replaced, storage_old))) {
+			nm_sett_util_storages_steal (&priv->storages, storage_old);
+			if (nms_ifcfg_rh_storage_get_uuid_opt (storage_old))
+				c_list_link_tail (&storages_deleted, &storage_old->parent._storage_lst);
+			else
+				nms_ifcfg_rh_storage_destroy (storage_old);
+		}
+	}
+
+	/* raise events. */
+
+	for (i = 0; i < storages_modified->len; i++) {
+		storage = storages_modified->pdata[i];
+		storage->dirty = TRUE;
+	}
+
+	for (i = 0; i < storages_modified->len; i++) {
+		gs_unref_object NMConnection *connection = NULL;
+		storage = storages_modified->pdata[i];
+
+		if (!storage->dirty) {
+			/* the entry is no longer dirty. In the meantime we already emited
+			 * another signal for it. */
+			continue;
+		}
+		storage->dirty = FALSE;
+		if (storage != nm_sett_util_storages_lookup_by_filename (&priv->storages, nms_ifcfg_rh_storage_get_filename (storage))) {
+			/* hm? The profile was deleted in the meantime? That is only possible
+			 * if the signal handler called again into the plugin. In any case, the event
+			 * was already emitted. Skip. */
+			continue;
+		}
+
+		connection = nms_ifcfg_rh_storage_steal_connection (storage);
+		if (!connection) {
+			nm_assert (!nms_ifcfg_rh_storage_get_uuid_opt (storage));
+			continue;
+		}
+
+		nm_assert (NM_IS_CONNECTION (connection));
+		nm_assert (nms_ifcfg_rh_storage_get_uuid_opt (storage));
+		callback (NM_SETTINGS_PLUGIN (self),
+		          NM_SETTINGS_STORAGE (storage),
+		          connection,
+		          user_data);
+	}
+
+	while ((storage = c_list_first_entry (&storages_deleted, NMSIfcfgRHStorage, parent._storage_lst))) {
+		c_list_unlink (&storage->parent._storage_lst);
+		callback (NM_SETTINGS_PLUGIN (self),
+		          NM_SETTINGS_STORAGE (storage),
+		          NULL,
+		          user_data);
+		nms_ifcfg_rh_storage_destroy (storage);
+	}
+}
+
+/*****************************************************************************/
+
+static void
+load_connections (NMSettingsPlugin *plugin,
+                  NMSettingsPluginConnectionLoadEntry *entries,
+                  gsize n_entries,
+                  NMSettingsPluginConnectionLoadCallback callback,
+                  gpointer user_data)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	nm_auto_clear_sett_util_storages NMSettUtilStorages storages_new = NM_SETT_UTIL_STORAGES_INIT (storages_new, nms_ifcfg_rh_storage_destroy);
+	gs_unref_hashtable GHashTable *dupl_filenames = NULL;
+	gs_unref_hashtable GHashTable *storages_replaced = NULL;
+	gs_unref_hashtable GHashTable *loaded_uuids = NULL;
+	const char *loaded_uuid;
+	GHashTableIter h_iter;
+	gsize i;
+
+	if (n_entries == 0)
+		return;
+
+	dupl_filenames = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
+
+	loaded_uuids = g_hash_table_new (nm_str_hash, g_str_equal);
+
+	storages_replaced = g_hash_table_new_full (nm_direct_hash, NULL, g_object_unref, NULL);
+
+	for (i = 0; i < n_entries; i++) {
+		NMSettingsPluginConnectionLoadEntry *const entry = &entries[i];
+		gs_free_error GError *local = NULL;
+		const char *full_filename;
+		const char *uuid;
+		gs_free char *full_filename_keep = NULL;
+		NMSettingsPluginConnectionLoadEntry *dupl_content_entry;
+		gs_unref_object NMSIfcfgRHStorage *storage = NULL;
+
+		if (entry->handled)
+			continue;
+
+		if (entry->filename[0] != '/')
+			continue;
+
+		full_filename_keep = utils_detect_ifcfg_path (entry->filename, FALSE);
+
+		if (!full_filename_keep) {
+			if (nm_utils_file_is_in_path (entry->filename, IFCFG_DIR)) {
+				nm_utils_error_set (&entry->error,
+				                    NM_UTILS_ERROR_UNKNOWN,
+				                    ("path is not a valid name for an ifcfg-rh file"));
+				entry->handled = TRUE;
+			}
+			continue;
+		}
+
+		if ((dupl_content_entry = g_hash_table_lookup (dupl_filenames, full_filename_keep))) {
+			/* we already visited this file. */
+			entry->handled = dupl_content_entry->handled;
+			if (dupl_content_entry->error) {
+				g_set_error_literal (&entry->error,
+				                     dupl_content_entry->error->domain,
+				                     dupl_content_entry->error->code,
+				                     dupl_content_entry->error->message);
+			}
+			continue;
+		}
+
+		entry->handled = TRUE;
+
+		full_filename = full_filename_keep;
+		if (!g_hash_table_insert (dupl_filenames, g_steal_pointer (&full_filename_keep), entry))
+			nm_assert_not_reached ();
+
+		storage = _load_file (self,
+		                      full_filename,
+		                      &local);
+		if (!storage) {
+			if (nm_utils_file_stat (full_filename, NULL) == -ENOENT) {
+				NMSIfcfgRHStorage *storage2;
+
+				/* the file does not exist. We take that as indication to unload the file
+				 * that was previously loaded... */
+				storage2 = nm_sett_util_storages_lookup_by_filename (&priv->storages, full_filename);
+				if (storage2)
+					g_hash_table_add (storages_replaced, g_object_ref (storage2));
+				continue;
+			}
+			g_propagate_error (&entry->error, g_steal_pointer (&local));
+			continue;
+		}
+
+		uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+		if (uuid)
+			g_hash_table_add (loaded_uuids, (char *) uuid);
+
+		nm_sett_util_storages_add_take (&storages_new, g_steal_pointer (&storage));
+	}
+
+	/* now we visit all UUIDs that are about to change... */
+	g_hash_table_iter_init (&h_iter, loaded_uuids);
+	while (g_hash_table_iter_next (&h_iter, (gpointer *) &loaded_uuid, NULL)) {
+		NMSIfcfgRHStorage *storage;
+		NMSettUtilStorageByUuidHead *sbuh;
+
+		sbuh = nm_sett_util_storages_lookup_by_uuid (&priv->storages, loaded_uuid);
+		if (!sbuh)
+			continue;
+
+		c_list_for_each_entry (storage, &sbuh->_storage_by_uuid_lst_head, parent._storage_by_uuid_lst) {
+			const char *full_filename = nms_ifcfg_rh_storage_get_filename (storage);
+			gs_unref_object NMSIfcfgRHStorage *storage_new = NULL;
+			gs_free_error GError *local = NULL;
+
+			if (g_hash_table_contains (dupl_filenames, full_filename)) {
+				/* already re-loaded. */
+				continue;
+			}
+
+			/* @storage has a UUID that was just loaded from disk, but we have an entry in cache.
+			 * Reload that file too despite not being told to do so. The reason is to get
+			 * the latest file timestamp so that we get the priorities right. */
+
+			storage_new = _load_file (self,
+			                          full_filename,
+			                          &local);
+			if (   storage_new
+			    && !nm_streq0 (loaded_uuid, nms_ifcfg_rh_storage_get_uuid_opt (storage_new))) {
+				/* the file now references a different UUID. We are not told to reload
+				 * that file, so this means the existing storage (with the previous
+				 * filename and UUID tuple) is no longer valid. */
+				g_clear_object (&storage_new);
+			}
+
+			g_hash_table_add (storages_replaced, g_object_ref (storage));
+			if (storage_new)
+				nm_sett_util_storages_add_take (&storages_new, g_steal_pointer (&storage_new));
+		}
+	}
+
+	nm_clear_pointer (&loaded_uuids, g_hash_table_destroy);
+	nm_clear_pointer (&dupl_filenames, g_hash_table_destroy);
+
+	_storages_consolidate (self,
+	                       &storages_new,
+	                       FALSE,
+	                       storages_replaced,
+	                       callback,
+	                       user_data);
+}
+
+static void
+reload_connections (NMSettingsPlugin *plugin,
+                    NMSettingsPluginConnectionLoadCallback callback,
+                    gpointer user_data)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+	nm_auto_clear_sett_util_storages NMSettUtilStorages storages_new = NM_SETT_UTIL_STORAGES_INIT (storages_new, nms_ifcfg_rh_storage_destroy);
+
+	nm_assert_self (self, TRUE);
+
+	_load_dir (self, &storages_new);
+
+	_storages_consolidate (self,
+	                       &storages_new,
+	                       TRUE,
+	                       NULL,
+	                       callback,
+	                       user_data);
+
+	nm_assert_self (self, FALSE);
+}
+
+static void
+load_connections_done (NMSettingsPlugin *plugin)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+
+	/* at the beginning of a load, we emit a change signal for unmanaged/unrecognized
+	 * specs that contain the sum of before and after (_unhandled_specs_merge_storages()).
+	 *
+	 * The idea is that while we emit signals about changes to connection, we have
+	 * the sum of all unmanaged/unrecognized devices from before and after.
+	 *
+	 * This if triggered at the end, to reset the specs. */
+	_unhandled_specs_reset (self);
+
+	nm_assert_self (self, TRUE);
+}
+
+/*****************************************************************************/
+
+static gboolean
+add_connection (NMSettingsPlugin *plugin,
+                NMConnection *connection,
+                NMSettingsStorage **out_storage,
+                NMConnection **out_connection,
+                GError **error)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	gs_unref_object NMSIfcfgRHStorage *storage = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	gs_free char *full_filename = NULL;
+	GError *local = NULL;
+	gboolean reread_same;
+	struct timespec mtime;
+
+	nm_assert_self (self, TRUE);
+	nm_assert (NM_IS_CONNECTION (connection));
+	nm_assert (out_storage && !*out_storage);
+	nm_assert (out_connection && !*out_connection);
+
+	if (!nms_ifcfg_rh_writer_write_connection (connection,
+	                                           IFCFG_DIR,
+	                                           NULL,
+	                                           nm_sett_util_allow_filename_cb,
+	                                           NM_SETT_UTIL_ALLOW_FILENAME_DATA (&priv->storages, NULL),
+	                                           &full_filename,
+	                                           &reread,
+	                                           &reread_same,
+	                                           &local)) {
+		_LOGT ("commit: %s (%s): failed to add: %s",
+		       nm_connection_get_uuid (connection),
+		       nm_connection_get_id (connection),
+		       local->message);
+		g_propagate_error (error, local);
+		return FALSE;
+	}
+
+	if (   !reread
+	    || reread_same)
+		nm_g_object_ref_set (&reread, connection);
+
+	nm_assert (full_filename && full_filename[0] == '/');
+
+	_LOGT ("commit: %s (%s) added as \"%s\"",
+	       nm_connection_get_uuid (reread),
+	       nm_connection_get_id (reread),
+	       full_filename);
+
+	storage = nms_ifcfg_rh_storage_new_connection (self,
+	                                               full_filename,
+	                                               g_steal_pointer (&reread),
+	                                               nm_sett_util_stat_mtime (full_filename, FALSE, &mtime));
+
+	nm_sett_util_storages_add_take (&priv->storages, g_object_ref (storage));
+
+	*out_connection = nms_ifcfg_rh_storage_steal_connection (storage);
+	*out_storage = NM_SETTINGS_STORAGE (g_steal_pointer (&storage));
+
+	nm_assert_self (self, TRUE);
+
+	return TRUE;
+}
+
+static gboolean
+update_connection (NMSettingsPlugin *plugin,
+                   NMSettingsStorage *storage_x,
+                   NMConnection *connection,
+                   NMSettingsStorage **out_storage,
+                   NMConnection **out_connection,
+                   GError **error)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	NMSIfcfgRHStorage *storage = NMS_IFCFG_RH_STORAGE (storage_x);
+	const char *full_filename;
+	const char *uuid;
+	GError *local = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean reread_same;
+	struct timespec mtime;
+
+	nm_assert_self (self, TRUE);
+	nm_assert (NM_IS_CONNECTION (connection));
+	nm_assert (NMS_IS_IFCFG_RH_STORAGE (storage));
+	nm_assert (_nm_connection_verify (connection, NULL) == NM_SETTING_VERIFY_SUCCESS);
+	nm_assert (!error || !*error);
+
+	uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+
+	nm_assert (uuid && nm_streq0 (uuid, nm_connection_get_uuid (connection)));
+
+	full_filename = nms_ifcfg_rh_storage_get_filename (storage);
+
+	nm_assert (full_filename);
+	nm_assert (storage == nm_sett_util_storages_lookup_by_filename (&priv->storages, full_filename));
+
+	if (!nms_ifcfg_rh_writer_write_connection (connection,
+	                                           IFCFG_DIR,
+	                                           full_filename,
+	                                           nm_sett_util_allow_filename_cb,
+	                                           NM_SETT_UTIL_ALLOW_FILENAME_DATA (&priv->storages, full_filename),
+	                                           NULL,
+	                                           &reread,
+	                                           &reread_same,
+	                                           &local)) {
+		_LOGT ("commit: failure to write %s (%s) to \"%s\": %s",
+		       nm_connection_get_uuid (connection),
+		       nm_connection_get_id (connection),
+		       full_filename,
+		       local->message);
+		g_propagate_error (error, local);
+		return FALSE;
+	}
+
+	if (   !reread
+	    || reread_same)
+		nm_g_object_ref_set (&reread, connection);
+
+	_LOGT ("commit: \"%s\": profile %s (%s) written",
+	       full_filename,
+	       uuid,
+	       nm_connection_get_id (connection));
+
+	storage->stat_mtime = *nm_sett_util_stat_mtime (full_filename, FALSE, &mtime);
+
+	*out_storage = NM_SETTINGS_STORAGE (g_object_ref (storage));
+	*out_connection = g_steal_pointer (&reread);
+
+	nm_assert_self (self, TRUE);
+
+	return TRUE;
+}
+
+static gboolean
+delete_connection (NMSettingsPlugin *plugin,
+                   NMSettingsStorage *storage_x,
+                   GError **error)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	NMSIfcfgRHStorage *storage = NMS_IFCFG_RH_STORAGE (storage_x);
+	const char *operation_message;
+	const char *full_filename;
+
+	nm_assert_self (self, TRUE);
+	nm_assert (!error || !*error);
+	nm_assert (NMS_IS_IFCFG_RH_STORAGE (storage));
+
+	full_filename = nms_ifcfg_rh_storage_get_filename (storage);
+	nm_assert (full_filename);
+
+	nm_assert (nms_ifcfg_rh_storage_get_uuid_opt (storage));
+
+	nm_assert (storage == nm_sett_util_storages_lookup_by_filename (&priv->storages, full_filename));
+
+	{
+		gs_free char *keyfile = utils_get_keys_path (full_filename);
+		gs_free char *routefile = utils_get_route_path (full_filename);
+		gs_free char *route6file = utils_get_route6_path (full_filename);
+		const char *const files[] = { full_filename, keyfile, routefile, route6file };
+		gboolean any_deleted = FALSE;
+		gboolean any_failure = FALSE;
+		int i;
+
+		for (i = 0; i < G_N_ELEMENTS (files); i++) {
+			int errsv;
+
+			if (unlink (files[i]) == 0) {
+				any_deleted = TRUE;
+				continue;
+			}
+			errsv = errno;
+			if (errsv == ENOENT)
+				continue;
+
+			_LOGW ("commit: failure to delete file \"%s\": %s",
+			       files[i],
+			       nm_strerror_native (errsv));
+			any_failure = TRUE;
+		}
+		if (any_failure)
+			operation_message = "failed to delete files from disk";
+		else if (any_deleted)
+			operation_message = "deleted from disk";
+		else
+			operation_message = "does not exist on disk";
+	}
+
+	_LOGT ("commit: deleted \"%s\", profile %s (%s)",
+	       full_filename,
+	       nms_ifcfg_rh_storage_get_uuid_opt (storage),
+	       operation_message);
+
+	nm_sett_util_storages_steal (&priv->storages, storage);
+	nms_ifcfg_rh_storage_destroy (storage);
+
+	nm_assert_self (self, TRUE);
+
+	return TRUE;
+}
+
+/*****************************************************************************/
+
+static void
+_unhandled_specs_reset (NMSIfcfgRHPlugin *self)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	gs_unref_hashtable GHashTable *unmanaged_specs = NULL;
+	gs_unref_hashtable GHashTable *unrecognized_specs = NULL;
+	NMSIfcfgRHStorage *storage;
+
+	unmanaged_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
+	unrecognized_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
+
+	c_list_for_each_entry (storage, &priv->storages._storage_lst_head, parent._storage_lst) {
+		if (storage->unmanaged_spec)
+			g_hash_table_add (unmanaged_specs, g_strdup (storage->unmanaged_spec));
+		if (storage->unrecognized_spec)
+			g_hash_table_add (unrecognized_specs, g_strdup (storage->unrecognized_spec));
+	}
+
+	if (!nm_utils_hashtable_same_keys (unmanaged_specs, priv->unmanaged_specs)) {
+		g_hash_table_unref (priv->unmanaged_specs);
+		priv->unmanaged_specs = g_steal_pointer (&unmanaged_specs);
+	}
+	if (!nm_utils_hashtable_same_keys (unrecognized_specs, priv->unrecognized_specs)) {
+		g_hash_table_unref (priv->unrecognized_specs);
+		priv->unrecognized_specs = g_steal_pointer (&unrecognized_specs);
+	}
+
+	if (!unmanaged_specs)
+		_nm_settings_plugin_emit_signal_unmanaged_specs_changed (NM_SETTINGS_PLUGIN (self));
+	if (!unrecognized_specs)
+		_nm_settings_plugin_emit_signal_unrecognized_specs_changed (NM_SETTINGS_PLUGIN (self));
+}
+
+static void
+_unhandled_specs_merge_storages (NMSIfcfgRHPlugin *self,
+                                 NMSettUtilStorages *storages)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	gboolean unmanaged_changed = FALSE;
+	gboolean unrecognized_changed = FALSE;
+	NMSIfcfgRHStorage *storage;
+
+	c_list_for_each_entry (storage, &storages->_storage_lst_head, parent._storage_lst) {
+		if (   storage->unmanaged_spec
+		    && !g_hash_table_contains (priv->unmanaged_specs, storage->unmanaged_spec)) {
+			unmanaged_changed = TRUE;
+			g_hash_table_add (priv->unmanaged_specs, g_strdup (storage->unmanaged_spec));
+		}
+		if (   storage->unrecognized_spec
+		    && !g_hash_table_contains (priv->unrecognized_specs, storage->unrecognized_spec)) {
+			unrecognized_changed = TRUE;
+			g_hash_table_add (priv->unrecognized_specs, g_strdup (storage->unrecognized_spec));
+		}
+	}
+
+	if (unmanaged_changed)
+		_nm_settings_plugin_emit_signal_unmanaged_specs_changed (NM_SETTINGS_PLUGIN (self));
+	if (unrecognized_changed)
+		_nm_settings_plugin_emit_signal_unrecognized_specs_changed (NM_SETTINGS_PLUGIN (self));
+}
+
+static GSList *
+_unhandled_specs_from_hashtable (GHashTable *hash)
+{
+	gs_free const char **keys = NULL;
+	GSList *list = NULL;
+	guint i, l;
+
+	keys = nm_utils_strdict_get_keys (hash, TRUE, &l);
+	for (i = l; i > 0; ) {
+		i--;
+		list = g_slist_prepend (list, g_strdup (keys[i]));
+	}
+	return list;
+}
+
+static GSList *
+get_unmanaged_specs (NMSettingsPlugin *plugin)
+{
+	return _unhandled_specs_from_hashtable (NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (plugin)->unmanaged_specs);
+}
+
+static GSList *
+get_unrecognized_specs (NMSettingsPlugin *plugin)
+{
+	return _unhandled_specs_from_hashtable (NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (plugin)->unrecognized_specs);
+}
+
+/*****************************************************************************/
+
+static void
+impl_ifcfgrh_get_ifcfg_details (NMSIfcfgRHPlugin *self,
+                                GDBusMethodInvocation *context,
+                                const char *in_ifcfg)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	gs_free char *ifcfg_path = NULL;
+	NMSIfcfgRHStorage *storage;
+	const char *uuid;
+	const char *path;
+
+	if (in_ifcfg[0] != '/') {
+		g_dbus_method_invocation_return_error (context,
+		                                       NM_SETTINGS_ERROR,
+		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                                       "ifcfg path '%s' is not absolute", in_ifcfg);
+		return;
+	}
+
+	ifcfg_path = utils_detect_ifcfg_path (in_ifcfg, TRUE);
+	if (!ifcfg_path) {
+		g_dbus_method_invocation_return_error (context,
+		                                       NM_SETTINGS_ERROR,
+		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                                       "ifcfg path '%s' is not an ifcfg base file", in_ifcfg);
+		return;
+	}
+
+	storage = nm_sett_util_storages_lookup_by_filename (&priv->storages, ifcfg_path);
+	if (!storage) {
+		g_dbus_method_invocation_return_error (context,
+		                                       NM_SETTINGS_ERROR,
+		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                                       "ifcfg file '%s' unknown", in_ifcfg);
+		return;
+	}
+
+	uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+	if (!uuid) {
+		g_dbus_method_invocation_return_error (context,
+		                                       NM_SETTINGS_ERROR,
+		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                                       "ifcfg file '%s' not managed by NetworkManager", in_ifcfg);
+		return;
+	}
+
+	/* It is ugly that the ifcfg-rh plugin needs to call back into NMSettings this
+	 * way.
+	 * There are alternatives (like invoking a signal), but they are all significant
+	 * extra code (and performance overhead). So the quick and dirty solution here
+	 * is likely to be simpler than getting this right (also from point of readability!).
+	 */
+	path = nm_settings_get_dbus_path_for_uuid (nm_settings_get (), uuid);
+
+	if (!path) {
+		g_dbus_method_invocation_return_error (context,
+		                                       NM_SETTINGS_ERROR,
+		                                       NM_SETTINGS_ERROR_FAILED,
+		                                       "unable to get the connection D-Bus path");
+		return;
+	}
+
+	g_dbus_method_invocation_return_value (context,
+	                                       g_variant_new ("(so)", uuid, path));
+}
+
+/*****************************************************************************/
+
+static void
+_dbus_clear (NMSIfcfgRHPlugin *self)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	guint id;
+
+	nm_clear_g_signal_handler (priv->dbus.connection, &priv->dbus.signal_id);
+
+	nm_clear_g_cancellable (&priv->dbus.cancellable);
+
+	if ((id = nm_steal_int (&priv->dbus.regist_id))) {
+		if (!g_dbus_connection_unregister_object (priv->dbus.connection, id))
+			_LOGW ("dbus: unexpected failure to unregister object");
+	}
+
+	g_clear_object (&priv->dbus.connection);
+}
+
+static void
+_dbus_connection_closed (GDBusConnection *connection,
+                         gboolean         remote_peer_vanished,
+                         GError          *error,
+                         gpointer         user_data)
+{
+	_LOGW ("dbus: %s bus closed", IFCFGRH1_BUS_NAME);
+	_dbus_clear (NMS_IFCFG_RH_PLUGIN (user_data));
+
+	/* Retry or recover? */
+}
+
+static void
+_method_call (GDBusConnection *connection,
+              const char *sender,
+              const char *object_path,
+              const char *interface_name,
+              const char *method_name,
+              GVariant *parameters,
+              GDBusMethodInvocation *invocation,
+              gpointer user_data)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (user_data);
+
+	if (nm_streq (interface_name, IFCFGRH1_IFACE1_NAME)) {
+		if (nm_streq (method_name, IFCFGRH1_IFACE1_METHOD_GET_IFCFG_DETAILS)) {
+			const char *ifcfg;
+
+			g_variant_get (parameters, "(&s)", &ifcfg);
+			impl_ifcfgrh_get_ifcfg_details (self, invocation, ifcfg);
+			return;
+		}
+	}
+
+	g_dbus_method_invocation_return_error (invocation,
+	                                       G_DBUS_ERROR,
+	                                       G_DBUS_ERROR_UNKNOWN_METHOD,
+	                                       "Unknown method %s",
+	                                       method_name);
+}
+
+static GDBusInterfaceInfo *const interface_info = NM_DEFINE_GDBUS_INTERFACE_INFO (
+	IFCFGRH1_IFACE1_NAME,
+	.methods = NM_DEFINE_GDBUS_METHOD_INFOS (
+		NM_DEFINE_GDBUS_METHOD_INFO (
+			IFCFGRH1_IFACE1_METHOD_GET_IFCFG_DETAILS,
+			.in_args = NM_DEFINE_GDBUS_ARG_INFOS (
+				NM_DEFINE_GDBUS_ARG_INFO ("ifcfg", "s"),
+			),
+			.out_args = NM_DEFINE_GDBUS_ARG_INFOS (
+				NM_DEFINE_GDBUS_ARG_INFO ("uuid", "s"),
+				NM_DEFINE_GDBUS_ARG_INFO ("path", "o"),
+			),
+		),
+	),
+);
+
+static void
+_dbus_request_name_done (GObject *source_object,
+                         GAsyncResult *res,
+                         gpointer user_data)
+{
+	GDBusConnection *connection = G_DBUS_CONNECTION (source_object);
+	NMSIfcfgRHPlugin *self;
+	NMSIfcfgRHPluginPrivate *priv;
+	gs_free_error GError *error = NULL;
+	gs_unref_variant GVariant *ret = NULL;
+	guint32 result;
+
+	ret = g_dbus_connection_call_finish (connection, res, &error);
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+		return;
+
+	self = NMS_IFCFG_RH_PLUGIN (user_data);
+	priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+
+	g_clear_object (&priv->dbus.cancellable);
+
+	if (!ret) {
+		_LOGW ("dbus: couldn't acquire D-Bus service: %s", error->message);
+		_dbus_clear (self);
+		return;
+	}
+
+	g_variant_get (ret, "(u)", &result);
+
+	if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
+		_LOGW ("dbus: couldn't acquire ifcfgrh1 D-Bus service (already taken)");
+		_dbus_clear (self);
+		return;
+	}
+
+	{
+		static const GDBusInterfaceVTable interface_vtable = {
+			.method_call = _method_call,
+		};
+
+		priv->dbus.regist_id = g_dbus_connection_register_object (connection,
+		                                                          IFCFGRH1_OBJECT_PATH,
+		                                                          interface_info,
+		                                                          NM_UNCONST_PTR (GDBusInterfaceVTable, &interface_vtable),
+		                                                          self,
+		                                                          NULL,
+		                                                          &error);
+		if (!priv->dbus.regist_id) {
+			_LOGW ("dbus: couldn't register D-Bus service: %s", error->message);
+			_dbus_clear (self);
+			return;
+		}
+	}
+
+	_LOGD ("dbus: acquired D-Bus service %s and exported %s object",
+	       IFCFGRH1_BUS_NAME,
+	       IFCFGRH1_OBJECT_PATH);
+}
+
+static void
+_dbus_create_done (GObject *source_object,
+                   GAsyncResult *res,
+                   gpointer user_data)
+{
+	NMSIfcfgRHPlugin *self;
+	NMSIfcfgRHPluginPrivate *priv;
+	gs_free_error GError *error = NULL;
+	GDBusConnection *connection;
+
+	connection = g_dbus_connection_new_for_address_finish (res, &error);
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+		return;
+
+	self = NMS_IFCFG_RH_PLUGIN (user_data);
+	priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+
+	g_clear_object (&priv->dbus.cancellable);
+
+	if (!connection) {
+		_LOGW ("dbus: couldn't initialize system bus: %s", error->message);
+		return;
+	}
+
+	priv->dbus.connection = connection;
+	priv->dbus.cancellable = g_cancellable_new ();
+
+	priv->dbus.signal_id = g_signal_connect (priv->dbus.connection,
+	                                         "closed",
+	                                         G_CALLBACK (_dbus_connection_closed),
+	                                         self);
+
+	g_dbus_connection_call (priv->dbus.connection,
+	                        DBUS_SERVICE_DBUS,
+	                        DBUS_PATH_DBUS,
+	                        DBUS_INTERFACE_DBUS,
+	                        "RequestName",
+	                        g_variant_new ("(su)",
+	                                       IFCFGRH1_BUS_NAME,
+	                                       DBUS_NAME_FLAG_DO_NOT_QUEUE),
+	                        G_VARIANT_TYPE ("(u)"),
+	                        G_DBUS_CALL_FLAGS_NONE,
+	                        -1,
+	                        priv->dbus.cancellable,
+	                        _dbus_request_name_done,
+	                        self);
+}
+
+static void
+_dbus_setup (NMSIfcfgRHPlugin *self)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	gs_free char *address = NULL;
+	gs_free_error GError *error = NULL;
+
+	_dbus_clear (self);
+
+	address = g_dbus_address_get_for_bus_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+	if (address == NULL) {
+		_LOGW ("dbus: failed getting address for system bus: %s", error->message);
+		return;
+	}
+
+	priv->dbus.cancellable = g_cancellable_new ();
+
+	g_dbus_connection_new_for_address (address,
+	                                   G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT
+	                                   | G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
+	                                   NULL,
+	                                   priv->dbus.cancellable,
+	                                   _dbus_create_done,
+	                                   self);
+}
+
+static void
+config_changed_cb (NMConfig *config,
+                   NMConfigData *config_data,
+                   NMConfigChangeFlags changes,
+                   NMConfigData *old_data,
+                   NMSIfcfgRHPlugin *self)
+{
+	NMSIfcfgRHPluginPrivate *priv;
+
+	/* If the dbus connection for some reason is borked the D-Bus service
+	 * won't be offered.
+	 *
+	 * On SIGHUP and SIGUSR1 try to re-connect to D-Bus. So in the unlikely
+	 * event that the D-Bus connection is broken, that allows for recovery
+	 * without need for restarting NetworkManager. */
+	if (!NM_FLAGS_ANY (changes,   NM_CONFIG_CHANGE_CAUSE_SIGHUP
+	                            | NM_CONFIG_CHANGE_CAUSE_SIGUSR1))
+		return;
+
+	priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	if (   !priv->dbus.connection
+	    && !priv->dbus.cancellable)
+		_dbus_setup (self);
+}
+
+/*****************************************************************************/
+
+static void
+nms_ifcfg_rh_plugin_init (NMSIfcfgRHPlugin *self)
+{
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+
+	priv->config = g_object_ref (nm_config_get ());
+
+	priv->unmanaged_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
+	priv->unrecognized_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
+
+	priv->storages = (NMSettUtilStorages) NM_SETT_UTIL_STORAGES_INIT (priv->storages, nms_ifcfg_rh_storage_destroy);
+}
+
+static void
+constructed (GObject *object)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (object);
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+
+	G_OBJECT_CLASS (nms_ifcfg_rh_plugin_parent_class)->constructed (object);
+
+	g_signal_connect (priv->config,
+	                  NM_CONFIG_SIGNAL_CONFIG_CHANGED,
+	                  G_CALLBACK (config_changed_cb),
+	                  self);
+
+	_dbus_setup (self);
+}
+
+static void
+dispose (GObject *object)
+{
+	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (object);
+	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+
+	if (priv->config)
+		g_signal_handlers_disconnect_by_func (priv->config, config_changed_cb, self);
+
+	/* FIXME(shutdown) we need a stop method so that we can unregistering the D-Bus service
+	 * when NMSettings is shutting down, and not when the instance gets destroyed. */
+	_dbus_clear (self);
+
+	nm_sett_util_storages_clear (&priv->storages);
+
+	g_clear_object (&priv->config);
+
+	G_OBJECT_CLASS (nms_ifcfg_rh_plugin_parent_class)->dispose (object);
+
+	nm_clear_pointer (&priv->unmanaged_specs, g_hash_table_destroy);
+	nm_clear_pointer (&priv->unrecognized_specs, g_hash_table_destroy);
+}
+
+static void
+nms_ifcfg_rh_plugin_class_init (NMSIfcfgRHPluginClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	NMSettingsPluginClass *plugin_class = NM_SETTINGS_PLUGIN_CLASS (klass);
+
+	object_class->constructed = constructed;
+	object_class->dispose     = dispose;
+
+	plugin_class->plugin_name            = "ifcfg-rh";
+	plugin_class->get_unmanaged_specs    = get_unmanaged_specs;
+	plugin_class->get_unrecognized_specs = get_unrecognized_specs;
+	plugin_class->reload_connections     = reload_connections;
+	plugin_class->load_connections       = load_connections;
+	plugin_class->load_connections_done  = load_connections_done;
+	plugin_class->add_connection         = add_connection;
+	plugin_class->update_connection      = update_connection;
+	plugin_class->delete_connection      = delete_connection;
+}
+
+/*****************************************************************************/
+
+G_MODULE_EXPORT NMSettingsPlugin *
+nm_settings_plugin_factory (void)
+{
+	return g_object_new (NMS_TYPE_IFCFG_RH_PLUGIN, NULL);
+}
diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.h b/src/settings/plugins/netplan/nms-netplan-plugin.h
new file mode 100644
index 0000000000000000000000000000000000000000..a226b323049f42da29a4a001d28874bb6e687a55
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.h
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * Dan Williams <dcbw@redhat.com>
+ * SÃ¸ren Sandmann <sandmann@daimi.au.dk>
+ *
+ * Copyright (C) 2007 - 2008 Red Hat, Inc.
+ */
+
+#ifndef __NMS_IFCFG_RH_PLUGIN_H__
+#define __NMS_IFCFG_RH_PLUGIN_H__
+
+#define NMS_TYPE_IFCFG_RH_PLUGIN            (nms_ifcfg_rh_plugin_get_type ())
+#define NMS_IFCFG_RH_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NMS_TYPE_IFCFG_RH_PLUGIN, NMSIfcfgRHPlugin))
+#define NMS_IFCFG_RH_PLUGIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NMS_TYPE_IFCFG_RH_PLUGIN, NMSIfcfgRHPluginClass))
+#define NMS_IS_IFCFG_RH_PLUGIN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NMS_TYPE_IFCFG_RH_PLUGIN))
+#define NMS_IS_IFCFG_RH_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NMS_TYPE_IFCFG_RH_PLUGIN))
+#define NMS_IFCFG_RH_PLUGIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NMS_TYPE_IFCFG_RH_PLUGIN, NMSIfcfgRHPluginClass))
+
+typedef struct _NMSIfcfgRHPlugin NMSIfcfgRHPlugin;
+typedef struct _NMSIfcfgRHPluginClass NMSIfcfgRHPluginClass;
+
+GType nms_ifcfg_rh_plugin_get_type (void);
+
+#endif /* __NMS_IFCFG_RH_PLUGIN_H__ */
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
new file mode 100644
index 0000000000000000000000000000000000000000..f348ca473a2102dc3231d1485dc52250384783c1
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -0,0 +1,5991 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * Copyright 2008 - 2017 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nms-ifcfg-rh-reader.h"
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <sys/wait.h>
+#include <sys/inotify.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include "nm-glib-aux/nm-secret-utils.h"
+#include "nm-connection.h"
+#include "nm-dbus-interface.h"
+#include "nm-setting-connection.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-vlan.h"
+#include "nm-setting-ip6-config.h"
+#include "nm-setting-wired.h"
+#include "nm-setting-wireless.h"
+#include "nm-setting-ethtool.h"
+#include "nm-setting-8021x.h"
+#include "nm-setting-bond.h"
+#include "nm-setting-team.h"
+#include "nm-setting-team-port.h"
+#include "nm-setting-bridge.h"
+#include "nm-setting-bridge-port.h"
+#include "nm-setting-dcb.h"
+#include "nm-setting-user.h"
+#include "nm-setting-proxy.h"
+#include "nm-setting-generic.h"
+#include "nm-core-internal.h"
+#include "nm-utils.h"
+#include "nm-libnm-core-intern/nm-ethtool-utils.h"
+
+#include "platform/nm-platform.h"
+#include "NetworkManagerUtils.h"
+
+#include "nms-ifcfg-rh-common.h"
+#include "nms-ifcfg-rh-utils.h"
+#include "shvar.h"
+
+/*****************************************************************************/
+
+#define _NMLOG_DOMAIN      LOGD_SETTINGS
+#define _NMLOG_PREFIX_NAME "ifcfg-rh"
+#define _NMLOG(level, ...) \
+    G_STMT_START { \
+        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
+                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
+                _NMLOG_PREFIX_NAME": " \
+                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
+    } G_STMT_END
+
+#define PARSE_WARNING(...) _LOGW ("%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), "    " _NM_UTILS_MACRO_REST(__VA_ARGS__))
+
+/*****************************************************************************/
+
+static char *
+get_full_file_path (const char *ifcfg_path, const char *file_path)
+{
+	const char *base = file_path;
+	gs_free char *dirname = NULL;
+	char *p;
+
+	g_return_val_if_fail (ifcfg_path != NULL, NULL);
+	g_return_val_if_fail (file_path != NULL, NULL);
+
+	if (file_path[0] == '/')
+		return g_strdup (file_path);
+
+	p = strrchr (file_path, '/');
+	if (p)
+		base = p + 1;
+
+	dirname = g_path_get_dirname (ifcfg_path);
+	return g_build_path ("/", dirname, base, NULL);
+}
+
+/*****************************************************************************/
+
+static NMSettingSecretFlags
+_secret_read_ifcfg_flags (shvarFile *ifcfg, const char *flags_key)
+{
+	NMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;
+	gs_free char *val_free = NULL;
+	const char *val;
+
+	nm_assert (flags_key);
+	nm_assert (g_str_has_suffix (flags_key, "_FLAGS"));
+
+	val = svGetValueStr (ifcfg, flags_key, &val_free);
+	if (val) {
+		if (strstr (val, SECRET_FLAG_AGENT))
+			flags |= NM_SETTING_SECRET_FLAG_AGENT_OWNED;
+		if (strstr (val, SECRET_FLAG_NOT_SAVED))
+			flags |= NM_SETTING_SECRET_FLAG_NOT_SAVED;
+		if (strstr (val, SECRET_FLAG_NOT_REQUIRED))
+			flags |= NM_SETTING_SECRET_FLAG_NOT_REQUIRED;
+	}
+	return flags;
+}
+
+static void
+_secret_read_ifcfg (shvarFile *ifcfg,
+                    shvarFile *keys_ifcfg,
+                    const char *name,
+                    char **value,
+                    NMSettingSecretFlags *flags)
+{
+	char flags_key[250];
+
+	nm_sprintf_buf (flags_key, "%s_FLAGS", name);
+
+	*flags = _secret_read_ifcfg_flags (ifcfg, flags_key);
+
+	if (*flags != NM_SETTING_SECRET_FLAG_NONE)
+		*value = NULL;
+	else {
+		*value = svGetValue_cp (ifcfg, name);
+		if (!*value && keys_ifcfg)
+			*value = svGetValue_cp (keys_ifcfg, name);
+	}
+}
+
+static void
+_secret_set_from_ifcfg (gpointer setting,
+                        shvarFile *ifcfg,
+                        shvarFile *keys_ifcfg,
+                        const char *ifcfg_key,
+                        const char *property_name)
+{
+	nm_auto_free_secret char *secret = NULL;
+	NMSettingSecretFlags flags;
+	char flags_key[250];
+
+	nm_assert (NM_IS_SETTING (setting));
+
+	_secret_read_ifcfg (ifcfg, keys_ifcfg, ifcfg_key, &secret, &flags);
+
+	g_object_set (setting,
+	              property_name,
+	              secret,
+	              nm_sprintf_buf (flags_key, "%s-flags", property_name),
+	              flags,
+	              NULL);
+}
+
+static gboolean
+_secret_password_raw_to_bytes (const char *ifcfg_key,
+                               const char *password_raw,
+                               GBytes **out_bytes,
+                               GError **error)
+{
+	nm_auto_free_secret_buf NMSecretBuf *secret = NULL;
+	gsize len;
+
+	if (!password_raw) {
+		NM_SET_OUT (out_bytes, NULL);
+		return TRUE;
+	}
+
+	if (password_raw[0] == '0' && password_raw[1] == 'x')
+		password_raw += 2;
+
+	secret = nm_secret_buf_new (strlen (password_raw) / 2 + 3);
+	if (!nm_utils_hexstr2bin_full (password_raw, FALSE, FALSE, ":", 0, secret->bin, secret->len, &len)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Invalid hex password in %s",
+		             ifcfg_key);
+		return FALSE;
+	}
+
+	NM_SET_OUT (out_bytes, nm_secret_buf_to_gbytes_take (g_steal_pointer (&secret), len));
+	return TRUE;
+}
+
+/*****************************************************************************/
+
+static GBytes *
+_cert_get_cert_bytes (const char *ifcfg_path,
+                      const char *value,
+                      GError **error)
+{
+	gs_free char *path = NULL;
+
+	if (NM_STR_HAS_PREFIX (value, "pkcs11:"))
+		return _nm_setting_802_1x_cert_value_to_bytes (NM_SETTING_802_1X_CK_SCHEME_PKCS11, (guint8 *) value, -1, error);
+
+	path = get_full_file_path (ifcfg_path, value);
+	return _nm_setting_802_1x_cert_value_to_bytes (NM_SETTING_802_1X_CK_SCHEME_PATH, (guint8 *) path, -1, error);
+}
+
+static gboolean
+_cert_get_cert (shvarFile *ifcfg,
+                const char *ifcfg_key,
+                GBytes **out_cert,
+                NMSetting8021xCKScheme *out_scheme,
+                GError **error)
+{
+	nm_auto_free_secret char *val_free = NULL;
+	const char *val;
+	gs_unref_bytes GBytes *cert = NULL;
+	GError *local = NULL;
+	NMSetting8021xCKScheme scheme;
+
+	val = svGetValueStr (ifcfg, ifcfg_key, &val_free);
+	if (!val) {
+		NM_SET_OUT (out_cert, NULL);
+		NM_SET_OUT (out_scheme, NM_SETTING_802_1X_CK_SCHEME_UNKNOWN);
+		return TRUE;
+	}
+
+	cert = _cert_get_cert_bytes (svFileGetName (ifcfg), val, &local);
+	if (!cert)
+		goto err;
+
+	scheme = _nm_setting_802_1x_cert_get_scheme (cert, &local);
+	if (scheme == NM_SETTING_802_1X_CK_SCHEME_UNKNOWN)
+		goto err;
+
+	NM_SET_OUT (out_cert, g_steal_pointer (&cert));
+	NM_SET_OUT (out_scheme, scheme);
+	return TRUE;
+
+err:
+	g_set_error (error,
+	             NM_SETTINGS_ERROR,
+	             NM_SETTINGS_ERROR_INVALID_CONNECTION,
+	             "invalid certificate %s: %s",
+	             ifcfg_key,
+	             local->message);
+	g_error_free (local);
+	return FALSE;
+}
+
+static gboolean
+_cert_set_from_ifcfg (gpointer setting,
+                      shvarFile *ifcfg,
+                      const char *ifcfg_key,
+                      const char *property_name,
+                      GBytes **out_cert,
+                      GError **error)
+{
+	gs_unref_bytes GBytes *cert = NULL;
+
+	if (!_cert_get_cert (ifcfg,
+	                     ifcfg_key,
+	                     &cert,
+	                     NULL,
+	                     error))
+		return FALSE;
+
+	g_object_set (setting, property_name, cert, NULL);
+
+	NM_SET_OUT (out_cert, g_steal_pointer (&cert));
+	return TRUE;
+}
+
+/*****************************************************************************/
+
+static void
+check_if_bond_slave (shvarFile *ifcfg,
+                     NMSettingConnection *s_con)
+{
+	gs_free char *value = NULL;
+	const char *v;
+	const char *master;
+
+	v = svGetValueStr (ifcfg, "MASTER_UUID", &value);
+	if (!v)
+		v = svGetValueStr (ifcfg, "MASTER", &value);
+
+	if (v) {
+		master = nm_setting_connection_get_master (s_con);
+		if (master) {
+			PARSE_WARNING ("Already configured as slave of %s. Ignoring MASTER{_UUID}=\"%s\"",
+			               master, v);
+			return;
+		}
+
+		g_object_set (s_con,
+		              NM_SETTING_CONNECTION_MASTER, v,
+		              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
+		              NULL);
+	}
+
+	/* We should be checking for SLAVE=yes as well, but NM used to not set that,
+	 * so for backward-compatibility, we don't check.
+	 */
+}
+
+static void
+check_if_team_slave (shvarFile *ifcfg,
+                     NMSettingConnection *s_con)
+{
+	gs_free char *value = NULL;
+	const char *v;
+	const char *master;
+
+	v = svGetValueStr (ifcfg, "TEAM_MASTER_UUID", &value);
+	if (!v)
+		v = svGetValueStr (ifcfg, "TEAM_MASTER", &value);
+	if (!v)
+		return;
+
+	master = nm_setting_connection_get_master (s_con);
+	if (master) {
+		PARSE_WARNING ("Already configured as slave of %s. Ignoring TEAM_MASTER{_UUID}=\"%s\"",
+		               master, v);
+		return;
+	}
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_MASTER, v,
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
+	              NULL);
+}
+
+static char *
+make_connection_name (shvarFile *ifcfg,
+                      const char *ifcfg_name,
+                      const char *suggested,
+                      const char *prefix)
+{
+	char *full_name = NULL, *name;
+
+	/* If the ifcfg file already has a NAME, always use that */
+	name = svGetValueStr_cp (ifcfg, "NAME");
+	if (name)
+		return name;
+
+	/* Otherwise construct a new NAME */
+	if (!prefix)
+		prefix = "System";
+
+	/* For cosmetic reasons, if the suggested name is the same as
+	 * the ifcfg files name, don't use it.  Mainly for wifi so that
+	 * the SSID is shown in the connection ID instead of just "wlan0".
+	 */
+	if (suggested && strcmp (ifcfg_name, suggested))
+		full_name = g_strdup_printf ("%s %s (%s)", prefix, suggested, ifcfg_name);
+	else
+		full_name = g_strdup_printf ("%s %s", prefix, ifcfg_name);
+
+	return full_name;
+}
+
+static NMSetting *
+make_connection_setting (const char *file,
+                         shvarFile *ifcfg,
+                         const char *type,
+                         const char *suggested,
+                         const char *prefix)
+{
+	NMSettingConnection *s_con;
+	NMSettingConnectionLldp lldp;
+	const char *ifcfg_name = NULL;
+	gs_free char *new_id = NULL;
+	const char *uuid;
+	gs_free char *uuid_free = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	gs_free char *stable_id = NULL;
+	const char *const *iter;
+	int vint64, i_val;
+
+	ifcfg_name = utils_get_ifcfg_name (file, TRUE);
+	if (!ifcfg_name)
+		return NULL;
+
+	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
+
+	new_id = make_connection_name (ifcfg, ifcfg_name, suggested, prefix);
+	g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
+
+	/* Try for a UUID key before falling back to hashing the file name */
+	uuid = svGetValueStr (ifcfg, "UUID", &uuid_free);
+	if (!uuid) {
+		uuid_free = nm_utils_uuid_generate_from_string (svFileGetName (ifcfg), -1, NM_UTILS_UUID_TYPE_LEGACY, NULL);
+		uuid = uuid_free;
+	}
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_TYPE, type,
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_STABLE_ID, svGetValue (ifcfg, "STABLE_ID", &stable_id),
+	              NULL);
+
+	v = svGetValueStr (ifcfg, "DEVICE", &value);
+	if (v) {
+		GError *error = NULL;
+
+		if (nm_utils_is_valid_iface_name (v, &error)) {
+			g_object_set (s_con,
+			              NM_SETTING_CONNECTION_INTERFACE_NAME, v,
+			              NULL);
+		} else {
+			PARSE_WARNING ("invalid DEVICE name '%s': %s", v, error->message);
+			g_error_free (error);
+		}
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "LLDP", &value);
+	if (nm_streq0 (v, "rx"))
+		lldp = NM_SETTING_CONNECTION_LLDP_ENABLE_RX;
+	else
+		lldp = svParseBoolean (v, NM_SETTING_CONNECTION_LLDP_DEFAULT);
+
+	/* Missing ONBOOT is treated as "ONBOOT=true" by the old network service */
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_AUTOCONNECT,
+	              svGetValueBoolean (ifcfg, "ONBOOT", TRUE),
+	              NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY,
+	              (int) svGetValueInt64 (ifcfg, "AUTOCONNECT_PRIORITY", 10,
+	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN,
+	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX,
+	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT),
+	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES,
+	              (int) svGetValueInt64 (ifcfg, "AUTOCONNECT_RETRIES", 10,
+	                                      -1, G_MAXINT32, -1),
+	              NM_SETTING_CONNECTION_MULTI_CONNECT,
+	              (gint) svGetValueInt64 (ifcfg, "MULTI_CONNECT", 10,
+	                                      G_MININT32, G_MAXINT32, NM_CONNECTION_MULTI_CONNECT_DEFAULT),
+	              NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES,
+	              svGetValueBoolean (ifcfg, "AUTOCONNECT_SLAVES", NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT),
+	              NM_SETTING_CONNECTION_LLDP, lldp,
+	              NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "USERS", &value);
+	if (v) {
+		gs_free const char **items = NULL;
+
+		items = nm_utils_strsplit_set (v, " ");
+		for (iter = items; iter && *iter; iter++) {
+			if (!nm_setting_connection_add_permission (s_con, "user", *iter, NULL))
+				PARSE_WARNING ("invalid USERS item '%s'", *iter);
+		}
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "ZONE", &value);
+	g_object_set (s_con, NM_SETTING_CONNECTION_ZONE, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "SECONDARY_UUIDS", &value);
+	if (v) {
+		gs_free const char **items = NULL;
+
+		items = nm_utils_strsplit_set (v, " \t");
+		for (iter = items; iter && *iter; iter++) {
+			if (!nm_setting_connection_add_secondary (s_con, *iter))
+				PARSE_WARNING ("secondary connection UUID '%s' already added", *iter);
+		}
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "BRIDGE_UUID", &value);
+	if (!v)
+		v = svGetValueStr (ifcfg, "BRIDGE", &value);
+	if (v) {
+		const char *old_value;
+
+		if ((old_value = nm_setting_connection_get_master (s_con))) {
+			PARSE_WARNING ("Already configured as slave of %s. Ignoring BRIDGE=\"%s\"",
+			               old_value, v);
+		} else {
+			g_object_set (s_con, NM_SETTING_CONNECTION_MASTER, v, NULL);
+			g_object_set (s_con, NM_SETTING_CONNECTION_SLAVE_TYPE,
+			              NM_SETTING_BRIDGE_SETTING_NAME, NULL);
+		}
+	}
+
+	check_if_bond_slave (ifcfg, s_con);
+	check_if_team_slave (ifcfg, s_con);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "OVS_PORT_UUID", &value);
+	if (!v)
+		v = svGetValueStr (ifcfg, "OVS_PORT", &value);
+	if (v) {
+		const char *old_value;
+
+		if ((old_value = nm_setting_connection_get_master (s_con))) {
+			PARSE_WARNING ("Already configured as slave of %s. Ignoring OVS_PORT=\"%s\"",
+			               old_value, v);
+		} else {
+			g_object_set (s_con, NM_SETTING_CONNECTION_MASTER, v, NULL);
+			g_object_set (s_con, NM_SETTING_CONNECTION_SLAVE_TYPE,
+			              NM_SETTING_OVS_PORT_SETTING_NAME, NULL);
+		}
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "GATEWAY_PING_TIMEOUT", &value);
+	if (v) {
+		gint64 tmp;
+
+		tmp = _nm_utils_ascii_str_to_int64 (v, 10, 0, G_MAXINT32 - 1, -1);
+		if (tmp >= 0) {
+			if (tmp > 600) {
+				tmp = 600;
+				PARSE_WARNING ("invalid GATEWAY_PING_TIMEOUT time");
+			}
+			g_object_set (s_con, NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT, (guint) tmp, NULL);
+		} else
+			PARSE_WARNING ("invalid GATEWAY_PING_TIMEOUT time");
+	}
+
+	switch (svGetValueBoolean (ifcfg, "CONNECTION_METERED", -1)) {
+	case TRUE:
+		g_object_set (s_con, NM_SETTING_CONNECTION_METERED, NM_METERED_YES, NULL);
+		break;
+	case FALSE:
+		g_object_set (s_con, NM_SETTING_CONNECTION_METERED, NM_METERED_NO, NULL);
+		break;
+	}
+
+	vint64 = svGetValueInt64 (ifcfg, "AUTH_RETRIES", 10, -1, G_MAXINT32, -1);
+	g_object_set (s_con, NM_SETTING_CONNECTION_AUTH_RETRIES, (int) vint64, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DEVTIMEOUT", &value);
+	if (v) {
+		vint64 = _nm_utils_ascii_str_to_int64 (v, 10, 0, ((gint64) G_MAXINT32) / 1000, -1);
+		if (vint64 != -1)
+			vint64 *= 1000;
+		else {
+			char *endptr;
+			double d;
+
+			d = g_ascii_strtod (v, &endptr);
+			if (   errno == 0
+			    && endptr[0] == '\0'
+			    && d >= 0.0) {
+				d *= 1000.0;
+
+				/* We round. Yes, this is not correct to round IEEE 754 floats in general,
+				 * but sufficient for our case where we know that NetworkManager wrote the
+				 * setting with up to 3 digits for the milliseconds. */
+				d += 0.5;
+				if (   d >= 0.0
+				    && d <= (double) G_MAXINT32)
+					vint64 = (gint64) d;
+			}
+		}
+		if (vint64 == -1)
+			PARSE_WARNING ("invalid DEVTIMEOUT setting");
+		else
+			g_object_set (s_con, NM_SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT, (int) vint64, NULL);
+	}
+
+	i_val = NM_SETTING_CONNECTION_MDNS_DEFAULT;
+	if (!svGetValueEnum (ifcfg, "MDNS",
+	                     nm_setting_connection_mdns_get_type (),
+	                     &i_val, NULL))
+		PARSE_WARNING ("invalid MDNS setting");
+	g_object_set (s_con, NM_SETTING_CONNECTION_MDNS, i_val, NULL);
+
+	i_val = NM_SETTING_CONNECTION_LLMNR_DEFAULT;
+	if (!svGetValueEnum (ifcfg, "LLMNR",
+	                     nm_setting_connection_llmnr_get_type (),
+	                     &i_val, NULL))
+		PARSE_WARNING ("invalid LLMNR setting");
+	g_object_set (s_con, NM_SETTING_CONNECTION_LLMNR, i_val, NULL);
+
+	return NM_SETTING (s_con);
+}
+
+static gboolean
+read_ip4_address (shvarFile *ifcfg,
+                  const char *tag,
+                  gboolean *out_has_key,
+                  guint32 *out_addr,
+                  GError **error)
+{
+	gs_free char *value_to_free = NULL;
+	const char *value;
+	in_addr_t a;
+
+	nm_assert (ifcfg);
+	nm_assert (tag);
+	nm_assert (!error || !*error);
+
+	value = svGetValueStr (ifcfg, tag, &value_to_free);
+	if (!value) {
+		NM_SET_OUT (out_has_key, FALSE);
+		NM_SET_OUT (out_addr, 0);
+		return TRUE;
+	}
+
+	if (inet_pton (AF_INET, value, &a) != 1) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Invalid %s IP4 address '%s'", tag, value);
+		return FALSE;
+	}
+
+	NM_SET_OUT (out_has_key, TRUE);
+	NM_SET_OUT (out_addr, a);
+	return TRUE;
+}
+
+static gboolean
+is_any_ip4_address_defined (shvarFile *ifcfg, int *idx)
+{
+	int i, ignore, *ret_idx;
+
+	ret_idx = idx ?: &ignore;
+
+	for (i = -1; i <= 2; i++) {
+		gs_free char *value = NULL;
+		char tag[256];
+
+		if (svGetValueStr (ifcfg, numbered_tag (tag, "IPADDR", i), &value)) {
+			*ret_idx = i;
+			return TRUE;
+		}
+
+		if (svGetValueStr (ifcfg, numbered_tag (tag, "PREFIX", i), &value)) {
+			*ret_idx = i;
+			return TRUE;
+		}
+
+		if (svGetValueStr (ifcfg, numbered_tag (tag, "NETMASK", i), &value)) {
+			*ret_idx = i;
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+/* Returns TRUE on missing address or valid address */
+static gboolean
+read_full_ip4_address (shvarFile *ifcfg,
+                       gint32 which,
+                       NMIPAddress *base_addr,
+                       NMIPAddress **out_address,
+                       char **out_gateway,
+                       GError **error)
+{
+	char tag[256];
+	char prefix_tag[256];
+	guint32 ipaddr;
+	gs_free char *value = NULL;
+	const char *v;
+	int prefix = 0;
+	gboolean has_key;
+	guint32 a;
+	char inet_buf[NM_UTILS_INET_ADDRSTRLEN];
+
+	g_return_val_if_fail (which >= -1, FALSE);
+	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (out_address != NULL, FALSE);
+	g_return_val_if_fail (*out_address == NULL, FALSE);
+	g_return_val_if_fail (!error || !*error, FALSE);
+
+	/* IP address */
+	if (!read_ip4_address (ifcfg,
+	                       numbered_tag (tag, "IPADDR", which),
+	                       &has_key, &ipaddr, error))
+		return FALSE;
+	if (!has_key) {
+		if (!base_addr)
+			return TRUE;
+		nm_ip_address_get_address_binary (base_addr, &ipaddr);
+	}
+
+	/* Gateway */
+	if (out_gateway && !*out_gateway) {
+		if (!read_ip4_address (ifcfg,
+		                       numbered_tag (tag, "GATEWAY", which),
+		                       &has_key, &a, error))
+			return FALSE;
+		if (has_key)
+			*out_gateway = nm_utils_inet4_ntop_dup (a);
+	}
+
+	/* Prefix */
+	numbered_tag (prefix_tag, "PREFIX", which);
+	v = svGetValueStr (ifcfg, prefix_tag, &value);
+	if (v) {
+		prefix = _nm_utils_ascii_str_to_int64 (v, 10, 0, 32, -1);
+		if (prefix < 0) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid IP4 prefix '%s'", v);
+			return FALSE;
+		}
+	} else {
+		/* Fall back to NETMASK if no PREFIX was specified */
+		if (!read_ip4_address (ifcfg,
+		                       numbered_tag (tag, "NETMASK", which),
+		                       &has_key, &a, error))
+			return FALSE;
+		if (has_key)
+			prefix = nm_utils_ip4_netmask_to_prefix (a);
+		else {
+			if (base_addr)
+				prefix = nm_ip_address_get_prefix (base_addr);
+			else {
+				/* Try to autodetermine the prefix for the address' class */
+				prefix = _nm_utils_ip4_get_default_prefix (ipaddr);
+				PARSE_WARNING ("missing %s, assuming %s/%d", prefix_tag, nm_utils_inet4_ntop (ipaddr, inet_buf), prefix);
+			}
+		}
+	}
+
+	*out_address = nm_ip_address_new_binary (AF_INET, &ipaddr, prefix, error);
+	if (*out_address)
+		return TRUE;
+
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+static gboolean
+parse_route_line_is_comment (const char *line)
+{
+	/* we obtained the line from a legacy route file. Here we skip
+	 * empty lines and comments.
+	 *
+	 * initscripts compares: "$line" =~ '^[[:space:]]*(\#.*)?$'
+	 */
+	while (nm_utils_is_separator (line[0]))
+		line++;
+	if (NM_IN_SET (line[0], '\0', '#'))
+		return TRUE;
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+typedef struct {
+	const char *key;
+
+	/* the element is not available in this case. */
+	bool disabled:1;
+
+	/* whether the element is to be ignored. Ignord is different from
+	 * "disabled", because we still parse the option, but don't use it. */
+	bool ignore:1;
+
+	bool int_base_16:1;
+
+	/* whether the command line option was found, and @v is
+	 * initialized. */
+	bool has:1;
+
+	/* the type, one of PARSE_LINE_TYPE_* */
+	char type;
+
+	union {
+		guint8 uint8;
+		guint32 uint32;
+		struct {
+			guint32 uint32;
+			bool lock:1;
+		} uint32_with_lock;
+		struct {
+			NMIPAddr addr;
+			guint8 plen;
+			bool has_plen:1;
+		} addr;
+	} v;
+
+} ParseLineInfo;
+
+enum {
+	/* route attributes */
+	PARSE_LINE_ATTR_ROUTE_TABLE,
+	PARSE_LINE_ATTR_ROUTE_SRC,
+	PARSE_LINE_ATTR_ROUTE_FROM,
+	PARSE_LINE_ATTR_ROUTE_TOS,
+	PARSE_LINE_ATTR_ROUTE_ONLINK,
+	PARSE_LINE_ATTR_ROUTE_WINDOW,
+	PARSE_LINE_ATTR_ROUTE_CWND,
+	PARSE_LINE_ATTR_ROUTE_INITCWND,
+	PARSE_LINE_ATTR_ROUTE_INITRWND,
+	PARSE_LINE_ATTR_ROUTE_MTU,
+
+	/* iproute2 arguments that only matter when parsing the file. */
+	PARSE_LINE_ATTR_ROUTE_TO,
+	PARSE_LINE_ATTR_ROUTE_VIA,
+	PARSE_LINE_ATTR_ROUTE_METRIC,
+
+	/* iproute2 parameters that are well known and that we silently ignore. */
+	PARSE_LINE_ATTR_ROUTE_DEV,
+};
+
+#define PARSE_LINE_TYPE_UINT8             '8'
+#define PARSE_LINE_TYPE_UINT32            'u'
+#define PARSE_LINE_TYPE_UINT32_WITH_LOCK  'l'
+#define PARSE_LINE_TYPE_ADDR              'a'
+#define PARSE_LINE_TYPE_ADDR_WITH_PREFIX  'p'
+#define PARSE_LINE_TYPE_IFNAME            'i'
+#define PARSE_LINE_TYPE_FLAG              'f'
+
+/**
+ * parse_route_line:
+ * @line: the line to parse. This is either a line from the route-* or route6-* file,
+ *   or the numbered OPTIONS setting.
+ * @addr_family: the address family.
+ * @options_route: (in-out): when line is from the OPTIONS setting, this is a pre-created
+ *   route object that is completed with the settings from options. Otherwise,
+ *   it shall point to %NULL and a new route is created and returned.
+ * @out_route: (out) (transfer-full) (allow-none): the parsed %NMIPRoute instance.
+ *   In case a @options_route is passed in, it returns the input route that was modified
+ *   in-place. But the caller must unref the returned route in either case.
+ * @error: the failure description.
+ *
+ * Parsing the route options line has two modes: one for the numbered OPTIONS
+ * setting, and one for initscript's handle_ip_file(), which takes the lines
+ * and passes them to `ip route add`. The modes are similar, but certain properties
+ * are not allowed for OPTIONS.
+ * The mode is differentiated by having an @options_route argument.
+ *
+ * Returns: returns a negative errno on failure. On success, it returns 0
+ *   and @out_route.
+ */
+static int
+parse_route_line (const char *line,
+                  int addr_family,
+                  NMIPRoute *options_route,
+                  NMIPRoute **out_route,
+                  GError **error)
+{
+	nm_auto_unref_ip_route NMIPRoute *route = NULL;
+	gs_free const char **words_free = NULL;
+	const char *const*words;
+	const char *s;
+	gsize i_words;
+	guint i;
+	char buf1[256];
+	char buf2[256];
+	ParseLineInfo infos[] = {
+		[PARSE_LINE_ATTR_ROUTE_TABLE]     = { .key = NM_IP_ROUTE_ATTRIBUTE_TABLE,
+		                                      .type = PARSE_LINE_TYPE_UINT32, },
+		[PARSE_LINE_ATTR_ROUTE_SRC]       = { .key = NM_IP_ROUTE_ATTRIBUTE_SRC,
+		                                      .type = PARSE_LINE_TYPE_ADDR, },
+		[PARSE_LINE_ATTR_ROUTE_FROM]      = { .key = NM_IP_ROUTE_ATTRIBUTE_FROM,
+		                                      .type = PARSE_LINE_TYPE_ADDR_WITH_PREFIX,
+		                                      .disabled = (addr_family != AF_INET6), },
+		[PARSE_LINE_ATTR_ROUTE_TOS]       = { .key = NM_IP_ROUTE_ATTRIBUTE_TOS,
+		                                      .type = PARSE_LINE_TYPE_UINT8,
+		                                      .int_base_16 = TRUE,
+		                                      .ignore = (addr_family != AF_INET), },
+		[PARSE_LINE_ATTR_ROUTE_ONLINK]    = { .key = NM_IP_ROUTE_ATTRIBUTE_ONLINK,
+		                                      .type = PARSE_LINE_TYPE_FLAG,
+		                                      .ignore = (addr_family != AF_INET), },
+		[PARSE_LINE_ATTR_ROUTE_WINDOW]    = { .key = NM_IP_ROUTE_ATTRIBUTE_WINDOW,
+		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
+		[PARSE_LINE_ATTR_ROUTE_CWND]      = { .key = NM_IP_ROUTE_ATTRIBUTE_CWND,
+		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
+		[PARSE_LINE_ATTR_ROUTE_INITCWND]  = { .key = NM_IP_ROUTE_ATTRIBUTE_INITCWND,
+		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
+		[PARSE_LINE_ATTR_ROUTE_INITRWND]  = { .key = NM_IP_ROUTE_ATTRIBUTE_INITRWND,
+		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
+		[PARSE_LINE_ATTR_ROUTE_MTU]       = { .key = NM_IP_ROUTE_ATTRIBUTE_MTU,
+		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
+
+		[PARSE_LINE_ATTR_ROUTE_TO]        = { .key = "to",
+		                                      .type = PARSE_LINE_TYPE_ADDR_WITH_PREFIX,
+		                                      .disabled = (options_route != NULL), },
+		[PARSE_LINE_ATTR_ROUTE_VIA]       = { .key = "via",
+		                                      .type = PARSE_LINE_TYPE_ADDR,
+		                                      .disabled = (options_route != NULL), },
+		[PARSE_LINE_ATTR_ROUTE_METRIC]    = { .key = "metric",
+		                                      .type = PARSE_LINE_TYPE_UINT32,
+		                                      .disabled = (options_route != NULL), },
+
+		[PARSE_LINE_ATTR_ROUTE_DEV]       = { .key = "dev",
+		                                      .type = PARSE_LINE_TYPE_IFNAME,
+		                                      .ignore = TRUE,
+		                                      .disabled = (options_route != NULL), },
+	};
+
+	nm_assert (line);
+	nm_assert_addr_family (addr_family);
+	nm_assert (!options_route || nm_ip_route_get_family (options_route) == addr_family);
+
+	/* initscripts read the legacy route file line-by-line and
+	 * use it as `ip route add $line`, thus doing split+glob.
+	 * Splitting on IFS (which we consider '<space><tab><newline>')
+	 * and globbing (which we obviously don't do).
+	 *
+	 * I think it's a mess, because it doesn't support escaping or
+	 * quoting. In fact, it can only encode benign values.
+	 *
+	 * We also use the same form for the numbered OPTIONS
+	 * variable. I think it's bad not to support any form of
+	 * escaping. But do that for now.
+	 *
+	 * Maybe later we want to support some form of quotation here.
+	 * Which of course, would be incompatible with initscripts.
+	 */
+	words_free = nm_utils_strsplit_set (line, " \t\n");
+
+	words = words_free ?: NM_PTRARRAY_EMPTY (const char *);
+
+	for (i_words = 0; words[i_words]; ) {
+		const gsize i_words0 = i_words;
+		const char *const w = words[i_words0];
+		ParseLineInfo *info;
+		gboolean unqualified_addr = FALSE;
+
+		for (i = 0; i < G_N_ELEMENTS (infos); i++) {
+			info = &infos[i];
+
+			if (info->disabled)
+				continue;
+
+			if (!nm_streq (w, info->key))
+				continue;
+
+			if (info->has) {
+				/* iproute2 for most arguments allows specifying them multiple times.
+				 * Let's not do that. */
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Duplicate option \"%s\"", w);
+				return -EINVAL;
+			}
+
+			info->has = TRUE;
+			switch (info->type) {
+			case PARSE_LINE_TYPE_UINT8:
+				i_words++;
+				goto parse_line_type_uint8;
+			case PARSE_LINE_TYPE_UINT32:
+				i_words++;
+				goto parse_line_type_uint32;
+			case PARSE_LINE_TYPE_UINT32_WITH_LOCK:
+				i_words++;
+				goto parse_line_type_uint32_with_lock;
+			case PARSE_LINE_TYPE_ADDR:
+				i_words++;
+				goto parse_line_type_addr;
+			case PARSE_LINE_TYPE_ADDR_WITH_PREFIX:
+				i_words++;
+				goto parse_line_type_addr_with_prefix;
+			case PARSE_LINE_TYPE_IFNAME:
+				i_words++;
+				goto parse_line_type_ifname;
+			case PARSE_LINE_TYPE_FLAG:
+				i_words++;
+				goto next;
+			default:
+				nm_assert_not_reached ();
+			}
+		}
+
+		/* "to" is also accepted unqualified... (once) */
+		info = &infos[PARSE_LINE_ATTR_ROUTE_TO];
+		if (!info->has && !info->disabled) {
+			unqualified_addr = TRUE;
+			info->has = TRUE;
+			goto parse_line_type_addr;
+		}
+
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Unrecognized argument (\"to\" is duplicate or \"%s\" is garbage)", w);
+		return -EINVAL;
+
+parse_line_type_uint8:
+		s = words[i_words];
+		if (!s)
+			goto err_word_missing_argument;
+		info->v.uint8 = _nm_utils_ascii_str_to_int64 (s,
+		                                              info->int_base_16 ? 16 : 10,
+		                                              0,
+		                                              G_MAXUINT8,
+		                                              0);;
+		if (errno) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Argument for \"%s\" is not a valid number", w);
+			return -EINVAL;
+		}
+		i_words++;
+		goto next;
+
+parse_line_type_uint32:
+parse_line_type_uint32_with_lock:
+		s = words[i_words];
+		if (!s)
+			goto err_word_missing_argument;
+		if (info->type == PARSE_LINE_TYPE_UINT32_WITH_LOCK) {
+			if (nm_streq (s, "lock")) {
+				s = words[++i_words];
+				if (!s)
+					goto err_word_missing_argument;
+				info->v.uint32_with_lock.lock = TRUE;
+			} else
+				info->v.uint32_with_lock.lock = FALSE;
+			info->v.uint32_with_lock.uint32 = _nm_utils_ascii_str_to_int64 (s, 10, 0, G_MAXUINT32, 0);;
+		} else {
+			info->v.uint32 = _nm_utils_ascii_str_to_int64 (s, 10, 0, G_MAXUINT32, 0);
+		}
+		if (errno) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Argument for \"%s\" is not a valid number", w);
+			return -EINVAL;
+		}
+		i_words++;
+		goto next;
+
+parse_line_type_ifname:
+		s = words[i_words];
+		if (!s)
+			goto err_word_missing_argument;
+		i_words++;
+		goto next;
+
+parse_line_type_addr:
+parse_line_type_addr_with_prefix:
+		s = words[i_words];
+		if (!s)
+			goto err_word_missing_argument;
+		{
+			int prefix = -1;
+
+			if (info->type == PARSE_LINE_TYPE_ADDR) {
+				if (!nm_utils_parse_inaddr_bin (addr_family,
+				                                s,
+				                                NULL,
+				                                &info->v.addr.addr)) {
+					if (   info == &infos[PARSE_LINE_ATTR_ROUTE_VIA]
+					    && nm_streq (s, "(null)")) {
+						/* Due to a bug, would older versions of NM write "via (null)"
+						 * (rh#1452648). Workaround that, and accept it.*/
+						memset (&info->v.addr.addr, 0, sizeof (info->v.addr.addr));
+					} else {
+						if (unqualified_addr) {
+							g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+							             "Unrecognized argument (inet prefix is expected rather then \"%s\")", w);
+							return -EINVAL;
+						} else {
+							g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+							             "Argument for \"%s\" is not a valid IPv%c address", w,
+							             addr_family == AF_INET ? '4' : '6');
+						}
+						return -EINVAL;
+					}
+				}
+			} else {
+				nm_assert (info->type == PARSE_LINE_TYPE_ADDR_WITH_PREFIX);
+				if (   info == &infos[PARSE_LINE_ATTR_ROUTE_TO]
+				    && nm_streq (s, "default")) {
+					memset (&info->v.addr.addr, 0, sizeof (info->v.addr.addr));
+					prefix = 0;
+				} else if (!nm_utils_parse_inaddr_prefix_bin (addr_family,
+				                                              s,
+				                                              NULL,
+				                                              &info->v.addr.addr,
+				                                              &prefix)) {
+					g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+					             "Argument for \"%s\" is not ADDR/PREFIX format", w);
+					return -EINVAL;
+				}
+			}
+			if (prefix == -1)
+				info->v.addr.has_plen = FALSE;
+			else {
+				info->v.addr.has_plen = TRUE;
+				info->v.addr.plen = prefix;
+			}
+		}
+		i_words++;
+		goto next;
+
+err_word_missing_argument:
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing argument for \"%s\"", w);
+		return -EINVAL;
+next:
+		;
+	}
+
+	if (options_route) {
+		route = options_route;
+		nm_ip_route_ref (route);
+	} else {
+		ParseLineInfo *info_to = &infos[PARSE_LINE_ATTR_ROUTE_TO];
+		ParseLineInfo *info_via = &infos[PARSE_LINE_ATTR_ROUTE_VIA];
+		ParseLineInfo *info_metric = &infos[PARSE_LINE_ATTR_ROUTE_METRIC];
+		guint prefix;
+
+		if (!info_to->has) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Missing destination prefix");
+			return -EINVAL;
+		}
+
+		prefix =   info_to->v.addr.has_plen
+		         ? info_to->v.addr.plen
+		         : (addr_family == AF_INET ? 32 : 128);
+
+		route = nm_ip_route_new_binary (addr_family,
+		                                &info_to->v.addr.addr,
+		                                prefix,
+		                                info_via->has ? &info_via->v.addr.addr : NULL,
+		                                info_metric->has ? (gint64) info_metric->v.uint32 : (gint64) -1,
+		                                error);
+		info_to->has = FALSE;
+		info_via->has = FALSE;
+		info_metric->has = FALSE;
+		if (!route)
+			return -EINVAL;
+	}
+
+	for (i = 0; i < G_N_ELEMENTS (infos); i++) {
+		ParseLineInfo *info = &infos[i];
+
+		if (!info->has)
+			continue;
+		if (info->ignore || info->disabled)
+			continue;
+		switch (info->type) {
+		case PARSE_LINE_TYPE_UINT8:
+			nm_ip_route_set_attribute (route,
+			                           info->key,
+			                           g_variant_new_byte (info->v.uint8));
+			break;
+		case PARSE_LINE_TYPE_UINT32:
+			nm_ip_route_set_attribute (route,
+			                           info->key,
+			                           g_variant_new_uint32 (info->v.uint32));
+			break;
+		case PARSE_LINE_TYPE_UINT32_WITH_LOCK:
+			if (info->v.uint32_with_lock.lock) {
+				nm_ip_route_set_attribute (route,
+				                           nm_sprintf_buf (buf1, "lock-%s", info->key),
+				                           g_variant_new_boolean (TRUE));
+			}
+			nm_ip_route_set_attribute (route,
+			                           info->key,
+			                           g_variant_new_uint32 (info->v.uint32_with_lock.uint32));
+			break;
+		case PARSE_LINE_TYPE_ADDR:
+		case PARSE_LINE_TYPE_ADDR_WITH_PREFIX:
+			nm_ip_route_set_attribute (route,
+			                           info->key,
+			                           g_variant_new_printf ("%s%s",
+			                                                 inet_ntop (addr_family, &info->v.addr.addr, buf1, sizeof (buf1)),
+			                                                 info->v.addr.has_plen
+			                                                    ? nm_sprintf_buf (buf2, "/%u", (unsigned) info->v.addr.plen)
+			                                                    : ""));
+			break;
+		case PARSE_LINE_TYPE_FLAG:
+			/* NOTE: the flag (for "onlink") only allows to explicitly set "TRUE".
+			 * There is no way to express an explicit "FALSE" setting
+			 * of this attribute, hence, the file format cannot encode
+			 * that configuration. */
+			nm_ip_route_set_attribute (route,
+			                           info->key,
+			                           g_variant_new_boolean (TRUE));
+			break;
+		default:
+			nm_assert_not_reached ();
+			break;
+		}
+	}
+
+	nm_assert (_nm_ip_route_attribute_validate_all (route));
+
+	NM_SET_OUT (out_route, g_steal_pointer (&route));
+	return 0;
+}
+
+/* Returns TRUE on missing route or valid route */
+static gboolean
+read_one_ip4_route (shvarFile *ifcfg,
+                    guint32 which,
+                    NMIPRoute **out_route,
+                    GError **error)
+{
+	char tag[256];
+	char netmask_tag[256];
+	guint32 dest;
+	guint32 next_hop;
+	guint32 netmask;
+	gboolean has_key;
+	const char *v;
+	gs_free char *value = NULL;
+	gint64 prefix, metric;
+	char inet_buf[NM_UTILS_INET_ADDRSTRLEN];
+
+	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (out_route && !*out_route, FALSE);
+	g_return_val_if_fail (!error || !*error, FALSE);
+
+	/* Destination */
+	if (!read_ip4_address (ifcfg,
+	                       numbered_tag (tag, "ADDRESS", which),
+	                       &has_key, &dest, error))
+		return FALSE;
+	if (!has_key) {
+		/* missing route = success */
+		*out_route = NULL;
+		return TRUE;
+	}
+
+	/* Next hop */
+	if (!read_ip4_address (ifcfg,
+	                       numbered_tag (tag, "GATEWAY", which),
+	                       NULL, &next_hop, error))
+		return FALSE;
+	/* We don't make distinction between missing GATEWAY IP and 0.0.0.0 */
+
+	/* Prefix */
+	if (!read_ip4_address (ifcfg,
+	                       numbered_tag (netmask_tag, "NETMASK", which),
+	                       &has_key, &netmask, error))
+		return FALSE;
+	if (has_key) {
+		prefix = nm_utils_ip4_netmask_to_prefix (netmask);
+		if (netmask != _nm_utils_ip4_prefix_to_netmask (prefix)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid IP4 netmask '%s' \"%s\"", netmask_tag, nm_utils_inet4_ntop (netmask, inet_buf));
+			return FALSE;
+		}
+	} else {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing IP4 route element '%s'", netmask_tag);
+		return FALSE;
+	}
+
+	/* Metric */
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, numbered_tag (tag, "METRIC", which), &value);
+	if (v) {
+		metric = _nm_utils_ascii_str_to_int64 (v, 10, 0, G_MAXUINT32, -1);
+		if (metric < 0) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid IP4 route metric '%s'", v);
+			return FALSE;
+		}
+	} else
+		metric = -1;
+
+	*out_route = nm_ip_route_new_binary (AF_INET, &dest, prefix, &next_hop, metric, error);
+	if (!*out_route)
+		return FALSE;
+
+	/* Options */
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, numbered_tag (tag, "OPTIONS", which), &value);
+	if (v) {
+		if (parse_route_line (v, AF_INET, *out_route, NULL, error) < 0) {
+			g_clear_pointer (out_route, nm_ip_route_unref);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+read_route_file (int addr_family,
+                 const char *filename,
+                 NMSettingIPConfig *s_ip,
+                 GError **error)
+{
+	gs_free char *contents = NULL;
+	char *contents_rest = NULL;
+	const char *line;
+	gsize len = 0;
+	gsize line_num;
+
+	g_return_val_if_fail (filename, FALSE);
+	g_return_val_if_fail (   (addr_family == AF_INET  && NM_IS_SETTING_IP4_CONFIG (s_ip))
+	                      || (addr_family == AF_INET6 && NM_IS_SETTING_IP6_CONFIG (s_ip)), FALSE);
+	g_return_val_if_fail (!error || !*error, FALSE);
+
+	if (   !g_file_get_contents (filename, &contents, &len, NULL)
+	    || !len) {
+		return TRUE;  /* missing/empty = success */
+	}
+
+	line_num = 0;
+	for (line = strtok_r (contents, "\n", &contents_rest);
+	     line;
+	     line = strtok_r (NULL, "\n", &contents_rest)) {
+		nm_auto_unref_ip_route NMIPRoute *route = NULL;
+		gs_free_error GError *local = NULL;
+		int e;
+
+		line_num++;
+
+		if (parse_route_line_is_comment (line))
+			continue;
+
+		e = parse_route_line (line, addr_family, NULL, &route, &local);
+
+		if (e < 0) {
+			if (e == -ERANGE)
+				PARSE_WARNING ("ignoring manual default route: '%s' (%s)", line, filename);
+			else {
+				/* we accept all unrecognized lines, because otherwise we would reject the
+				 * entire connection. */
+				PARSE_WARNING ("ignoring invalid route at \"%s\" (%s:%lu): %s", line, filename, (long unsigned) line_num, local->message);
+			}
+			continue;
+		}
+
+		if (!nm_setting_ip_config_add_route (s_ip, route))
+			PARSE_WARNING ("duplicate IPv%c route", addr_family == AF_INET ? '4' : '6');
+	}
+
+	return TRUE;
+}
+
+static void
+parse_dns_options (NMSettingIPConfig *ip_config, const char *value)
+{
+	gs_free const char **options = NULL;
+	const char *const *item;
+
+	g_return_if_fail (ip_config);
+
+	if (!value)
+		return;
+
+	if (!nm_setting_ip_config_has_dns_options (ip_config))
+		nm_setting_ip_config_clear_dns_options (ip_config, TRUE);
+
+	options = nm_utils_strsplit_set (value, " ");
+	if (options) {
+		for (item = options; *item; item++) {
+			if (!nm_setting_ip_config_add_dns_option (ip_config, *item))
+				PARSE_WARNING ("can't add DNS option '%s'", *item);
+		}
+	}
+}
+
+static gboolean
+parse_full_ip6_address (shvarFile *ifcfg,
+                        const char *addr_str,
+                        int i,
+                        NMIPAddress **out_address,
+                        GError **error)
+{
+	NMIPAddress *addr;
+	NMIPAddr addr_bin;
+	int prefix;
+
+	nm_assert (addr_str);
+	nm_assert (out_address && !*out_address);
+	nm_assert (!error || !*error);
+
+	if (!nm_utils_parse_inaddr_prefix_bin (AF_INET6,
+	                                       addr_str,
+	                                       NULL,
+	                                       &addr_bin,
+	                                       &prefix)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Invalid IP6 address '%s'", addr_str);
+		return FALSE;
+	}
+
+	if (prefix < 0)
+		prefix = 64;
+
+	addr = nm_ip_address_new_binary (AF_INET6, &addr_bin, prefix, error);
+	if (!addr)
+		return FALSE;
+
+	*out_address = addr;
+	return TRUE;
+}
+
+static NMSetting *
+make_user_setting (shvarFile *ifcfg)
+{
+	gboolean has_user_data = FALSE;
+	gs_unref_object NMSettingUser *s_user = NULL;
+	gs_unref_hashtable GHashTable *keys = NULL;
+	GHashTableIter iter;
+	const char *key;
+	nm_auto_free_gstring GString *str = NULL;
+
+	keys = svGetKeys (ifcfg, SV_KEY_TYPE_USER);
+	if (!keys)
+		return NULL;
+
+	g_hash_table_iter_init (&iter, keys);
+	while (g_hash_table_iter_next (&iter, (gpointer *) &key, NULL)) {
+		const char *value;
+		gs_free char *value_to_free = NULL;
+
+		value = svGetValue (ifcfg, key, &value_to_free);
+
+		if (!value)
+			continue;
+
+		if (!str)
+			str = g_string_sized_new (100);
+		else
+			g_string_set_size (str, 0);
+
+		if (!nms_ifcfg_rh_utils_user_key_decode (key + NM_STRLEN ("NM_USER_"), str))
+			continue;
+
+		if (!s_user)
+			s_user = NM_SETTING_USER (nm_setting_user_new ());
+
+		if (nm_setting_user_set_data (s_user, str->str,
+		                              value, NULL))
+			has_user_data = TRUE;
+	}
+
+	return   has_user_data
+	       ? NM_SETTING (g_steal_pointer (&s_user))
+	       : NULL;
+}
+
+static NMSetting *
+make_match_setting (shvarFile *ifcfg)
+{
+	NMSettingMatch *s_match = NULL;
+	gs_free const char **strv = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	gsize i;
+
+	v = svGetValueStr (ifcfg, "MATCH_INTERFACE_NAME", &value);
+	if (!v)
+		return NULL;
+
+	strv = nm_utils_escaped_tokens_split (v, NM_ASCII_SPACES);
+	if (strv) {
+		for (i = 0; strv[i]; i++) {
+			if (!s_match)
+				s_match = (NMSettingMatch *) nm_setting_match_new ();
+			nm_setting_match_add_interface_name (s_match, strv[i]);
+		}
+	}
+
+	return (NMSetting *) s_match;
+}
+
+static NMSetting *
+make_proxy_setting (shvarFile *ifcfg)
+{
+	NMSettingProxy *s_proxy = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	NMSettingProxyMethod method;
+
+	v = svGetValueStr (ifcfg, "PROXY_METHOD", &value);
+	if (!v)
+		return NULL;
+
+	if (!g_ascii_strcasecmp (v, "auto"))
+		method = NM_SETTING_PROXY_METHOD_AUTO;
+	else
+		method = NM_SETTING_PROXY_METHOD_NONE;
+
+	s_proxy = (NMSettingProxy *) nm_setting_proxy_new ();
+
+	switch (method) {
+	case NM_SETTING_PROXY_METHOD_AUTO:
+		g_object_set (s_proxy,
+		              NM_SETTING_PROXY_METHOD, (int) NM_SETTING_PROXY_METHOD_AUTO,
+		              NULL);
+
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "PAC_URL", &value);
+		if (v)
+			g_object_set (s_proxy, NM_SETTING_PROXY_PAC_URL, v, NULL);
+
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "PAC_SCRIPT", &value);
+		if (v)
+			g_object_set (s_proxy, NM_SETTING_PROXY_PAC_SCRIPT, v, NULL);
+
+		break;
+	case NM_SETTING_PROXY_METHOD_NONE:
+		g_object_set (s_proxy,
+		              NM_SETTING_PROXY_METHOD, (int) NM_SETTING_PROXY_METHOD_NONE,
+		              NULL);
+		break;
+	}
+
+	if (svGetValueBoolean (ifcfg, "BROWSER_ONLY", FALSE))
+		g_object_set (s_proxy, NM_SETTING_PROXY_BROWSER_ONLY, TRUE, NULL);
+
+	return NM_SETTING (s_proxy);
+}
+
+static NMSetting *
+make_ip4_setting (shvarFile *ifcfg,
+                  shvarFile *network_ifcfg,
+                  gboolean routes_read,
+                  gboolean *out_has_defroute,
+                  GError **error)
+{
+	gs_unref_object NMSettingIPConfig *s_ip4 = NULL;
+	gs_free char *route_path = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	char *method;
+	gs_free char *dns_options_free = NULL;
+	const char *dns_options = NULL;
+	gs_free char *gateway = NULL;
+	int i;
+	guint32 a;
+	gboolean has_key;
+	shvarFile *route_ifcfg;
+	gboolean never_default;
+	gint64 timeout;
+	int priority;
+	const char *const *item;
+	guint32 route_table;
+
+	nm_assert (out_has_defroute && !*out_has_defroute);
+
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+
+	/* First check if DEFROUTE is set for this device; DEFROUTE has the
+	 * opposite meaning from never-default. The default if DEFROUTE is not
+	 * specified is DEFROUTE=yes which means that this connection can be used
+	 * as a default route
+	 */
+	i = svGetValueBoolean (ifcfg, "DEFROUTE", -1);
+	if (i == -1)
+		never_default = FALSE;
+	else {
+		never_default = !i;
+		*out_has_defroute = TRUE;
+	}
+
+	/* Then check if GATEWAYDEV; it's global and overrides DEFROUTE */
+	if (network_ifcfg) {
+		gs_free char *gatewaydev_value = NULL;
+		const char *gatewaydev;
+
+		/* Get the connection ifcfg device name and the global gateway device */
+		v = svGetValueStr (ifcfg, "DEVICE", &value);
+		gatewaydev = svGetValueStr (network_ifcfg, "GATEWAYDEV", &gatewaydev_value);
+		dns_options = svGetValue (network_ifcfg, "RES_OPTIONS", &dns_options_free);
+
+		/* If there was a global gateway device specified, then only connections
+		 * for that device can be the default connection.
+		 */
+		if (gatewaydev && v)
+			never_default = !!strcmp (v, gatewaydev);
+
+		nm_clear_g_free (&value);
+	}
+
+	v = svGetValueStr (ifcfg, "BOOTPROTO", &value);
+
+	if (!v || !*v || !g_ascii_strcasecmp (v, "none")) {
+		if (is_any_ip4_address_defined (ifcfg, NULL))
+			method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
+		else
+			method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
+	} else if (!g_ascii_strcasecmp (v, "bootp") || !g_ascii_strcasecmp (v, "dhcp")) {
+		method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+	} else if (!g_ascii_strcasecmp (v, "static")) {
+		if (is_any_ip4_address_defined (ifcfg, NULL))
+			method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
+		else
+			method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
+	} else if (!g_ascii_strcasecmp (v, "autoip")) {
+		method = NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL;
+	} else if (!g_ascii_strcasecmp (v, "shared")) {
+		method = NM_SETTING_IP4_CONFIG_METHOD_SHARED;
+	} else {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Unknown BOOTPROTO '%s'", v);
+		return NULL;
+	}
+
+	/* the route table (policy routing) is ignored if we don't handle routes. */
+	route_table = svGetValueInt64 (ifcfg, "IPV4_ROUTE_TABLE", 10,
+	                               0, G_MAXUINT32, 0);
+	if (   route_table != 0
+	    && !routes_read) {
+		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing (IPV4_ROUTE_TABLE) is ignored");
+		route_table = 0;
+	}
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, method,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (ifcfg, "PEERDNS", TRUE),
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (ifcfg, "PEERROUTES", TRUE),
+	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, never_default,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (ifcfg, "IPV4_FAILURE_FATAL", FALSE),
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (ifcfg, "IPV4_ROUTE_METRIC", 10,
+	                                                                  -1, G_MAXUINT32, -1),
+	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, (guint) route_table,
+	              NULL);
+
+	if (nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED))
+		return NM_SETTING (g_steal_pointer (&s_ip4));
+
+	/* Handle DHCP settings */
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DHCP_HOSTNAME", &value);
+	if (v)
+		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DHCP_FQDN", &value);
+	if (v) {
+		g_object_set (s_ip4,
+		              NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, NULL,
+		              NM_SETTING_IP4_CONFIG_DHCP_FQDN, v,
+		              NULL);
+	}
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, svGetValueBoolean (ifcfg, "DHCP_SEND_HOSTNAME", TRUE),
+	              NM_SETTING_IP_CONFIG_DHCP_TIMEOUT, svGetValueInt64 (ifcfg, "IPV4_DHCP_TIMEOUT", 10, 0, G_MAXINT32, 0),
+	              NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DHCP_CLIENT_ID", &value);
+	if (v)
+		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, v, NULL);
+
+	/* Read static IP addresses.
+	 * Read them even for AUTO method - in this case the addresses are
+	 * added to the automatic ones. Note that this is not currently supported by
+	 * the legacy 'network' service (ifup-eth).
+	 */
+	for (i = -1;; i++) {
+		NMIPAddress *addr = NULL;
+
+		/* gateway will only be set if still unset. Hence, we don't leak gateway
+		 * here by calling read_full_ip4_address() repeatedly */
+		if (!read_full_ip4_address (ifcfg, i, NULL, &addr, &gateway, error))
+			return NULL;
+
+		if (!addr) {
+			/* The first mandatory variable is 2-indexed (IPADDR2)
+			 * Variables IPADDR, IPADDR0 and IPADDR1 are optional */
+			if (i > 1)
+				break;
+			continue;
+		}
+
+		if (!nm_setting_ip_config_add_address (s_ip4, addr))
+			PARSE_WARNING ("duplicate IP4 address");
+		nm_ip_address_unref (addr);
+	}
+
+	/* Gateway */
+	if (!gateway) {
+		if (network_ifcfg) {
+			gboolean read_success;
+
+			read_success = read_ip4_address (network_ifcfg, "GATEWAY", &has_key, &a, error);
+			if (!read_success)
+				return NULL;
+			if (has_key) {
+				if (nm_setting_ip_config_get_num_addresses (s_ip4) == 0) {
+					gs_free char *f = g_path_get_basename (svFileGetName (ifcfg));
+					PARSE_WARNING ("ignoring GATEWAY (/etc/sysconfig/network) for %s "
+					               "because the connection has no static addresses", f);
+				} else
+					gateway = nm_utils_inet4_ntop_dup (a);
+			}
+		}
+	}
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_GATEWAY, gateway, NULL);
+
+	if (gateway && never_default)
+		PARSE_WARNING ("GATEWAY will be ignored when DEFROUTE is disabled");
+
+	/* We used to skip saving a lot of unused properties for the ipv4 shared method.
+	 * We want now to persist them but... unfortunately loading DNS or DOMAIN options
+	 * would cause a fail in the ipv4 verify() function. As we don't want any regression
+	 * in the unlikely event that someone has a working ifcfg file for an IPv4 shared ip
+	 * connection with a crafted "DNS" entry... don't load it. So we will avoid failing
+	 * the connection) */
+	if (!nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED)) {
+		/* DNS servers
+		 * Pick up just IPv4 addresses (IPv6 addresses are taken by make_ip6_setting())
+		 */
+		for (i = 1; i <= 10; i++) {
+			char tag[256];
+
+			numbered_tag (tag, "DNS", i);
+			nm_clear_g_free (&value);
+			v = svGetValueStr (ifcfg, tag, &value);
+			if (v) {
+				if (nm_utils_ipaddr_valid (AF_INET, v)) {
+					if (!nm_setting_ip_config_add_dns (s_ip4, v))
+						PARSE_WARNING ("duplicate DNS server %s", tag);
+				} else if (nm_utils_ipaddr_valid (AF_INET6, v)) {
+					/* Ignore IPv6 addresses */
+				} else {
+					PARSE_WARNING ("invalid DNS server address %s", v);
+					return NULL;
+				}
+			}
+		}
+
+		/* DNS searches */
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "DOMAIN", &value);
+		if (v) {
+			gs_free const char **searches = NULL;
+
+			searches = nm_utils_strsplit_set (v, " ");
+			if (searches) {
+				for (item = searches; *item; item++) {
+					if (!nm_setting_ip_config_add_dns_search (s_ip4, *item))
+						PARSE_WARNING ("duplicate DNS domain '%s'", *item);
+				}
+			}
+		}
+	}
+
+	/* DNS options */
+	nm_clear_g_free (&value);
+	parse_dns_options (s_ip4, svGetValue (ifcfg, "RES_OPTIONS", &value));
+	parse_dns_options (s_ip4, dns_options);
+
+	/* DNS priority */
+	priority = svGetValueInt64 (ifcfg, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
+	              priority,
+	              NULL);
+
+	/* Static routes  - route-<name> file */
+	route_path = utils_get_route_path (svFileGetName (ifcfg));
+
+	if (!routes_read) {
+		/* NOP */
+	} else if (utils_has_route_file_new_syntax (route_path)) {
+		/* Parse route file in new syntax */
+		route_ifcfg = utils_get_route_ifcfg (svFileGetName (ifcfg), FALSE);
+		if (route_ifcfg) {
+			for (i = 0;; i++) {
+				NMIPRoute *route = NULL;
+
+				if (!read_one_ip4_route (route_ifcfg, i, &route, error)) {
+					svCloseFile (route_ifcfg);
+					return NULL;
+				}
+
+				if (!route)
+					break;
+
+				if (!nm_setting_ip_config_add_route (s_ip4, route))
+					PARSE_WARNING ("duplicate IP4 route");
+				nm_ip_route_unref (route);
+			}
+			svCloseFile (route_ifcfg);
+		}
+	} else {
+		if (!read_route_file (AF_INET, route_path, s_ip4, error))
+			return NULL;
+	}
+
+	/* Legacy value NM used for a while but is incorrect (rh #459370) */
+	if (   !nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED)
+	    && !nm_setting_ip_config_get_num_dns_searches (s_ip4)) {
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "SEARCH", &value);
+		if (v) {
+			gs_free const char **searches = NULL;
+
+			searches = nm_utils_strsplit_set (v, " ");
+			if (searches) {
+				for (item = searches; *item; item++) {
+					if (!nm_setting_ip_config_add_dns_search (s_ip4, *item))
+						PARSE_WARNING ("duplicate DNS search '%s'", *item);
+				}
+			}
+		}
+	}
+
+	timeout = svGetValueInt64 (ifcfg, "ACD_TIMEOUT", 10, -1, NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX, -2);
+	if (timeout == -2) {
+		timeout = svGetValueInt64 (ifcfg, "ARPING_WAIT", 10, -1,
+		                           NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX / 1000, -1);
+		if (timeout > 0)
+			timeout *= 1000;
+	}
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DAD_TIMEOUT, (int) timeout, NULL);
+
+	return NM_SETTING (g_steal_pointer (&s_ip4));
+}
+
+static void
+read_aliases (NMSettingIPConfig *s_ip4, gboolean read_defroute, const char *filename)
+{
+	GDir *dir;
+	gs_free char *dirname  = NULL;
+	gs_free char *base  = NULL;
+	NMIPAddress *base_addr = NULL;
+	GError *err = NULL;
+
+	g_return_if_fail (s_ip4 != NULL);
+	g_return_if_fail (filename != NULL);
+
+	if (nm_setting_ip_config_get_num_addresses (s_ip4) > 0)
+		base_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+
+	dirname = g_path_get_dirname (filename);
+	nm_assert (dirname != NULL);
+	base = g_path_get_basename (filename);
+	nm_assert (base != NULL);
+
+	dir = g_dir_open (dirname, 0, &err);
+	if (dir) {
+		const char *item;
+		NMIPAddress *addr;
+		gboolean ok;
+
+		while ((item = g_dir_read_name (dir))) {
+			nm_auto_shvar_file_close shvarFile *parsed = NULL;
+			gs_free char *gateway = NULL;
+			gs_free char *device_value = NULL;
+			gs_free char *full_path = NULL;
+			const char *device;
+			const char *p;
+
+			if (!utils_is_ifcfg_alias_file (item, base))
+				continue;
+
+			full_path = g_build_filename (dirname, item, NULL);
+
+			p = strchr (item, ':');
+			g_assert (p != NULL); /* we know this is true from utils_is_ifcfg_alias_file() */
+			for (p++; *p; p++) {
+				if (!g_ascii_isalnum (*p) && *p != '_')
+					break;
+			}
+			if (*p) {
+				PARSE_WARNING ("ignoring alias file '%s' with invalid name", full_path);
+				continue;
+			}
+
+			parsed = svOpenFile (full_path, &err);
+			if (!parsed) {
+				PARSE_WARNING ("couldn't parse alias file '%s': %s", full_path, err->message);
+				g_clear_error (&err);
+				continue;
+			}
+
+			device = svGetValueStr (parsed, "DEVICE", &device_value);
+			if (!device) {
+				PARSE_WARNING ("alias file '%s' has no DEVICE", full_path);
+				continue;
+			}
+			/* We know that item starts with IFCFG_TAG from utils_is_ifcfg_alias_file() */
+			if (strcmp (device, item + strlen (IFCFG_TAG)) != 0) {
+				PARSE_WARNING ("alias file '%s' has invalid DEVICE (%s) for filename",
+				               full_path, device);
+				continue;
+			}
+
+			addr = NULL;
+			ok = read_full_ip4_address (parsed, -1, base_addr, &addr,
+			                            read_defroute ? &gateway : NULL,
+			                            &err);
+			if (ok) {
+				nm_ip_address_set_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL, g_variant_new_string (device));
+				if (!nm_setting_ip_config_add_address (s_ip4, addr))
+					PARSE_WARNING ("duplicate IP4 address in alias file %s", item);
+				if (nm_streq0 (nm_setting_ip_config_get_method (s_ip4), NM_SETTING_IP4_CONFIG_METHOD_DISABLED))
+					g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL, NULL);
+				if (read_defroute) {
+					int i;
+
+					if (gateway) {
+						g_object_set (s_ip4, NM_SETTING_IP_CONFIG_GATEWAY, gateway, NULL);
+						read_defroute = FALSE;
+					}
+					i = svGetValueBoolean (parsed, "DEFROUTE", -1);
+					if (i != -1) {
+						g_object_set (s_ip4,
+						              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, (gboolean) !i,
+						              NULL);
+						read_defroute = FALSE;
+					}
+				}
+			} else {
+				PARSE_WARNING ("error reading IP4 address from alias file '%s': %s",
+				               full_path, err ? err->message : "no address");
+				g_clear_error (&err);
+			}
+			nm_ip_address_unref (addr);
+		}
+
+		g_dir_close (dir);
+	} else {
+		PARSE_WARNING ("can not read directory '%s': %s", dirname, err->message);
+		g_error_free (err);
+	}
+}
+
+static NMSetting *
+make_ip6_setting (shvarFile *ifcfg,
+                  shvarFile *network_ifcfg,
+                  gboolean routes_read,
+                  GError **error)
+{
+	gs_unref_object NMSettingIPConfig *s_ip6 = NULL;
+	const char *v;
+	gs_free char *value = NULL;
+	gboolean ipv6init;
+	gboolean ipv6forwarding;
+	gboolean disabled;
+	gboolean dhcp6 = FALSE;
+	char *method = NM_SETTING_IP6_CONFIG_METHOD_MANUAL;
+	const char *ipv6addr, *ipv6addr_secondaries;
+	gs_free char *ipv6addr_to_free = NULL;
+	gs_free char *ipv6addr_secondaries_to_free = NULL;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+	guint32 i;
+	int i_val;
+	GError *local = NULL;
+	int priority;
+	gboolean never_default = FALSE;
+	gboolean ip6_privacy = FALSE, ip6_privacy_prefer_public_ip;
+	NMSettingIP6ConfigPrivacy ip6_privacy_val;
+	guint32 route_table;
+
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+
+	/* First check if IPV6_DEFROUTE is set for this device; IPV6_DEFROUTE has the
+	 * opposite meaning from never-default. The default if IPV6_DEFROUTE is not
+	 * specified is IPV6_DEFROUTE=yes which means that this connection can be used
+	 * as a default route
+	 */
+	never_default = !svGetValueBoolean (ifcfg, "IPV6_DEFROUTE", TRUE);
+
+	/* Then check if IPV6_DEFAULTGW or IPV6_DEFAULTDEV is specified;
+	 * they are global and override IPV6_DEFROUTE
+	 * When both are set, the device specified in IPV6_DEFAULTGW takes preference.
+	 */
+	if (network_ifcfg) {
+		const char *ipv6_defaultgw, *ipv6_defaultdev;
+		gs_free char *ipv6_defaultgw_to_free = NULL;
+		gs_free char *ipv6_defaultdev_to_free = NULL;
+		const char *default_dev = NULL;
+
+		/* Get the connection ifcfg device name and the global default route device */
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "DEVICE", &value);
+		ipv6_defaultgw = svGetValueStr (network_ifcfg, "IPV6_DEFAULTGW", &ipv6_defaultgw_to_free);
+		ipv6_defaultdev = svGetValueStr (network_ifcfg, "IPV6_DEFAULTDEV", &ipv6_defaultdev_to_free);
+
+		if (ipv6_defaultgw) {
+			default_dev = strchr (ipv6_defaultgw, '%');
+			if (default_dev)
+				default_dev++;
+		}
+		if (!default_dev)
+			default_dev = ipv6_defaultdev;
+
+		/* If there was a global default route device specified, then only connections
+		 * for that device can be the default connection.
+		 */
+		if (default_dev && v)
+			never_default = !!strcmp (v, default_dev);
+	}
+
+	/* Find out method property */
+	/* Is IPV6 enabled? Set method to "ignored", when not enabled */
+	disabled = svGetValueBoolean(ifcfg, "IPV6_DISABLED", FALSE);
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IPV6INIT", &value);
+	ipv6init = svGetValueBoolean (ifcfg, "IPV6INIT", FALSE);
+	if (!v) {
+		if (network_ifcfg)
+			ipv6init = svGetValueBoolean (network_ifcfg, "IPV6INIT", FALSE);
+	}
+
+	if (disabled)
+		method = NM_SETTING_IP6_CONFIG_METHOD_DISABLED;
+	else if (!ipv6init)
+		method = NM_SETTING_IP6_CONFIG_METHOD_IGNORE;
+	else {
+		ipv6forwarding = svGetValueBoolean (ifcfg, "IPV6FORWARDING", FALSE);
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "IPV6_AUTOCONF", &value);
+		dhcp6 = svGetValueBoolean (ifcfg, "DHCPV6C", FALSE);
+
+		if (!g_strcmp0 (v, "shared"))
+			method = NM_SETTING_IP6_CONFIG_METHOD_SHARED;
+		else if (svParseBoolean (v, !ipv6forwarding))
+			method = NM_SETTING_IP6_CONFIG_METHOD_AUTO;
+		else if (dhcp6)
+			method = NM_SETTING_IP6_CONFIG_METHOD_DHCP;
+		else {
+			/* IPV6_AUTOCONF=no and no IPv6 address -> method 'link-local' */
+			nm_clear_g_free (&value);
+			v = svGetValueStr (ifcfg, "IPV6ADDR", &value);
+			if (!v) {
+				nm_clear_g_free (&value);
+				v = svGetValueStr (ifcfg, "IPV6ADDR_SECONDARIES", &value);
+			}
+
+			if (!v)
+				method = NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL;
+		}
+	}
+	/* TODO - handle other methods */
+
+	/* Read IPv6 Privacy Extensions configuration */
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IPV6_PRIVACY", &value);
+	if (v) {
+		ip6_privacy = svParseBoolean (v, FALSE);
+		if (!ip6_privacy)
+			ip6_privacy = (g_strcmp0 (v, "rfc4941") == 0) ||
+			              (g_strcmp0 (v, "rfc3041") == 0);
+	}
+	ip6_privacy_prefer_public_ip = svGetValueBoolean (ifcfg, "IPV6_PRIVACY_PREFER_PUBLIC_IP", FALSE);
+	ip6_privacy_val = v ?
+	                      (ip6_privacy ?
+	                          (ip6_privacy_prefer_public_ip ? NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR : NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR) :
+	                          NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED) :
+	                      NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN;
+
+	/* the route table (policy routing) is ignored if we don't handle routes. */
+	route_table = svGetValueInt64 (ifcfg, "IPV6_ROUTE_TABLE", 10,
+	                               0, G_MAXUINT32, 0);
+	if (   route_table != 0
+	    && !routes_read) {
+		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing (IPV6_ROUTE_TABLE) is ignored");
+		route_table = 0;
+	}
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, method,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (ifcfg, "IPV6_PEERDNS", TRUE),
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (ifcfg, "IPV6_PEERROUTES", TRUE),
+	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, never_default,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (ifcfg, "IPV6_FAILURE_FATAL", FALSE),
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (ifcfg, "IPV6_ROUTE_METRIC", 10,
+	                                                                  -1, G_MAXUINT32, -1),
+	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, (guint) route_table,
+	              NM_SETTING_IP6_CONFIG_IP6_PRIVACY, ip6_privacy_val,
+	              NULL);
+
+	/* Don't bother to read IP, DNS and routes when IPv6 is disabled */
+	if (NM_IN_STRSET (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	                          NM_SETTING_IP6_CONFIG_METHOD_DISABLED))
+		return NM_SETTING (g_steal_pointer (&s_ip6));
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DHCPV6_DUID", &value);
+	if (v)
+		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_DHCP_DUID, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DHCPV6_HOSTNAME", &value);
+	/* Use DHCP_HOSTNAME as fallback if it is in FQDN format and ipv6.method is
+	 * auto or dhcp: this is required to support old ifcfg files
+	 */
+	if (!v && (   !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
+		       || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_DHCP))) {
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "DHCP_HOSTNAME", &value);
+		if (v && !strchr (v, '.'))
+			v = NULL;
+	}
+	if (v)
+		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, v, NULL);
+
+	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME,
+	              svGetValueBoolean (ifcfg, "DHCPV6_SEND_HOSTNAME", TRUE), NULL);
+
+	/* Read static IP addresses.
+	 * Read them even for AUTO and DHCP methods - in this case the addresses are
+	 * added to the automatic ones. Note that this is not currently supported by
+	 * the legacy 'network' service (ifup-eth).
+	 */
+	ipv6addr = svGetValueStr (ifcfg, "IPV6ADDR", &ipv6addr_to_free);
+	ipv6addr_secondaries = svGetValueStr (ifcfg, "IPV6ADDR_SECONDARIES", &ipv6addr_secondaries_to_free);
+
+	nm_clear_g_free (&value);
+	value = g_strjoin (ipv6addr && ipv6addr_secondaries ? " " : NULL,
+	                   ipv6addr ?: "",
+	                   ipv6addr_secondaries ?: "",
+	                   NULL);
+
+	list = nm_utils_strsplit_set (value, " ");
+	for (iter = list, i = 0; iter && *iter; iter++, i++) {
+		NMIPAddress *addr = NULL;
+
+		if (!parse_full_ip6_address (ifcfg, *iter, i, &addr, error))
+			return NULL;
+
+		if (!nm_setting_ip_config_add_address (s_ip6, addr))
+			PARSE_WARNING ("duplicate IP6 address");
+		nm_ip_address_unref (addr);
+	}
+
+	/* Gateway */
+	if (nm_setting_ip_config_get_num_addresses (s_ip6)) {
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, "IPV6_DEFAULTGW", &value);
+		if (!v) {
+			/* If no gateway in the ifcfg, try global /etc/sysconfig/network instead */
+			if (network_ifcfg) {
+				nm_clear_g_free (&value);
+				v = svGetValueStr (network_ifcfg, "IPV6_DEFAULTGW", &value);
+			}
+		}
+		if (v) {
+			char *ptr;
+			if ((ptr = strchr (v, '%')) != NULL)
+				*ptr = '\0';  /* remove %interface prefix if present */
+			if (!nm_utils_ipaddr_valid (AF_INET6, v)) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Invalid IP6 address '%s'", v);
+				return NULL;
+			}
+
+			g_object_set (s_ip6, NM_SETTING_IP_CONFIG_GATEWAY, v, NULL);
+		}
+	}
+
+	i_val = NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64;
+	if (!svGetValueEnum (ifcfg, "IPV6_ADDR_GEN_MODE",
+	                     nm_setting_ip6_config_addr_gen_mode_get_type (),
+	                     &i_val, &local)) {
+		PARSE_WARNING ("%s", local->message);
+		g_clear_error (&local);
+	}
+	g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, i_val, NULL);
+
+	/* IPv6 tokenized interface identifier */
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IPV6_TOKEN", &value);
+	if (v)
+		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_TOKEN, v, NULL);
+
+	/* DNS servers
+	 * Pick up just IPv6 addresses (IPv4 addresses are taken by make_ip4_setting())
+	 */
+	for (i = 1; i <= 10; i++) {
+		char tag[256];
+
+		numbered_tag (tag, "DNS", i);
+		nm_clear_g_free (&value);
+		v = svGetValueStr (ifcfg, tag, &value);
+		if (!v) {
+			/* all done */
+			break;
+		}
+
+		if (nm_utils_ipaddr_valid (AF_INET6, v)) {
+			if (!nm_setting_ip_config_add_dns (s_ip6, v))
+				PARSE_WARNING ("duplicate DNS server %s", tag);
+		} else if (nm_utils_ipaddr_valid (AF_INET, v)) {
+			/* Ignore IPv4 addresses */
+		} else {
+			PARSE_WARNING ("invalid DNS server address %s", v);
+			return NULL;
+		}
+	}
+
+	if (!routes_read) {
+		/* NOP */
+	} else {
+		gs_free char *route6_path = NULL;
+
+		/* Read static routes from route6-<interface> file */
+		route6_path = utils_get_route6_path (svFileGetName (ifcfg));
+		if (!read_route_file (AF_INET6, route6_path, s_ip6, error))
+			return NULL;
+	}
+
+	/* DNS searches */
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IPV6_DOMAIN", &value);
+	if (v) {
+		gs_free const char **searches = NULL;
+
+		searches = nm_utils_strsplit_set (v, " ");
+		if (searches) {
+			for (iter = searches; *iter; iter++) {
+				if (!nm_setting_ip_config_add_dns_search (s_ip6, *iter))
+					PARSE_WARNING ("duplicate DNS domain '%s'", *iter);
+			}
+		}
+	}
+
+	/* DNS options */
+	nm_clear_g_free (&value);
+	parse_dns_options (s_ip6, svGetValue (ifcfg, "IPV6_RES_OPTIONS", &value));
+
+	/* DNS priority */
+	priority = svGetValueInt64 (ifcfg, "IPV6_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
+	              priority,
+	              NULL);
+
+	return NM_SETTING (g_steal_pointer (&s_ip6));
+}
+
+static NMSetting *
+make_sriov_setting (shvarFile *ifcfg)
+{
+	gs_unref_hashtable GHashTable *keys = NULL;
+	gs_unref_ptrarray GPtrArray *vfs = NULL;
+	int autoprobe_drivers;
+	NMSettingSriov *s_sriov;
+	gint64 total_vfs;
+
+
+	total_vfs = svGetValueInt64 (ifcfg, "SRIOV_TOTAL_VFS", 10, 0, G_MAXUINT32, -1);
+
+	autoprobe_drivers = svGetValueInt64 (ifcfg,
+	                                     "SRIOV_AUTOPROBE_DRIVERS",
+	                                     10,
+	                                     NM_TERNARY_DEFAULT,
+	                                     NM_TERNARY_TRUE,
+	                                     -2);
+
+	keys = svGetKeys (ifcfg, SV_KEY_TYPE_SRIOV_VF);
+	if (keys) {
+		GHashTableIter iter;
+		const char *key;
+
+		g_hash_table_iter_init (&iter, keys);
+		while (g_hash_table_iter_next (&iter, (gpointer *) &key, NULL)) {
+			gs_free_error GError *error = NULL;
+			gs_free char *value_to_free = NULL;
+			const char *value;
+			NMSriovVF *vf;
+
+			nm_assert (g_str_has_prefix (key, "SRIOV_VF"));
+
+			value = svGetValue (ifcfg, key, &value_to_free);
+			if (!value)
+				continue;
+
+			key += NM_STRLEN ("SRIOV_VF");
+
+			vf = _nm_utils_sriov_vf_from_strparts (key, value, TRUE, &error);
+			if (!vf) {
+				PARSE_WARNING ("ignoring invalid SR-IOV VF '%s %s': %s",
+				               key, value, error->message);
+				continue;
+			}
+			if (!vfs)
+				vfs = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_sriov_vf_unref);
+			g_ptr_array_add (vfs, vf);
+		}
+	}
+
+	/* Create the setting when at least one key is set */
+	if (   total_vfs < 0
+	    && !vfs
+	    && autoprobe_drivers < NM_TERNARY_DEFAULT)
+		return NULL;
+
+	s_sriov = (NMSettingSriov *) nm_setting_sriov_new ();
+
+	autoprobe_drivers = NM_MAX (autoprobe_drivers, NM_TERNARY_DEFAULT);
+	total_vfs = NM_MAX (total_vfs, 0);
+
+	g_object_set (s_sriov,
+	              NM_SETTING_SRIOV_TOTAL_VFS, (guint) total_vfs,
+	              NM_SETTING_SRIOV_VFS, vfs,
+	              NM_SETTING_SRIOV_AUTOPROBE_DRIVERS, autoprobe_drivers,
+	              NULL);
+
+	return (NMSetting *) s_sriov;
+}
+
+static NMSetting *
+make_tc_setting (shvarFile *ifcfg)
+{
+	NMSettingTCConfig *s_tc = NULL;
+	char tag[256];
+	int i;
+
+	s_tc = (NMSettingTCConfig *) nm_setting_tc_config_new ();
+
+	for (i = 1;; i++) {
+		NMTCQdisc *qdisc = NULL;
+		gs_free char *value_to_free = NULL;
+		const char *value = NULL;
+		GError *local = NULL;
+
+		value = svGetValueStr (ifcfg, numbered_tag (tag, "QDISC", i), &value_to_free);
+		if (!value)
+			break;
+
+		qdisc = nm_utils_tc_qdisc_from_str (value, &local);
+		if (!qdisc) {
+			PARSE_WARNING ("ignoring bad tc qdisc: '%s': %s", value, local->message);
+			continue;
+		}
+
+		if (!nm_setting_tc_config_add_qdisc (s_tc, qdisc))
+			PARSE_WARNING ("duplicate tc qdisc");
+
+		nm_tc_qdisc_unref (qdisc);
+	}
+
+	for (i = 1;; i++) {
+		NMTCTfilter *tfilter = NULL;
+		gs_free char *value_to_free = NULL;
+		const char *value = NULL;
+		GError *local = NULL;
+
+		value = svGetValueStr (ifcfg, numbered_tag (tag, "FILTER", i), &value_to_free);
+		if (!value)
+			break;
+
+		tfilter = nm_utils_tc_tfilter_from_str (value, &local);
+		if (!tfilter) {
+			PARSE_WARNING ("ignoring bad tc filter: '%s': %s", value, local->message);
+			continue;
+		}
+
+		if (!nm_setting_tc_config_add_tfilter (s_tc, tfilter))
+			PARSE_WARNING ("duplicate tc filter");
+
+		nm_tc_tfilter_unref (tfilter);
+	}
+
+	if (   nm_setting_tc_config_get_num_qdiscs (s_tc) > 0
+	    || nm_setting_tc_config_get_num_tfilters (s_tc) > 0)
+		return NM_SETTING (s_tc);
+
+	g_object_unref (s_tc);
+	return NULL;
+}
+
+typedef struct {
+	const char *enable_key;
+	const char *advertise_key;
+	const char *willing_key;
+	const char *flags_prop;
+} DcbFlagsProperty;
+
+enum {
+	DCB_APP_FCOE_FLAGS = 0,
+	DCB_APP_ISCSI_FLAGS = 1,
+	DCB_APP_FIP_FLAGS = 2,
+	DCB_PFC_FLAGS = 3,
+	DCB_PG_FLAGS = 4,
+};
+
+static DcbFlagsProperty dcb_flags_props[] = {
+	{ KEY_DCB_APP_FCOE_ENABLE,  KEY_DCB_APP_FCOE_ADVERTISE,  KEY_DCB_APP_FCOE_WILLING,  NM_SETTING_DCB_APP_FCOE_FLAGS },
+	{ KEY_DCB_APP_ISCSI_ENABLE, KEY_DCB_APP_ISCSI_ADVERTISE, KEY_DCB_APP_ISCSI_WILLING, NM_SETTING_DCB_APP_ISCSI_FLAGS },
+	{ KEY_DCB_APP_FIP_ENABLE,   KEY_DCB_APP_FIP_ADVERTISE,   KEY_DCB_APP_FIP_WILLING,   NM_SETTING_DCB_APP_FIP_FLAGS },
+	{ KEY_DCB_PFC_ENABLE,       KEY_DCB_PFC_ADVERTISE,       KEY_DCB_PFC_WILLING,       NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS },
+	{ KEY_DCB_PG_ENABLE,        KEY_DCB_PG_ADVERTISE,        KEY_DCB_PG_WILLING,        NM_SETTING_DCB_PRIORITY_GROUP_FLAGS },
+	{ NULL },
+};
+
+static NMSettingDcbFlags
+read_dcb_flags (shvarFile *ifcfg, DcbFlagsProperty *property)
+{
+	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
+
+	if (svGetValueBoolean (ifcfg, property->enable_key, FALSE))
+		flags |= NM_SETTING_DCB_FLAG_ENABLE;
+	if (svGetValueBoolean (ifcfg, property->advertise_key, FALSE))
+		flags |= NM_SETTING_DCB_FLAG_ADVERTISE;
+	if (svGetValueBoolean (ifcfg, property->willing_key, FALSE))
+		flags |= NM_SETTING_DCB_FLAG_WILLING;
+
+	return flags;
+}
+
+static gboolean
+read_dcb_app (shvarFile *ifcfg,
+              NMSettingDcb *s_dcb,
+              const char *app,
+              DcbFlagsProperty *flags_prop,
+              const char *priority_prop,
+              GError **error)
+{
+	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
+	gs_free char *value = NULL;
+	const char *v;
+	gboolean success = TRUE;
+	int priority = -1;
+	char key[255];
+
+	flags = read_dcb_flags (ifcfg, flags_prop);
+
+	/* Priority */
+	nm_sprintf_buf (key, "DCB_APP_%s_PRIORITY", app);
+	v = svGetValueStr (ifcfg, key, &value);
+	if (v) {
+		priority = _nm_utils_ascii_str_to_int64 (v, 0, 0, 7, -1);
+		if (priority < 0) {
+			success = FALSE;
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid %s value '%s' (expected 0 - 7)",
+			             key, v);
+		}
+
+		if (!(flags & NM_SETTING_DCB_FLAG_ENABLE))
+			PARSE_WARNING ("ignoring DCB %s priority; app not enabled", app);
+	}
+
+	if (success) {
+		g_object_set (G_OBJECT (s_dcb),
+		              flags_prop->flags_prop, flags,
+		              priority_prop, (guint) priority,
+		              NULL);
+	}
+
+	return success;
+}
+
+typedef void (*DcbSetBoolFunc) (NMSettingDcb *, guint, gboolean);
+
+static gboolean
+read_dcb_bool_array (shvarFile *ifcfg,
+                     NMSettingDcb *s_dcb,
+                     NMSettingDcbFlags flags,
+                     const char *prop,
+                     const char *desc,
+                     DcbSetBoolFunc set_func,
+                     GError **error)
+{
+	gs_free char *value = NULL;
+	const char *v;
+	guint i;
+
+	v = svGetValueStr (ifcfg, prop, &value);
+	if (!v)
+		return TRUE;
+
+	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
+		PARSE_WARNING ("ignoring %s; %s is not enabled", prop, desc);
+		return TRUE;
+	}
+
+	if (strlen (v) != 8) {
+		PARSE_WARNING ("%s value '%s' must be 8 characters long", prop, v);
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "boolean array must be 8 characters");
+		return FALSE;
+	}
+
+	/* All characters must be either 0 or 1 */
+	for (i = 0; i < 8; i++) {
+		if (v[i] != '0' && v[i] != '1') {
+			PARSE_WARNING ("invalid %s value '%s': not all 0s and 1s", prop, v);
+			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			                     "invalid boolean digit");
+			return FALSE;
+		}
+		set_func (s_dcb, i, (v[i] == '1'));
+	}
+	return TRUE;
+}
+
+typedef void (*DcbSetUintFunc) (NMSettingDcb *, guint, guint);
+
+static gboolean
+read_dcb_uint_array (shvarFile *ifcfg,
+                     NMSettingDcb *s_dcb,
+                     NMSettingDcbFlags flags,
+                     const char *prop,
+                     const char *desc,
+                     gboolean f_allowed,
+                     DcbSetUintFunc set_func,
+                     GError **error)
+{
+	gs_free char *val = NULL;
+	guint i;
+
+	val = svGetValueStr_cp (ifcfg, prop);
+	if (!val)
+		return TRUE;
+
+	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
+		PARSE_WARNING ("ignoring %s; %s is not enabled", prop, desc);
+		return TRUE;
+	}
+
+	if (strlen (val) != 8) {
+		PARSE_WARNING ("%s value '%s' must be 8 characters long", prop, val);
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "uint array must be 8 characters");
+		return FALSE;
+	}
+
+	/* All characters must be either 0 - 7 or (optionally) f */
+	for (i = 0; i < 8; i++) {
+		if (val[i] >= '0' && val[i] <= '7')
+			set_func (s_dcb, i, val[i] - '0');
+		else if (f_allowed && (val[i] == 'f' || val[i] == 'F'))
+			set_func (s_dcb, i, 15);
+		else {
+			PARSE_WARNING ("invalid %s value '%s': not 0 - 7%s",
+			               prop, val, f_allowed ? " or 'f'" : "");
+			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			                     "invalid uint digit");
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+read_dcb_percent_array (shvarFile *ifcfg,
+                        NMSettingDcb *s_dcb,
+                        NMSettingDcbFlags flags,
+                        const char *prop,
+                        const char *desc,
+                        gboolean sum_pct,
+                        DcbSetUintFunc set_func,
+                        GError **error)
+{
+	gs_free char *val = NULL;
+	gs_free const char **split = NULL;
+	const char *const *iter;
+	guint i, sum = 0;
+
+	val = svGetValueStr_cp (ifcfg, prop);
+	if (!val)
+		return TRUE;
+
+	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
+		PARSE_WARNING ("ignoring %s; %s is not enabled", prop, desc);
+		return TRUE;
+	}
+
+	split = nm_utils_strsplit_set (val, ",");
+	if (NM_PTRARRAY_LEN (split) != 8) {
+		PARSE_WARNING ("invalid %s percentage list value '%s'", prop, val);
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "percent array must be 8 elements");
+		return FALSE;
+	}
+
+	for (iter = split, i = 0; iter && *iter; iter++, i++) {
+		int tmp;
+
+		tmp = _nm_utils_ascii_str_to_int64 (*iter, 0, 0, 100, -1);
+		if (tmp < 0) {
+			PARSE_WARNING ("invalid %s percentage value '%s'", prop, *iter);
+			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			                     "invalid percent element");
+			return FALSE;
+		}
+		set_func (s_dcb, i, (guint) tmp);
+		sum += (guint) tmp;
+	}
+
+	if (sum_pct && (sum != 100)) {
+		PARSE_WARNING ("%s percentages do not equal 100%%", prop);
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "invalid percentage sum");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+make_dcb_setting (shvarFile *ifcfg,
+                  NMSetting **out_setting,
+                  GError **error)
+{
+	gs_unref_object NMSettingDcb *s_dcb = NULL;
+	gboolean dcb_on;
+	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
+
+	g_return_val_if_fail (out_setting != NULL, FALSE);
+
+	dcb_on = !!svGetValueBoolean (ifcfg, "DCB", FALSE);
+	if (!dcb_on)
+		return TRUE;
+
+	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
+
+	/* FCOE */
+	if (!read_dcb_app (ifcfg, s_dcb, "FCOE",
+	                   &dcb_flags_props[DCB_APP_FCOE_FLAGS],
+	                   NM_SETTING_DCB_APP_FCOE_PRIORITY,
+	                   error)) {
+		return FALSE;
+	}
+	if (nm_setting_dcb_get_app_fcoe_flags (s_dcb) & NM_SETTING_DCB_FLAG_ENABLE) {
+		gs_free char *val = NULL;
+
+		val = svGetValueStr_cp (ifcfg, KEY_DCB_APP_FCOE_MODE);
+		if (val) {
+			if (NM_IN_STRSET (val, NM_SETTING_DCB_FCOE_MODE_FABRIC,
+			                       NM_SETTING_DCB_FCOE_MODE_VN2VN))
+				g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_APP_FCOE_MODE, val, NULL);
+			else {
+				PARSE_WARNING ("invalid FCoE mode '%s'", val);
+				g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				                     "invalid FCoE mode");
+				return FALSE;
+			}
+		}
+	}
+
+	/* iSCSI */
+	if (!read_dcb_app (ifcfg, s_dcb, "ISCSI",
+	                   &dcb_flags_props[DCB_APP_ISCSI_FLAGS],
+	                   NM_SETTING_DCB_APP_ISCSI_PRIORITY,
+	                   error)) {
+		return FALSE;
+	}
+
+	/* FIP */
+	if (!read_dcb_app (ifcfg, s_dcb, "FIP",
+	                   &dcb_flags_props[DCB_APP_FIP_FLAGS],
+	                   NM_SETTING_DCB_APP_FIP_PRIORITY,
+	                   error)) {
+		return FALSE;
+	}
+
+	/* Priority Flow Control */
+	flags = read_dcb_flags (ifcfg, &dcb_flags_props[DCB_PFC_FLAGS]);
+	g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS, flags, NULL);
+
+	if (!read_dcb_bool_array (ifcfg,
+	                          s_dcb,
+	                          flags,
+	                          KEY_DCB_PFC_UP,
+	                          "PFC",
+	                          nm_setting_dcb_set_priority_flow_control,
+	                          error)) {
+		return FALSE;
+	}
+
+	/* Priority Groups */
+	flags = read_dcb_flags (ifcfg, &dcb_flags_props[DCB_PG_FLAGS]);
+	g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_PRIORITY_GROUP_FLAGS, flags, NULL);
+
+	if (!read_dcb_uint_array (ifcfg,
+	                          s_dcb,
+	                          flags,
+	                          KEY_DCB_PG_ID,
+	                          "PGID",
+	                          TRUE,
+	                          nm_setting_dcb_set_priority_group_id,
+	                          error)) {
+		return FALSE;
+	}
+
+	/* Group bandwidth */
+	if (!read_dcb_percent_array (ifcfg,
+	                             s_dcb,
+	                             flags,
+	                             KEY_DCB_PG_PCT,
+	                             "PGPCT",
+	                             TRUE,
+	                             nm_setting_dcb_set_priority_group_bandwidth,
+	                             error)) {
+		return FALSE;
+	}
+
+	/* Priority bandwidth */
+	if (!read_dcb_percent_array (ifcfg,
+	                             s_dcb,
+	                             flags,
+	                             KEY_DCB_PG_UPPCT,
+	                             "UPPCT",
+	                             FALSE,
+	                             nm_setting_dcb_set_priority_bandwidth,
+	                             error)) {
+		return FALSE;
+	}
+
+	/* Strict Bandwidth */
+	if (!read_dcb_bool_array (ifcfg,
+	                          s_dcb,
+	                          flags,
+	                          KEY_DCB_PG_STRICT,
+	                          "STRICT",
+	                          nm_setting_dcb_set_priority_strict_bandwidth,
+	                          error)) {
+		return FALSE;
+	}
+
+	if (!read_dcb_uint_array (ifcfg,
+	                          s_dcb,
+	                          flags,
+	                          KEY_DCB_PG_UP2TC,
+	                          "UP2TC",
+	                          FALSE,
+	                          nm_setting_dcb_set_priority_traffic_class,
+	                          error)) {
+		return FALSE;
+	}
+
+	*out_setting = NM_SETTING (g_steal_pointer (&s_dcb));
+	return TRUE;
+}
+
+static gboolean
+add_one_wep_key (shvarFile *ifcfg,
+                 const char *shvar_key,
+                 guint8 key_idx,
+                 gboolean passphrase,
+                 NMSettingWirelessSecurity *s_wsec,
+                 GError **error)
+{
+	gs_free char *value_free = NULL;
+	const char *value;
+	const char *key = NULL;
+
+	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (shvar_key != NULL, FALSE);
+	g_return_val_if_fail (key_idx <= 3, FALSE);
+	g_return_val_if_fail (s_wsec != NULL, FALSE);
+
+	value = svGetValueStr (ifcfg, shvar_key, &value_free);
+	if (!value)
+		return TRUE;
+
+	/* Validate keys */
+	if (passphrase) {
+		if (value[0] && strlen (value) < 64)
+			key = value;
+	} else {
+		if (NM_IN_SET (strlen (value), 10, 26)) {
+			/* Hexadecimal WEP key */
+			if (NM_STRCHAR_ANY (value, ch, !g_ascii_isxdigit (ch))) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Invalid hexadecimal WEP key.");
+				return FALSE;
+			}
+			key = value;
+		} else if (   !strncmp (value, "s:", 2)
+		           && NM_IN_SET (strlen (value), 7, 15)) {
+			/* ASCII key */
+			if (NM_STRCHAR_ANY (value + 2, ch, !g_ascii_isprint (ch))) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Invalid ASCII WEP key.");
+				return FALSE;
+			}
+
+			/* Remove 's:' prefix.
+			 * Don't convert to hex string. wpa_supplicant takes 'wep_key0' option over D-Bus as byte array
+			 * and converts it to hex string itself. Even though we convert hex string keys into a bin string
+			 * before passing to wpa_supplicant, this prevents two unnecessary conversions. And mainly,
+			 * ASCII WEP key doesn't change to HEX WEP key in UI, which could confuse users.
+			 */
+			key = value + 2;
+		}
+	}
+
+	if (!key) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Invalid WEP key length.");
+		return FALSE;
+	}
+
+	nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
+	return TRUE;
+}
+
+static gboolean
+read_wep_keys (shvarFile *ifcfg,
+               NMWepKeyType key_type,
+               guint8 def_idx,
+               NMSettingWirelessSecurity *s_wsec,
+               GError **error)
+{
+	if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
+		if (!add_one_wep_key (ifcfg, "KEY1", 0, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY2", 1, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY3", 2, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY4", 3, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY", def_idx, FALSE, s_wsec, error))
+			return FALSE;
+	}
+
+	if (key_type != NM_WEP_KEY_TYPE_KEY) {
+		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+static NMSetting *
+make_wep_setting (shvarFile *ifcfg,
+                  const char *file,
+                  GError **error)
+{
+	gs_unref_object NMSettingWirelessSecurity *s_wsec = NULL;
+	gs_free char *value = NULL;
+	shvarFile *keys_ifcfg = NULL;
+	int default_key_idx = 0;
+	gboolean has_default_key = FALSE;
+	NMSettingSecretFlags key_flags;
+
+	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
+
+	value = svGetValueStr_cp (ifcfg, "DEFAULTKEY");
+	if (value) {
+		default_key_idx = _nm_utils_ascii_str_to_int64 (value, 0, 1, 4, 0);
+		if (default_key_idx == 0) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid default WEP key '%s'", value);
+			return NULL;
+		}
+		has_default_key = TRUE;
+		default_key_idx--;  /* convert to [0...3] */
+		g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, (guint) default_key_idx, NULL);
+		nm_clear_g_free (&value);
+	}
+
+	/* Read WEP key flags */
+	key_flags = _secret_read_ifcfg_flags (ifcfg, "WEP_KEY_FLAGS");
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, key_flags, NULL);
+
+	/* Read keys in the ifcfg file if they are system-owned */
+	if (key_flags == NM_SETTING_SECRET_FLAG_NONE) {
+		NMWepKeyType key_type;
+		const char *v;
+		gs_free char *to_free = NULL;
+
+		v = svGetValueStr (ifcfg, "KEY_TYPE", &to_free);
+		if (!v)
+			key_type = NM_WEP_KEY_TYPE_UNKNOWN;
+		else if (nm_streq (v, "key"))
+			key_type = NM_WEP_KEY_TYPE_KEY;
+		else if (nm_streq (v, "passphrase"))
+			key_type = NM_WEP_KEY_TYPE_PASSPHRASE;
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid KEY_TYPE value '%s'", v);
+			return FALSE;
+		}
+
+		if (!read_wep_keys (ifcfg, key_type, default_key_idx, s_wsec, error))
+			return NULL;
+
+		/* Try to get keys from the "shadow" key file */
+		keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
+		if (keys_ifcfg) {
+			if (!read_wep_keys (keys_ifcfg, key_type, default_key_idx, s_wsec, error)) {
+				svCloseFile (keys_ifcfg);
+				return NULL;
+			}
+			svCloseFile (keys_ifcfg);
+			g_assert (error == NULL || *error == NULL);
+		}
+
+		g_object_set (G_OBJECT (s_wsec),
+		              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, key_type,
+		              NULL);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "SECURITYMODE");
+	if (value) {
+		gs_free char *lcase = NULL;
+
+		lcase = g_ascii_strdown (value, -1);
+		nm_clear_g_free (&value);
+
+		if (nm_streq (lcase, "open")) {
+			g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", NULL);
+		} else if (nm_streq (lcase, "restricted")) {
+			g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared", NULL);
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid WEP authentication algorithm '%s'",
+			             lcase);
+			return NULL;
+		}
+	}
+
+	/* If no WEP keys were given, and the keys are not agent-owned, and no
+	 * default WEP key index was given, then the connection is unencrypted.
+	 */
+	if (   !nm_setting_wireless_security_get_wep_key (s_wsec, 0)
+	    && !nm_setting_wireless_security_get_wep_key (s_wsec, 1)
+	    && !nm_setting_wireless_security_get_wep_key (s_wsec, 2)
+	    && !nm_setting_wireless_security_get_wep_key (s_wsec, 3)
+	    && (has_default_key == FALSE)
+	    && (key_flags == NM_SETTING_SECRET_FLAG_NONE)) {
+		const char *auth_alg;
+
+		auth_alg = nm_setting_wireless_security_get_auth_alg (s_wsec);
+		if (auth_alg && !strcmp (auth_alg, "shared")) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "WEP Shared Key authentication is invalid for "
+			             "unencrypted connections.");
+			return NULL;
+		}
+
+		/* Unencrypted */
+		return NULL;
+	}
+
+	return NM_SETTING (g_steal_pointer (&s_wsec));
+}
+
+static gboolean
+fill_wpa_ciphers (shvarFile *ifcfg,
+                  NMSettingWirelessSecurity *wsec,
+                  gboolean group,
+                  gboolean adhoc)
+{
+	gs_free char *value = NULL;
+	const char *p;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+	int i = 0;
+
+	p = svGetValueStr (ifcfg, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
+	if (!p)
+		return TRUE;
+
+	list = nm_utils_strsplit_set (p, " ");
+	for (iter = list; iter && *iter; iter++, i++) {
+		if (!strcmp (*iter, "CCMP")) {
+			if (group)
+				nm_setting_wireless_security_add_group (wsec, "ccmp");
+			else
+				nm_setting_wireless_security_add_pairwise (wsec, "ccmp");
+		} else if (!strcmp (*iter, "TKIP")) {
+			if (group)
+				nm_setting_wireless_security_add_group (wsec, "tkip");
+			else
+				nm_setting_wireless_security_add_pairwise (wsec, "tkip");
+		} else if (group && !strcmp (*iter, "WEP104"))
+			nm_setting_wireless_security_add_group (wsec, "wep104");
+		else if (group && !strcmp (*iter, "WEP40"))
+			nm_setting_wireless_security_add_group (wsec, "wep40");
+		else {
+			PARSE_WARNING ("ignoring invalid %s cipher '%s'",
+			               group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE",
+			               *iter);
+		}
+	}
+
+	return TRUE;
+}
+
+#define WPA_PMK_LEN 32
+
+static char *
+parse_wpa_psk (shvarFile *ifcfg,
+               const char *file,
+               GBytes *ssid,
+               GError **error)
+{
+	shvarFile *keys_ifcfg;
+	gs_free char *psk = NULL;
+	size_t plen;
+
+	/* Passphrase must be between 10 and 66 characters in length because WPA
+	 * hex keys are exactly 64 characters (no quoting), and WPA passphrases
+	 * are between 8 and 63 characters (inclusive), plus optional quoting if
+	 * the passphrase contains spaces.
+	 */
+
+	/* Try to get keys from the "shadow" key file */
+	keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
+	if (keys_ifcfg) {
+		psk = svGetValueStr_cp (keys_ifcfg, "WPA_PSK");
+		svCloseFile (keys_ifcfg);
+	}
+
+	/* Fall back to the original ifcfg */
+	if (!psk)
+		psk = svGetValueStr_cp (ifcfg, "WPA_PSK");
+
+	if (!psk)
+		return NULL;
+
+	plen = strlen (psk);
+
+	if (plen == 64) {
+		/* Verify the hex PSK; 64 digits */
+		if (!NM_STRCHAR_ALL (psk, ch, g_ascii_isxdigit (ch))) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid WPA_PSK (contains non-hexadecimal characters)");
+			return NULL;
+		}
+	} else {
+		if (plen < 8 || plen > 63) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid WPA_PSK (passphrases must be between "
+			             "8 and 63 characters long (inclusive))");
+			return NULL;
+		}
+	}
+
+	return g_steal_pointer (&psk);
+}
+
+static gboolean
+eap_simple_reader (const char *eap_method,
+                   shvarFile *ifcfg,
+                   shvarFile *keys_ifcfg,
+                   NMSetting8021x *s_8021x,
+                   gboolean phase2,
+                   GError **error)
+{
+	NMSettingSecretFlags flags;
+	gs_free char *identity_free = NULL;
+	nm_auto_free_secret char *password_raw_str = NULL;
+	gs_unref_bytes GBytes *password_raw_bytes = NULL;
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY,
+	              svGetValueStr (ifcfg, "IEEE_8021X_IDENTITY", &identity_free),
+	              NULL);
+
+	_secret_set_from_ifcfg (s_8021x,
+	                        ifcfg,
+	                        keys_ifcfg,
+	                        "IEEE_8021X_PASSWORD",
+	                        NM_SETTING_802_1X_PASSWORD);
+
+	_secret_read_ifcfg (ifcfg, keys_ifcfg, "IEEE_8021X_PASSWORD_RAW", &password_raw_str, &flags);
+	if (!_secret_password_raw_to_bytes ("IEEE_8021X_PASSWORD_RAW",
+	                                    password_raw_str,
+	                                    &password_raw_bytes,
+	                                    error))
+		return FALSE;
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_PASSWORD_RAW_FLAGS,
+	              flags,
+	              NM_SETTING_802_1X_PASSWORD_RAW,
+	              password_raw_bytes,
+	              NULL);
+
+	return TRUE;
+}
+
+static gboolean
+eap_tls_reader (const char *eap_method,
+                shvarFile *ifcfg,
+                shvarFile *keys_ifcfg,
+                NMSetting8021x *s_8021x,
+                gboolean phase2,
+                GError **error)
+{
+	gs_unref_bytes GBytes *privkey = NULL;
+	gs_unref_bytes GBytes *client_cert = NULL;
+	gs_free char *identity_free = NULL;
+	gs_free char *value_to_free = NULL;
+	const char *client_cert_var;
+	const char *client_cert_prop;
+	NMSetting8021xCKFormat format;
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY,
+	              svGetValueStr (ifcfg, "IEEE_8021X_IDENTITY", &identity_free),
+	              NULL);
+
+	/* CA certificate */
+	if (!_cert_set_from_ifcfg (s_8021x,
+	                           ifcfg,
+	                           phase2 ? "IEEE_8021X_INNER_CA_CERT" : "IEEE_8021X_CA_CERT",
+	                           phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT : NM_SETTING_802_1X_CA_CERT,
+	                           NULL,
+	                           error))
+		return FALSE;
+	_secret_set_from_ifcfg (s_8021x,
+	                        ifcfg,
+	                        keys_ifcfg,
+	                        phase2 ? "IEEE_8021X_INNER_CA_CERT_PASSWORD" : "IEEE_8021X_CA_CERT_PASSWORD",
+	                        phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD : NM_SETTING_802_1X_CA_CERT_PASSWORD);
+
+	/* Private key */
+	if (!_cert_set_from_ifcfg (s_8021x,
+	                           ifcfg,
+	                           phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY" : "IEEE_8021X_PRIVATE_KEY",
+	                           phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY : NM_SETTING_802_1X_PRIVATE_KEY,
+	                           &privkey,
+	                           error))
+		return FALSE;
+	_secret_set_from_ifcfg (s_8021x,
+	                        ifcfg,
+	                        keys_ifcfg,
+	                        phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY_PASSWORD" : "IEEE_8021X_PRIVATE_KEY_PASSWORD",
+	                        phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD : NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD);
+
+	/* Client certificate */
+	client_cert_var = phase2 ? "IEEE_8021X_INNER_CLIENT_CERT" : "IEEE_8021X_CLIENT_CERT";
+	client_cert_prop = phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT : NM_SETTING_802_1X_CLIENT_CERT;
+	if (!_cert_set_from_ifcfg (s_8021x,
+	                           ifcfg,
+	                           client_cert_var,
+	                           client_cert_prop,
+	                           &client_cert,
+	                           error))
+		return FALSE;
+	_secret_set_from_ifcfg (s_8021x,
+	                        ifcfg,
+	                        keys_ifcfg,
+	                        phase2 ? "IEEE_8021X_INNER_CLIENT_CERT_PASSWORD" : "IEEE_8021X_CLIENT_CERT_PASSWORD",
+	                        phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD : NM_SETTING_802_1X_CLIENT_CERT_PASSWORD);
+
+	/* In the past when the private key and client certificate
+	 * were the same PKCS #12 file we used to write only the
+	 * private key variable. Still support that even if it means
+	 * that we have to look into the file content, which makes
+	 * the connection not self-contained.
+	 */
+	if (   !client_cert
+	    && privkey
+	    && !svGetValue (ifcfg, client_cert_var, &value_to_free)) {
+		if (phase2)
+			format = nm_setting_802_1x_get_phase2_private_key_format (s_8021x);
+		else
+			format = nm_setting_802_1x_get_private_key_format (s_8021x);
+
+		if (format == NM_SETTING_802_1X_CK_FORMAT_PKCS12)
+			g_object_set (s_8021x, client_cert_prop, privkey, NULL);
+	}
+
+	return TRUE;
+}
+
+static gboolean
+eap_peap_reader (const char *eap_method,
+                 shvarFile *ifcfg,
+                 shvarFile *keys_ifcfg,
+                 NMSetting8021x *s_8021x,
+                 gboolean phase2,
+                 GError **error)
+{
+	gs_free char *value = NULL;
+	const char *v;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+
+	if (!_cert_set_from_ifcfg (s_8021x,
+	                           ifcfg,
+	                           "IEEE_8021X_CA_CERT",
+	                           NM_SETTING_802_1X_CA_CERT,
+	                           NULL,
+	                           error))
+		return FALSE;
+	_secret_set_from_ifcfg (s_8021x,
+	                        ifcfg,
+	                        keys_ifcfg,
+	                        "IEEE_8021X_CA_CERT_PASSWORD",
+	                        NM_SETTING_802_1X_CA_CERT_PASSWORD);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_PEAP_VERSION", &value);
+	if (v) {
+		if (!strcmp (v, "0"))
+			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPVER, "0", NULL);
+		else if (!strcmp (v, "1"))
+			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPVER, "1", NULL);
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Unknown IEEE_8021X_PEAP_VERSION value '%s'",
+			             v);
+			return FALSE;
+		}
+	}
+
+	if (svGetValueBoolean (ifcfg, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", FALSE))
+		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1", NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_ANON_IDENTITY", &value);
+	if (v)
+		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS", &value);
+	if (!v) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
+		return FALSE;
+	}
+
+	/* Handle options for the inner auth method */
+	list = nm_utils_strsplit_set (v, " ");
+	iter = list;
+	if (iter) {
+		if (NM_IN_STRSET (*iter, "MSCHAPV2",
+		                         "MD5",
+		                         "GTC")) {
+			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
+				return FALSE;
+		} else if (nm_streq (*iter, "TLS")) {
+			if (!eap_tls_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
+				return FALSE;
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
+			             *iter);
+			return FALSE;
+		}
+
+		{
+			gs_free char *lower = NULL;
+
+			lower = g_ascii_strdown (*iter, -1);
+			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, lower, NULL);
+		}
+	}
+
+	if (!nm_setting_802_1x_get_phase2_auth (s_8021x)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "No valid IEEE_8021X_INNER_AUTH_METHODS found.");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+eap_ttls_reader (const char *eap_method,
+                 shvarFile *ifcfg,
+                 shvarFile *keys_ifcfg,
+                 NMSetting8021x *s_8021x,
+                 gboolean phase2,
+                 GError **error)
+{
+	gs_free char *inner_auth = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+
+	if (!_cert_set_from_ifcfg (s_8021x,
+	                           ifcfg,
+	                           "IEEE_8021X_CA_CERT",
+	                           NM_SETTING_802_1X_CA_CERT,
+	                           NULL,
+	                           error))
+		return FALSE;
+	_secret_set_from_ifcfg (s_8021x,
+	                        ifcfg,
+	                        keys_ifcfg,
+	                        "IEEE_8021X_CA_CERT_PASSWORD",
+	                        NM_SETTING_802_1X_CA_CERT_PASSWORD);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_ANON_IDENTITY", &value);
+	if (v)
+		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS", &value);
+	if (!v) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
+		return FALSE;
+	}
+
+	inner_auth = g_ascii_strdown (v, -1);
+
+	/* Handle options for the inner auth method */
+	list = nm_utils_strsplit_set (inner_auth, " ");
+	iter = list;
+	if (iter) {
+		if (NM_IN_STRSET (*iter, "mschapv2",
+		                         "mschap",
+		                         "pap",
+		                         "chap")) {
+			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
+				return FALSE;
+			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, *iter, NULL);
+		} else if (nm_streq (*iter, "eap-tls")) {
+			if (!eap_tls_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
+				return FALSE;
+			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, "tls", NULL);
+		} else if (NM_IN_STRSET (*iter, "eap-mschapv2",
+		                                "eap-md5",
+		                                "eap-gtc")) {
+			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
+				return FALSE;
+			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, (*iter + NM_STRLEN ("eap-")), NULL);
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
+			             *iter);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+eap_fast_reader (const char *eap_method,
+                 shvarFile *ifcfg,
+                 shvarFile *keys_ifcfg,
+                 NMSetting8021x *s_8021x,
+                 gboolean phase2,
+                 GError **error)
+{
+	char *anon_ident = NULL;
+	char *pac_file = NULL;
+	char *real_pac_path = NULL;
+	char *inner_auth = NULL;
+	char *fast_provisioning = NULL;
+	char *lower;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+	const char *pac_prov_str;
+	gboolean allow_unauth = FALSE, allow_auth = FALSE;
+	gboolean success = FALSE;
+
+	pac_file = svGetValueStr_cp (ifcfg, "IEEE_8021X_PAC_FILE");
+	if (pac_file) {
+		real_pac_path = get_full_file_path (svFileGetName (ifcfg), pac_file);
+		g_object_set (s_8021x, NM_SETTING_802_1X_PAC_FILE, real_pac_path, NULL);
+	}
+
+	fast_provisioning = svGetValueStr_cp (ifcfg, "IEEE_8021X_FAST_PROVISIONING");
+	if (fast_provisioning) {
+		gs_free const char **list1 = NULL;
+
+		list1 = nm_utils_strsplit_set (fast_provisioning, " \t");
+		for (iter = list1; iter && *iter; iter++) {
+			if (strcmp (*iter, "allow-unauth") == 0)
+				allow_unauth = TRUE;
+			else if (strcmp (*iter, "allow-auth") == 0)
+				allow_auth = TRUE;
+			else {
+				PARSE_WARNING ("invalid IEEE_8021X_FAST_PROVISIONING '%s' "
+				               "(space-separated list of these values [allow-auth, allow-unauth] expected)",
+				               *iter);
+			}
+		}
+	}
+	pac_prov_str = allow_unauth ? (allow_auth ? "3" : "1") : (allow_auth ? "2" : "0");
+	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING, pac_prov_str, NULL);
+
+	if (!pac_file && !(allow_unauth || allow_auth)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "IEEE_8021X_PAC_FILE not provided and EAP-FAST automatic PAC provisioning disabled.");
+		goto done;
+	}
+
+	anon_ident = svGetValueStr_cp (ifcfg, "IEEE_8021X_ANON_IDENTITY");
+	if (anon_ident)
+		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, anon_ident, NULL);
+
+	inner_auth = svGetValueStr_cp (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS");
+	if (!inner_auth) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
+		goto done;
+	}
+
+	/* Handle options for the inner auth method */
+	list = nm_utils_strsplit_set (inner_auth, " ");
+	iter = list;
+	if (iter) {
+		if (   !strcmp (*iter, "MSCHAPV2")
+		    || !strcmp (*iter, "GTC")) {
+			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
+				goto done;
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
+			             *iter);
+			goto done;
+		}
+
+		lower = g_ascii_strdown (*iter, -1);
+		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, lower, NULL);
+		g_free (lower);
+	}
+
+	if (!nm_setting_802_1x_get_phase2_auth (s_8021x)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "No valid IEEE_8021X_INNER_AUTH_METHODS found.");
+		goto done;
+	}
+
+	success = TRUE;
+
+done:
+	g_free (inner_auth);
+	g_free (fast_provisioning);
+	g_free (real_pac_path);
+	g_free (pac_file);
+	g_free (anon_ident);
+	return success;
+}
+
+typedef struct {
+	const char *method;
+	gboolean (*reader) (const char *eap_method,
+	                    shvarFile *ifcfg,
+	                    shvarFile *keys_ifcfg,
+	                    NMSetting8021x *s_8021x,
+	                    gboolean phase2,
+	                    GError **error);
+	gboolean wifi_phase2_only;
+} EAPReader;
+
+static EAPReader eap_readers[] = {
+	{ "md5", eap_simple_reader, TRUE },
+	{ "pap", eap_simple_reader, TRUE },
+	{ "chap", eap_simple_reader, TRUE },
+	{ "mschap", eap_simple_reader, TRUE },
+	{ "mschapv2", eap_simple_reader, TRUE },
+	{ "leap", eap_simple_reader, FALSE },
+	{ "pwd", eap_simple_reader, FALSE },
+	{ "tls", eap_tls_reader, FALSE },
+	{ "peap", eap_peap_reader, FALSE },
+	{ "ttls", eap_ttls_reader, FALSE },
+	{ "fast", eap_fast_reader, FALSE },
+	{ NULL, NULL }
+};
+
+static void
+read_8021x_list_value (shvarFile *ifcfg,
+                       const char *ifcfg_var_name,
+                       NMSetting8021x *setting,
+                       const char *prop_name)
+{
+	gs_free char *value = NULL;
+	gs_free const char **strv = NULL;
+	const char *v;
+
+	g_return_if_fail (ifcfg != NULL);
+	g_return_if_fail (ifcfg_var_name != NULL);
+	g_return_if_fail (prop_name != NULL);
+
+	v = svGetValueStr (ifcfg, ifcfg_var_name, &value);
+	if (!v)
+		return;
+
+	strv = nm_utils_strsplit_set (v, " \t");
+	if (strv)
+		g_object_set (setting, prop_name, strv, NULL);
+}
+
+static NMSetting8021x *
+fill_8021x (shvarFile *ifcfg,
+            const char *file,
+            const char *key_mgmt,
+            gboolean wifi,
+            GError **error)
+{
+	nm_auto_shvar_file_close shvarFile *keys_ifcfg = NULL;
+	gs_unref_object NMSetting8021x *s_8021x = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+	gint64 timeout;
+	int i_val;
+
+	v = svGetValueStr (ifcfg, "IEEE_8021X_EAP_METHODS", &value);
+	if (!v) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing IEEE_8021X_EAP_METHODS for key management '%s'",
+		             key_mgmt);
+		return NULL;
+	}
+
+	list = nm_utils_strsplit_set (v, " ");
+
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+
+	/* Read in the lookaside keys_ifcfg file, if present */
+	keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
+
+	/* Validate and handle each EAP method */
+	for (iter = list; iter && *iter; iter++) {
+		EAPReader *eap = &eap_readers[0];
+		gboolean found = FALSE;
+		gs_free char *lower = NULL;
+
+		lower = g_ascii_strdown (*iter, -1);
+		while (eap->method) {
+			if (strcmp (eap->method, lower))
+				goto next;
+
+			/* Some EAP methods don't provide keying material, thus they
+			 * cannot be used with Wi-Fi unless they are an inner method
+			 * used with TTLS or PEAP or whatever.
+			 */
+			if (wifi && eap->wifi_phase2_only) {
+				PARSE_WARNING ("ignored invalid IEEE_8021X_EAP_METHOD '%s'; not allowed for wifi.",
+				               lower);
+				goto next;
+			}
+
+			/* Parse EAP method specific options */
+			if (!(*eap->reader)(lower, ifcfg, keys_ifcfg, s_8021x, FALSE, error))
+				return NULL;
+
+			nm_setting_802_1x_add_eap_method (s_8021x, lower);
+			found = TRUE;
+			break;
+
+next:
+			eap++;
+		}
+
+		if (!found)
+			PARSE_WARNING ("ignored unknown IEEE_8021X_EAP_METHOD '%s'.", lower);
+	}
+
+	if (nm_setting_802_1x_get_num_eap_methods (s_8021x) == 0) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "No valid EAP methods found in IEEE_8021X_EAP_METHODS.");
+		return NULL;
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_SUBJECT_MATCH", &value);
+	g_object_set (s_8021x, NM_SETTING_802_1X_SUBJECT_MATCH, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_PHASE2_SUBJECT_MATCH", &value);
+	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH, v, NULL);
+
+	i_val = NM_SETTING_802_1X_AUTH_FLAGS_NONE;
+	if (!svGetValueEnum (ifcfg, "IEEE_8021X_PHASE1_AUTH_FLAGS",
+	                     nm_setting_802_1x_auth_flags_get_type (),
+	                     &i_val, error))
+		return NULL;
+	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_AUTH_FLAGS, (guint) i_val, NULL);
+
+	read_8021x_list_value (ifcfg, "IEEE_8021X_ALTSUBJECT_MATCHES",
+	                       s_8021x, NM_SETTING_802_1X_ALTSUBJECT_MATCHES);
+	read_8021x_list_value (ifcfg, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES",
+	                       s_8021x, NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_DOMAIN_SUFFIX_MATCH", &value);
+	g_object_set (s_8021x, NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH, v, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH", &value);
+	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH, v, NULL);
+
+	timeout = svGetValueInt64 (ifcfg, "IEEE_8021X_AUTH_TIMEOUT", 10, 0, G_MAXINT32, 0);
+	g_object_set (s_8021x, NM_SETTING_802_1X_AUTH_TIMEOUT, (int) timeout, NULL);
+
+	return g_steal_pointer (&s_8021x);
+}
+
+static NMSetting *
+make_wpa_setting (shvarFile *ifcfg,
+                  const char *file,
+                  GBytes *ssid,
+                  gboolean adhoc,
+                  NMSetting8021x **s_8021x,
+                  GError **error)
+{
+	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	gboolean wpa_psk = FALSE, wpa_sae = FALSE, wpa_eap = FALSE, ieee8021x = FALSE;
+	int i_val;
+	GError *local = NULL;
+
+	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+
+	v = svGetValueStr (ifcfg, "KEY_MGMT", &value);
+	wpa_psk = nm_streq0 (v, "WPA-PSK");
+	wpa_sae = nm_streq0 (v, "SAE");
+	wpa_eap = nm_streq0 (v, "WPA-EAP");
+	ieee8021x = nm_streq0 (v, "IEEE8021X");
+	if (   !wpa_psk
+	    && !wpa_sae
+	    && !wpa_eap
+	    && !ieee8021x)
+		return NULL; /* Not WPA or Dynamic WEP */
+
+	/* WPS */
+	i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
+	if (!svGetValueEnum (ifcfg, "WPS_METHOD",
+	                     nm_setting_wireless_security_wps_method_get_type (),
+	                     &i_val, error))
+		return NULL;
+	g_object_set (wsec,
+	              NM_SETTING_WIRELESS_SECURITY_WPS_METHOD, (guint) i_val,
+	              NULL);
+
+	/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
+	if (wpa_psk || wpa_sae || wpa_eap) {
+		fill_wpa_ciphers (ifcfg, wsec, FALSE, adhoc);
+		fill_wpa_ciphers (ifcfg, wsec, TRUE, adhoc);
+	}
+
+	/* WPA and/or RSN */
+	if (adhoc) {
+		/* Ad-Hoc mode only supports RSN proto */
+		nm_setting_wireless_security_add_proto (wsec, "rsn");
+	} else {
+		gs_free char *value2 = NULL;
+		const char *v2;
+
+		v2 = svGetValueStr (ifcfg, "WPA_ALLOW_WPA", &value2);
+		if (v2 && svParseBoolean (v2, TRUE))
+			nm_setting_wireless_security_add_proto (wsec, "wpa");
+
+		nm_clear_g_free (&value2);
+		v2 = svGetValueStr (ifcfg, "WPA_ALLOW_WPA2", &value2);
+		if (v2 && svParseBoolean (v2, TRUE))
+			nm_setting_wireless_security_add_proto (wsec, "rsn");
+	}
+
+	if (wpa_psk || wpa_sae) {
+		NMSettingSecretFlags psk_flags;
+
+		psk_flags = _secret_read_ifcfg_flags (ifcfg, "WPA_PSK_FLAGS");
+		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS, psk_flags, NULL);
+
+		/* Read PSK if it's system-owned */
+		if (psk_flags == NM_SETTING_SECRET_FLAG_NONE) {
+			gs_free char *psk = NULL;
+
+			psk = parse_wpa_psk (ifcfg, file, ssid, &local);
+			if (psk)
+				g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
+			else if (local) {
+				g_propagate_error (error, local);
+				return NULL;
+			}
+		}
+
+		if (wpa_psk)
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
+		else {
+			nm_assert (wpa_sae);
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "sae", NULL);
+		}
+	} else {
+		nm_assert (wpa_eap || ieee8021x);
+
+		/* Adhoc mode is mutually exclusive with any 802.1x-based authentication */
+		if (adhoc) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Ad-Hoc mode cannot be used with KEY_MGMT type '%s'", v);
+			return NULL;
+		}
+
+		*s_8021x = fill_8021x (ifcfg, file, v, TRUE, error);
+		if (!*s_8021x)
+			return NULL;
+
+		{
+			gs_free char *lower = g_ascii_strdown (v, -1);
+
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, lower, NULL);
+		}
+	}
+
+	i_val = NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT;
+	if (!svGetValueEnum (ifcfg, "PMF",
+	                     nm_setting_wireless_security_pmf_get_type (),
+	                     &i_val, error))
+		return NULL;
+	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PMF, i_val, NULL);
+
+	i_val = NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT;
+	if (!svGetValueEnum (ifcfg, "FILS",
+	                     nm_setting_wireless_security_fils_get_type (),
+	                     &i_val, error))
+		return NULL;
+	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_FILS, i_val, NULL);
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "SECURITYMODE", &value);
+	if (NM_IN_STRSET (v, NULL, "open"))
+		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, v, NULL);
+
+	return (NMSetting *) g_steal_pointer (&wsec);
+}
+
+static NMSetting *
+make_leap_setting (shvarFile *ifcfg,
+                   const char *file,
+                   GError **error)
+{
+	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
+	shvarFile *keys_ifcfg;
+	gs_free char *value = NULL;
+	NMSettingSecretFlags flags;
+
+	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+
+	value = svGetValueStr_cp (ifcfg, "KEY_MGMT");
+	if (!value || strcmp (value, "IEEE8021X"))
+		return NULL;
+	nm_clear_g_free (&value);
+
+	value = svGetValueStr_cp (ifcfg, "SECURITYMODE");
+	if (!value || strcasecmp (value, "leap"))
+		return NULL; /* Not LEAP */
+	nm_clear_g_free (&value);
+
+	flags = _secret_read_ifcfg_flags (ifcfg, "IEEE_8021X_PASSWORD_FLAGS");
+	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags, NULL);
+
+	/* Read LEAP password if it's system-owned */
+	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
+		value = svGetValueStr_cp (ifcfg, "IEEE_8021X_PASSWORD");
+		if (!value) {
+			/* Try to get keys from the "shadow" key file */
+			keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
+			if (keys_ifcfg) {
+				value = svGetValueStr_cp (keys_ifcfg, "IEEE_8021X_PASSWORD");
+				svCloseFile (keys_ifcfg);
+			}
+		}
+		if (value && strlen (value))
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, value, NULL);
+		nm_clear_g_free (&value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "IEEE_8021X_IDENTITY");
+	if (!value) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing LEAP identity");
+		return NULL;
+	}
+	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, value, NULL);
+	nm_clear_g_free (&value);
+
+	g_object_set (wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
+	              NULL);
+
+	return (NMSetting *) g_steal_pointer (&wsec);
+}
+
+static NMSetting *
+make_wireless_security_setting (shvarFile *ifcfg,
+                                const char *file,
+                                GBytes *ssid,
+                                gboolean adhoc,
+                                NMSetting8021x **s_8021x,
+                                GError **error)
+{
+	NMSetting *wsec;
+
+	g_return_val_if_fail (error && !*error, NULL);
+
+	if (!adhoc) {
+		wsec = make_leap_setting (ifcfg, file, error);
+		if (wsec)
+			return wsec;
+		else if (*error)
+			return NULL;
+	}
+
+	wsec = make_wpa_setting (ifcfg, file, ssid, adhoc, s_8021x, error);
+	if (wsec)
+		return wsec;
+	else if (*error)
+		return NULL;
+
+	wsec = make_wep_setting (ifcfg, file, error);
+	if (wsec)
+		return wsec;
+	else if (*error)
+		return NULL;
+
+	return NULL; /* unencrypted */
+}
+
+static const char **
+transform_hwaddr_blacklist (const char *blacklist)
+{
+	const char **strv;
+	gsize i, j;
+
+	strv = nm_utils_strsplit_set (blacklist, " \t");
+	if (!strv)
+		return NULL;
+	for (i = 0, j = 0; strv[j]; j++) {
+		const char *s = strv[j];
+
+		if (!nm_utils_hwaddr_valid (s, ETH_ALEN)) {
+			PARSE_WARNING ("invalid MAC in HWADDR_BLACKLIST '%s'", s);
+			continue;
+		}
+		strv[i++] = s;
+	}
+	strv[i] = NULL;
+	return strv;
+}
+
+static NMSetting *
+make_wireless_setting (shvarFile *ifcfg,
+                       GError **error)
+{
+	NMSettingWireless *s_wireless;
+	const char *cvalue;
+	char *value = NULL;
+	gint64 chan = 0;
+	NMSettingMacRandomization mac_randomization;
+	NMSettingWirelessPowersave powersave = NM_SETTING_WIRELESS_POWERSAVE_DEFAULT;
+
+	s_wireless = NM_SETTING_WIRELESS (nm_setting_wireless_new ());
+
+	value = svGetValueStr_cp (ifcfg, "HWADDR");
+	if (value) {
+		value = g_strstrip (value);
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "MACADDR");
+	if (value) {
+		value = g_strstrip (value);
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS, value, NULL);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "GENERATE_MAC_ADDRESS_MASK");
+	g_object_set (s_wireless, NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK, value, NULL);
+	g_free (value);
+
+	cvalue = svGetValueStr (ifcfg, "HWADDR_BLACKLIST", &value);
+	if (cvalue) {
+		gs_free const char **strv = NULL;
+
+		strv = transform_hwaddr_blacklist (cvalue);
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST, strv, NULL);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "ESSID");
+	if (value) {
+		gs_unref_bytes GBytes *bytes = NULL;
+		gsize ssid_len = 0;
+		gsize value_len = strlen (value);
+
+		if (   value_len > 2
+		    && (value_len % 2) == 0
+		    && g_str_has_prefix (value, "0x")
+		    && NM_STRCHAR_ALL (&value[2], ch, g_ascii_isxdigit (ch))) {
+			/* interpret the value as hex-digits iff value starts
+			 * with "0x" followed by pairs of hex digits */
+			bytes = nm_utils_hexstr2bin (&value[2]);
+		} else
+			bytes = g_bytes_new (value, value_len);
+
+		ssid_len = g_bytes_get_size (bytes);
+		if (ssid_len > 32 || ssid_len == 0) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid SSID '%s' (size %zu not between 1 and 32 inclusive)",
+			             value, ssid_len);
+			g_free (value);
+			goto error;
+		}
+
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, bytes, NULL);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "MODE");
+	if (value) {
+		char *lcase;
+		const char *mode = NULL;
+
+		lcase = g_ascii_strdown (value, -1);
+		g_free (value);
+
+		if (!strcmp (lcase, "ad-hoc")) {
+			mode = "adhoc";
+		} else if (!strcmp (lcase, "ap")) {
+			mode = "ap";
+		} else if (!strcmp (lcase, "managed") || !strcmp (lcase, "auto")) {
+			mode = "infrastructure";
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid mode '%s' (not 'Ad-Hoc', 'Ap', 'Managed', or 'Auto')",
+			             lcase);
+			g_free (lcase);
+			goto error;
+		}
+		g_free (lcase);
+
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, mode, NULL);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "BSSID");
+	if (value) {
+		value = g_strstrip (value);
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_BSSID, value, NULL);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "CHANNEL");
+	if (value) {
+		chan = _nm_utils_ascii_str_to_int64 (value, 10, 1, 196, 0);
+		if (chan == 0) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid wireless channel '%s'", value);
+			g_free (value);
+			goto error;
+		}
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_CHANNEL, (guint32) chan, NULL);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "BAND");
+	if (value) {
+		if (!strcmp (value, "a")) {
+			if (chan && chan <= 14) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Band '%s' invalid for channel %u", value, (guint32) chan);
+				g_free (value);
+				goto error;
+			}
+		} else if (!strcmp (value, "bg")) {
+			if (chan && chan > 14) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Band '%s' invalid for channel %u", value, (guint32) chan);
+				g_free (value);
+				goto error;
+			}
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid wireless band '%s'", value);
+			g_free (value);
+			goto error;
+		}
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, value, NULL);
+		g_free (value);
+	} else if (chan > 0) {
+		if (chan > 14)
+			g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, "a", NULL);
+		else
+			g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, "bg", NULL);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "MTU");
+	if (value) {
+		int mtu;
+
+		mtu = _nm_utils_ascii_str_to_int64 (value, 10, 0, 50000, -1);
+		if (mtu == -1) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid wireless MTU '%s'", value);
+			g_free (value);
+			goto error;
+		}
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MTU, (guint) mtu, NULL);
+		g_free (value);
+	}
+
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_HIDDEN,
+	              svGetValueBoolean (ifcfg, "SSID_HIDDEN", FALSE),
+	              NULL);
+
+	cvalue = svGetValue (ifcfg, "POWERSAVE", &value);
+	if (cvalue) {
+		if (!strcmp (cvalue, "default"))
+			powersave = NM_SETTING_WIRELESS_POWERSAVE_DEFAULT;
+		else if (!strcmp (cvalue, "ignore"))
+			powersave = NM_SETTING_WIRELESS_POWERSAVE_IGNORE;
+		else if (!strcmp (cvalue, "disable") || !strcmp (cvalue, "no"))
+			powersave = NM_SETTING_WIRELESS_POWERSAVE_DISABLE;
+		else if (!strcmp (cvalue, "enable") || !strcmp (cvalue, "yes"))
+			powersave = NM_SETTING_WIRELESS_POWERSAVE_ENABLE;
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid POWERSAVE value '%s'", cvalue);
+			g_free (value);
+			goto error;
+		}
+		g_free (value);
+	}
+
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_POWERSAVE,
+	              powersave,
+	              NULL);
+
+	cvalue = svGetValue (ifcfg, "MAC_ADDRESS_RANDOMIZATION", &value);
+	if (cvalue) {
+		if (strcmp (cvalue, "default") == 0)
+			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
+		else if (strcmp (cvalue, "never") == 0)
+			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_NEVER;
+		else if (strcmp (cvalue, "always") == 0)
+			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_ALWAYS;
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid MAC_ADDRESS_RANDOMIZATION value '%s'", cvalue);
+			g_free (value);
+			goto error;
+		}
+		g_free (value);
+	} else
+		mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
+
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION,
+	              mac_randomization,
+	              NULL);
+
+	return NM_SETTING (s_wireless);
+
+error:
+	if (s_wireless)
+		g_object_unref (s_wireless);
+	return NULL;
+}
+
+static NMConnection *
+wireless_connection_from_ifcfg (const char *file,
+                                shvarFile *ifcfg,
+                                GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *wireless_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+	GBytes *ssid;
+	NMSetting *security_setting = NULL;
+	gs_free char *ssid_utf8 = NULL;
+	const char *mode;
+	gboolean adhoc = FALSE;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	/* Wireless */
+	wireless_setting = make_wireless_setting (ifcfg, error);
+	if (!wireless_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, wireless_setting);
+
+	ssid = nm_setting_wireless_get_ssid (NM_SETTING_WIRELESS (wireless_setting));
+	mode = nm_setting_wireless_get_mode (NM_SETTING_WIRELESS (wireless_setting));
+	if (mode && !strcmp (mode, "adhoc"))
+		adhoc = TRUE;
+
+	/* Wireless security */
+	security_setting = make_wireless_security_setting (ifcfg, file, ssid, adhoc, &s_8021x, &local);
+	if (local) {
+		g_object_unref (connection);
+		g_propagate_error (error, local);
+		return NULL;
+	}
+	if (security_setting) {
+		nm_connection_add_setting (connection, security_setting);
+		if (s_8021x)
+			nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+	}
+
+	if (ssid)
+		ssid_utf8 = _nm_utils_ssid_to_utf8 (ssid);
+
+	/* Connection */
+	con_setting = make_connection_setting (file,
+	                                       ifcfg,
+	                                       NM_SETTING_WIRELESS_SETTING_NAME,
+	                                       nm_str_not_empty (ssid_utf8) ?: "unmanaged",
+	                                       NULL);
+
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	return connection;
+}
+
+static void
+parse_ethtool_option (const char *value,
+                      NMSettingWiredWakeOnLan *out_flags,
+                      char **out_password,
+                      gboolean *out_autoneg,
+                      guint32 *out_speed,
+                      const char **out_duplex,
+                      NMSettingEthtool **out_s_ethtool)
+{
+	gs_free const char **words = NULL;
+	guint i;
+
+	words = nm_utils_strsplit_set (value, " \t\n");
+	if (!words)
+		return;
+
+	if (words[0] && words[0][0] == '-') {
+		/* /sbin/ethtool $opts */
+		if (NM_IN_STRSET (words[0], "-K", "--features", "--offload")) {
+			if (!words[1]) {
+				/* first argument must be the interface name. This is invalid. */
+				return;
+			}
+
+			if (!*out_s_ethtool)
+				*out_s_ethtool = NM_SETTING_ETHTOOL (nm_setting_ethtool_new ());
+
+			for (i = 2; words[i]; ) {
+				const char *opt = words[i];
+				const char *opt_val = words[++i];
+				const NMEthtoolData *d = NULL;
+				NMTernary onoff = NM_TERNARY_DEFAULT;
+
+				if (nm_streq0 (opt_val, "on"))
+					onoff = NM_TERNARY_TRUE;
+				else if (nm_streq0 (opt_val, "off"))
+					onoff = NM_TERNARY_FALSE;
+
+				d = nms_ifcfg_rh_utils_get_ethtool_by_name (opt);
+
+				if (!d) {
+					if (onoff != NM_TERNARY_DEFAULT) {
+						/* the next value is just the on/off argument. Skip it too. */
+						i++;
+					}
+
+					/* silently ignore unsupported offloading features. */
+					continue;
+				}
+
+				i++;
+
+				if (onoff == NM_TERNARY_DEFAULT) {
+					PARSE_WARNING ("Expects on/off argument for feature '%s'", opt);
+					continue;
+				}
+
+				nm_setting_ethtool_set_feature (*out_s_ethtool,
+				                                d->optname,
+				                                onoff);
+			}
+		}
+		return;
+	}
+
+	/* /sbin/ethtool -s ${REALDEVICE} $opts */
+	for (i = 0; words[i]; ) {
+		const char *opt = words[i];
+		const char *opt_val = words[++i];
+
+		if (nm_streq (opt, "autoneg")) {
+			if (!opt_val) {
+				PARSE_WARNING ("Auto-negotiation option missing");
+				break;
+			}
+			i++;
+
+			if (nm_streq (opt_val, "off"))
+				*out_autoneg = FALSE;
+			else if (nm_streq (opt_val, "on"))
+				*out_autoneg = TRUE;
+			else
+				PARSE_WARNING ("Auto-negotiation unknown value: %s", opt_val);
+			continue;
+		}
+
+		if (nm_streq (opt, "speed")) {
+			guint32 speed;
+
+			if (!opt_val) {
+				PARSE_WARNING ("Speed option missing");
+				break;
+			}
+			i++;
+
+			speed =  _nm_utils_ascii_str_to_int64 (opt_val, 10, 0, G_MAXUINT32, 0);
+			if (errno == 0)
+				*out_speed = speed;
+			else
+				PARSE_WARNING ("Speed value '%s' is invalid", opt_val);
+			continue;
+		}
+
+		if (nm_streq (opt, "duplex")) {
+			if (!opt_val) {
+				PARSE_WARNING ("Duplex option missing");
+				break;
+			}
+			i++;
+
+			if (nm_streq (opt_val, "half"))
+				*out_duplex = "half";
+			else if (nm_streq (opt_val, "full"))
+				*out_duplex = "full";
+			else
+				PARSE_WARNING ("Duplex unknown value: %s", opt_val);
+			continue;
+		}
+
+		if (nm_streq (opt, "wol")) {
+			NMSettingWiredWakeOnLan wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_NONE;
+
+			if (!opt_val) {
+				PARSE_WARNING ("Wake-on-LAN options missing");
+				break;
+			}
+			i++;
+
+			for (; *opt_val; opt_val++) {
+				switch (*opt_val) {
+				case 'p':
+					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_PHY;
+					break;
+				case 'u':
+					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST;
+					break;
+				case 'm':
+					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST;
+					break;
+				case 'b':
+					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST;
+					break;
+				case 'a':
+					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_ARP;
+					break;
+				case 'g':
+					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC;
+					break;
+				case 's':
+					break;
+				case 'd':
+					wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_NONE;
+					break;
+				default:
+					PARSE_WARNING ("unrecognized Wake-on-LAN option '%c'", *opt_val);
+				}
+			}
+
+			*out_flags = wol_flags;
+			continue;
+		}
+
+		if (nm_streq (opt, "sopass")) {
+			if (!opt_val) {
+				PARSE_WARNING ("Wake-on-LAN password missing");
+				break;
+			}
+			i++;
+
+			if (nm_utils_hwaddr_valid (opt_val, ETH_ALEN)) {
+				g_clear_pointer (out_password, g_free);
+				*out_password = g_strdup (opt_val);
+			} else
+				PARSE_WARNING ("Wake-on-LAN password '%s' is invalid", opt_val);
+			continue;
+		}
+
+		/* Silently skip unknown options */
+	}
+}
+
+static GPtrArray *
+read_routing_rules_parse (shvarFile *ifcfg,
+                          gboolean routes_read)
+{
+	gs_unref_ptrarray GPtrArray *arr = NULL;
+	gs_free const char **keys = NULL;
+	guint i, len;
+
+	keys = svGetKeysSorted (ifcfg, SV_KEY_TYPE_ROUTING_RULE4 | SV_KEY_TYPE_ROUTING_RULE6, &len);
+	if (len == 0)
+		return NULL;
+
+	if (!routes_read) {
+		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing rules (ROUTING_RULE*) settings are ignored");
+		return NULL;
+	}
+
+	arr = g_ptr_array_new_full (len, (GDestroyNotify) nm_ip_routing_rule_unref);
+	for (i = 0; i < len; i++) {
+		const char *key = keys[i];
+		nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
+		gs_free_error GError *local = NULL;
+		gs_free char *value_to_free = NULL;
+		const char *value;
+		gboolean key_is_ipv4;
+
+		key_is_ipv4 = (key[NM_STRLEN ("ROUTING_RULE")] == '_');
+		nm_assert (  key_is_ipv4  == NM_STR_HAS_PREFIX (key, "ROUTING_RULE_"));
+		nm_assert ((!key_is_ipv4) == NM_STR_HAS_PREFIX (key, "ROUTING_RULE6_"));
+
+		value = svGetValueStr (ifcfg, key, &value_to_free);
+		if (!value)
+			continue;
+
+		rule = nm_ip_routing_rule_from_string (value,
+		                                       NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
+		                                       | (key_is_ipv4
+		                                          ? NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET
+		                                          : NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6),
+		                                       NULL,
+		                                       &local);
+		if (!rule) {
+			PARSE_WARNING ("invalid routing rule %s=\"%s\": %s", key, value, local->message);
+			continue;
+		}
+
+		g_ptr_array_add (arr, g_steal_pointer (&rule));
+	}
+
+	if (arr->len == 0)
+		return NULL;
+
+	return g_steal_pointer (&arr);
+}
+
+static void
+read_routing_rules (shvarFile *ifcfg,
+                    gboolean routes_read,
+                    NMSettingIPConfig *s_ip4,
+                    NMSettingIPConfig *s_ip6)
+{
+	gs_unref_ptrarray GPtrArray *routing_rules = NULL;
+	guint i;
+
+	routing_rules = read_routing_rules_parse (ifcfg, routes_read);
+	if (!routing_rules)
+		return;
+
+	for (i = 0; i < routing_rules->len; i++) {
+		NMIPRoutingRule *rule = routing_rules->pdata[i];
+
+		nm_setting_ip_config_add_routing_rule (  (nm_ip_routing_rule_get_addr_family (rule) == AF_INET)
+		                                       ? s_ip4
+		                                       : s_ip6,
+		                                       rule);
+	}
+}
+
+static void
+parse_ethtool_options (shvarFile *ifcfg, NMConnection *connection)
+{
+	NMSettingWired *s_wired;
+	gs_unref_object NMSettingEthtool *s_ethtool = NULL;
+	NMSettingWiredWakeOnLan wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT;
+	gs_free char *ethtool_opts_free = NULL;
+	const char *ethtool_opts;
+	gs_free char *wol_password = NULL;
+	gs_free char *wol_value_free = NULL;
+	const char *tmp;
+	gboolean autoneg = FALSE;
+	guint32 speed = 0;
+	const char *duplex = NULL;
+	gboolean wired_found = FALSE;
+
+	ethtool_opts = svGetValue (ifcfg, "ETHTOOL_OPTS", &ethtool_opts_free);
+	if (ethtool_opts) {
+		wired_found = TRUE;
+		/* WAKE_ON_LAN_IGNORE is inferred from a specified but empty ETHTOOL_OPTS */
+		if (!ethtool_opts[0])
+			wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE;
+		else {
+			gs_free const char **opts = NULL;
+			const char *const *iter;
+
+			opts = nm_utils_strsplit_set (ethtool_opts, ";");
+			for (iter = opts; iter && iter[0]; iter++) {
+				/* in case of repeated wol_passwords, parse_ethtool_option()
+				 * will do the right thing and clear wol_password before resetting. */
+				parse_ethtool_option (iter[0],
+				                      &wol_flags,
+				                      &wol_password,
+				                      &autoneg,
+				                      &speed,
+				                      &duplex,
+				                      &s_ethtool);
+			}
+		}
+	}
+
+	/* ETHTOOL_WAKE_ON_LAN = ignore overrides WoL settings in ETHTOOL_OPTS */
+	tmp = svGetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN", &wol_value_free);
+	if (tmp)
+		wired_found = TRUE;
+	if (nm_streq0 (tmp, "ignore"))
+		wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE;
+	else if (tmp)
+		PARSE_WARNING ("invalid ETHTOOL_WAKE_ON_LAN value '%s'", tmp);
+
+	if (   wol_password
+	    && !NM_FLAGS_HAS (wol_flags, NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC)) {
+		PARSE_WARNING ("Wake-on-LAN password not expected");
+		nm_clear_g_free (&wol_password);
+	}
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	if (!s_wired && wired_found) {
+		s_wired = (NMSettingWired *) nm_setting_wired_new ();
+		nm_connection_add_setting (connection, NM_SETTING (s_wired));
+	}
+	if (s_wired) {
+		g_object_set (s_wired,
+		              NM_SETTING_WIRED_WAKE_ON_LAN, wol_flags,
+		              NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD, wol_password,
+		              NM_SETTING_WIRED_AUTO_NEGOTIATE, autoneg,
+		              NM_SETTING_WIRED_SPEED, speed,
+		              NM_SETTING_WIRED_DUPLEX, duplex,
+		              NULL);
+	}
+
+	if (s_ethtool) {
+		nm_connection_add_setting (connection,
+		                           NM_SETTING (g_steal_pointer (&s_ethtool)));
+	}
+}
+
+static NMSetting *
+make_wired_setting (shvarFile *ifcfg,
+                    const char *file,
+                    NMSetting8021x **s_8021x,
+                    GError **error)
+{
+	gs_unref_object NMSettingWired *s_wired = NULL;
+	const char *cvalue;
+	gs_free char *value = NULL;
+	gboolean found = FALSE;
+
+	s_wired = NM_SETTING_WIRED (nm_setting_wired_new ());
+
+	cvalue = svGetValue (ifcfg, "MTU", &value);
+	if (cvalue) {
+		int mtu;
+
+		mtu = _nm_utils_ascii_str_to_int64 (cvalue, 0, 0, 65535, -1);
+		if (mtu >= 0)
+			g_object_set (s_wired, NM_SETTING_WIRED_MTU, (guint) mtu, NULL);
+		else
+			PARSE_WARNING ("invalid MTU '%s'", cvalue);
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	value = svGetValue_cp (ifcfg, "HWADDR");
+	if (value) {
+		if (value[0] != '\0') {
+			value = g_strstrip (value);
+			g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, value, NULL);
+		}
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValue (ifcfg, "SUBCHANNELS", &value);
+	if (cvalue) {
+		if (cvalue[0] != '\0') {
+			const char *p = cvalue;
+			gboolean success = TRUE;
+
+			/* basic sanity checks */
+			while (*p) {
+				if (!g_ascii_isxdigit (*p) && (*p != ',') && (*p != '.')) {
+					PARSE_WARNING ("invalid SUBCHANNELS '%s'", cvalue);
+					success = FALSE;
+					break;
+				}
+				p++;
+			}
+
+			if (success) {
+				gs_free const char **chans = NULL;
+				guint32 num_chans;
+
+				chans = nm_utils_strsplit_set (cvalue, ",");
+				num_chans = NM_PTRARRAY_LEN (chans);
+				if (num_chans < 2 || num_chans > 3) {
+					PARSE_WARNING ("invalid SUBCHANNELS '%s' (%u channels, 2 or 3 expected)",
+					               cvalue, (unsigned) NM_PTRARRAY_LEN (chans));
+				} else
+					g_object_set (s_wired, NM_SETTING_WIRED_S390_SUBCHANNELS, chans, NULL);
+			}
+		}
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValue (ifcfg, "PORTNAME", &value);
+	if (cvalue) {
+		if (cvalue[0] != '\0')
+			nm_setting_wired_add_s390_option (s_wired, "portname", cvalue);
+		found = TRUE;
+		nm_clear_g_free (&value);
+	}
+
+	cvalue = svGetValue (ifcfg, "CTCPROT", &value);
+	if (cvalue) {
+		if (cvalue[0] != '\0')
+			nm_setting_wired_add_s390_option (s_wired, "ctcprot", cvalue);
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValue (ifcfg, "NETTYPE", &value);
+	if (cvalue) {
+		if (NM_IN_STRSET (cvalue, "qeth", "lcs", "ctc"))
+			g_object_set (s_wired, NM_SETTING_WIRED_S390_NETTYPE, cvalue, NULL);
+		else
+			PARSE_WARNING ("unknown s390 NETTYPE '%s'", cvalue);
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValue (ifcfg, "OPTIONS", &value);
+	if (cvalue)
+		found = TRUE;
+	if (cvalue && cvalue[0]) {
+		gs_free const char **options = NULL;
+		gsize i;
+
+		options = nm_utils_escaped_tokens_split (cvalue, NM_ASCII_SPACES);
+		for (i = 0; options && options[i]; i++) {
+			const char *line = options[i];
+			const char *equals;
+			gboolean valid = FALSE;
+
+			equals = strchr (line, '=');
+			if (equals) {
+				((char *) equals)[0] = '\0';
+				valid = nm_setting_wired_add_s390_option (s_wired, line, equals + 1);
+			}
+			if (!valid)
+				PARSE_WARNING ("invalid s390 OPTION '%s'", line);
+		}
+		found = TRUE;
+	}
+	nm_clear_g_free (&value);
+
+	cvalue = svGetValueStr (ifcfg, "MACADDR", &value);
+	if (cvalue) {
+		if (cvalue[0] != '\0') {
+			g_object_set (s_wired,
+			              NM_SETTING_WIRED_CLONED_MAC_ADDRESS,
+			              cvalue,
+			              NULL);
+		}
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK", &value);
+	if (cvalue) {
+		if (cvalue[0] != '\0') {
+			g_object_set (s_wired,
+			              NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK,
+			              cvalue,
+			              NULL);
+		}
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValueStr (ifcfg, "HWADDR_BLACKLIST", &value);
+	if (cvalue) {
+		gs_free const char **strv = NULL;
+
+		strv = transform_hwaddr_blacklist (cvalue);
+		g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST, strv, NULL);
+		nm_clear_g_free (&value);
+		found = TRUE;
+	}
+
+	cvalue = svGetValue (ifcfg, "KEY_MGMT", &value);
+	if (cvalue)
+		found = TRUE;
+	if (cvalue && cvalue[0] != '\0') {
+		if (!strcmp (cvalue, "IEEE8021X")) {
+			*s_8021x = fill_8021x (ifcfg, file, cvalue, FALSE, error);
+			if (!*s_8021x)
+				return NULL;
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Unknown wired KEY_MGMT type '%s'", cvalue);
+			return NULL;
+		}
+	}
+	nm_clear_g_free (&value);
+
+	if (!found) {
+		g_set_error (error,
+		             NM_UTILS_ERROR,
+		             NM_UTILS_ERROR_SETTING_MISSING,
+		             "The setting is missing.");
+		return NULL;
+	}
+
+	return (NMSetting *) g_steal_pointer (&s_wired);
+}
+
+static NMConnection *
+wired_connection_from_ifcfg (const char *file,
+                             shvarFile *ifcfg,
+                             GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *wired_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_WIRED_SETTING_NAME, NULL, NULL);
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
+		g_propagate_error (error, local);
+		g_object_unref (connection);
+		return NULL;
+	}
+	g_clear_error (&local);
+
+	if (wired_setting)
+		nm_connection_add_setting (connection, wired_setting);
+
+	if (s_8021x)
+		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	return connection;
+}
+
+static gboolean
+parse_infiniband_p_key (shvarFile *ifcfg,
+                        int *out_p_key,
+                        char **out_parent,
+                        GError **error)
+{
+	char *device = NULL, *physdev = NULL, *pkey_id = NULL;
+	char *ifname = NULL;
+	int id;
+	gboolean ret = FALSE;
+
+	device = svGetValueStr_cp (ifcfg, "DEVICE");
+	if (!device) {
+		PARSE_WARNING ("InfiniBand connection specified PKEY but not DEVICE");
+		goto done;
+	}
+
+	physdev = svGetValueStr_cp (ifcfg, "PHYSDEV");
+	if (!physdev) {
+		PARSE_WARNING ("InfiniBand connection specified PKEY but not PHYSDEV");
+		goto done;
+	}
+
+	pkey_id = svGetValueStr_cp (ifcfg, "PKEY_ID");
+	if (!pkey_id) {
+		PARSE_WARNING ("InfiniBand connection specified PKEY but not PKEY_ID");
+		goto done;
+	}
+
+	id = _nm_utils_ascii_str_to_int64 (pkey_id, 0, 0, 0xFFFF, -1);
+	if (id == -1) {
+		PARSE_WARNING ("invalid InfiniBand PKEY_ID '%s'", pkey_id);
+		goto done;
+	}
+	id = (id | 0x8000);
+
+	ifname = g_strdup_printf ("%s.%04x", physdev, (unsigned) id);
+	if (strcmp (device, ifname) != 0) {
+		PARSE_WARNING ("InfiniBand DEVICE (%s) does not match PHYSDEV+PKEY_ID (%s)",
+		               device, ifname);
+		goto done;
+	}
+
+	*out_p_key = id;
+	*out_parent = g_strdup (physdev);
+	ret = TRUE;
+
+ done:
+	g_free (device);
+	g_free (physdev);
+	g_free (pkey_id);
+	g_free (ifname);
+
+	if (!ret) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create InfiniBand setting.");
+	}
+	return ret;
+}
+
+static NMSetting *
+make_infiniband_setting (shvarFile *ifcfg,
+                         const char *file,
+                         GError **error)
+{
+	NMSettingInfiniband *s_infiniband;
+	char *value = NULL;
+
+	s_infiniband = NM_SETTING_INFINIBAND (nm_setting_infiniband_new ());
+
+	value = svGetValueStr_cp (ifcfg, "MTU");
+	if (value) {
+		int mtu;
+
+		mtu = _nm_utils_ascii_str_to_int64 (value, 0, 0, 65535, -1);
+		if (mtu >= 0)
+			g_object_set (s_infiniband, NM_SETTING_INFINIBAND_MTU, (guint) mtu, NULL);
+		else
+			PARSE_WARNING ("invalid MTU '%s'", value);
+		g_free (value);
+	}
+
+	value = svGetValueStr_cp (ifcfg, "HWADDR");
+	if (value) {
+		value = g_strstrip (value);
+		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_MAC_ADDRESS, value, NULL);
+		g_free (value);
+	}
+
+	if (svGetValueBoolean (ifcfg, "CONNECTED_MODE", FALSE))
+		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "connected", NULL);
+	else
+		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram", NULL);
+
+	if (svGetValueBoolean (ifcfg, "PKEY", FALSE)) {
+		gs_free char *parent = NULL;
+		int p_key;
+
+		if (!parse_infiniband_p_key (ifcfg, &p_key, &parent, error)) {
+			g_object_unref (s_infiniband);
+			return NULL;
+		}
+
+		g_object_set (s_infiniband,
+		              NM_SETTING_INFINIBAND_P_KEY, p_key,
+		              NM_SETTING_INFINIBAND_PARENT, parent,
+		              NULL);
+	}
+
+	return (NMSetting *) s_infiniband;
+}
+
+static NMConnection *
+infiniband_connection_from_ifcfg (const char *file,
+                                  shvarFile *ifcfg,
+                                  GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *infiniband_setting = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_INFINIBAND_SETTING_NAME, NULL, NULL);
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	infiniband_setting = make_infiniband_setting (ifcfg, file, error);
+	if (!infiniband_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, infiniband_setting);
+
+	return connection;
+}
+
+static void
+handle_bond_option (NMSettingBond *s_bond,
+                    const char *key,
+                    const char *value)
+{
+	char *sanitized = NULL, *j;
+	const char *p = value;
+
+	/* Remove any quotes or +/- from arp_ip_target */
+	if (!g_strcmp0 (key, NM_SETTING_BOND_OPTION_ARP_IP_TARGET) && value && value[0]) {
+		if (*p == '\'' || *p == '"')
+			p++;
+		j = sanitized = g_malloc0 (strlen (p) + 1);
+		while (*p) {
+			if (*p != '+' && *p != '-' && *p != '\'' && *p != '"')
+				*j++ = *p;
+			p++;
+		}
+	}
+
+	if (!nm_setting_bond_add_option (s_bond, key, sanitized ?: value))
+		PARSE_WARNING ("invalid bonding option '%s' = %s",
+		               key, sanitized ?: value);
+	g_free (sanitized);
+}
+
+static NMSetting *
+make_bond_setting (shvarFile *ifcfg,
+                   const char *file,
+                   GError **error)
+{
+	NMSettingBond *s_bond;
+	gs_free char *value = NULL;
+	const char *v;
+
+	v = svGetValueStr (ifcfg, "DEVICE", &value);
+	if (!v) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "mandatory DEVICE keyword missing");
+		return NULL;
+	}
+
+	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "BONDING_OPTS", &value);
+	if (v) {
+		gs_free const char **items = NULL;
+		const char *const *iter;
+
+		items = nm_utils_strsplit_set (v, " ");
+		for (iter = items; iter && *iter; iter++) {
+			gs_free char *key = NULL;
+			const char *val;
+
+			val = strchr (*iter, '=');
+			if (!val)
+				continue;
+			key = g_strndup (*iter, val - *iter);
+			val++;
+			if (key[0] && val[0])
+				handle_bond_option (s_bond, key, val);
+		}
+	}
+
+	return (NMSetting *) s_bond;
+}
+
+static NMConnection *
+bond_connection_from_ifcfg (const char *file,
+                            shvarFile *ifcfg,
+                            GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *bond_setting = NULL;
+	NMSetting *wired_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_BOND_SETTING_NAME, NULL, _("Bond"));
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	bond_setting = make_bond_setting (ifcfg, file, error);
+	if (!bond_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, bond_setting);
+
+	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
+		g_propagate_error (error, local);
+		g_object_unref (connection);
+		return NULL;
+	}
+	g_clear_error (&local);
+
+	if (wired_setting)
+		nm_connection_add_setting (connection, wired_setting);
+
+	if (s_8021x)
+		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	return connection;
+}
+
+static NMSetting *
+make_team_setting (shvarFile *ifcfg,
+                   const char *file,
+                   GError **error)
+{
+	NMSetting *s_team;
+	gs_free char *value_device = NULL;
+	gs_free char *value = NULL;
+
+	if (!svGetValueStr (ifcfg, "DEVICE", &value_device)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "mandatory DEVICE keyword missing");
+		return NULL;
+	}
+
+	s_team = nm_setting_team_new ();
+	g_object_set (s_team,
+	              NM_SETTING_TEAM_CONFIG,
+	              svGetValue (ifcfg, "TEAM_CONFIG", &value),
+	              NULL);
+	return s_team;
+}
+
+static NMConnection *
+team_connection_from_ifcfg (const char *file,
+                            shvarFile *ifcfg,
+                            GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *team_setting = NULL;
+	NMSetting *wired_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_TEAM_SETTING_NAME, NULL, _("Team"));
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	team_setting = make_team_setting (ifcfg, file, error);
+	if (!team_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, team_setting);
+
+	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
+		g_propagate_error (error, local);
+		g_object_unref (connection);
+		return NULL;
+	}
+	g_clear_error (&local);
+
+	if (wired_setting)
+		nm_connection_add_setting (connection, wired_setting);
+
+	if (s_8021x)
+		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	return connection;
+}
+
+typedef enum {
+	BRIDGE_OPT_TYPE_MAIN,
+	BRIDGE_OPT_TYPE_OPTION,
+	BRIDGE_OPT_TYPE_PORT_MAIN,
+	BRIDGE_OPT_TYPE_PORT_OPTION,
+} BridgeOptType;
+
+typedef void (*BridgeOptFunc) (NMSetting *setting,
+                               gboolean stp,
+                               const char *key,
+                               const char *value,
+                               BridgeOptType opt_type);
+
+static void
+handle_bridge_option (NMSetting *setting,
+                      gboolean stp,
+                      const char *key,
+                      const char *value,
+                      BridgeOptType opt_type)
+{
+	static const struct {
+		const char *key;
+		const char *property_name;
+		BridgeOptType opt_type;
+		gboolean only_with_stp;
+		gboolean extended_bool;
+	} m/*etadata*/[] = {
+		{ "DELAY",              NM_SETTING_BRIDGE_FORWARD_DELAY,      BRIDGE_OPT_TYPE_MAIN,   .only_with_stp = TRUE },
+		{ "priority",           NM_SETTING_BRIDGE_PRIORITY,           BRIDGE_OPT_TYPE_OPTION, .only_with_stp = TRUE },
+		{ "hello_time",         NM_SETTING_BRIDGE_HELLO_TIME,         BRIDGE_OPT_TYPE_OPTION, .only_with_stp = TRUE },
+		{ "max_age",            NM_SETTING_BRIDGE_MAX_AGE,            BRIDGE_OPT_TYPE_OPTION, .only_with_stp = TRUE },
+		{ "ageing_time",        NM_SETTING_BRIDGE_AGEING_TIME,        BRIDGE_OPT_TYPE_OPTION },
+		{ "multicast_snooping", NM_SETTING_BRIDGE_MULTICAST_SNOOPING, BRIDGE_OPT_TYPE_OPTION },
+		{ "vlan_filtering",     NM_SETTING_BRIDGE_VLAN_FILTERING,     BRIDGE_OPT_TYPE_OPTION },
+		{ "default_pvid",       NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID,  BRIDGE_OPT_TYPE_OPTION },
+		{ "group_fwd_mask",     NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, BRIDGE_OPT_TYPE_OPTION },
+		{ "priority",           NM_SETTING_BRIDGE_PORT_PRIORITY,      BRIDGE_OPT_TYPE_PORT_OPTION },
+		{ "path_cost",          NM_SETTING_BRIDGE_PORT_PATH_COST,     BRIDGE_OPT_TYPE_PORT_OPTION },
+		{ "hairpin_mode",       NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE,  BRIDGE_OPT_TYPE_PORT_OPTION, .extended_bool = TRUE, },
+	};
+	const char *error_message = NULL;
+	int i;
+	gint64 v;
+
+	for (i = 0; i < G_N_ELEMENTS (m); i++) {
+		GParamSpec *param_spec;
+
+		if (opt_type != m[i].opt_type)
+			continue;
+		if (!nm_streq (key, m[i].key))
+			continue;
+		if (m[i].only_with_stp && !stp) {
+			PARSE_WARNING ("'%s' invalid when STP is disabled", key);
+			return;
+		}
+
+		param_spec = g_object_class_find_property (G_OBJECT_GET_CLASS (setting), m[i].property_name);
+		switch (param_spec->value_type) {
+		case G_TYPE_BOOLEAN:
+			if (m[i].extended_bool) {
+				if (!strcasecmp (value, "on") || !strcasecmp (value, "yes") || !strcmp (value, "1"))
+					v = TRUE;
+				else if (!strcasecmp (value, "off") || !strcasecmp (value, "no"))
+					v = FALSE;
+				else {
+					error_message = "is not a boolean";
+					goto warn;
+				}
+			} else {
+				v = _nm_utils_ascii_str_to_int64 (value, 10, 0, 1, -1);
+				if (v == -1) {
+					error_message = nm_strerror_native (errno);
+					goto warn;
+				}
+			}
+			if (!nm_g_object_set_property_boolean (G_OBJECT (setting), m[i].property_name, v, NULL)) {
+				error_message = "number is out of range";
+				goto warn;
+			}
+			return;
+		case G_TYPE_UINT:
+			v = _nm_utils_ascii_str_to_int64 (value, 10, 0, G_MAXUINT, -1);
+			if (v == -1) {
+				error_message = nm_strerror_native (errno);
+				goto warn;
+			}
+			if (!nm_g_object_set_property_uint (G_OBJECT (setting), m[i].property_name, v, NULL)) {
+				error_message = "number is out of range";
+				goto warn;
+			}
+			return;
+		default:
+			nm_assert_not_reached ();
+			continue;
+		}
+
+warn:
+		PARSE_WARNING ("invalid %s value '%s': %s", key, value, error_message);
+		return;
+	}
+
+	PARSE_WARNING ("unhandled bridge option '%s'", key);
+}
+
+static void
+handle_bridging_opts (NMSetting *setting,
+                      gboolean stp,
+                      const char *value,
+                      BridgeOptFunc func,
+                      BridgeOptType opt_type)
+{
+	gs_free const char **items = NULL;
+	const char *const *iter;
+
+	items = nm_utils_strsplit_set (value, " ");
+	for (iter = items; iter && *iter; iter++) {
+		gs_free char *key = NULL;
+		const char *val;
+
+		val = strchr (*iter, '=');
+		if (!val)
+			continue;
+		key = g_strndup (*iter, val - *iter);
+		val++;
+		if (key[0] && val[0])
+			func (setting, stp, key, val, opt_type);
+	}
+}
+
+static void
+read_bridge_vlans (shvarFile *ifcfg,
+                   const char *key,
+                   NMSetting *setting,
+                   const char *property)
+{
+	gs_unref_ptrarray GPtrArray *array = NULL;
+	gs_free char *value_to_free = NULL;
+	const char *value;
+
+	value = svGetValueStr (ifcfg, key, &value_to_free);
+	if (value) {
+		gs_free const char **strv = NULL;
+		const char *const *iter;
+		GError *local = NULL;
+		NMBridgeVlan *vlan;
+
+		array = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+
+		strv = nm_utils_escaped_tokens_split (value, ",");
+		if (strv) {
+			for (iter = strv; *iter; iter++) {
+				vlan = nm_bridge_vlan_from_str (*iter, &local);
+				if (!vlan) {
+					PARSE_WARNING ("invalid bridge VLAN: %s", local->message);
+					g_clear_error (&local);
+					continue;
+				}
+				g_ptr_array_add (array, vlan);
+			}
+		}
+		nm_clear_g_free (&value_to_free);
+	}
+
+	g_object_set (setting, property, array, NULL);
+}
+
+static NMSetting *
+make_bridge_setting (shvarFile *ifcfg,
+                     const char *file,
+                     GError **error)
+{
+	gs_unref_object NMSettingBridge *s_bridge = NULL;
+	gs_free char *value_to_free = NULL;
+	const char *value;
+	gboolean stp = FALSE;
+	gboolean stp_set = FALSE;
+
+	value = svGetValueStr (ifcfg, "DEVICE", &value_to_free);
+	if (!value) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "mandatory DEVICE keyword missing");
+		return NULL;
+	}
+	nm_clear_g_free (&value_to_free);
+
+	s_bridge = NM_SETTING_BRIDGE (nm_setting_bridge_new ());
+
+	value = svGetValueStr (ifcfg, "BRIDGE_MACADDR", &value_to_free);
+	if (value) {
+		g_object_set (s_bridge, NM_SETTING_BRIDGE_MAC_ADDRESS, value, NULL);
+		nm_clear_g_free (&value_to_free);
+	}
+
+	value = svGetValueStr (ifcfg, "STP", &value_to_free);
+	if (value) {
+		if (!strcasecmp (value, "on") || !strcasecmp (value, "yes")) {
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, TRUE, NULL);
+			stp = TRUE;
+			stp_set = TRUE;
+		} else if (!strcasecmp (value, "off") || !strcasecmp (value, "no")) {
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, FALSE, NULL);
+			stp_set = TRUE;
+		} else
+			PARSE_WARNING ("invalid STP value '%s'", value);
+		nm_clear_g_free (&value_to_free);
+	}
+
+	if (!stp_set) {
+		/* Missing or invalid STP property means "no" */
+		g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, FALSE, NULL);
+	}
+
+	value = svGetValueStr (ifcfg, "DELAY", &value_to_free);
+	if (value) {
+		handle_bridge_option (NM_SETTING (s_bridge), stp, "DELAY", value, BRIDGE_OPT_TYPE_MAIN);
+		nm_clear_g_free (&value_to_free);
+	}
+
+	value = svGetValueStr (ifcfg, "BRIDGING_OPTS", &value_to_free);
+	if (value) {
+		handle_bridging_opts (NM_SETTING (s_bridge), stp, value, handle_bridge_option, BRIDGE_OPT_TYPE_OPTION);
+		nm_clear_g_free (&value_to_free);
+	}
+
+	read_bridge_vlans (ifcfg,
+	                   "BRIDGE_VLANS",
+	                   NM_SETTING (s_bridge),
+	                   NM_SETTING_BRIDGE_VLANS);
+
+	return (NMSetting *) g_steal_pointer (&s_bridge);
+}
+
+static NMConnection *
+bridge_connection_from_ifcfg (const char *file,
+                              shvarFile *ifcfg,
+                              GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *bridge_setting = NULL;
+	NMSetting *wired_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_BRIDGE_SETTING_NAME, NULL, _("Bridge"));
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	bridge_setting = make_bridge_setting (ifcfg, file, error);
+	if (!bridge_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, bridge_setting);
+
+	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
+		g_propagate_error (error, local);
+		g_object_unref (connection);
+		return NULL;
+	}
+	g_clear_error (&local);
+
+	if (wired_setting)
+		nm_connection_add_setting (connection, wired_setting);
+
+	if (s_8021x)
+		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	return connection;
+}
+
+static NMSetting *
+make_bridge_port_setting (shvarFile *ifcfg)
+{
+	NMSetting *s_port = NULL;
+	gs_free char *value_to_free = NULL;
+	const char *value;
+
+	g_return_val_if_fail (ifcfg != NULL, FALSE);
+
+	value = svGetValueStr (ifcfg, "BRIDGE_UUID", &value_to_free);
+	if (!value)
+		value = svGetValueStr (ifcfg, "BRIDGE", &value_to_free);
+	if (value) {
+		nm_clear_g_free (&value_to_free);
+
+		s_port = nm_setting_bridge_port_new ();
+		value = svGetValueStr (ifcfg, "BRIDGING_OPTS", &value_to_free);
+		if (value) {
+			handle_bridging_opts (s_port, FALSE, value, handle_bridge_option, BRIDGE_OPT_TYPE_PORT_OPTION);
+			nm_clear_g_free (&value_to_free);
+		}
+
+		read_bridge_vlans (ifcfg,
+		                   "BRIDGE_PORT_VLANS",
+		                   s_port,
+		                   NM_SETTING_BRIDGE_PORT_VLANS);
+	}
+
+	return s_port;
+}
+
+static NMSetting *
+make_team_port_setting (shvarFile *ifcfg)
+{
+	NMSetting *s_port;
+	gs_free char *value = NULL;
+
+	value = svGetValueStr_cp (ifcfg, "TEAM_PORT_CONFIG");
+	if (!value)
+		return NULL;
+
+	s_port = nm_setting_team_port_new ();
+	g_object_set (s_port,
+	              NM_SETTING_TEAM_PORT_CONFIG,
+	              value,
+	              NULL);
+	return s_port;
+}
+
+static gboolean
+is_bond_device (const char *name, shvarFile *parsed)
+{
+	g_return_val_if_fail (name != NULL, FALSE);
+	g_return_val_if_fail (parsed != NULL, FALSE);
+
+	if (svGetValueBoolean (parsed, "BONDING_MASTER", FALSE))
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean
+is_vlan_device (const char *name, shvarFile *parsed)
+{
+	g_return_val_if_fail (name != NULL, FALSE);
+	g_return_val_if_fail (parsed != NULL, FALSE);
+
+	if (svGetValueBoolean (parsed, "VLAN", FALSE))
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean
+is_wifi_device (const char *name, shvarFile *parsed)
+{
+	const NMPlatformLink *pllink;
+
+	g_return_val_if_fail (name != NULL, FALSE);
+	g_return_val_if_fail (parsed != NULL, FALSE);
+
+	pllink = nm_platform_link_get_by_ifname (NM_PLATFORM_GET, name);
+	return    pllink
+	       && pllink->type == NM_LINK_TYPE_WIFI;
+}
+
+static void
+parse_prio_map_list (NMSettingVlan *s_vlan,
+                     shvarFile *ifcfg,
+                     const char *key,
+                     NMVlanPriorityMap map)
+{
+	gs_free char *value = NULL;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+	const char *v;
+
+	v = svGetValueStr (ifcfg, key, &value);
+	if (!v)
+		return;
+	list = nm_utils_strsplit_set (v, ",");
+
+	for (iter = list; iter && *iter; iter++) {
+		if (!strchr (*iter, ':'))
+			continue;
+		if (!nm_setting_vlan_add_priority_str (s_vlan, map, *iter))
+			PARSE_WARNING ("invalid %s priority map item '%s'", key, *iter);
+	}
+}
+
+static NMSetting *
+make_vlan_setting (shvarFile *ifcfg,
+                   const char *file,
+                   GError **error)
+{
+	gs_unref_object NMSettingVlan *s_vlan = NULL;
+	gs_free char *parent = NULL;
+	gs_free char *iface_name = NULL;
+	gs_free char *value = NULL;
+	const char *v = NULL;
+	int vlan_id = -1;
+	guint32 vlan_flags = 0;
+	int gvrp, reorder_hdr;
+
+	v = svGetValueStr (ifcfg, "VLAN_ID", &value);
+	if (v) {
+		vlan_id = _nm_utils_ascii_str_to_int64 (v, 10, 0, 4095, -1);
+		if (vlan_id == -1) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid VLAN_ID '%s'", v);
+			return NULL;
+		}
+	}
+
+	/* Need DEVICE if we don't have a separate VLAN_ID property */
+	iface_name = svGetValueStr_cp (ifcfg, "DEVICE");
+	if (!iface_name && vlan_id < 0) {
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "Missing DEVICE property; cannot determine VLAN ID.");
+		return NULL;
+	}
+
+	s_vlan = NM_SETTING_VLAN (nm_setting_vlan_new ());
+
+	/* Parent interface from PHYSDEV takes precedence if it exists */
+	parent = svGetValueStr_cp (ifcfg, "PHYSDEV");
+
+	if (iface_name) {
+		v = strchr (iface_name, '.');
+		if (v) {
+			/* eth0.43; PHYSDEV is assumed from it if unknown */
+			if (!parent) {
+				parent = g_strndup (iface_name, v - iface_name);
+				if (g_str_has_prefix (parent, "vlan")) {
+					/* Like initscripts, if no PHYSDEV and we get an obviously
+					 * invalid parent interface from DEVICE, fail.
+					 */
+					nm_clear_g_free (&parent);
+				}
+			}
+			v++;
+		} else {
+			/* format like vlan43; PHYSDEV must be set */
+			if (g_str_has_prefix (iface_name, "vlan"))
+				v = iface_name + 4;
+		}
+
+		if (v) {
+			int device_vlan_id;
+
+			/* Grab VLAN ID from interface name; this takes precedence over the
+			 * separate VLAN_ID property for backwards compat.
+			 */
+			device_vlan_id = _nm_utils_ascii_str_to_int64 (v, 10, 0, 4095, -1);
+			if (device_vlan_id != -1)
+				vlan_id = device_vlan_id;
+		}
+	}
+
+	if (vlan_id < 0) {
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "Failed to determine VLAN ID from DEVICE or VLAN_ID.");
+		return NULL;
+	}
+	g_object_set (s_vlan, NM_SETTING_VLAN_ID, vlan_id, NULL);
+
+	if (parent == NULL) {
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		                     "Failed to determine VLAN parent from DEVICE or PHYSDEV");
+		return NULL;
+	}
+	g_object_set (s_vlan, NM_SETTING_VLAN_PARENT, parent, NULL);
+
+	vlan_flags |= NM_VLAN_FLAG_REORDER_HEADERS;
+
+	gvrp = svGetValueBoolean (ifcfg, "GVRP", -1);
+	if (gvrp > 0)
+		vlan_flags |= NM_VLAN_FLAG_GVRP;
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "VLAN_FLAGS", &value);
+	if (v) {
+		gs_free const char **strv = NULL;
+		const char *const *ptr;
+
+		strv = nm_utils_strsplit_set (v, ", ");
+		for (ptr = strv; ptr && *ptr; ptr++) {
+			if (nm_streq (*ptr, "GVRP") && gvrp == -1)
+				vlan_flags |= NM_VLAN_FLAG_GVRP;
+			if (nm_streq (*ptr, "LOOSE_BINDING"))
+				vlan_flags |=  NM_VLAN_FLAG_LOOSE_BINDING;
+			if (nm_streq (*ptr, "NO_REORDER_HDR"))
+				vlan_flags &= ~NM_VLAN_FLAG_REORDER_HEADERS;
+		}
+	}
+
+	reorder_hdr = svGetValueBoolean (ifcfg, "REORDER_HDR", -1);
+	if (   reorder_hdr != -1
+	    && reorder_hdr != NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS))
+		PARSE_WARNING ("REORDER_HDR key is deprecated, use VLAN_FLAGS");
+
+	if (svGetValueBoolean (ifcfg, "MVRP", FALSE))
+		vlan_flags |= NM_VLAN_FLAG_MVRP;
+
+	g_object_set (s_vlan, NM_SETTING_VLAN_FLAGS, vlan_flags, NULL);
+
+	parse_prio_map_list (s_vlan, ifcfg, "VLAN_INGRESS_PRIORITY_MAP", NM_VLAN_INGRESS_MAP);
+	parse_prio_map_list (s_vlan, ifcfg, "VLAN_EGRESS_PRIORITY_MAP", NM_VLAN_EGRESS_MAP);
+
+	return NM_SETTING (g_steal_pointer (&s_vlan));
+}
+
+static NMConnection *
+vlan_connection_from_ifcfg (const char *file,
+                            shvarFile *ifcfg,
+                            GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *wired_setting = NULL;
+	NMSetting *vlan_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_VLAN_SETTING_NAME, NULL, "Vlan");
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	vlan_setting = make_vlan_setting (ifcfg, file, error);
+	if (!vlan_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, vlan_setting);
+
+	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
+		g_propagate_error (error, local);
+		g_object_unref (connection);
+		return NULL;
+	}
+	g_clear_error (&local);
+
+	if (wired_setting)
+		nm_connection_add_setting (connection, wired_setting);
+
+	if (s_8021x)
+		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	return connection;
+}
+
+static NMConnection *
+create_unhandled_connection (const char *filename, shvarFile *ifcfg,
+                             const char *type, char **out_spec)
+{
+	NMConnection *connection;
+	NMSetting *s_con;
+	gs_free char *value = NULL;
+	const char *v;
+
+	nm_assert (out_spec && !*out_spec);
+
+	connection = nm_simple_connection_new ();
+
+	/* Get NAME, UUID, etc. We need to set a connection type (generic) and add
+	 * an empty type-specific setting as well, to make sure it passes
+	 * nm_connection_verify() later.
+	 */
+	s_con = make_connection_setting (filename, ifcfg, NM_SETTING_GENERIC_SETTING_NAME,
+	                                 NULL, NULL);
+	nm_connection_add_setting (connection, s_con);
+
+	nm_connection_add_setting (connection, nm_setting_generic_new ());
+
+	/* Get a spec */
+	v = svGetValueStr (ifcfg, "HWADDR", &value);
+	if (v) {
+		gs_free char *lower = g_ascii_strdown (v, -1);
+
+		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_MAC_TAG"%s", type, lower);
+		return connection;
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "SUBCHANNELS", &value);
+	if (v) {
+		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_S390_SUBCHANNELS_TAG"%s", type, v);
+		return connection;
+	}
+
+	nm_clear_g_free (&value);
+	v = svGetValueStr (ifcfg, "DEVICE", &value);
+	if (v) {
+		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_INTERFACE_NAME_TAG"=%s", type, v);
+		return connection;
+	}
+
+	g_object_unref (connection);
+	return NULL;
+}
+
+static void
+check_dns_search_domains (shvarFile *ifcfg, NMSetting *s_ip4, NMSetting *s_ip6)
+{
+	if (!s_ip6)
+		return;
+
+	/* If there is no IPv4 config or it doesn't contain DNS searches,
+	 * read DOMAIN and put the domains into IPv6.
+	 */
+	if (   !s_ip4
+	    || nm_setting_ip_config_get_num_dns_searches (NM_SETTING_IP_CONFIG (s_ip4)) == 0) {
+		/* DNS searches */
+		gs_free char *value = NULL;
+		const char *v;
+
+		v = svGetValueStr (ifcfg, "DOMAIN", &value);
+		if (v) {
+			gs_free const char **searches = NULL;
+			const char *const *item;
+
+			searches = nm_utils_strsplit_set (v, " ");
+			if (searches) {
+				for (item = searches; *item; item++) {
+					if (!nm_setting_ip_config_add_dns_search (NM_SETTING_IP_CONFIG (s_ip6), *item))
+						PARSE_WARNING ("duplicate DNS domain '%s'", *item);
+				}
+			}
+		}
+	}
+}
+
+static NMConnection *
+connection_from_file_full (const char *filename,
+                           const char *network_file,  /* for unit tests only */
+                           const char *test_type,     /* for unit tests only */
+                           char **out_unhandled,
+                           GError **error,
+                           gboolean *out_ignore_error)
+{
+	nm_auto_shvar_file_close shvarFile *main_ifcfg = NULL;
+	nm_auto_shvar_file_close shvarFile *network_ifcfg = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_free char *type = NULL;
+	char *devtype, *bootproto;
+	NMSetting *s_ip4, *s_ip6, *s_tc, *s_proxy, *s_port, *s_dcb = NULL, *s_user;
+	NMSetting *s_sriov, *s_match;
+	const char *ifcfg_name = NULL;
+	gboolean has_ip4_defroute = FALSE;
+	gboolean has_complex_routes_v4;
+	gboolean has_complex_routes_v6;
+
+	g_return_val_if_fail (filename != NULL, NULL);
+	g_return_val_if_fail (out_unhandled && !*out_unhandled, NULL);
+
+	NM_SET_OUT (out_ignore_error, FALSE);
+
+	/* Non-NULL only for unit tests; normally use /etc/sysconfig/network */
+	if (!network_file)
+		network_file = SYSCONFDIR "/sysconfig/network";
+
+	ifcfg_name = utils_get_ifcfg_name (filename, TRUE);
+	if (!ifcfg_name) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Ignoring connection '%s' because it's not an ifcfg file.", filename);
+		return NULL;
+	}
+
+	main_ifcfg = svOpenFile (filename, error);
+	if (!main_ifcfg)
+		return NULL;
+
+	network_ifcfg = svOpenFile (network_file, NULL);
+
+	if (!svGetValueBoolean (main_ifcfg, "NM_CONTROLLED", TRUE)) {
+		connection = create_unhandled_connection (filename, main_ifcfg, "unmanaged", out_unhandled);
+		if (!connection) {
+			NM_SET_OUT (out_ignore_error, TRUE);
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "NM_CONTROLLED was false but device was not uniquely identified; device will be managed");
+		}
+		return g_steal_pointer (&connection);
+	}
+
+	/* iBFT is handled by nm-initrd-generator during boot. */
+	bootproto = svGetValueStr_cp (main_ifcfg, "BOOTPROTO");
+	if (bootproto && !g_ascii_strcasecmp (bootproto, "ibft")) {
+		NM_SET_OUT (out_ignore_error, TRUE);
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Ignoring iBFT configuration");
+		g_free (bootproto);
+		return NULL;
+	}
+	g_free (bootproto);
+
+	devtype = svGetValueStr_cp (main_ifcfg, "DEVICETYPE");
+	if (devtype) {
+		if (!strcasecmp (devtype, TYPE_TEAM))
+			type = g_strdup (TYPE_TEAM);
+		else if (!strcasecmp (devtype, TYPE_TEAM_PORT)) {
+			gs_free char *device = NULL;
+
+			type = svGetValueStr_cp (main_ifcfg, "TYPE");
+			device = svGetValueStr_cp (main_ifcfg, "DEVICE");
+
+			if (type) {
+				/* nothing to do */
+			} else if (device && is_vlan_device (device, main_ifcfg))
+				type = g_strdup (TYPE_VLAN);
+			else
+				type = g_strdup (TYPE_ETHERNET);
+		}
+		g_free (devtype);
+	}
+	if (!type) {
+		gs_free char *t = NULL;
+
+		/* Team and TeamPort types are also accepted by the mere
+		 * presence of TEAM_CONFIG/TEAM_MASTER. They don't require
+		 * DEVICETYPE. */
+		t = svGetValueStr_cp (main_ifcfg, "TEAM_CONFIG");
+		if (t)
+			type = g_strdup (TYPE_TEAM);
+	}
+
+	if (!type)
+		type = svGetValueStr_cp (main_ifcfg, "TYPE");
+
+	if (!type) {
+		gs_free char *tmp = NULL;
+		char *device;
+
+		if ((tmp = svGetValueStr_cp (main_ifcfg, "IPV6TUNNELIPV4"))) {
+			NM_SET_OUT (out_ignore_error, TRUE);
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Ignoring unsupported connection due to IPV6TUNNELIPV4");
+			return NULL;
+		}
+
+		device = svGetValueStr_cp (main_ifcfg, "DEVICE");
+		if (!device) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "File '%s' had neither TYPE nor DEVICE keys.", filename);
+			return NULL;
+		}
+
+		if (!strcmp (device, "lo")) {
+			NM_SET_OUT (out_ignore_error, TRUE);
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Ignoring loopback device config.");
+			g_free (device);
+			return NULL;
+		}
+
+		if (!test_type) {
+			if (is_bond_device (device, main_ifcfg))
+				type = g_strdup (TYPE_BOND);
+			else if (is_vlan_device (device, main_ifcfg))
+				type = g_strdup (TYPE_VLAN);
+			else if (is_wifi_device (device, main_ifcfg))
+				type = g_strdup (TYPE_WIRELESS);
+			else {
+				gs_free char *p_path = NULL;
+				char *p_device;
+				gsize i;
+
+				/* network-functions detects DEVICETYPE based on the ifcfg-* name and the existence
+				 * of a ifup script:
+				 *    [ -z "$DEVICETYPE" ] && DEVICETYPE=$(echo ${DEVICE} | sed "s/[0-9]*$//")
+				 * later...
+				 *    OTHERSCRIPT="/etc/sysconfig/network-scripts/ifup-${DEVICETYPE}"
+				 * */
+#define IFUP_PATH_PREFIX "/etc/sysconfig/network-scripts/ifup-"
+				i = strlen (device);
+				p_path = g_malloc (NM_STRLEN (IFUP_PATH_PREFIX) + i + 1);
+				p_device = &p_path[NM_STRLEN (IFUP_PATH_PREFIX)];
+				memcpy (p_device, device, i + 1);
+
+				/* strip trailing numbers */
+				while (i >= 1) {
+					i--;
+					if (p_device[i] < '0' || p_device[i] > '9')
+						break;
+					p_device[i] = '\0';
+				}
+
+				if (nm_streq (p_device, "eth"))
+					type = g_strdup (TYPE_ETHERNET);
+				else if (nm_streq (p_device, "wireless"))
+					type = g_strdup (TYPE_WIRELESS);
+				else if (p_device[0]) {
+					memcpy (p_path, IFUP_PATH_PREFIX, NM_STRLEN (IFUP_PATH_PREFIX));
+					if (access (p_path, X_OK) == 0) {
+						/* for all other types, this is not something we want to handle. */
+						NM_SET_OUT (out_ignore_error, TRUE);
+						g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+						             "Ignore script for unknown device type which has a matching %s script",
+						             p_path);
+						return NULL;
+					}
+				}
+
+				if (!type)
+					type = g_strdup (TYPE_ETHERNET);
+			}
+		} else {
+			/* For the unit tests, there won't necessarily be any
+			 * adapters of the connection's type in the system so the
+			 * type can't be tested with ioctls.
+			 */
+			type = g_strdup (test_type);
+		}
+
+		g_free (device);
+	} else {
+		/* Check for IBM s390 CTC devices and call them Ethernet */
+		if (g_strcmp0 (type, "CTC") == 0) {
+			g_free (type);
+			type = g_strdup (TYPE_ETHERNET);
+		}
+	}
+
+	if (nm_streq0 (type, TYPE_ETHERNET)) {
+		gs_free char *bond_options = NULL;
+
+		if (svGetValueStr (main_ifcfg, "BONDING_OPTS", &bond_options)) {
+			/* initscripts consider these as bond masters */
+			g_free (type);
+			type = g_strdup (TYPE_BOND);
+		}
+	}
+
+	if (svGetValueBoolean (main_ifcfg, "BONDING_MASTER", FALSE) &&
+	    strcasecmp (type, TYPE_BOND)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "BONDING_MASTER=yes key only allowed in TYPE=bond connections");
+		return NULL;
+	}
+
+	/* Construct the connection */
+	if (!strcasecmp (type, TYPE_ETHERNET))
+		connection = wired_connection_from_ifcfg (filename, main_ifcfg, error);
+	else if (!strcasecmp (type, TYPE_WIRELESS))
+		connection = wireless_connection_from_ifcfg (filename, main_ifcfg, error);
+	else if (!strcasecmp (type, TYPE_INFINIBAND))
+		connection = infiniband_connection_from_ifcfg (filename, main_ifcfg, error);
+	else if (!strcasecmp (type, TYPE_BOND))
+		connection = bond_connection_from_ifcfg (filename, main_ifcfg, error);
+	else if (!strcasecmp (type, TYPE_TEAM))
+		connection = team_connection_from_ifcfg (filename, main_ifcfg, error);
+	else if (!strcasecmp (type, TYPE_VLAN))
+		connection = vlan_connection_from_ifcfg (filename, main_ifcfg, error);
+	else if (!strcasecmp (type, TYPE_BRIDGE))
+		connection = bridge_connection_from_ifcfg (filename, main_ifcfg, error);
+	else {
+		connection = create_unhandled_connection (filename, main_ifcfg, "unrecognized", out_unhandled);
+		if (!connection) {
+			PARSE_WARNING ("connection type was unrecognized but device was not uniquely identified; device may be managed");
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Failed to read unrecognized connection");
+		}
+		return g_steal_pointer (&connection);
+	}
+
+	if (!connection)
+		return NULL;
+
+	parse_ethtool_options (main_ifcfg, connection);
+
+	has_complex_routes_v4 = utils_has_complex_routes (filename, AF_INET);
+	has_complex_routes_v6 = utils_has_complex_routes (filename, AF_INET6);
+
+	if (has_complex_routes_v4 || has_complex_routes_v6) {
+		if (has_complex_routes_v4 && !has_complex_routes_v6)
+			PARSE_WARNING ("'rule-' file is present; you will need to use a dispatcher script to apply these routes");
+		else if (has_complex_routes_v6 && !has_complex_routes_v4)
+			PARSE_WARNING ("'rule6-' file is present; you will need to use a dispatcher script to apply these routes");
+		else
+			PARSE_WARNING ("'rule-' and 'rule6-' files are present; you will need to use a dispatcher script to apply these routes");
+	}
+
+	s_ip6 = make_ip6_setting (main_ifcfg,
+	                          network_ifcfg,
+	                          !has_complex_routes_v4 && !has_complex_routes_v6,
+	                          error);
+	if (!s_ip6)
+		return NULL;
+	nm_connection_add_setting (connection, s_ip6);
+
+	s_ip4 = make_ip4_setting (main_ifcfg,
+	                          network_ifcfg,
+	                          !has_complex_routes_v4 && !has_complex_routes_v6,
+	                          &has_ip4_defroute,
+	                          error);
+	if (!s_ip4)
+		return NULL;
+	read_aliases (NM_SETTING_IP_CONFIG (s_ip4),
+	              !has_ip4_defroute && !nm_setting_ip_config_get_gateway (NM_SETTING_IP_CONFIG (s_ip4)),
+	              filename);
+	nm_connection_add_setting (connection, s_ip4);
+
+	read_routing_rules (main_ifcfg,
+	                    !has_complex_routes_v4 && !has_complex_routes_v6,
+	                    NM_SETTING_IP_CONFIG (s_ip4),
+	                    NM_SETTING_IP_CONFIG (s_ip6));
+
+	s_sriov = make_sriov_setting (main_ifcfg);
+	if (s_sriov)
+		nm_connection_add_setting (connection, s_sriov);
+
+	s_tc = make_tc_setting (main_ifcfg);
+	if (s_tc)
+		nm_connection_add_setting (connection, s_tc);
+
+	/* For backwards compatibility, if IPv4 is disabled or the
+	 * config fails for some reason, we read DOMAIN and put the
+	 * values into IPv6 config instead of IPv4.
+	 */
+	check_dns_search_domains (main_ifcfg, s_ip4, s_ip6);
+
+	s_proxy = make_proxy_setting (main_ifcfg);
+	if (s_proxy)
+		nm_connection_add_setting (connection, s_proxy);
+
+	s_user = make_user_setting (main_ifcfg);
+	if (s_user)
+		nm_connection_add_setting (connection, s_user);
+
+	s_match = make_match_setting (main_ifcfg);
+	if (s_match)
+		nm_connection_add_setting (connection, s_match);
+
+	s_port = make_bridge_port_setting (main_ifcfg);
+	if (s_port)
+		nm_connection_add_setting (connection, s_port);
+
+	s_port = make_team_port_setting (main_ifcfg);
+	if (s_port)
+		nm_connection_add_setting (connection, s_port);
+
+	if (!make_dcb_setting (main_ifcfg, &s_dcb, error))
+		return NULL;
+	if (s_dcb)
+		nm_connection_add_setting (connection, s_dcb);
+
+	if (!nm_connection_normalize (connection, NULL, NULL, error))
+		return NULL;
+
+	return g_steal_pointer (&connection);
+}
+
+NMConnection *
+connection_from_file (const char *filename,
+                      char **out_unhandled,
+                      GError **error,
+                      gboolean *out_ignore_error)
+{
+	return connection_from_file_full (filename, NULL, NULL,
+	                                  out_unhandled,
+	                                  error,
+	                                  out_ignore_error);
+}
+
+NMConnection *
+nmtst_connection_from_file (const char *filename,
+                            const char *network_file,
+                            const char *test_type,
+                            char **out_unhandled,
+                            GError **error)
+{
+	return connection_from_file_full (filename,
+	                                  network_file,
+	                                  test_type,
+	                                  out_unhandled,
+	                                  error,
+	                                  NULL);
+}
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.h b/src/settings/plugins/netplan/nms-netplan-reader.h
new file mode 100644
index 0000000000000000000000000000000000000000..72e6b5144d0244323fe50d255f1fa7d64c671ccc
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-reader.h
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ */
+
+#ifndef __NMS_IFCFG_RH_READER_H__
+#define __NMS_IFCFG_RH_READER_H__
+
+#include "nm-connection.h"
+
+NMConnection *connection_from_file (const char *filename,
+                                    char **out_unhandled,
+                                    GError **error,
+                                    gboolean *out_ignore_error);
+
+NMConnection *nmtst_connection_from_file (const char *filename,
+                                          const char *network_file,
+                                          const char *test_type,
+                                          char **out_unhandled,
+                                          GError **error);
+
+#endif  /* __NMS_IFCFG_RH_READER_H__ */
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.c b/src/settings/plugins/netplan/nms-netplan-utils.c
new file mode 100644
index 0000000000000000000000000000000000000000..f5dfdc7507398553604b0c86d2ac18530d28adc1
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-utils.c
@@ -0,0 +1,589 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * (C) Copyright 2008 - 2017 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nms-ifcfg-rh-utils.h"
+
+#include <stdlib.h>
+
+#include "nm-core-internal.h"
+#include "NetworkManagerUtils.h"
+
+#include "nms-ifcfg-rh-common.h"
+
+/*****************************************************************************/
+
+gboolean
+nms_ifcfg_rh_util_parse_unhandled_spec (const char *unhandled_spec,
+                                        const char **out_unmanaged_spec,
+                                        const char **out_unrecognized_spec)
+{
+	if (unhandled_spec) {
+		if (NM_STR_HAS_PREFIX (unhandled_spec, "unmanaged:")) {
+			NM_SET_OUT (out_unmanaged_spec, &unhandled_spec[NM_STRLEN ("unmanaged:")]);
+			NM_SET_OUT (out_unrecognized_spec, NULL);
+			return TRUE;
+		}
+		if (NM_STR_HAS_PREFIX (unhandled_spec, "unrecognized:")) {
+			NM_SET_OUT (out_unmanaged_spec, NULL);
+			NM_SET_OUT (out_unrecognized_spec, &unhandled_spec[NM_STRLEN ("unrecognized:")]);
+			return TRUE;
+		}
+	}
+	NM_SET_OUT (out_unmanaged_spec, NULL);
+	NM_SET_OUT (out_unrecognized_spec, NULL);
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+/*
+ * Check ';[a-fA-F0-9]{8}' file suffix used for temporary files by rpm when
+ * installing packages.
+ *
+ * Implementation taken from upstart.
+ */
+static gboolean
+check_rpm_temp_suffix (const char *path)
+{
+	const char *ptr;
+
+	g_return_val_if_fail (path != NULL, FALSE);
+
+	/* Matches *;[a-fA-F0-9]{8}; used by rpm */
+	ptr = strrchr (path, ';');
+	if (   ptr
+	    && strspn (ptr + 1, "abcdefABCDEF0123456789") == 8
+	    && !ptr[9])
+		return TRUE;
+	return FALSE;
+}
+
+static gboolean
+check_suffix (const char *base, const char *tag)
+{
+	int len, tag_len;
+
+	g_return_val_if_fail (base != NULL, TRUE);
+	g_return_val_if_fail (tag != NULL, TRUE);
+
+	len = strlen (base);
+	tag_len = strlen (tag);
+	if ((len > tag_len) && !strcasecmp (base + len - tag_len, tag))
+		return TRUE;
+	return FALSE;
+}
+
+gboolean
+utils_should_ignore_file (const char *filename, gboolean only_ifcfg)
+{
+	gs_free char *base = NULL;
+
+	g_return_val_if_fail (filename != NULL, TRUE);
+
+	base = g_path_get_basename (filename);
+
+	/* Only handle ifcfg, keys, and routes files */
+	if (strncmp (base, IFCFG_TAG, strlen (IFCFG_TAG)) != 0) {
+		if (only_ifcfg)
+			return TRUE;
+		else if (   strncmp (base, KEYS_TAG, strlen (KEYS_TAG)) != 0
+		         && strncmp (base, ROUTE_TAG, strlen (ROUTE_TAG)) != 0
+		         && strncmp (base, ROUTE6_TAG, strlen (ROUTE6_TAG)) != 0)
+			return TRUE;
+	}
+
+	/* But not those that have certain suffixes */
+	if (   check_suffix (base, BAK_TAG)
+	    || check_suffix (base, TILDE_TAG)
+	    || check_suffix (base, ORIG_TAG)
+	    || check_suffix (base, REJ_TAG)
+	    || check_suffix (base, RPMNEW_TAG)
+	    || check_suffix (base, AUGNEW_TAG)
+	    || check_suffix (base, AUGTMP_TAG)
+	    || check_rpm_temp_suffix (base))
+		return TRUE;
+
+	return FALSE;
+}
+
+char *
+utils_cert_path (const char *parent, const char *suffix, const char *extension)
+{
+	gs_free char *dir = NULL;
+	const char *name;
+
+	g_return_val_if_fail (parent, NULL);
+	g_return_val_if_fail (suffix, NULL);
+	g_return_val_if_fail (extension, NULL);
+
+	name = utils_get_ifcfg_name (parent, FALSE);
+	g_return_val_if_fail (name, NULL);
+
+	dir = g_path_get_dirname (parent);
+	return g_strdup_printf ("%s/%s-%s.%s", dir, name, suffix, extension);
+}
+
+const char *
+utils_get_ifcfg_name (const char *file, gboolean only_ifcfg)
+{
+	const char *name;
+
+	g_return_val_if_fail (file != NULL, NULL);
+
+	name = strrchr (file, '/');
+	if (!name)
+		name = file;
+	else
+		name++;
+	if (!*name)
+		return NULL;
+
+#define MATCH_TAG_AND_RETURN(name, TAG) \
+	G_STMT_START { \
+		if (strncmp (name, TAG, NM_STRLEN (TAG)) == 0) { \
+			name += NM_STRLEN (TAG); \
+			if (name[0] == '\0') \
+				return NULL; \
+			else \
+				return name; \
+		} \
+	} G_STMT_END
+
+	/* Do not detect alias files and return 'eth0:0' instead of 'eth0'.
+	 * Unfortunately, we cannot be sure that our files don't contain colons,
+	 * so we cannot reject files with colons.
+	 *
+	 * Instead, you must not call utils_get_ifcfg_name() with an alias file
+	 * or files that are ignored. */
+	MATCH_TAG_AND_RETURN (name, IFCFG_TAG);
+	if (!only_ifcfg) {
+		MATCH_TAG_AND_RETURN (name, KEYS_TAG);
+		MATCH_TAG_AND_RETURN (name, ROUTE_TAG);
+		MATCH_TAG_AND_RETURN (name, ROUTE6_TAG);
+	}
+
+	return NULL;
+}
+
+/* Used to get any ifcfg/extra file path from any other ifcfg/extra path
+ * in the form <tag><name>.
+ */
+static char *
+utils_get_extra_path (const char *parent, const char *tag)
+{
+	char *item_path = NULL, *dirname;
+	const char *name;
+
+	g_return_val_if_fail (parent != NULL, NULL);
+	g_return_val_if_fail (tag != NULL, NULL);
+
+	dirname = g_path_get_dirname (parent);
+	if (!dirname)
+		g_return_val_if_reached (NULL);
+
+	name = utils_get_ifcfg_name (parent, FALSE);
+	if (name) {
+		if (!strcmp (dirname, "."))
+			item_path = g_strdup_printf ("%s%s", tag, name);
+		else
+			item_path = g_strdup_printf ("%s/%s%s", dirname, tag, name);
+	}
+	g_free (dirname);
+
+	return item_path;
+}
+
+char *
+utils_get_ifcfg_path (const char *parent)
+{
+	return utils_get_extra_path (parent, IFCFG_TAG);
+}
+
+char *
+utils_get_keys_path (const char *parent)
+{
+	return utils_get_extra_path (parent, KEYS_TAG);
+}
+
+char *
+utils_get_route_path (const char *parent)
+{
+	return utils_get_extra_path (parent, ROUTE_TAG);
+}
+
+char *
+utils_get_route6_path (const char *parent)
+{
+	return utils_get_extra_path (parent, ROUTE6_TAG);
+}
+
+shvarFile *
+utils_get_extra_ifcfg (const char *parent, const char *tag, gboolean should_create)
+{
+	shvarFile *ifcfg = NULL;
+	char *path;
+
+	path = utils_get_extra_path (parent, tag);
+	if (!path)
+		return NULL;
+
+	if (should_create && !g_file_test (path, G_FILE_TEST_EXISTS))
+		ifcfg = svCreateFile (path);
+
+	if (!ifcfg)
+		ifcfg = svOpenFile (path, NULL);
+
+	g_free (path);
+	return ifcfg;
+}
+
+shvarFile *
+utils_get_keys_ifcfg (const char *parent, gboolean should_create)
+{
+	return utils_get_extra_ifcfg (parent, KEYS_TAG, should_create);
+}
+
+shvarFile *
+utils_get_route_ifcfg (const char *parent, gboolean should_create)
+{
+	return utils_get_extra_ifcfg (parent, ROUTE_TAG, should_create);
+}
+
+/* Finds out if route file has new or older format
+ * Returns TRUE  - new syntax (ADDRESS<n>=a.b.c.d ...), error opening file or empty
+ *         FALSE - older syntax, i.e. argument to 'ip route add' (1.2.3.0/24 via 11.22.33.44)
+ */
+gboolean
+utils_has_route_file_new_syntax (const char *filename)
+{
+	char *contents = NULL;
+	gsize len = 0;
+	gboolean ret = FALSE;
+	const char *pattern = "^[[:space:]]*ADDRESS[0-9]+=";
+
+	g_return_val_if_fail (filename != NULL, TRUE);
+
+	if (!g_file_get_contents (filename, &contents, &len, NULL))
+		return TRUE;
+
+	if (len <= 0) {
+		ret = TRUE;
+		goto gone;
+	}
+
+	if (g_regex_match_simple (pattern, contents, G_REGEX_MULTILINE, 0))
+		ret = TRUE;
+
+gone:
+	g_free (contents);
+	return ret;
+}
+
+gboolean
+utils_has_complex_routes (const char *filename, int addr_family)
+{
+	g_return_val_if_fail (filename, TRUE);
+
+	if (NM_IN_SET (addr_family, AF_UNSPEC, AF_INET)) {
+		gs_free char *rules = utils_get_extra_path (filename, RULE_TAG);
+
+		if (g_file_test (rules, G_FILE_TEST_EXISTS))
+			return TRUE;
+	}
+
+	if (NM_IN_SET (addr_family, AF_UNSPEC, AF_INET6)) {
+		gs_free char *rules = utils_get_extra_path (filename, RULE6_TAG);
+		if (g_file_test (rules, G_FILE_TEST_EXISTS))
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+/* Find out if the 'alias' file name might be an alias file for 'ifcfg' file name,
+ * or any alias when 'ifcfg' is NULL. Does not check that it's actually a valid
+ * alias name; that happens in reader.c
+ */
+gboolean
+utils_is_ifcfg_alias_file (const char *alias, const char *ifcfg)
+{
+	g_return_val_if_fail (alias != NULL, FALSE);
+
+	if (strncmp (alias, IFCFG_TAG, strlen (IFCFG_TAG)))
+		return FALSE;
+
+	if (ifcfg) {
+		size_t len = strlen (ifcfg);
+
+		return (strncmp (alias, ifcfg, len) == 0 && alias[len] == ':');
+	} else {
+		return (strchr (alias, ':') != NULL);
+	}
+}
+
+char *
+utils_detect_ifcfg_path (const char *path, gboolean only_ifcfg)
+{
+	const char *base;
+
+	g_return_val_if_fail (path != NULL, NULL);
+
+	if (utils_should_ignore_file (path, only_ifcfg))
+		return NULL;
+
+	base = strrchr (path, '/');
+	if (!base)
+		base = path;
+	else
+		base += 1;
+
+	if (NM_STR_HAS_PREFIX (base, IFCFG_TAG)) {
+		if (base[NM_STRLEN (IFCFG_TAG)] == '\0')
+			return NULL;
+		if (utils_is_ifcfg_alias_file (base, NULL)) {
+			gs_free char *ifcfg = NULL;
+			char *ptr;
+
+			ifcfg = g_strdup (path);
+			ptr = strrchr (ifcfg, ':');
+			if (   ptr
+			    && ptr > ifcfg
+			    && !strchr (ptr, '/')) {
+				*ptr = '\0';
+				if (g_file_test (ifcfg, G_FILE_TEST_EXISTS)) {
+					/* the file has a colon, so it is probably an alias.
+					 * To be ~more~ certain that this is an alias file,
+					 * check whether a corresponding base file exists. */
+					if (only_ifcfg)
+						return NULL;
+					return g_steal_pointer (&ifcfg);
+				}
+			}
+		}
+		return g_strdup (path);
+	}
+
+	if (only_ifcfg)
+		return NULL;
+	return utils_get_ifcfg_path (path);
+}
+
+void
+nms_ifcfg_rh_utils_user_key_encode (const char *key, GString *str_buffer)
+{
+	gsize i;
+
+	nm_assert (key);
+	nm_assert (str_buffer);
+
+	for (i = 0; key[i]; i++) {
+		char ch = key[i];
+
+		/* we encode the key in only upper case letters, digits, and underscore.
+		 * As we expect lower-case letters to be more common, we encode lower-case
+		 * letters as upper case, and upper-case letters with a leading underscore. */
+
+		if (ch >= '0' && ch <= '9') {
+			g_string_append_c (str_buffer, ch);
+			continue;
+		}
+		if (ch >= 'a' && ch <= 'z') {
+			g_string_append_c (str_buffer, ch - 'a' + 'A');
+			continue;
+		}
+		if (ch == '.') {
+			g_string_append (str_buffer, "__");
+			continue;
+		}
+		if (ch >= 'A' && ch <= 'Z') {
+			g_string_append_c (str_buffer, '_');
+			g_string_append_c (str_buffer, ch);
+			continue;
+		}
+		g_string_append_printf (str_buffer, "_%03o", (unsigned) ch);
+	}
+}
+
+gboolean
+nms_ifcfg_rh_utils_user_key_decode (const char *name, GString *str_buffer)
+{
+	gsize i;
+
+	nm_assert (name);
+	nm_assert (str_buffer);
+
+	if (!name[0])
+		return FALSE;
+
+	for (i = 0; name[i]; ) {
+		char ch = name[i];
+
+		if (ch >= '0' && ch <= '9') {
+			g_string_append_c (str_buffer, ch);
+			i++;
+			continue;
+		}
+		if (ch >= 'A' && ch <= 'Z') {
+			g_string_append_c (str_buffer, ch - 'A' + 'a');
+			i++;
+			continue;
+		}
+
+		if (ch == '_') {
+			ch = name[i + 1];
+			if (ch == '_') {
+				g_string_append_c (str_buffer, '.');
+				i += 2;
+				continue;
+			}
+			if (ch >= 'A' && ch <= 'Z') {
+				g_string_append_c (str_buffer, ch);
+				i += 2;
+				continue;
+			}
+			if (ch >= '0' && ch <= '7') {
+				char ch2, ch3;
+				unsigned v;
+
+				ch2 = name[i + 2];
+				if (!(ch2 >= '0' && ch2 <= '7'))
+					return FALSE;
+
+				ch3 = name[i + 3];
+				if (!(ch3 >= '0' && ch3 <= '7'))
+					return FALSE;
+
+#define OCTAL_VALUE(ch) ((unsigned) ((ch) - '0'))
+				v = (OCTAL_VALUE (ch)  << 6) +
+				    (OCTAL_VALUE (ch2) << 3) +
+				     OCTAL_VALUE (ch3);
+				if (   v > 0xFF
+				    || v == 0)
+					return FALSE;
+				ch = (char) v;
+				if (   (ch >= 'A' && ch <= 'Z')
+				    || (ch >= '0' && ch <= '9')
+				    || (ch == '.')
+				    || (ch >= 'a' && ch <= 'z')) {
+					/* such characters are not expected to be encoded via
+					 * octal representation. The encoding is invalid. */
+					return FALSE;
+				}
+				g_string_append_c (str_buffer, ch);
+				i += 4;
+				continue;
+			}
+			return FALSE;
+		}
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*****************************************************************************/
+
+const char *const _nm_ethtool_ifcfg_names[] = {
+#define ETHT_NAME(eid, ename) \
+[eid - _NM_ETHTOOL_ID_FEATURE_FIRST] = ""ename""
+	/* indexed by NMEthtoolID - _NM_ETHTOOL_ID_FEATURE_FIRST */
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_ESP_HW_OFFLOAD,               "esp-hw-offload"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_ESP_TX_CSUM_HW_OFFLOAD,       "esp-tx-csum-hw-offload"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_FCOE_MTU,                     "fcoe-mtu"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_GRO,                          "gro"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_GSO,                          "gso"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_HIGHDMA,                      "highdma"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_HW_TC_OFFLOAD,                "hw-tc-offload"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_L2_FWD_OFFLOAD,               "l2-fwd-offload"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_LOOPBACK,                     "loopback"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_LRO,                          "lro"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_NTUPLE,                       "ntuple"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX,                           "rx"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RXHASH,                       "rxhash"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RXVLAN,                       "rxvlan"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_ALL,                       "rx-all"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_FCS,                       "rx-fcs"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_GRO_HW,                    "rx-gro-hw"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_UDP_TUNNEL_PORT_OFFLOAD,   "rx-udp_tunnel-port-offload"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_VLAN_FILTER,               "rx-vlan-filter"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_VLAN_STAG_FILTER,          "rx-vlan-stag-filter"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_RX_VLAN_STAG_HW_PARSE,        "rx-vlan-stag-hw-parse"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_SG,                           "sg"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TLS_HW_RECORD,                "tls-hw-record"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TLS_HW_TX_OFFLOAD,            "tls-hw-tx-offload"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TSO,                          "tso"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX,                           "tx"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TXVLAN,                       "txvlan"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_CHECKSUM_FCOE_CRC,         "tx-checksum-fcoe-crc"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_CHECKSUM_IPV4,             "tx-checksum-ipv4"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_CHECKSUM_IPV6,             "tx-checksum-ipv6"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_CHECKSUM_IP_GENERIC,       "tx-checksum-ip-generic"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_CHECKSUM_SCTP,             "tx-checksum-sctp"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_ESP_SEGMENTATION,          "tx-esp-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_FCOE_SEGMENTATION,         "tx-fcoe-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_GRE_CSUM_SEGMENTATION,     "tx-gre-csum-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_GRE_SEGMENTATION,          "tx-gre-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_GSO_PARTIAL,               "tx-gso-partial"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_GSO_ROBUST,                "tx-gso-robust"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_IPXIP4_SEGMENTATION,       "tx-ipxip4-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_IPXIP6_SEGMENTATION,       "tx-ipxip6-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_NOCACHE_COPY,              "tx-nocache-copy"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_SCATTER_GATHER,            "tx-scatter-gather"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_SCATTER_GATHER_FRAGLIST,   "tx-scatter-gather-fraglist"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_SCTP_SEGMENTATION,         "tx-sctp-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_TCP6_SEGMENTATION,         "tx-tcp6-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_TCP_ECN_SEGMENTATION,      "tx-tcp-ecn-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_TCP_MANGLEID_SEGMENTATION, "tx-tcp-mangleid-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_TCP_SEGMENTATION,          "tx-tcp-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_UDP_SEGMENTATION,          "tx-udp-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_UDP_TNL_CSUM_SEGMENTATION, "tx-udp_tnl-csum-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_UDP_TNL_SEGMENTATION,      "tx-udp_tnl-segmentation"),
+	ETHT_NAME (NM_ETHTOOL_ID_FEATURE_TX_VLAN_STAG_HW_INSERT,       "tx-vlan-stag-hw-insert"),
+};
+
+const NMEthtoolData *
+nms_ifcfg_rh_utils_get_ethtool_by_name (const char *name)
+{
+	static const struct {
+		NMEthtoolID ethtool_id;
+		const char *kernel_name;
+	} kernel_names[] = {
+		{ NM_ETHTOOL_ID_FEATURE_GRO,    "rx-gro" },
+		{ NM_ETHTOOL_ID_FEATURE_GSO,    "tx-generic-segmentation" },
+		{ NM_ETHTOOL_ID_FEATURE_LRO,    "rx-lro" },
+		{ NM_ETHTOOL_ID_FEATURE_NTUPLE, "rx-ntuple-filter" },
+		{ NM_ETHTOOL_ID_FEATURE_RX,     "rx-checksum" },
+		{ NM_ETHTOOL_ID_FEATURE_RXHASH, "rx-hashing" },
+		{ NM_ETHTOOL_ID_FEATURE_RXVLAN, "rx-vlan-hw-parse" },
+		{ NM_ETHTOOL_ID_FEATURE_TXVLAN, "tx-vlan-hw-insert" },
+	};
+	guint i;
+
+	for (i = 0; i < G_N_ELEMENTS (_nm_ethtool_ifcfg_names); i++) {
+		if (nm_streq (name, _nm_ethtool_ifcfg_names[i]))
+			return nm_ethtool_data[i];
+	}
+
+	/* Option not found. Note that ethtool utility has built-in features and
+	 * NetworkManager's API follows the naming of these built-in features, whenever
+	 * they exist.
+	 * For example, NM's "ethtool.feature-ntuple" corresponds to ethtool utility's "ntuple"
+	 * feature. However the underlying kernel feature is called "rx-ntuple-filter" (as reported
+	 * for ETH_SS_FEATURES).
+	 *
+	 * With ethtool utility, whose command line we attempt to parse here, the user can also
+	 * specify the name of the underlying kernel feature directly. So, check whether that is
+	 * the case and if yes, map them to the corresponding NetworkManager's features. */
+	for (i = 0; i < G_N_ELEMENTS (kernel_names); i++) {
+		if (nm_streq (name, kernel_names[i].kernel_name))
+			return nm_ethtool_data[kernel_names[i].ethtool_id];
+	}
+
+	return NULL;
+}
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.h b/src/settings/plugins/netplan/nms-netplan-utils.h
new file mode 100644
index 0000000000000000000000000000000000000000..e0308178cf8ebc123d7a80672ac9fdb42c986685
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-utils.h
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * (C) Copyright 2008 - 2017 Red Hat, Inc.
+ */
+
+#ifndef _UTILS_H_
+#define _UTILS_H_
+
+#include "nm-connection.h"
+#include "nm-libnm-core-intern/nm-ethtool-utils.h"
+
+#include "shvar.h"
+
+gboolean nms_ifcfg_rh_util_parse_unhandled_spec (const char *unhandled_spec,
+                                                 const char **out_unmanaged_spec,
+                                                 const char **out_unrecognized_spec);
+
+#define NM_IFCFG_CONNECTION_LOG_PATH(path)  ((path) ?: "in-memory")
+#define NM_IFCFG_CONNECTION_LOG_FMT         "%s (%s,\"%s\")"
+#define NM_IFCFG_CONNECTION_LOG_ARG(con)    NM_IFCFG_CONNECTION_LOG_PATH (nm_settings_connection_get_filename ((NMSettingsConnection *) (con))), nm_settings_connection_get_uuid ((NMSettingsConnection *) (con)), nm_settings_connection_get_id ((NMSettingsConnection *) (con))
+#define NM_IFCFG_CONNECTION_LOG_FMTD        "%s (%s,\"%s\",%p)"
+#define NM_IFCFG_CONNECTION_LOG_ARGD(con)   NM_IFCFG_CONNECTION_LOG_PATH (nm_settings_connection_get_filename ((NMSettingsConnection *) (con))), nm_settings_connection_get_uuid ((NMSettingsConnection *) (con)), nm_settings_connection_get_id ((NMSettingsConnection *) (con)), (con)
+
+char *utils_cert_path (const char *parent, const char *suffix, const char *extension);
+
+const char *utils_get_ifcfg_name (const char *file, gboolean only_ifcfg);
+
+gboolean utils_should_ignore_file (const char *filename, gboolean only_ifcfg);
+
+char *utils_get_ifcfg_path (const char *parent);
+char *utils_get_keys_path (const char *parent);
+char *utils_get_route_path (const char *parent);
+char *utils_get_route6_path (const char *parent);
+
+shvarFile *utils_get_extra_ifcfg (const char *parent, const char *tag, gboolean should_create);
+shvarFile *utils_get_keys_ifcfg (const char *parent, gboolean should_create);
+shvarFile *utils_get_route_ifcfg (const char *parent, gboolean should_create);
+
+gboolean utils_has_route_file_new_syntax (const char *filename);
+gboolean utils_has_complex_routes (const char *filename, int addr_family);
+
+gboolean utils_is_ifcfg_alias_file (const char *alias, const char *ifcfg);
+
+char *utils_detect_ifcfg_path (const char *path, gboolean only_ifcfg);
+
+void nms_ifcfg_rh_utils_user_key_encode (const char *key, GString *str_buffer);
+gboolean nms_ifcfg_rh_utils_user_key_decode (const char *name, GString *str_buffer);
+
+static inline const char *
+_nms_ifcfg_rh_utils_numbered_tag (char *buf, gsize buf_len, const char *tag_name, int which)
+{
+	gsize l;
+
+	l = g_strlcpy (buf, tag_name, buf_len);
+	nm_assert (l < buf_len);
+	if (which != -1) {
+		buf_len -= l;
+		l = g_snprintf (&buf[l], buf_len, "%d", which);
+		nm_assert (l < buf_len);
+	}
+	return buf;
+}
+#define numbered_tag(buf, tag_name, which) \
+	({ \
+		_nm_unused char *const _buf = (buf); \
+		\
+		/* some static assert trying to ensure that the buffer is statically allocated.
+		 * It disallows a buffer size of sizeof(gpointer) to catch that. */ \
+		G_STATIC_ASSERT (G_N_ELEMENTS (buf) == sizeof (buf) && sizeof (buf) != sizeof (char *) && sizeof (buf) < G_MAXINT); \
+		_nms_ifcfg_rh_utils_numbered_tag (buf, sizeof (buf), ""tag_name"", (which)); \
+	})
+
+/*****************************************************************************/
+
+extern const char *const _nm_ethtool_ifcfg_names[_NM_ETHTOOL_ID_FEATURE_NUM];
+
+static inline const char *
+nms_ifcfg_rh_utils_get_ethtool_name (NMEthtoolID ethtool_id)
+{
+	nm_assert (ethtool_id >= _NM_ETHTOOL_ID_FEATURE_FIRST && ethtool_id <= _NM_ETHTOOL_ID_FEATURE_LAST);
+	nm_assert ((ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST) < G_N_ELEMENTS (_nm_ethtool_ifcfg_names));
+	nm_assert (_nm_ethtool_ifcfg_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST]);
+
+	return _nm_ethtool_ifcfg_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST];
+}
+
+const NMEthtoolData *nms_ifcfg_rh_utils_get_ethtool_by_name (const char *name);
+
+#endif  /* _UTILS_H_ */
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
new file mode 100644
index 0000000000000000000000000000000000000000..7dc054fb823e21fa0aa7396c0910bc0e208cb62a
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -0,0 +1,3464 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service - keyfile plugin
+ *
+ * Copyright 2009 - 2015 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nms-ifcfg-rh-writer.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+
+#include "nm-glib-aux/nm-enum-utils.h"
+#include "nm-glib-aux/nm-io-utils.h"
+#include "nm-manager.h"
+#include "nm-setting-connection.h"
+#include "nm-setting-wired.h"
+#include "nm-setting-wireless.h"
+#include "nm-setting-ethtool.h"
+#include "nm-setting-8021x.h"
+#include "nm-setting-proxy.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-ip6-config.h"
+#include "nm-setting-pppoe.h"
+#include "nm-setting-vlan.h"
+#include "nm-setting-user.h"
+#include "nm-setting-team.h"
+#include "nm-setting-team-port.h"
+#include "nm-utils.h"
+#include "nm-core-internal.h"
+#include "NetworkManagerUtils.h"
+#include "nm-meta-setting.h"
+#include "nm-libnm-core-intern/nm-ethtool-utils.h"
+
+#include "nms-ifcfg-rh-common.h"
+#include "nms-ifcfg-rh-reader.h"
+#include "nms-ifcfg-rh-utils.h"
+#include "shvar.h"
+
+/*****************************************************************************/
+
+#define _NMLOG_DOMAIN      LOGD_SETTINGS
+#define _NMLOG_PREFIX_NAME "ifcfg-rh"
+#define _NMLOG(level, ...) \
+    G_STMT_START { \
+        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
+                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
+                _NMLOG_PREFIX_NAME": " \
+                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
+    } G_STMT_END
+
+/*****************************************************************************/
+
+static void
+save_secret_flags (shvarFile *ifcfg,
+                   const char *key,
+                   NMSettingSecretFlags flags)
+{
+	GString *str;
+
+	g_return_if_fail (ifcfg != NULL);
+	g_return_if_fail (key != NULL);
+
+	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
+		svUnsetValue (ifcfg, key);
+		return;
+	}
+
+	/* Convert flags bitfield into string representation */
+	str = g_string_sized_new (20);
+	if (flags & NM_SETTING_SECRET_FLAG_AGENT_OWNED)
+		g_string_append (str, SECRET_FLAG_AGENT);
+
+	if (flags & NM_SETTING_SECRET_FLAG_NOT_SAVED) {
+		if (str->len)
+			g_string_append_c (str, ' ');
+		g_string_append (str, SECRET_FLAG_NOT_SAVED);
+	}
+
+	if (flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED) {
+		if (str->len)
+			g_string_append_c (str, ' ');
+		g_string_append (str, SECRET_FLAG_NOT_REQUIRED);
+	}
+
+	svSetValueStr (ifcfg, key, str->len ? str->str : NULL);
+	g_string_free (str, TRUE);
+}
+
+static void
+set_secret (shvarFile *ifcfg,
+            GHashTable *secrets,
+            const char *key,
+            const char *value,
+            const char *flags_key,
+            NMSettingSecretFlags flags)
+{
+	/* Clear the secret from the ifcfg and the associated "keys" file */
+	svUnsetValue (ifcfg, key);
+
+	/* Save secret flags */
+	save_secret_flags (ifcfg, flags_key, flags);
+
+	/* Only write the secret if it's system owned and supposed to be saved */
+	if (flags != NM_SETTING_SECRET_FLAG_NONE)
+		value = NULL;
+
+	g_hash_table_replace (secrets, g_strdup (key), g_strdup (value));
+}
+
+static gboolean
+write_secrets (shvarFile *ifcfg,
+               GHashTable *secrets,
+               GError **error)
+{
+	nm_auto_shvar_file_close shvarFile *keyfile = NULL;
+	gs_free const char **secrets_keys = NULL;
+	guint i, secrets_keys_n;
+	GError *local = NULL;
+	gboolean any_secrets = FALSE;
+
+	keyfile = utils_get_keys_ifcfg (svFileGetName (ifcfg), TRUE);
+	if (!keyfile) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Failure to create secrets file for '%s'", svFileGetName (ifcfg));
+		return FALSE;
+	}
+
+	/* we purge all existing secrets. */
+	svUnsetAll (keyfile, SV_KEY_TYPE_ANY);
+
+	secrets_keys = nm_utils_strdict_get_keys (secrets, TRUE, &secrets_keys_n);
+	for (i = 0; i < secrets_keys_n; i++) {
+		const char *k = secrets_keys[i];
+		const char *v = g_hash_table_lookup (secrets, k);
+
+		if (v) {
+			svSetValueStr (keyfile, k, v);
+			any_secrets = TRUE;
+		}
+	}
+
+	if (!any_secrets)
+		(void) unlink (svFileGetName (keyfile));
+	else if (!svWriteFile (keyfile, 0600, &local)) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Failure to write secrets to '%s': %s", svFileGetName (keyfile), local->message);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+typedef struct {
+	const NMSetting8021xSchemeVtable *vtable;
+	const char *ifcfg_rh_key;
+} Setting8021xSchemeVtable;
+
+static const Setting8021xSchemeVtable setting_8021x_scheme_vtable[] = {
+#define _D(_scheme_type, _ifcfg_rh_key) \
+	[(_scheme_type)] = { \
+		.vtable       = &nm_setting_8021x_scheme_vtable[(_scheme_type)], \
+		.ifcfg_rh_key = ""_ifcfg_rh_key"", \
+	}
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT,            "IEEE_8021X_CA_CERT"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT,     "IEEE_8021X_INNER_CA_CERT"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT,        "IEEE_8021X_CLIENT_CERT"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT, "IEEE_8021X_INNER_CLIENT_CERT"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY,        "IEEE_8021X_PRIVATE_KEY"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_PRIVATE_KEY, "IEEE_8021X_INNER_PRIVATE_KEY"),
+#undef _D
+};
+
+static gboolean
+write_object (NMSetting8021x *s_8021x,
+              shvarFile *ifcfg,
+              GHashTable *secrets,
+              GHashTable *blobs,
+              const Setting8021xSchemeVtable *objtype,
+              gboolean force_write,
+              GError **error)
+{
+	NMSetting8021xCKScheme scheme;
+	const char *value = NULL;
+	GBytes *blob = NULL;
+	const char *password = NULL;
+	NMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;
+	char secret_name[100];
+	char secret_flags[sizeof (secret_name) + NM_STRLEN ("_FLAGS")];
+	const char *extension;
+	char *standard_file;
+
+	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (objtype != NULL, FALSE);
+
+	scheme = (*(objtype->vtable->scheme_func))(s_8021x);
+	switch (scheme) {
+	case NM_SETTING_802_1X_CK_SCHEME_UNKNOWN:
+		break;
+	case NM_SETTING_802_1X_CK_SCHEME_BLOB:
+		blob = (*(objtype->vtable->blob_func))(s_8021x);
+		break;
+	case NM_SETTING_802_1X_CK_SCHEME_PATH:
+		value = (*(objtype->vtable->path_func))(s_8021x);
+		break;
+	case NM_SETTING_802_1X_CK_SCHEME_PKCS11:
+		value = (*(objtype->vtable->uri_func))(s_8021x);
+		break;
+	default:
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Unhandled certificate object scheme");
+		return FALSE;
+	}
+
+	/* Set the password for certificate/private key. */
+	nm_sprintf_buf (secret_name, "%s_PASSWORD", objtype->ifcfg_rh_key);
+	nm_sprintf_buf (secret_flags, "%s_PASSWORD_FLAGS", objtype->ifcfg_rh_key);
+	password = (*(objtype->vtable->passwd_func))(s_8021x);
+	flags = (*(objtype->vtable->pwflag_func))(s_8021x);
+	set_secret (ifcfg, secrets, secret_name, password, secret_flags, flags);
+
+	if (!objtype->vtable->format_func)
+		extension = "der";
+	else if (objtype->vtable->format_func (s_8021x) == NM_SETTING_802_1X_CK_FORMAT_PKCS12)
+		extension = "p12";
+	else
+		extension = "pem";
+
+	/* If the object path was specified, prefer that over any raw cert data that
+	 * may have been sent.
+	 */
+	if (value) {
+		svSetValueStr (ifcfg, objtype->ifcfg_rh_key, value);
+		return TRUE;
+	}
+
+	/* If it's raw certificate data, write the data out to the standard file */
+	if (blob) {
+		char *new_file;
+
+		new_file = utils_cert_path (svFileGetName (ifcfg), objtype->vtable->file_suffix, extension);
+		g_hash_table_replace (blobs, new_file, g_bytes_ref (blob));
+		svSetValueStr (ifcfg, objtype->ifcfg_rh_key, new_file);
+		return TRUE;
+	}
+
+	/* If certificate/private key wasn't sent, the connection may no longer be
+	 * 802.1x and thus we clear out the paths and certs.
+	 *
+	 * Since no cert/private key is now being used, delete any standard file
+	 * that was created for this connection, but leave other files alone.
+	 * Thus, for example,
+	 * /etc/sysconfig/network-scripts/ca-cert-Test_Write_Wifi_WPA_EAP-TLS.der
+	 * will be deleted, but /etc/pki/tls/cert.pem will not.
+	 */
+	standard_file = utils_cert_path (svFileGetName (ifcfg), objtype->vtable->file_suffix, extension);
+	g_hash_table_replace (blobs, standard_file, NULL);
+	svSetValue (ifcfg, objtype->ifcfg_rh_key, force_write ? "" : NULL);
+	return TRUE;
+}
+
+static gboolean
+write_blobs (GHashTable *blobs, GError **error)
+{
+	GHashTableIter iter;
+	const char *filename;
+	GBytes *blob;
+
+	if (!blobs)
+		return TRUE;
+
+	g_hash_table_iter_init (&iter, blobs);
+	while (g_hash_table_iter_next (&iter, (gpointer *) &filename, (gpointer *) &blob)) {
+		GError *write_error = NULL;
+
+		if (!blob) {
+			(void) unlink (filename);
+			continue;
+		}
+
+		/* Write the raw certificate data out to the standard file so that we
+		 * can use paths from now on instead of pushing around the certificate
+		 * data itself.
+		 */
+		if (!nm_utils_file_set_contents (filename,
+		                                 (const char *) g_bytes_get_data (blob, NULL),
+		                                 g_bytes_get_size (blob),
+		                                 0600,
+		                                 NULL,
+		                                 &write_error)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Could not write certificate to file \"%s\": %s",
+			             filename,
+			             write_error->message);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+write_8021x_certs (NMSetting8021x *s_8021x,
+                   GHashTable *secrets,
+                   GHashTable *blobs,
+                   gboolean phase2,
+                   shvarFile *ifcfg,
+                   GError **error)
+{
+	const Setting8021xSchemeVtable *pk_otype = NULL;
+	gs_free char *value_to_free = NULL;
+
+	/* CA certificate */
+	if (!write_object (s_8021x, ifcfg, secrets, blobs,
+	                   phase2
+	                       ? &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT]
+	                       : &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT],
+	                   FALSE,
+	                   error))
+		return FALSE;
+
+	/* Private key */
+	if (phase2)
+		pk_otype = &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_PRIVATE_KEY];
+	else
+		pk_otype = &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY];
+
+	/* Save the private key */
+	if (!write_object (s_8021x, ifcfg, secrets, blobs, pk_otype, FALSE, error))
+		return FALSE;
+
+	/* Save the client certificate.
+	 * If there is a private key, always write a property for the
+	 * client certificate even if it is empty, so that the reader
+	 * doesn't have to read the private key file to determine if it
+	 * is a PKCS #12 one which serves also as client certificate.
+	 */
+	if (!write_object (s_8021x, ifcfg, secrets, blobs,
+	                   phase2
+	                       ? &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT]
+	                       : &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT],
+	                   !!svGetValue (ifcfg, pk_otype->ifcfg_rh_key, &value_to_free),
+	                   error))
+		return FALSE;
+
+	return TRUE;
+}
+
+static gboolean
+write_8021x_setting (NMConnection *connection,
+                     shvarFile *ifcfg,
+                     GHashTable *secrets,
+                     GHashTable *blobs,
+                     gboolean wired,
+                     GError **error)
+{
+	NMSetting8021x *s_8021x;
+	NMSetting8021xAuthFlags auth_flags;
+	const char *value, *match;
+	gconstpointer ptr;
+	GBytes* bytes;
+	char *tmp = NULL;
+	GString *phase2_auth;
+	GString *str;
+	guint32 i, num;
+	gsize size;
+	int vint;
+
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	if (!s_8021x) {
+		/* If wired, clear KEY_MGMT */
+		if (wired)
+			svUnsetValue (ifcfg, "KEY_MGMT");
+		return TRUE;
+	}
+
+	/* If wired, write KEY_MGMT */
+	if (wired)
+		svSetValueStr (ifcfg, "KEY_MGMT", "IEEE8021X");
+
+	/* EAP method */
+	if (nm_setting_802_1x_get_num_eap_methods (s_8021x)) {
+		value = nm_setting_802_1x_get_eap_method (s_8021x, 0);
+		if (value)
+			tmp = g_ascii_strup (value, -1);
+	}
+	svSetValueStr (ifcfg, "IEEE_8021X_EAP_METHODS", tmp);
+	g_free (tmp);
+
+	svSetValueStr (ifcfg, "IEEE_8021X_IDENTITY",
+	               nm_setting_802_1x_get_identity (s_8021x));
+
+	svSetValueStr (ifcfg, "IEEE_8021X_ANON_IDENTITY",
+	               nm_setting_802_1x_get_anonymous_identity (s_8021x));
+
+	set_secret (ifcfg,
+	            secrets,
+	            "IEEE_8021X_PASSWORD",
+	            nm_setting_802_1x_get_password (s_8021x),
+	            "IEEE_8021X_PASSWORD_FLAGS",
+	            nm_setting_802_1x_get_password_flags (s_8021x));
+
+	tmp = NULL;
+	bytes = nm_setting_802_1x_get_password_raw (s_8021x);
+	if (bytes) {
+		ptr = g_bytes_get_data (bytes, &size);
+		tmp = nm_utils_bin2hexstr (ptr, size, -1);
+	}
+	set_secret (ifcfg,
+	            secrets,
+	            "IEEE_8021X_PASSWORD_RAW",
+	            tmp,
+	            "IEEE_8021X_PASSWORD_RAW_FLAGS",
+	            nm_setting_802_1x_get_password_raw_flags (s_8021x));
+	g_free (tmp);
+
+	/* PEAP version */
+	value = nm_setting_802_1x_get_phase1_peapver (s_8021x);
+	svUnsetValue (ifcfg, "IEEE_8021X_PEAP_VERSION");
+	if (value && (!strcmp (value, "0") || !strcmp (value, "1")))
+		svSetValueStr (ifcfg, "IEEE_8021X_PEAP_VERSION", value);
+
+	/* Force new PEAP label */
+	value = nm_setting_802_1x_get_phase1_peaplabel (s_8021x);
+	svUnsetValue (ifcfg, "IEEE_8021X_PEAP_FORCE_NEW_LABEL");
+	if (value && !strcmp (value, "1"))
+		svSetValueStr (ifcfg, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", "yes");
+
+	/* PAC file */
+	value = nm_setting_802_1x_get_pac_file (s_8021x);
+	svUnsetValue (ifcfg, "IEEE_8021X_PAC_FILE");
+	if (value)
+		svSetValueStr (ifcfg, "IEEE_8021X_PAC_FILE", value);
+
+	/* FAST PAC provisioning */
+	value = nm_setting_802_1x_get_phase1_fast_provisioning (s_8021x);
+	svUnsetValue (ifcfg, "IEEE_8021X_FAST_PROVISIONING");
+	if (value) {
+		if (strcmp (value, "1") == 0)
+			svSetValueStr (ifcfg, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth");
+		else if (strcmp (value, "2") == 0)
+			svSetValueStr (ifcfg, "IEEE_8021X_FAST_PROVISIONING", "allow-auth");
+		else if (strcmp (value, "3") == 0)
+			svSetValueStr (ifcfg, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth allow-auth");
+	}
+
+	/* Phase2 auth methods */
+	svUnsetValue (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS");
+	phase2_auth = g_string_new (NULL);
+
+	value = nm_setting_802_1x_get_phase2_auth (s_8021x);
+	if (value) {
+		tmp = g_ascii_strup (value, -1);
+		g_string_append (phase2_auth, tmp);
+		g_free (tmp);
+	}
+
+	value = nm_setting_802_1x_get_phase2_autheap (s_8021x);
+	if (value) {
+		if (phase2_auth->len)
+			g_string_append_c (phase2_auth, ' ');
+
+		tmp = g_ascii_strup (value, -1);
+		g_string_append_printf (phase2_auth, "EAP-%s", tmp);
+		g_free (tmp);
+	}
+
+	auth_flags = nm_setting_802_1x_get_phase1_auth_flags (s_8021x);
+	if (auth_flags == NM_SETTING_802_1X_AUTH_FLAGS_NONE) {
+		svUnsetValue (ifcfg, "IEEE_8021X_PHASE1_AUTH_FLAGS");
+	} else {
+		svSetValueEnum (ifcfg, "IEEE_8021X_PHASE1_AUTH_FLAGS",
+		                nm_setting_802_1x_auth_flags_get_type(),
+		                auth_flags);
+	}
+
+	svSetValueStr (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS",
+	               phase2_auth->len ? phase2_auth->str : NULL);
+
+	g_string_free (phase2_auth, TRUE);
+
+	svSetValueStr (ifcfg, "IEEE_8021X_SUBJECT_MATCH",
+	               nm_setting_802_1x_get_subject_match (s_8021x));
+
+	svSetValueStr (ifcfg, "IEEE_8021X_PHASE2_SUBJECT_MATCH",
+	               nm_setting_802_1x_get_phase2_subject_match (s_8021x));
+
+	svUnsetValue (ifcfg, "IEEE_8021X_ALTSUBJECT_MATCHES");
+	str = g_string_new (NULL);
+	num = nm_setting_802_1x_get_num_altsubject_matches (s_8021x);
+	for (i = 0; i < num; i++) {
+		if (i > 0)
+			g_string_append_c (str, ' ');
+		match = nm_setting_802_1x_get_altsubject_match (s_8021x, i);
+		g_string_append (str, match);
+	}
+	if (str->len > 0)
+		svSetValueStr (ifcfg, "IEEE_8021X_ALTSUBJECT_MATCHES", str->str);
+	g_string_free (str, TRUE);
+
+	svUnsetValue (ifcfg, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES");
+	str = g_string_new (NULL);
+	num = nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x);
+	for (i = 0; i < num; i++) {
+		if (i > 0)
+			g_string_append_c (str, ' ');
+		match = nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, i);
+		g_string_append (str, match);
+	}
+	if (str->len > 0)
+		svSetValueStr (ifcfg, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES", str->str);
+	g_string_free (str, TRUE);
+
+	svSetValueStr (ifcfg, "IEEE_8021X_DOMAIN_SUFFIX_MATCH",
+	               nm_setting_802_1x_get_domain_suffix_match (s_8021x));
+	svSetValueStr (ifcfg, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH",
+	               nm_setting_802_1x_get_phase2_domain_suffix_match (s_8021x));
+
+	vint = nm_setting_802_1x_get_auth_timeout (s_8021x);
+	svSetValueInt64_cond (ifcfg, "IEEE_8021X_AUTH_TIMEOUT", vint > 0, vint);
+
+	if (!write_8021x_certs (s_8021x, secrets, blobs, FALSE, ifcfg, error))
+		return FALSE;
+
+	/* phase2/inner certs */
+	if (!write_8021x_certs (s_8021x, secrets, blobs, TRUE, ifcfg, error))
+		return FALSE;
+
+	return TRUE;
+}
+
+static gboolean
+write_wireless_security_setting (NMConnection *connection,
+                                 shvarFile *ifcfg,
+                                 GHashTable *secrets,
+                                 gboolean adhoc,
+                                 gboolean *no_8021x,
+                                 GError **error)
+{
+	NMSettingWirelessSecurity *s_wsec;
+	const char *key_mgmt, *auth_alg, *key, *proto, *cipher;
+	const char *psk = NULL;
+	gboolean wep = FALSE, wpa = FALSE, dynamic_wep = FALSE;
+	NMSettingWirelessSecurityWpsMethod wps_method;
+	char *tmp;
+	guint32 i, num;
+	GString *str;
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	if (!s_wsec) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+		return FALSE;
+	}
+
+	key_mgmt = nm_setting_wireless_security_get_key_mgmt (s_wsec);
+	g_assert (key_mgmt);
+
+	auth_alg = nm_setting_wireless_security_get_auth_alg (s_wsec);
+
+	svUnsetValue (ifcfg, "DEFAULTKEY");
+
+	if (!strcmp (key_mgmt, "none")) {
+		svUnsetValue (ifcfg, "KEY_MGMT");
+		wep = TRUE;
+		*no_8021x = TRUE;
+	} else if (!strcmp (key_mgmt, "wpa-psk")) {
+		svSetValueStr (ifcfg, "KEY_MGMT", "WPA-PSK");
+		wpa = TRUE;
+		*no_8021x = TRUE;
+	} else if (!strcmp (key_mgmt, "sae")) {
+		svSetValueStr (ifcfg, "KEY_MGMT", "SAE");
+		wpa = TRUE;
+		*no_8021x = TRUE;
+	} else if (!strcmp (key_mgmt, "ieee8021x")) {
+		svSetValueStr (ifcfg, "KEY_MGMT", "IEEE8021X");
+		dynamic_wep = TRUE;
+	} else if (!strcmp (key_mgmt, "wpa-eap")) {
+		svSetValueStr (ifcfg, "KEY_MGMT", "WPA-EAP");
+		wpa = TRUE;
+	}
+
+	svUnsetValue (ifcfg, "SECURITYMODE");
+	if (auth_alg) {
+		if (!strcmp (auth_alg, "shared"))
+			svSetValueStr (ifcfg, "SECURITYMODE", "restricted");
+		else if (!strcmp (auth_alg, "open"))
+			svSetValueStr (ifcfg, "SECURITYMODE", "open");
+		else if (!strcmp (auth_alg, "leap")) {
+			svSetValueStr (ifcfg, "SECURITYMODE", "leap");
+			svSetValueStr (ifcfg, "IEEE_8021X_IDENTITY",
+			               nm_setting_wireless_security_get_leap_username (s_wsec));
+			set_secret (ifcfg,
+			            secrets,
+			            "IEEE_8021X_PASSWORD",
+			            nm_setting_wireless_security_get_leap_password (s_wsec),
+			            "IEEE_8021X_PASSWORD_FLAGS",
+			            nm_setting_wireless_security_get_leap_password_flags (s_wsec));
+			*no_8021x = TRUE;
+		}
+	}
+
+	/* WPS */
+	wps_method = nm_setting_wireless_security_get_wps_method (s_wsec);
+	if (wps_method == NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT)
+		svUnsetValue (ifcfg, "WPS_METHOD");
+	else
+		svSetValueEnum (ifcfg, "WPS_METHOD", nm_setting_wireless_security_wps_method_get_type (), wps_method);
+
+	/* WEP keys */
+
+	/* Clear any default key */
+	set_secret (ifcfg, secrets, "KEY", NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+
+	/* Clear existing keys */
+	for (i = 0; i < 4; i++) {
+		char tag[64];
+
+		numbered_tag (tag, "KEY_PASSPHRASE", i + 1);
+		set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+
+		numbered_tag (tag, "KEY", i + 1);
+		set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+	}
+
+	/* And write the new ones out */
+	if (wep) {
+		NMWepKeyType key_type;
+		const char *key_type_str = NULL;
+
+		/* Default WEP TX key index */
+		svSetValueInt64 (ifcfg, "DEFAULTKEY", nm_setting_wireless_security_get_wep_tx_keyidx(s_wsec) + 1);
+
+		key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+		switch (key_type) {
+		case NM_WEP_KEY_TYPE_KEY:
+			key_type_str = "key";
+			break;
+		case NM_WEP_KEY_TYPE_PASSPHRASE:
+			key_type_str = "passphrase";
+			break;
+		case NM_WEP_KEY_TYPE_UNKNOWN:
+			break;
+		}
+		svSetValue (ifcfg, "KEY_TYPE", key_type_str);
+
+		for (i = 0; i < 4; i++) {
+			key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
+			if (key) {
+				gs_free char *ascii_key = NULL;
+				char tag[64];
+				gboolean key_valid = TRUE;
+
+				/* Passphrase needs a different ifcfg key since with WEP, there
+				 * are some passphrases that are indistinguishable from WEP hex
+				 * keys.
+				 */
+				if (key_type == NM_WEP_KEY_TYPE_UNKNOWN) {
+					if (nm_utils_wep_key_valid (key, NM_WEP_KEY_TYPE_KEY))
+						key_type = NM_WEP_KEY_TYPE_KEY;
+					else if (nm_utils_wep_key_valid (key, NM_WEP_KEY_TYPE_PASSPHRASE))
+						key_type = NM_WEP_KEY_TYPE_PASSPHRASE;
+				}
+
+				if (key_type == NM_WEP_KEY_TYPE_PASSPHRASE)
+					numbered_tag (tag, "KEY_PASSPHRASE", i + 1);
+				else if (key_type == NM_WEP_KEY_TYPE_KEY) {
+					numbered_tag (tag, "KEY", i + 1);
+
+					/* Add 's:' prefix for ASCII keys */
+					if (strlen (key) == 5 || strlen (key) == 13) {
+						ascii_key = g_strdup_printf ("s:%s", key);
+						key = ascii_key;
+					}
+				} else {
+					g_warn_if_reached ();
+					key_valid = FALSE;
+				}
+
+				if (key_valid) {
+					set_secret (ifcfg,
+					            secrets,
+					            tag,
+					            key,
+					            "WEP_KEY_FLAGS",
+					            nm_setting_wireless_security_get_wep_key_flags (s_wsec));
+				}
+			}
+		}
+	}
+
+	/* WPA protos */
+	svUnsetValue (ifcfg, "WPA_ALLOW_WPA");
+	svUnsetValue (ifcfg, "WPA_ALLOW_WPA2");
+	num = nm_setting_wireless_security_get_num_protos (s_wsec);
+	for (i = 0; i < num; i++) {
+		proto = nm_setting_wireless_security_get_proto (s_wsec, i);
+		if (proto && !strcmp (proto, "wpa"))
+			svSetValueStr (ifcfg, "WPA_ALLOW_WPA", "yes");
+		else if (proto && !strcmp (proto, "rsn"))
+			svSetValueStr (ifcfg, "WPA_ALLOW_WPA2", "yes");
+	}
+
+	/* WPA Pairwise ciphers */
+	svUnsetValue (ifcfg, "CIPHER_PAIRWISE");
+	str = g_string_new (NULL);
+	num = nm_setting_wireless_security_get_num_pairwise (s_wsec);
+	for (i = 0; i < num; i++) {
+		if (i > 0)
+			g_string_append_c (str, ' ');
+		cipher = nm_setting_wireless_security_get_pairwise (s_wsec, i);
+
+		/* Don't write out WEP40 or WEP104 if for some reason they are set; they
+		 * are not valid pairwise ciphers.
+		 */
+		if (strcmp (cipher, "wep40") && strcmp (cipher, "wep104")) {
+			tmp = g_ascii_strup (cipher, -1);
+			g_string_append (str, tmp);
+			g_free (tmp);
+		}
+	}
+	if (strlen (str->str) && (dynamic_wep == FALSE))
+		svSetValueStr (ifcfg, "CIPHER_PAIRWISE", str->str);
+	g_string_free (str, TRUE);
+
+	/* WPA Group ciphers */
+	svUnsetValue (ifcfg, "CIPHER_GROUP");
+	str = g_string_new (NULL);
+	num = nm_setting_wireless_security_get_num_groups (s_wsec);
+	for (i = 0; i < num; i++) {
+		if (i > 0)
+			g_string_append_c (str, ' ');
+		cipher = nm_setting_wireless_security_get_group (s_wsec, i);
+		tmp = g_ascii_strup (cipher, -1);
+		g_string_append (str, tmp);
+		g_free (tmp);
+	}
+	if (strlen (str->str) && (dynamic_wep == FALSE))
+		svSetValueStr (ifcfg, "CIPHER_GROUP", str->str);
+	g_string_free (str, TRUE);
+
+	if (wpa)
+		psk = nm_setting_wireless_security_get_psk (s_wsec);
+
+	set_secret (ifcfg,
+	            secrets,
+	            "WPA_PSK",
+	            psk,
+	            "WPA_PSK_FLAGS",
+	            wpa ? nm_setting_wireless_security_get_psk_flags (s_wsec) : NM_SETTING_SECRET_FLAG_NONE);
+
+	if (nm_setting_wireless_security_get_pmf (s_wsec) == NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT)
+		svUnsetValue (ifcfg, "PMF");
+	else {
+		svSetValueEnum (ifcfg, "PMF", nm_setting_wireless_security_pmf_get_type (),
+		                nm_setting_wireless_security_get_pmf (s_wsec));
+	}
+
+	if (nm_setting_wireless_security_get_fils (s_wsec) == NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT)
+		svUnsetValue (ifcfg, "FILS");
+	else {
+		svSetValueEnum (ifcfg, "FILS", nm_setting_wireless_security_fils_get_type (),
+		                nm_setting_wireless_security_get_fils (s_wsec));
+	}
+
+	return TRUE;
+}
+
+static gboolean
+write_wireless_setting (NMConnection *connection,
+                        shvarFile *ifcfg,
+                        GHashTable *secrets,
+                        gboolean *no_8021x,
+                        GError **error)
+{
+	NMSettingWireless *s_wireless;
+	GBytes *ssid;
+	const guint8 *ssid_data;
+	gsize ssid_len;
+	const char *mode, *bssid;
+	const char *device_mac, *cloned_mac;
+	guint32 mtu, chan, i;
+	gboolean adhoc = FALSE, hex_ssid = FALSE;
+	const char *const*macaddr_blacklist;
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	if (!s_wireless) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_WIRELESS_SETTING_NAME);
+		return FALSE;
+	}
+
+	device_mac = nm_setting_wireless_get_mac_address (s_wireless);
+	svSetValueStr (ifcfg, "HWADDR", device_mac);
+
+	cloned_mac = nm_setting_wireless_get_cloned_mac_address (s_wireless);
+	svSetValueStr (ifcfg, "MACADDR", cloned_mac);
+
+	svSetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK",
+	               nm_setting_wireless_get_generate_mac_address_mask (s_wireless));
+
+	svUnsetValue (ifcfg, "HWADDR_BLACKLIST");
+	macaddr_blacklist = nm_setting_wireless_get_mac_address_blacklist (s_wireless);
+	if (macaddr_blacklist[0]) {
+		char *blacklist_str;
+
+		blacklist_str = g_strjoinv (" ", (char **) macaddr_blacklist);
+		svSetValueStr (ifcfg, "HWADDR_BLACKLIST", blacklist_str);
+		g_free (blacklist_str);
+	}
+
+	mtu = nm_setting_wireless_get_mtu (s_wireless);
+	svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	if (!ssid) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing SSID in '%s' setting", NM_SETTING_WIRELESS_SETTING_NAME);
+		return FALSE;
+	}
+	ssid_data = g_bytes_get_data (ssid, &ssid_len);
+	if (!ssid_len || ssid_len > 32) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Invalid SSID in '%s' setting", NM_SETTING_WIRELESS_SETTING_NAME);
+		return FALSE;
+	}
+
+	/* If the SSID contains any non-printable characters, we need to use the
+	 * hex notation of the SSID instead.
+	 */
+	if (   ssid_len > 2
+	    && ssid_data[0] == '0'
+	    && ssid_data[1] == 'x') {
+		hex_ssid = TRUE;
+		for (i = 2; i < ssid_len; i++) {
+			if (!g_ascii_isxdigit (ssid_data[i])) {
+				hex_ssid = FALSE;
+				break;
+			}
+		}
+	}
+	if (!hex_ssid) {
+		for (i = 0; i < ssid_len; i++) {
+			if (!g_ascii_isprint (ssid_data[i])) {
+				hex_ssid = TRUE;
+				break;
+			}
+		}
+	}
+
+	if (hex_ssid) {
+		GString *str;
+
+		/* Hex SSIDs don't get quoted */
+		str = g_string_sized_new (ssid_len * 2 + 3);
+		g_string_append (str, "0x");
+		for (i = 0; i < ssid_len; i++)
+			g_string_append_printf (str, "%02X", ssid_data[i]);
+		svSetValueStr (ifcfg, "ESSID", str->str);
+		g_string_free (str, TRUE);
+	} else {
+		char buf[33];
+
+		nm_assert (ssid_len <= 32);
+		memcpy (buf, ssid_data, ssid_len);
+		buf[ssid_len] = '\0';
+		svSetValueStr (ifcfg, "ESSID", buf);
+	}
+
+	mode = nm_setting_wireless_get_mode (s_wireless);
+	if (!mode)
+		svUnsetValue(ifcfg, "MODE");
+	else if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_INFRA))
+		svSetValueStr (ifcfg, "MODE", "Managed");
+	else if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_ADHOC)) {
+		svSetValueStr (ifcfg, "MODE", "Ad-Hoc");
+		adhoc = TRUE;
+	} else if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_AP))
+		svSetValueStr (ifcfg, "MODE", "Ap");
+	else {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Invalid mode '%s' in '%s' setting",
+		             mode, NM_SETTING_WIRELESS_SETTING_NAME);
+		return FALSE;
+	}
+
+	svUnsetValue (ifcfg, "CHANNEL");
+	svUnsetValue (ifcfg, "BAND");
+	chan = nm_setting_wireless_get_channel (s_wireless);
+	if (chan) {
+		svSetValueInt64 (ifcfg, "CHANNEL", chan);
+	} else {
+		/* Band only set if channel is not, since channel implies band */
+		svSetValueStr (ifcfg, "BAND", nm_setting_wireless_get_band (s_wireless));
+	}
+
+	bssid = nm_setting_wireless_get_bssid (s_wireless);
+	svSetValueStr (ifcfg, "BSSID", bssid);
+
+	/* Ensure DEFAULTKEY and SECURITYMODE are cleared unless there's security;
+	 * otherwise there's no way to detect WEP vs. open when WEP keys aren't
+	 * saved.
+	 */
+	svUnsetValue (ifcfg, "DEFAULTKEY");
+	svUnsetValue (ifcfg, "SECURITYMODE");
+
+	if (nm_connection_get_setting_wireless_security (connection)) {
+		if (!write_wireless_security_setting (connection, ifcfg, secrets, adhoc, no_8021x, error))
+			return FALSE;
+	} else {
+		/* Clear out wifi security keys */
+		svUnsetValue (ifcfg, "KEY_MGMT");
+		svUnsetValue (ifcfg, "IEEE_8021X_IDENTITY");
+		set_secret (ifcfg, secrets, "IEEE_8021X_PASSWORD", NULL, "IEEE_8021X_PASSWORD_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+		svUnsetValue (ifcfg, "SECURITYMODE");
+
+		/* Clear existing keys */
+		set_secret (ifcfg, secrets, "KEY", NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+		for (i = 0; i < 4; i++) {
+			char tag[64];
+
+			numbered_tag (tag, "KEY_PASSPHRASE", i + 1);
+			set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+
+			numbered_tag (tag, "KEY", i + 1);
+			set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+		}
+
+		svUnsetValue (ifcfg, "DEFAULTKEY");
+		svUnsetValue (ifcfg, "WPA_ALLOW_WPA");
+		svUnsetValue (ifcfg, "WPA_ALLOW_WPA2");
+		svUnsetValue (ifcfg, "CIPHER_PAIRWISE");
+		svUnsetValue (ifcfg, "CIPHER_GROUP");
+		set_secret (ifcfg, secrets, "WPA_PSK", NULL, "WPA_PSK_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
+	}
+
+	svSetValueStr (ifcfg, "SSID_HIDDEN", nm_setting_wireless_get_hidden (s_wireless) ? "yes" : NULL);
+
+	switch (nm_setting_wireless_get_powersave (s_wireless)) {
+	case NM_SETTING_WIRELESS_POWERSAVE_IGNORE:
+		svSetValueStr (ifcfg, "POWERSAVE", "ignore");
+		break;
+	case NM_SETTING_WIRELESS_POWERSAVE_DISABLE:
+		svSetValueStr (ifcfg, "POWERSAVE", "disable");
+		break;
+	case NM_SETTING_WIRELESS_POWERSAVE_ENABLE:
+		svSetValueStr (ifcfg, "POWERSAVE", "enable");
+		break;
+	default:
+	case NM_SETTING_WIRELESS_POWERSAVE_DEFAULT:
+		svUnsetValue (ifcfg, "POWERSAVE");
+		break;
+	}
+
+	switch (nm_setting_wireless_get_mac_address_randomization (s_wireless)) {
+	case NM_SETTING_MAC_RANDOMIZATION_NEVER:
+		svSetValueStr (ifcfg, "MAC_ADDRESS_RANDOMIZATION", "never");
+		break;
+	case NM_SETTING_MAC_RANDOMIZATION_ALWAYS:
+		svSetValueStr (ifcfg, "MAC_ADDRESS_RANDOMIZATION", "always");
+		break;
+	case NM_SETTING_MAC_RANDOMIZATION_DEFAULT:
+	default:
+		svSetValueStr (ifcfg, "MAC_ADDRESS_RANDOMIZATION", "default");
+		break;
+	}
+
+	svSetValueStr (ifcfg, "TYPE", TYPE_WIRELESS);
+
+	return TRUE;
+}
+
+static gboolean
+write_infiniband_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingInfiniband *s_infiniband;
+	const char *mac, *transport_mode, *parent;
+	guint32 mtu;
+	int p_key;
+
+	s_infiniband = nm_connection_get_setting_infiniband (connection);
+	if (!s_infiniband) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_INFINIBAND_SETTING_NAME);
+		return FALSE;
+	}
+
+	mac = nm_setting_infiniband_get_mac_address (s_infiniband);
+	svSetValueStr (ifcfg, "HWADDR", mac);
+
+	mtu = nm_setting_infiniband_get_mtu (s_infiniband);
+	svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+
+	transport_mode = nm_setting_infiniband_get_transport_mode (s_infiniband);
+	svSetValueBoolean (ifcfg, "CONNECTED_MODE", nm_streq (transport_mode, "connected"));
+
+	p_key = nm_setting_infiniband_get_p_key (s_infiniband);
+	if (p_key != -1) {
+		svSetValueStr (ifcfg, "PKEY", "yes");
+		svSetValueInt64 (ifcfg, "PKEY_ID", p_key);
+
+		parent = nm_setting_infiniband_get_parent (s_infiniband);
+		if (parent)
+			svSetValueStr (ifcfg, "PHYSDEV", parent);
+	}
+
+	svSetValueStr (ifcfg, "TYPE", TYPE_INFINIBAND);
+
+	return TRUE;
+}
+
+static gboolean
+write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingWired *s_wired;
+	const char *const*s390_subchannels;
+	guint32 mtu, num_opts, i;
+	const char *const*macaddr_blacklist;
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	if (!s_wired) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_WIRED_SETTING_NAME);
+		return FALSE;
+	}
+
+	svSetValueStr (ifcfg, "HWADDR",
+	               nm_setting_wired_get_mac_address (s_wired));
+
+	svSetValueStr (ifcfg, "MACADDR",
+	               nm_setting_wired_get_cloned_mac_address (s_wired));
+
+	svSetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK",
+	               nm_setting_wired_get_generate_mac_address_mask (s_wired));
+
+	macaddr_blacklist = nm_setting_wired_get_mac_address_blacklist (s_wired);
+	if (macaddr_blacklist[0]) {
+		gs_free char *blacklist_str = NULL;
+
+		blacklist_str = g_strjoinv (" ", (char **) macaddr_blacklist);
+		svSetValueStr (ifcfg, "HWADDR_BLACKLIST", blacklist_str);
+	} else
+		svUnsetValue (ifcfg, "HWADDR_BLACKLIST");
+
+	mtu = nm_setting_wired_get_mtu (s_wired);
+	svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+
+	s390_subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
+
+	{
+		gs_free char *tmp = NULL;
+		gsize len = NM_PTRARRAY_LEN (s390_subchannels);
+
+		if (len == 2) {
+			tmp = g_strdup_printf ("%s,%s",
+			                       s390_subchannels[0],
+			                       s390_subchannels[1]);
+		} else if (len == 3) {
+			tmp = g_strdup_printf ("%s,%s,%s",
+			                       s390_subchannels[0],
+			                       s390_subchannels[1],
+			                       s390_subchannels[2]);
+		}
+
+		svSetValueStr (ifcfg, "SUBCHANNELS", tmp);
+	}
+
+	svSetValueStr (ifcfg, "NETTYPE",
+	               nm_setting_wired_get_s390_nettype (s_wired));
+
+	svSetValueStr (ifcfg, "PORTNAME",
+	               nm_setting_wired_get_s390_option_by_key (s_wired, "portname"));
+
+	svSetValueStr (ifcfg, "CTCPROT",
+	               nm_setting_wired_get_s390_option_by_key (s_wired, "ctcprot"));
+
+	svUnsetValue (ifcfg, "OPTIONS");
+	num_opts = nm_setting_wired_get_num_s390_options (s_wired);
+	if (s390_subchannels && num_opts) {
+		nm_auto_free_gstring GString *tmp = NULL;
+
+		for (i = 0; i < num_opts; i++) {
+			const char *s390_key, *s390_val;
+
+			nm_setting_wired_get_s390_option (s_wired, i, &s390_key, &s390_val);
+
+			/* portname is handled separately */
+			if (NM_IN_STRSET (s390_key, "portname", "ctcprot"))
+				continue;
+
+			if (strchr (s390_key, '=')) {
+				/* this key cannot be expressed. But after all, it's not valid anyway
+				 * and the connection shouldn't even verify. */
+				continue;
+			}
+
+			if (!tmp)
+				tmp = g_string_sized_new (30);
+			else
+				g_string_append_c (tmp, ' ');
+			nm_utils_escaped_tokens_escape_gstr (s390_key, NM_ASCII_SPACES, tmp);
+			g_string_append_c (tmp, '=');
+			nm_utils_escaped_tokens_escape_gstr (s390_val, NM_ASCII_SPACES, tmp);
+		}
+		if (tmp)
+			svSetValueStr (ifcfg, "OPTIONS", tmp->str);
+	}
+
+	svSetValueStr (ifcfg, "TYPE", TYPE_ETHERNET);
+
+	return TRUE;
+}
+
+static gboolean
+write_ethtool_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingWired *s_wired;
+	NMSettingEthtool *s_ethtool;
+	const char *duplex;
+	guint32 speed;
+	GString *str = NULL;
+	gboolean auto_negotiate;
+	NMSettingWiredWakeOnLan wol;
+	const char *wol_password;
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	s_ethtool = NM_SETTING_ETHTOOL (nm_connection_get_setting (connection, NM_TYPE_SETTING_ETHTOOL));
+
+	if (!s_wired && !s_ethtool) {
+		svUnsetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN");
+		svUnsetValue (ifcfg, "ETHTOOL_OPTS");
+		return TRUE;
+	}
+
+	if (s_wired) {
+		auto_negotiate = nm_setting_wired_get_auto_negotiate (s_wired);
+		speed = nm_setting_wired_get_speed (s_wired);
+		duplex = nm_setting_wired_get_duplex (s_wired);
+
+		/* autoneg off + speed 0 + duplex NULL, means we want NM
+		 * to skip link configuration which is default. So write
+		 * down link config only if we have auto-negotiate true or
+		 * a valid value for one among speed and duplex.
+		 */
+		if (auto_negotiate) {
+			str = g_string_sized_new (64);
+			g_string_printf (str, "autoneg on");
+		} else if (speed || duplex) {
+			str = g_string_sized_new (64);
+			g_string_printf (str, "autoneg off");
+		}
+		if (speed)
+			g_string_append_printf (str, " speed %u", speed);
+		if (duplex)
+			g_string_append_printf (str, " duplex %s", duplex);
+
+		wol = nm_setting_wired_get_wake_on_lan (s_wired);
+		wol_password = nm_setting_wired_get_wake_on_lan_password (s_wired);
+
+		svSetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN",
+		              wol == NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE
+		            ? "ignore"
+		            : NULL);
+		if (!NM_IN_SET (wol, NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE,
+		                     NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT)) {
+			if (!str)
+				str = g_string_sized_new (30);
+			else
+				g_string_append (str, " ");
+
+			g_string_append (str, "wol ");
+
+			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_PHY))
+				g_string_append (str, "p");
+			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST))
+				g_string_append (str, "u");
+			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST))
+				g_string_append (str, "m");
+			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST))
+				g_string_append (str, "b");
+			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_ARP))
+				g_string_append (str, "a");
+			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC))
+				g_string_append (str, "g");
+
+			if (!NM_FLAGS_ANY (wol, NM_SETTING_WIRED_WAKE_ON_LAN_ALL))
+				g_string_append (str, "d");
+
+			if (wol_password && NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC))
+				g_string_append_printf (str, "s sopass %s", wol_password);
+		}
+	} else
+		svUnsetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN");
+
+	if (s_ethtool) {
+		NMEthtoolID ethtool_id;
+		NMSettingConnection *s_con;
+		const char *iface = NULL;
+
+		s_con = nm_connection_get_setting_connection (connection);
+		if (s_con) {
+			iface = nm_setting_connection_get_interface_name (s_con);
+			if (   iface
+			    && (   !iface[0]
+			        || !NM_STRCHAR_ALL (iface, ch,    (ch >= 'a' && ch <= 'z')
+			                                       || (ch >= 'A' && ch <= 'Z')
+			                                       || (ch >= '0' && ch <= '9')
+			                                       || NM_IN_SET (ch, '_'))))
+				iface = NULL;
+		}
+
+		if (!str)
+			str = g_string_sized_new (30);
+		else
+			g_string_append (str, " ; ");
+		g_string_append (str, "-K ");
+		g_string_append (str, iface ?: "net0");
+
+		for (ethtool_id = _NM_ETHTOOL_ID_FEATURE_FIRST; ethtool_id <= _NM_ETHTOOL_ID_FEATURE_LAST; ethtool_id++) {
+			const NMEthtoolData *ed = nm_ethtool_data[ethtool_id];
+			NMTernary val;
+
+			nm_assert (nms_ifcfg_rh_utils_get_ethtool_name (ethtool_id));
+
+			val = nm_setting_ethtool_get_feature (s_ethtool, ed->optname);
+			if (val == NM_TERNARY_DEFAULT)
+				continue;
+
+			g_string_append_c (str, ' ');
+			g_string_append (str, nms_ifcfg_rh_utils_get_ethtool_name (ethtool_id));
+			g_string_append (str, val == NM_TERNARY_TRUE ? " on" : " off");
+		}
+	}
+
+	if (str) {
+		svSetValueStr (ifcfg, "ETHTOOL_OPTS", str->str);
+		g_string_free (str, TRUE);
+	} else
+		svUnsetValue (ifcfg, "ETHTOOL_OPTS");
+
+	return TRUE;
+}
+
+static char *
+vlan_priority_maplist_to_stringlist (NMSettingVlan *s_vlan, NMVlanPriorityMap map)
+{
+	char **strlist;
+	char *value;
+
+	if (map == NM_VLAN_INGRESS_MAP)
+		g_object_get (G_OBJECT (s_vlan), NM_SETTING_VLAN_INGRESS_PRIORITY_MAP, &strlist, NULL);
+	else if (map == NM_VLAN_EGRESS_MAP)
+		g_object_get (G_OBJECT (s_vlan), NM_SETTING_VLAN_EGRESS_PRIORITY_MAP, &strlist, NULL);
+	else
+		return NULL;
+
+	if (strlist[0])
+		value = g_strjoinv (",", strlist);
+	else
+		value = NULL;
+	g_strfreev (strlist);
+
+	return value;
+}
+
+static gboolean
+write_wired_for_virtual (NMConnection *connection, shvarFile *ifcfg)
+{
+	NMSettingWired *s_wired;
+	gboolean has_wired = FALSE;
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	if (s_wired) {
+		const char *device_mac, *cloned_mac;
+		guint32 mtu;
+
+		has_wired = TRUE;
+
+		device_mac = nm_setting_wired_get_mac_address (s_wired);
+		svSetValue (ifcfg, "HWADDR", device_mac ?: "");
+
+		cloned_mac = nm_setting_wired_get_cloned_mac_address (s_wired);
+		svSetValueStr (ifcfg, "MACADDR", cloned_mac);
+
+		svSetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK",
+		               nm_setting_wired_get_generate_mac_address_mask (s_wired));
+
+		mtu = nm_setting_wired_get_mtu (s_wired);
+		svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+	}
+	return has_wired;
+}
+
+static gboolean
+write_vlan_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+{
+	NMSettingVlan *s_vlan;
+	char *tmp;
+	guint32 vlan_flags = 0;
+	gsize s_buf_len;
+	char s_buf[50], *s_buf_ptr;
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	if (!s_vlan) {
+		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		                     "Missing VLAN setting");
+		return FALSE;
+	}
+
+	svSetValueStr (ifcfg, "VLAN", "yes");
+	svSetValueStr (ifcfg, "TYPE", TYPE_VLAN);
+	svSetValueStr (ifcfg, "PHYSDEV", nm_setting_vlan_get_parent (s_vlan));
+	svSetValueInt64 (ifcfg, "VLAN_ID", nm_setting_vlan_get_id (s_vlan));
+
+	vlan_flags = nm_setting_vlan_get_flags (s_vlan);
+	svSetValueBoolean (ifcfg, "REORDER_HDR", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS));
+	svSetValueBoolean (ifcfg, "GVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_GVRP));
+
+	nm_utils_strbuf_init (s_buf, &s_buf_ptr, &s_buf_len);
+
+	if (NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_LOOSE_BINDING))
+		nm_utils_strbuf_append_str (&s_buf_ptr, &s_buf_len, "LOOSE_BINDING");
+	if (!NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS))
+		nm_utils_strbuf_append (&s_buf_ptr, &s_buf_len, "%sNO_REORDER_HDR", s_buf[0] ? "," : "");
+
+	svSetValueStr (ifcfg, "VLAN_FLAGS", s_buf);
+
+	svSetValueBoolean (ifcfg, "MVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_MVRP));
+
+	tmp = vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_INGRESS_MAP);
+	svSetValueStr (ifcfg, "VLAN_INGRESS_PRIORITY_MAP", tmp);
+	g_free (tmp);
+
+	tmp = vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_EGRESS_MAP);
+	svSetValueStr (ifcfg, "VLAN_EGRESS_PRIORITY_MAP", tmp);
+	g_free (tmp);
+
+	svUnsetValue (ifcfg, "HWADDR");
+	svUnsetValue (ifcfg, "MACADDR");
+	svUnsetValue (ifcfg, "MTU");
+
+	*wired = write_wired_for_virtual (connection, ifcfg);
+
+	return TRUE;
+}
+
+static gboolean
+write_bond_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+{
+	NMSettingBond *s_bond;
+	guint32 i, num_opts;
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	if (!s_bond) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_BOND_SETTING_NAME);
+		return FALSE;
+	}
+
+	svUnsetValue (ifcfg, "BONDING_OPTS");
+
+	num_opts = nm_setting_bond_get_num_options (s_bond);
+	if (num_opts) {
+		nm_auto_free_gstring GString *str = NULL;
+		const char *name, *value;
+
+		str = g_string_sized_new (64);
+		for (i = 0; i < num_opts; i++) {
+			if (str->len)
+				g_string_append_c (str, ' ');
+			nm_setting_bond_get_option (s_bond, i, &name, &value);
+			g_string_append_printf (str, "%s=%s", name, value);
+		}
+
+		svSetValueStr (ifcfg, "BONDING_OPTS", str->str);
+	}
+
+	svSetValueStr (ifcfg, "TYPE", TYPE_BOND);
+	svSetValueStr (ifcfg, "BONDING_MASTER", "yes");
+
+	*wired = write_wired_for_virtual (connection, ifcfg);
+
+	return TRUE;
+}
+
+static gboolean
+write_team_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+{
+	NMSettingTeam *s_team;
+	const char *config;
+
+	s_team = nm_connection_get_setting_team (connection);
+	if (!s_team) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_TEAM_SETTING_NAME);
+		return FALSE;
+	}
+
+	config = nm_setting_team_get_config (s_team);
+	svSetValueStr (ifcfg, "TEAM_CONFIG", config);
+
+	*wired = write_wired_for_virtual (connection, ifcfg);
+
+	return TRUE;
+}
+
+static guint32
+get_setting_default_uint (NMSetting *setting, const char *prop)
+{
+	GParamSpec *pspec;
+	GValue val = G_VALUE_INIT;
+	guint32 ret = 0;
+
+	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (setting), prop);
+	g_assert (pspec);
+	g_value_init (&val, pspec->value_type);
+	g_param_value_set_default (pspec, &val);
+	g_assert (G_VALUE_HOLDS_UINT (&val));
+	ret = g_value_get_uint (&val);
+	g_value_unset (&val);
+	return ret;
+}
+
+static gboolean
+get_setting_default_boolean (NMSetting *setting, const char *prop)
+{
+	GParamSpec *pspec;
+	GValue val = G_VALUE_INIT;
+	gboolean ret = 0;
+
+	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (setting), prop);
+	g_assert (pspec);
+	g_value_init (&val, pspec->value_type);
+	g_param_value_set_default (pspec, &val);
+	g_assert (G_VALUE_HOLDS_BOOLEAN (&val));
+	ret = g_value_get_boolean (&val);
+	g_value_unset (&val);
+	return ret;
+}
+
+static gboolean
+write_bridge_vlans (NMSetting *setting,
+                    const char *property_name,
+                    shvarFile *ifcfg,
+                    const char *key,
+                    GError **error)
+{
+	gs_unref_ptrarray GPtrArray *vlans = NULL;
+	NMBridgeVlan *vlan;
+	GString *string;
+	guint i;
+
+	g_object_get (setting, property_name, &vlans, NULL);
+
+	if (!vlans || !vlans->len) {
+		svUnsetValue (ifcfg, key);
+		return TRUE;
+	}
+
+	string = g_string_new ("");
+	for (i = 0; i < vlans->len; i++) {
+		gs_free char *vlan_str = NULL;
+
+		vlan = vlans->pdata[i];
+		vlan_str = nm_bridge_vlan_to_str (vlan, error);
+		if (!vlan_str)
+			return FALSE;
+		if (string->len > 0)
+			g_string_append (string, ",");
+		nm_utils_escaped_tokens_escape_gstr_assert (vlan_str, ",", string);
+	}
+
+	svSetValueStr (ifcfg, key, string->str);
+	g_string_free (string, TRUE);
+	return TRUE;
+}
+
+static gboolean
+write_bridge_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+{
+	NMSettingBridge *s_bridge;
+	guint32 i;
+	gboolean b;
+	GString *opts;
+	const char *mac;
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	if (!s_bridge) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_BRIDGE_SETTING_NAME);
+		return FALSE;
+	}
+
+	svUnsetValue (ifcfg, "BRIDGING_OPTS");
+	svSetValueBoolean (ifcfg, "STP", FALSE);
+	svUnsetValue (ifcfg, "DELAY");
+
+	mac = nm_setting_bridge_get_mac_address (s_bridge);
+	svSetValueStr (ifcfg, "BRIDGE_MACADDR", mac);
+
+	/* Bridge options */
+	opts = g_string_sized_new (32);
+
+	if (nm_setting_bridge_get_stp (s_bridge)) {
+		svSetValueStr (ifcfg, "STP", "yes");
+
+		i = nm_setting_bridge_get_forward_delay (s_bridge);
+		if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_FORWARD_DELAY))
+			svSetValueInt64 (ifcfg, "DELAY", i);
+
+		g_string_append_printf (opts, "priority=%u", nm_setting_bridge_get_priority (s_bridge));
+
+		i = nm_setting_bridge_get_hello_time (s_bridge);
+		if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_HELLO_TIME)) {
+			if (opts->len)
+				g_string_append_c (opts, ' ');
+			g_string_append_printf (opts, "hello_time=%u", i);
+		}
+
+		i = nm_setting_bridge_get_max_age (s_bridge);
+		if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_MAX_AGE)) {
+			if (opts->len)
+				g_string_append_c (opts, ' ');
+			g_string_append_printf (opts, "max_age=%u", i);
+		}
+	}
+
+	i = nm_setting_bridge_get_ageing_time (s_bridge);
+	if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_AGEING_TIME)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "ageing_time=%u", i);
+	}
+
+	i = nm_setting_bridge_get_group_forward_mask (s_bridge);
+	if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_GROUP_FORWARD_MASK)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "group_fwd_mask=%u", i);
+	}
+
+	b = nm_setting_bridge_get_multicast_snooping (s_bridge);
+	if (b != get_setting_default_boolean (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_MULTICAST_SNOOPING)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "multicast_snooping=%u", (guint32) b);
+	}
+
+	b = nm_setting_bridge_get_vlan_filtering (s_bridge);
+	if (b != get_setting_default_boolean (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_VLAN_FILTERING)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "vlan_filtering=%u", (guint32) b);
+	}
+
+	i = nm_setting_bridge_get_vlan_default_pvid (s_bridge);
+	if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "default_pvid=%u", i);
+	}
+
+	if (opts->len)
+		svSetValueStr (ifcfg, "BRIDGING_OPTS", opts->str);
+	g_string_free (opts, TRUE);
+
+	if (!write_bridge_vlans ((NMSetting *) s_bridge,
+	                         NM_SETTING_BRIDGE_VLANS,
+	                         ifcfg,
+	                         "BRIDGE_VLANS",
+	                         error))
+		return FALSE;
+
+	svSetValueStr (ifcfg, "TYPE", TYPE_BRIDGE);
+
+	*wired = write_wired_for_virtual (connection, ifcfg);
+
+	return TRUE;
+}
+
+static gboolean
+write_bridge_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingBridgePort *s_port;
+	guint32 i;
+	GString *string;
+
+	s_port = nm_connection_get_setting_bridge_port (connection);
+	if (!s_port)
+		return TRUE;
+
+	svUnsetValue (ifcfg, "BRIDGING_OPTS");
+
+	/* Bridge options */
+	string = g_string_sized_new (32);
+
+	i = nm_setting_bridge_port_get_priority (s_port);
+	if (i != get_setting_default_uint (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PRIORITY))
+		g_string_append_printf (string, "priority=%u", i);
+
+	i = nm_setting_bridge_port_get_path_cost (s_port);
+	if (i != get_setting_default_uint (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PATH_COST)) {
+		if (string->len)
+			g_string_append_c (string, ' ');
+		g_string_append_printf (string, "path_cost=%u", i);
+	}
+
+	if (nm_setting_bridge_port_get_hairpin_mode (s_port)) {
+		if (string->len)
+			g_string_append_c (string, ' ');
+		g_string_append_printf (string, "hairpin_mode=1");
+	}
+
+	if (string->len)
+		svSetValueStr (ifcfg, "BRIDGING_OPTS", string->str);
+	g_string_free (string, TRUE);
+
+	if (!write_bridge_vlans ((NMSetting *) s_port,
+	                         NM_SETTING_BRIDGE_PORT_VLANS,
+	                         ifcfg,
+	                         "BRIDGE_PORT_VLANS",
+	                         error))
+		return FALSE;
+
+	return TRUE;
+}
+
+static gboolean
+write_team_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingTeamPort *s_port;
+	const char *config;
+
+	s_port = nm_connection_get_setting_team_port (connection);
+	if (!s_port)
+		return TRUE;
+
+	config = nm_setting_team_port_get_config (s_port);
+	svSetValueStr (ifcfg, "TEAM_PORT_CONFIG", config);
+
+	return TRUE;
+}
+
+static void
+write_dcb_flags (shvarFile *ifcfg, const char *tag, NMSettingDcbFlags flags)
+{
+	char prop[NM_STRLEN ("DCB_xxxxxxxxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyyyy")];
+
+	nm_sprintf_buf (prop, "DCB_%s_ENABLE", tag);
+	svSetValueStr (ifcfg, prop, (flags & NM_SETTING_DCB_FLAG_ENABLE) ? "yes" : NULL);
+
+	nm_sprintf_buf (prop, "DCB_%s_ADVERTISE", tag);
+	svSetValueStr (ifcfg, prop, (flags & NM_SETTING_DCB_FLAG_ADVERTISE) ? "yes" : NULL);
+
+	nm_sprintf_buf (prop, "DCB_%s_WILLING", tag);
+	svSetValueStr (ifcfg, prop, (flags & NM_SETTING_DCB_FLAG_WILLING) ? "yes" : NULL);
+}
+
+static void
+write_dcb_app (shvarFile *ifcfg,
+               const char *tag,
+               NMSettingDcbFlags flags,
+               int priority)
+{
+	char prop[NM_STRLEN ("DCB_xxxxxxxxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyyyy")];
+
+	write_dcb_flags (ifcfg, tag, flags);
+
+	nm_sprintf_buf (prop, "DCB_%s_PRIORITY", tag);
+	if ((flags & NM_SETTING_DCB_FLAG_ENABLE) && (priority >= 0))
+		svSetValueInt64 (ifcfg, prop, priority);
+	else
+		svUnsetValue (ifcfg, prop);
+}
+
+typedef gboolean (*DcbGetBoolFunc) (NMSettingDcb *, guint);
+
+static void
+write_dcb_bool_array (shvarFile *ifcfg,
+                      const char *key,
+                      NMSettingDcb *s_dcb,
+                      NMSettingDcbFlags flags,
+                      DcbGetBoolFunc get_func)
+{
+	char str[9];
+	guint i;
+
+	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
+		svUnsetValue (ifcfg, key);
+		return;
+	}
+
+	str[8] = 0;
+	for (i = 0; i < 8; i++)
+		str[i] = get_func (s_dcb, i) ? '1' : '0';
+	svSetValueStr (ifcfg, key, str);
+}
+
+typedef guint (*DcbGetUintFunc) (NMSettingDcb *, guint);
+
+static void
+write_dcb_uint_array (shvarFile *ifcfg,
+                      const char *key,
+                      NMSettingDcb *s_dcb,
+                      NMSettingDcbFlags flags,
+                      DcbGetUintFunc get_func)
+{
+	char str[9];
+	guint i, num;
+
+	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
+		svUnsetValue (ifcfg, key);
+		return;
+	}
+
+	str[8] = 0;
+	for (i = 0; i < 8; i++) {
+		num = get_func (s_dcb, i);
+		if (num < 10)
+			str[i] = '0' + num;
+		else if (num == 15)
+			str[i] = 'f';
+		else
+			g_assert_not_reached ();
+	}
+	svSetValueStr (ifcfg, key, str);
+}
+
+static void
+write_dcb_percent_array (shvarFile *ifcfg,
+                         const char *key,
+                         NMSettingDcb *s_dcb,
+                         NMSettingDcbFlags flags,
+                         DcbGetUintFunc get_func)
+{
+	GString *str;
+	guint i;
+
+	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
+		svUnsetValue (ifcfg, key);
+		return;
+	}
+
+	str = g_string_sized_new (30);
+	for (i = 0; i < 8; i++) {
+		if (str->len)
+			g_string_append_c (str, ',');
+		g_string_append_printf (str, "%d", get_func (s_dcb, i));
+	}
+	svSetValueStr (ifcfg, key, str->str);
+	g_string_free (str, TRUE);
+}
+
+static gboolean
+write_dcb_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingDcb *s_dcb;
+	NMSettingDcbFlags flags;
+
+	s_dcb = nm_connection_get_setting_dcb (connection);
+	if (!s_dcb) {
+		static const char *clear_keys[] = {
+		    "DCB",
+		    KEY_DCB_APP_FCOE_ENABLE,
+		    KEY_DCB_APP_FCOE_ADVERTISE,
+		    KEY_DCB_APP_FCOE_WILLING,
+		    KEY_DCB_APP_FCOE_MODE,
+		    KEY_DCB_APP_ISCSI_ENABLE,
+		    KEY_DCB_APP_ISCSI_ADVERTISE,
+		    KEY_DCB_APP_ISCSI_WILLING,
+		    KEY_DCB_APP_FIP_ENABLE,
+		    KEY_DCB_APP_FIP_ADVERTISE,
+		    KEY_DCB_APP_FIP_WILLING,
+		    KEY_DCB_PFC_ENABLE,
+		    KEY_DCB_PFC_ADVERTISE,
+		    KEY_DCB_PFC_WILLING,
+		    KEY_DCB_PFC_UP,
+		    KEY_DCB_PG_ENABLE,
+		    KEY_DCB_PG_ADVERTISE,
+		    KEY_DCB_PG_WILLING,
+		    KEY_DCB_PG_ID,
+		    KEY_DCB_PG_PCT,
+		    KEY_DCB_PG_UPPCT,
+		    KEY_DCB_PG_STRICT,
+		    KEY_DCB_PG_UP2TC,
+		    NULL };
+		const char **iter;
+
+		for (iter = clear_keys; *iter; iter++)
+			svUnsetValue (ifcfg, *iter);
+		return TRUE;
+	}
+
+	svSetValueStr (ifcfg, "DCB", "yes");
+
+	write_dcb_app (ifcfg, "APP_FCOE",
+	               nm_setting_dcb_get_app_fcoe_flags (s_dcb),
+	               nm_setting_dcb_get_app_fcoe_priority (s_dcb));
+	if (nm_setting_dcb_get_app_fcoe_flags (s_dcb) & NM_SETTING_DCB_FLAG_ENABLE)
+		svSetValueStr (ifcfg, KEY_DCB_APP_FCOE_MODE, nm_setting_dcb_get_app_fcoe_mode (s_dcb));
+	else
+		svUnsetValue (ifcfg, KEY_DCB_APP_FCOE_MODE);
+
+	write_dcb_app (ifcfg, "APP_ISCSI",
+	               nm_setting_dcb_get_app_iscsi_flags (s_dcb),
+	               nm_setting_dcb_get_app_iscsi_priority (s_dcb));
+	write_dcb_app (ifcfg, "APP_FIP",
+	               nm_setting_dcb_get_app_fip_flags (s_dcb),
+	               nm_setting_dcb_get_app_fip_priority (s_dcb));
+
+	write_dcb_flags (ifcfg, "PFC", nm_setting_dcb_get_priority_flow_control_flags (s_dcb));
+	write_dcb_bool_array (ifcfg, KEY_DCB_PFC_UP, s_dcb,
+	                      nm_setting_dcb_get_priority_flow_control_flags (s_dcb),
+	                      nm_setting_dcb_get_priority_flow_control);
+
+	flags = nm_setting_dcb_get_priority_group_flags (s_dcb);
+	write_dcb_flags (ifcfg, "PG", flags);
+	write_dcb_uint_array (ifcfg, KEY_DCB_PG_ID, s_dcb, flags, nm_setting_dcb_get_priority_group_id);
+	write_dcb_percent_array (ifcfg, KEY_DCB_PG_PCT, s_dcb, flags, nm_setting_dcb_get_priority_group_bandwidth);
+	write_dcb_percent_array (ifcfg, KEY_DCB_PG_UPPCT, s_dcb, flags, nm_setting_dcb_get_priority_bandwidth);
+	write_dcb_bool_array (ifcfg, KEY_DCB_PG_STRICT, s_dcb, flags, nm_setting_dcb_get_priority_strict_bandwidth);
+	write_dcb_uint_array (ifcfg, KEY_DCB_PG_UP2TC, s_dcb, flags, nm_setting_dcb_get_priority_traffic_class);
+
+	return TRUE;
+}
+
+static void
+write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
+{
+	guint32 n, i;
+	GString *str;
+	const char *master, *master_iface = NULL, *type;
+	int vint;
+	gint32 vint32;
+	NMSettingConnectionMdns mdns;
+	NMSettingConnectionLlmnr llmnr;
+	guint32 vuint32;
+	const char *tmp;
+
+	svSetValueStr (ifcfg, "NAME", nm_setting_connection_get_id (s_con));
+	svSetValueStr (ifcfg, "UUID", nm_setting_connection_get_uuid (s_con));
+	svSetValueStr (ifcfg, "STABLE_ID", nm_setting_connection_get_stable_id (s_con));
+	svSetValueStr (ifcfg, "DEVICE", nm_setting_connection_get_interface_name (s_con));
+	svSetValueBoolean (ifcfg, "ONBOOT", nm_setting_connection_get_autoconnect (s_con));
+
+	vint = nm_setting_connection_get_autoconnect_priority (s_con);
+	svSetValueInt64_cond (ifcfg, "AUTOCONNECT_PRIORITY",
+	                      vint != NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT,
+	                      vint);
+
+	vint = nm_setting_connection_get_autoconnect_retries (s_con);
+	svSetValueInt64_cond (ifcfg, "AUTOCONNECT_RETRIES",
+	                      vint != -1,
+	                      vint);
+
+	vint = nm_setting_connection_get_multi_connect (s_con);
+	svSetValueInt64_cond (ifcfg, "MULTI_CONNECT",
+	                      vint != NM_CONNECTION_MULTI_CONNECT_DEFAULT,
+	                      vint);
+
+	/* Only save the value for master connections */
+	type = nm_setting_connection_get_connection_type (s_con);
+	if (_nm_connection_type_is_master (type)) {
+		NMSettingConnectionAutoconnectSlaves autoconnect_slaves;
+		autoconnect_slaves = nm_setting_connection_get_autoconnect_slaves (s_con);
+		svSetValueStr (ifcfg, "AUTOCONNECT_SLAVES",
+		               autoconnect_slaves == NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES ? "yes" :
+		               autoconnect_slaves == NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO ? "no" : NULL);
+	} else
+		svUnsetValue (ifcfg, "AUTOCONNECT_SLAVES");
+
+	switch (nm_setting_connection_get_lldp (s_con)) {
+	case NM_SETTING_CONNECTION_LLDP_ENABLE_RX:
+		tmp = "rx";
+		break;
+	case NM_SETTING_CONNECTION_LLDP_DISABLE:
+		tmp = "no";
+		break;
+	default:
+		tmp = NULL;
+	}
+	svSetValueStr (ifcfg, "LLDP", tmp);
+
+	/* Permissions */
+	svUnsetValue (ifcfg, "USERS");
+	n = nm_setting_connection_get_num_permissions (s_con);
+	if (n > 0) {
+		str = g_string_sized_new (n * 20);
+
+		for (i = 0; i < n; i++) {
+			const char *puser = NULL;
+
+			/* Items separated by space for consistency with eg
+			 * IPV6ADDR_SECONDARIES and DOMAIN.
+			 */
+			if (str->len)
+				g_string_append_c (str, ' ');
+
+			if (nm_setting_connection_get_permission (s_con, i, NULL, &puser, NULL))
+				g_string_append (str, puser);
+		}
+		svSetValueStr (ifcfg, "USERS", str->str);
+		g_string_free (str, TRUE);
+	}
+
+	svSetValueStr (ifcfg, "ZONE", nm_setting_connection_get_zone (s_con));
+
+	svSetValueStr (ifcfg, "MASTER_UUID", NULL);
+	svSetValueStr (ifcfg, "MASTER", NULL);
+	svSetValueStr (ifcfg, "SLAVE", NULL);
+	svSetValueStr (ifcfg, "BRIDGE_UUID", NULL);
+	svSetValueStr (ifcfg, "BRIDGE", NULL);
+	svSetValueStr (ifcfg, "TEAM_MASTER_UUID", NULL);
+	svSetValueStr (ifcfg, "TEAM_MASTER", NULL);
+
+	master = nm_setting_connection_get_master (s_con);
+	if (master) {
+		/* The reader prefers the *_UUID variants, however we still try to resolve
+		 * it into an interface name, so that legacy tooling is not confused. */
+		if (!nm_utils_get_testing ()) {
+			/* This is conditional for easier testing. */
+			master_iface = nm_manager_iface_for_uuid (nm_manager_get (), master);
+		}
+		if (!master_iface) {
+			master_iface = master;
+			master = NULL;
+
+		}
+
+		if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME)) {
+			svSetValueStr (ifcfg, "MASTER_UUID", master);
+			svSetValueStr (ifcfg, "MASTER", master_iface);
+			svSetValueStr (ifcfg, "SLAVE", "yes");
+		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BRIDGE_SETTING_NAME)) {
+			svSetValueStr (ifcfg, "BRIDGE_UUID", master);
+			svSetValueStr (ifcfg, "BRIDGE", master_iface);
+		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME)) {
+			svSetValueStr (ifcfg, "TEAM_MASTER_UUID", master);
+			svSetValueStr (ifcfg, "TEAM_MASTER", master_iface);
+			if (NM_IN_STRSET (type,
+			                  NM_SETTING_WIRED_SETTING_NAME,
+			                  NM_SETTING_VLAN_SETTING_NAME))
+				svUnsetValue (ifcfg, "TYPE");
+		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_OVS_PORT_SETTING_NAME)) {
+			svSetValueStr (ifcfg, "OVS_PORT_UUID", master);
+			svSetValueStr (ifcfg, "OVS_PORT", master_iface);
+		} else {
+			_LOGW ("don't know how to set master for a %s slave",
+			       nm_setting_connection_get_slave_type (s_con));
+		}
+	}
+
+	if (nm_streq0 (type, NM_SETTING_TEAM_SETTING_NAME))
+		svSetValueStr (ifcfg, "DEVICETYPE", TYPE_TEAM);
+	else if (master_iface && nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME))
+		svSetValueStr (ifcfg, "DEVICETYPE", TYPE_TEAM_PORT);
+	else
+		svUnsetValue (ifcfg, "DEVICETYPE");
+
+	/* secondary connection UUIDs */
+	svUnsetValue (ifcfg, "SECONDARY_UUIDS");
+	n = nm_setting_connection_get_num_secondaries (s_con);
+	if (n > 0) {
+		str = g_string_sized_new (n * 37);
+
+		for (i = 0; i < n; i++) {
+			const char *uuid;
+
+			/* Items separated by space for consistency with eg
+			 * IPV6ADDR_SECONDARIES and DOMAIN.
+			 */
+			if (str->len)
+				g_string_append_c (str, ' ');
+
+			if ((uuid = nm_setting_connection_get_secondary (s_con, i)) != NULL)
+				g_string_append (str, uuid);
+		}
+		svSetValueStr (ifcfg, "SECONDARY_UUIDS", str->str);
+		g_string_free (str, TRUE);
+	}
+
+	vuint32 = nm_setting_connection_get_gateway_ping_timeout (s_con);
+	svSetValueInt64_cond (ifcfg, "GATEWAY_PING_TIMEOUT",
+	                      vuint32 != 0,
+	                      vuint32);
+
+	switch (nm_setting_connection_get_metered (s_con)) {
+	case NM_METERED_YES:
+		svSetValueStr (ifcfg, "CONNECTION_METERED", "yes");
+		break;
+	case NM_METERED_NO:
+		svSetValueStr (ifcfg, "CONNECTION_METERED", "no");
+		break;
+	default:
+		svUnsetValue (ifcfg, "CONNECTION_METERED");
+	}
+
+	vint = nm_setting_connection_get_auth_retries (s_con);
+	svSetValueInt64_cond (ifcfg, "AUTH_RETRIES", vint >= 0, vint);
+
+	vint32 = nm_setting_connection_get_wait_device_timeout (s_con);
+	if (vint32 == -1)
+		svUnsetValue (ifcfg, "DEVTIMEOUT");
+	else if ((vint32 % 1000) == 0)
+		svSetValueInt64 (ifcfg, "DEVTIMEOUT", vint32 / 1000);
+	else {
+		char b[100];
+
+		svSetValueStr (ifcfg,
+		               "DEVTIMEOUT",
+		               nm_sprintf_buf (b, "%.3f", ((double) vint) / 1000.0));
+	}
+
+	mdns = nm_setting_connection_get_mdns (s_con);
+	if (mdns != NM_SETTING_CONNECTION_MDNS_DEFAULT) {
+		svSetValueEnum (ifcfg, "MDNS", nm_setting_connection_mdns_get_type (),
+		                mdns);
+	} else
+		svUnsetValue (ifcfg, "MDNS");
+
+	llmnr = nm_setting_connection_get_llmnr (s_con);
+	if (llmnr != NM_SETTING_CONNECTION_LLMNR_DEFAULT) {
+		svSetValueEnum (ifcfg, "LLMNR", nm_setting_connection_llmnr_get_type (),
+		                llmnr);
+	} else
+		svUnsetValue (ifcfg, "LLMNR");
+}
+
+static char *
+get_route_attributes_string (NMIPRoute *route, int family)
+{
+	gs_free const char **names = NULL;
+	GVariant *attr, *lock;
+	GString *str;
+	guint i, len;
+
+	names = _nm_ip_route_get_attribute_names (route, TRUE, &len);
+	if (!len)
+		return NULL;
+
+	str = g_string_new ("");
+
+	for (i = 0; i < len; i++) {
+		attr = nm_ip_route_get_attribute (route, names[i]);
+
+		if (!nm_ip_route_attribute_validate (names[i], attr, family, NULL, NULL))
+			continue;
+
+		if (NM_IN_STRSET (names[i], NM_IP_ROUTE_ATTRIBUTE_WINDOW,
+		                            NM_IP_ROUTE_ATTRIBUTE_CWND,
+		                            NM_IP_ROUTE_ATTRIBUTE_INITCWND,
+		                            NM_IP_ROUTE_ATTRIBUTE_INITRWND,
+		                            NM_IP_ROUTE_ATTRIBUTE_MTU)) {
+			char lock_name[256];
+
+			nm_sprintf_buf (lock_name, "lock-%s", names[i]);
+			lock = nm_ip_route_get_attribute (route, lock_name);
+
+			g_string_append_printf (str,
+			                        "%s %s%u",
+			                        names[i],
+			                        (lock && g_variant_get_boolean (lock)) ? "lock " : "",
+			                        g_variant_get_uint32 (attr));
+		} else if (strstr (names[i], "lock-")) {
+			const char *n = &(names[i])[NM_STRLEN ("lock-")];
+
+			attr = nm_ip_route_get_attribute (route, n);
+			if (!attr) {
+				g_string_append_printf (str,
+				                        "%s lock 0",
+				                        n);
+			} else {
+				/* we also have a corresponding attribute with the numeric value. The
+				 * lock setting is handled above. */
+			}
+		} else if (nm_streq (names[i], NM_IP_ROUTE_ATTRIBUTE_TOS)) {
+			g_string_append_printf (str, "%s 0x%02x", names[i], (unsigned) g_variant_get_byte (attr));
+		} else if (nm_streq (names[i], NM_IP_ROUTE_ATTRIBUTE_TABLE)) {
+			g_string_append_printf (str, "%s %u", names[i], (unsigned) g_variant_get_uint32 (attr));
+		} else if (nm_streq (names[i], NM_IP_ROUTE_ATTRIBUTE_ONLINK)) {
+			if (g_variant_get_boolean (attr))
+				g_string_append (str, "onlink");
+		} else if (NM_IN_STRSET (names[i], NM_IP_ROUTE_ATTRIBUTE_SRC,
+		                                   NM_IP_ROUTE_ATTRIBUTE_FROM)) {
+			char *arg = nm_streq (names[i], NM_IP_ROUTE_ATTRIBUTE_SRC) ? "src" : "from";
+
+			g_string_append_printf (str, "%s %s", arg, g_variant_get_string (attr, NULL));
+		} else {
+			g_warn_if_reached ();
+			continue;
+		}
+		if (names[i + 1])
+			g_string_append_c (str, ' ');
+	}
+
+	return g_string_free (str, FALSE);
+}
+
+static shvarFile *
+write_route_file_svformat (const char *filename, NMSettingIPConfig *s_ip4)
+{
+	shvarFile *routefile;
+	guint i, num;
+
+	routefile = utils_get_route_ifcfg (filename, TRUE);
+
+	svUnsetAll (routefile, SV_KEY_TYPE_ROUTE_SVFORMAT);
+
+	num = nm_setting_ip_config_get_num_routes (s_ip4);
+	for (i = 0; i < num; i++) {
+		char buf[INET_ADDRSTRLEN];
+		NMIPRoute *route;
+		guint32 netmask;
+		gint64 metric;
+		char addr_key[64];
+		char gw_key[64];
+		char netmask_key[64];
+		char metric_key[64];
+		char options_key[64];
+		gs_free char *options = NULL;
+
+		numbered_tag (addr_key, "ADDRESS", i);
+		numbered_tag (netmask_key, "NETMASK", i);
+		numbered_tag (gw_key, "GATEWAY", i);
+
+		route = nm_setting_ip_config_get_route (s_ip4, i);
+
+		svSetValueStr (routefile, addr_key, nm_ip_route_get_dest (route));
+
+		netmask = _nm_utils_ip4_prefix_to_netmask (nm_ip_route_get_prefix (route));
+		svSetValueStr (routefile, netmask_key,
+		               nm_utils_inet4_ntop (netmask, buf));
+
+		svSetValueStr (routefile, gw_key, nm_ip_route_get_next_hop (route));
+
+		metric = nm_ip_route_get_metric (route);
+		if (metric != -1) {
+			svSetValueInt64 (routefile,
+			                 numbered_tag (metric_key, "METRIC", i),
+			                 metric);
+		}
+
+		options = get_route_attributes_string (route, AF_INET);
+		if (options) {
+			svSetValueStr (routefile,
+			               numbered_tag (options_key, "OPTIONS", i),
+			               options);
+		}
+	}
+
+	return routefile;
+}
+
+static GString *
+write_route_file (NMSettingIPConfig *s_ip)
+{
+	GString *contents;
+	NMIPRoute *route;
+	guint32 i, num;
+	int addr_family;
+
+	addr_family = nm_setting_ip_config_get_addr_family (s_ip);
+
+	num = nm_setting_ip_config_get_num_routes (s_ip);
+	if (num == 0)
+		return NULL;
+
+	contents = g_string_new ("");
+
+	for (i = 0; i < num; i++) {
+		gs_free char *options = NULL;
+		const char *next_hop;
+		gint64 metric;
+
+		route = nm_setting_ip_config_get_route (s_ip, i);
+		next_hop = nm_ip_route_get_next_hop (route);
+		metric = nm_ip_route_get_metric (route);
+		options = get_route_attributes_string (route, addr_family);
+
+		g_string_append_printf (contents, "%s/%u",
+		                        nm_ip_route_get_dest (route),
+		                        nm_ip_route_get_prefix (route));
+		if (next_hop)
+			g_string_append_printf (contents, " via %s", next_hop);
+		if (metric >= 0)
+			g_string_append_printf (contents, " metric %u", (guint) metric);
+		if (options) {
+			g_string_append_c (contents, ' ');
+			g_string_append (contents, options);
+		}
+
+		g_string_append_c (contents, '\n');
+	}
+
+	return contents;
+}
+
+static gboolean
+write_proxy_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingProxy *s_proxy;
+	NMSettingProxyMethod method;
+	const char *pac_url, *pac_script;
+
+	s_proxy = nm_connection_get_setting_proxy (connection);
+	if (!s_proxy)
+		return TRUE;
+
+	svUnsetValue (ifcfg, "BROWSER_ONLY");
+	svUnsetValue (ifcfg, "PAC_URL");
+	svUnsetValue (ifcfg, "PAC_SCRIPT");
+
+	method = nm_setting_proxy_get_method (s_proxy);
+	switch (method) {
+	case NM_SETTING_PROXY_METHOD_AUTO:
+		svSetValueStr (ifcfg, "PROXY_METHOD", "auto");
+
+		pac_url = nm_setting_proxy_get_pac_url (s_proxy);
+		if (pac_url)
+			svSetValueStr (ifcfg, "PAC_URL", pac_url);
+
+		pac_script = nm_setting_proxy_get_pac_script (s_proxy);
+		if (pac_script)
+			svSetValueStr (ifcfg, "PAC_SCRIPT", pac_script);
+
+		break;
+	case NM_SETTING_PROXY_METHOD_NONE:
+		svSetValueStr (ifcfg, "PROXY_METHOD", "none");
+		break;
+	}
+
+	svSetValueBoolean (ifcfg, "BROWSER_ONLY", nm_setting_proxy_get_browser_only (s_proxy));
+
+	return TRUE;
+}
+
+static gboolean
+write_user_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingUser *s_user;
+	guint i, len;
+	const char *const*keys;
+
+	s_user = NM_SETTING_USER (nm_connection_get_setting (connection, NM_TYPE_SETTING_USER));
+
+	svUnsetAll (ifcfg, SV_KEY_TYPE_USER);
+
+	if (!s_user)
+		return TRUE;
+
+	keys = nm_setting_user_get_keys (s_user, &len);
+	if (len) {
+		nm_auto_free_gstring GString *str = g_string_sized_new (100);
+
+		for (i = 0; i < len; i++) {
+			const char *key = keys[i];
+
+			g_string_set_size (str, 0);
+			g_string_append (str, "NM_USER_");
+			nms_ifcfg_rh_utils_user_key_encode (key, str);
+			svSetValue (ifcfg,
+			            str->str,
+			            nm_setting_user_get_data (s_user, key));
+		}
+	}
+
+	return TRUE;
+}
+
+static void
+write_sriov_setting (NMConnection *connection, shvarFile *ifcfg)
+{
+	NMSettingSriov *s_sriov;
+	guint i, num = 0;
+	NMTernary b;
+	NMSriovVF *vf;
+	char key[32];
+	char *str;
+
+	svUnsetAll (ifcfg, SV_KEY_TYPE_SRIOV_VF);
+
+	s_sriov = NM_SETTING_SRIOV (nm_connection_get_setting (connection,
+	                                                       NM_TYPE_SETTING_SRIOV));
+	if (!s_sriov) {
+		svUnsetValue (ifcfg, "SRIOV_TOTAL_VFS");
+		svUnsetValue (ifcfg, "SRIOV_AUTOPROBE_DRIVERS");
+		return;
+	}
+
+	svSetValueInt64 (ifcfg, "SRIOV_TOTAL_VFS", nm_setting_sriov_get_total_vfs (s_sriov));
+
+	b = nm_setting_sriov_get_autoprobe_drivers (s_sriov);
+	if (b != NM_TERNARY_DEFAULT)
+		svSetValueInt64 (ifcfg, "SRIOV_AUTOPROBE_DRIVERS", b);
+	else
+		svUnsetValue (ifcfg, "SRIOV_AUTOPROBE_DRIVERS");
+
+	num = nm_setting_sriov_get_num_vfs (s_sriov);
+	for (i = 0; i < num; i++) {
+		vf = nm_setting_sriov_get_vf (s_sriov, i);
+		nm_sprintf_buf (key, "SRIOV_VF%u", nm_sriov_vf_get_index (vf));
+		str = nm_utils_sriov_vf_to_str (vf, TRUE, NULL);
+		svSetValueStr (ifcfg, key, str);
+		g_free (str);
+	}
+}
+
+static gboolean
+write_tc_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingTCConfig *s_tc;
+	guint i, num, n;
+	char tag[64];
+
+	svUnsetAll (ifcfg, SV_KEY_TYPE_TC);
+
+	s_tc = nm_connection_get_setting_tc_config (connection);
+	if (!s_tc)
+		return TRUE;
+
+	num = nm_setting_tc_config_get_num_qdiscs (s_tc);
+	for (n = 1, i = 0; i < num; i++) {
+		NMTCQdisc *qdisc;
+		gs_free char *str = NULL;
+
+		qdisc = nm_setting_tc_config_get_qdisc (s_tc, i);
+		str = nm_utils_tc_qdisc_to_str (qdisc, error);
+		if (!str)
+			return FALSE;
+
+		svSetValueStr (ifcfg, numbered_tag (tag, "QDISC", n), str);
+		n++;
+	}
+
+	num = nm_setting_tc_config_get_num_tfilters (s_tc);
+	for (n = 1, i = 0; i < num; i++) {
+		NMTCTfilter *tfilter;
+		gs_free char *str = NULL;
+
+		tfilter = nm_setting_tc_config_get_tfilter (s_tc, i);
+		str = nm_utils_tc_tfilter_to_str (tfilter, error);
+		if (!str)
+			return FALSE;
+
+		svSetValueStr (ifcfg, numbered_tag (tag, "FILTER", n), str);
+		n++;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+write_match_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingMatch *s_match;
+	nm_auto_free_gstring GString *str = NULL;
+	guint i, num;
+
+	svUnsetValue (ifcfg, "MATCH_INTERFACE_NAME");
+
+	s_match = (NMSettingMatch *) nm_connection_get_setting (connection, NM_TYPE_SETTING_MATCH);
+	if (!s_match)
+		return TRUE;
+
+	num = nm_setting_match_get_num_interface_names (s_match);
+	for (i = 0; i < num; i++) {
+		const char *name;
+
+		name = nm_setting_match_get_interface_name (s_match, i);
+		if (!name || !name[0])
+			continue;
+
+		if (!str)
+			str = g_string_new ("");
+		else
+			g_string_append_c (str, ' ');
+		nm_utils_escaped_tokens_escape_gstr (name, NM_ASCII_SPACES, str);
+	}
+
+	if (str)
+		svSetValueStr (ifcfg, "MATCH_INTERFACE_NAME", str->str);
+
+	return TRUE;
+}
+
+static void
+write_res_options (shvarFile *ifcfg, NMSettingIPConfig *s_ip, const char *var)
+{
+	nm_auto_free_gstring GString *value = NULL;
+	guint i, num_options;
+
+	if (!nm_setting_ip_config_has_dns_options (s_ip)) {
+		svUnsetValue (ifcfg, var);
+		return;
+	}
+
+	value = g_string_new (NULL);
+	num_options = nm_setting_ip_config_get_num_dns_options (s_ip);
+	for (i = 0; i < num_options; i++) {
+		if (i > 0)
+			g_string_append_c (value, ' ');
+		g_string_append (value, nm_setting_ip_config_get_dns_option (s_ip, i));
+	}
+
+	svSetValue (ifcfg, var, value->str);
+}
+
+static gboolean
+write_ip4_setting (NMConnection *connection,
+                   shvarFile *ifcfg,
+                   shvarFile **out_route_content_svformat,
+                   GString **out_route_content,
+                   GError **error)
+{
+	NMSettingIPConfig *s_ip4;
+	const char *value;
+	char *tmp;
+	char tag[64];
+	int j;
+	guint i, num, n;
+	gint64 route_metric;
+	NMIPRouteTableSyncMode route_table;
+	int priority;
+	int timeout;
+	GString *searches;
+	const char *method = NULL;
+	gboolean has_netmask;
+
+	NM_SET_OUT (out_route_content_svformat, NULL);
+	NM_SET_OUT (out_route_content, NULL);
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (!s_ip4) {
+		/* slave-type: clear IPv4 settings.
+		 *
+		 * Some IPv4 setting related options are not cleared,
+		 * for no strong reason. */
+		svUnsetValue (ifcfg, "BOOTPROTO");
+		svUnsetValue (ifcfg, "RES_OPTIONS");
+		svUnsetAll (ifcfg, SV_KEY_TYPE_IP4_ADDRESS);
+		return TRUE;
+	}
+
+	method = nm_setting_ip_config_get_method (s_ip4);
+
+	/* Missing IP4 setting is assumed to be DHCP */
+	if (!method)
+		method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+
+	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED)) {
+		/* IPv4 disabled, clear IPv4 related parameters */
+		svUnsetValue (ifcfg, "BOOTPROTO");
+		for (j = -1; j < 256; j++) {
+			svUnsetValue (ifcfg, numbered_tag (tag, "IPADDR", j));
+			svUnsetValue (ifcfg, numbered_tag (tag, "PREFIX", j));
+			svUnsetValue (ifcfg, numbered_tag (tag, "NETMASK", j));
+			svUnsetValue (ifcfg, numbered_tag (tag, "GATEWAY", j));
+		}
+		return TRUE;
+	}
+
+	num = nm_setting_ip_config_get_num_addresses (s_ip4);
+
+	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO))
+		svSetValueStr (ifcfg, "BOOTPROTO", "dhcp");
+	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)) {
+		/* Preserve the archaic form of "static" if there actually
+		 * is static configuration. */
+		if (g_strcmp0 (svGetValue (ifcfg, "BOOTPROTO", &tmp), "static") || !num)
+			svSetValueStr (ifcfg, "BOOTPROTO", "none");
+		g_free (tmp);
+	} else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
+		svSetValueStr (ifcfg, "BOOTPROTO", "autoip");
+	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED))
+		svSetValueStr (ifcfg, "BOOTPROTO", "shared");
+
+	has_netmask = !!svFindFirstKeyWithPrefix (ifcfg, "NETMASK");
+
+	/* Write out IPADDR<n>, PREFIX<n>, GATEWAY<n> for current IP addresses
+	 * without labels. Unset obsolete NETMASK<n>.
+	 */
+	for (i = n = 0; i < num; i++) {
+		NMIPAddress *addr;
+		guint prefix;
+
+		addr = nm_setting_ip_config_get_address (s_ip4, i);
+
+		if (i > 0) {
+			GVariant *label;
+
+			label = nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL);
+			if (label)
+				continue;
+		}
+
+		if (n == 0) {
+			/* Instead of index 0 use un-numbered variables.
+			 * It's needed for compatibility with ifup that only recognizes 'GATEAWAY'
+			 * See https://bugzilla.redhat.com/show_bug.cgi?id=771673
+			 * and https://bugzilla.redhat.com/show_bug.cgi?id=1105770
+			 */
+			j = -1;
+		} else
+			j = n;
+
+		svSetValueStr (ifcfg,
+		               numbered_tag (tag, "IPADDR", j),
+		               nm_ip_address_get_address (addr));
+
+		prefix = nm_ip_address_get_prefix (addr);
+		svSetValueInt64 (ifcfg, numbered_tag (tag, "PREFIX", j), prefix);
+
+		/* If the legacy "NETMASK" is present, keep it. */
+		numbered_tag (tag, "NETMASK", j);
+		if (has_netmask) {
+			char buf[INET_ADDRSTRLEN];
+
+			svSetValueStr (ifcfg, tag,
+			               nm_utils_inet4_ntop (_nm_utils_ip4_prefix_to_netmask (prefix), buf));
+		} else
+			svUnsetValue (ifcfg, tag);
+
+		n++;
+	}
+
+	svUnsetValue (ifcfg, numbered_tag (tag, "IPADDR", 0));
+	svUnsetValue (ifcfg, numbered_tag (tag, "PREFIX", 0));
+	svUnsetValue (ifcfg, numbered_tag (tag, "NETMASK", 0));
+	if (n == 0) {
+		svUnsetValue (ifcfg, "IPADDR");
+		svUnsetValue (ifcfg, "PREFIX");
+		svUnsetValue (ifcfg, "NETMASK");
+	}
+	for (j = n; j < 256; j++) {
+		svUnsetValue (ifcfg, numbered_tag (tag, "IPADDR", j));
+		svUnsetValue (ifcfg, numbered_tag (tag, "PREFIX", j));
+		svUnsetValue (ifcfg, numbered_tag (tag, "NETMASK", j));
+	}
+
+	for (j = -1; j < 256; j++) {
+		if (j != 0)
+			svUnsetValue (ifcfg, numbered_tag (tag, "GATEWAY", j));
+	}
+	svSetValueStr (ifcfg, "GATEWAY", nm_setting_ip_config_get_gateway (s_ip4));
+
+	num = nm_setting_ip_config_get_num_dns (s_ip4);
+	for (i = 0; i < 254; i++) {
+		const char *dns;
+
+		numbered_tag (tag, "DNS", i + 1);
+		if (i >= num)
+			svUnsetValue (ifcfg, tag);
+		else {
+			dns = nm_setting_ip_config_get_dns (s_ip4, i);
+			svSetValueStr (ifcfg, tag, dns);
+		}
+	}
+
+	num = nm_setting_ip_config_get_num_dns_searches (s_ip4);
+	if (num > 0) {
+		searches = g_string_new (NULL);
+		for (i = 0; i < num; i++) {
+			if (i > 0)
+				g_string_append_c (searches, ' ');
+			g_string_append (searches, nm_setting_ip_config_get_dns_search (s_ip4, i));
+		}
+		svSetValueStr (ifcfg, "DOMAIN", searches->str);
+		g_string_free (searches, TRUE);
+	} else
+		svUnsetValue (ifcfg, "DOMAIN");
+
+	/* DEFROUTE; remember that it has the opposite meaning from never-default */
+	svSetValueBoolean (ifcfg, "DEFROUTE", !nm_setting_ip_config_get_never_default (s_ip4));
+
+	/* Missing PEERDNS means TRUE, so write it only when is FALSE */
+	svSetValueStr (ifcfg, "PEERDNS",
+	               nm_setting_ip_config_get_ignore_auto_dns (s_ip4) ? "no" : NULL);
+	/* Missing PEERROUTES means TRUE, so write it only when is FALSE */
+	svSetValueStr (ifcfg, "PEERROUTES",
+	               nm_setting_ip_config_get_ignore_auto_routes (s_ip4) ? "no" : NULL);
+
+	value = nm_setting_ip_config_get_dhcp_hostname (s_ip4);
+	svSetValueStr (ifcfg, "DHCP_HOSTNAME", value);
+
+	value = nm_setting_ip4_config_get_dhcp_fqdn (NM_SETTING_IP4_CONFIG (s_ip4));
+	svSetValueStr (ifcfg, "DHCP_FQDN", value);
+
+	/* Missing DHCP_SEND_HOSTNAME means TRUE, and we prefer not write it explicitly
+	 * in that case, because it is NM-specific variable
+	 */
+	svSetValueStr (ifcfg, "DHCP_SEND_HOSTNAME",
+	               nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) ? NULL : "no");
+
+	value = nm_setting_ip4_config_get_dhcp_client_id (NM_SETTING_IP4_CONFIG (s_ip4));
+	svSetValueStr (ifcfg, "DHCP_CLIENT_ID", value);
+
+	timeout = nm_setting_ip_config_get_dhcp_timeout (s_ip4);
+	svSetValueInt64_cond (ifcfg,
+	                      "IPV4_DHCP_TIMEOUT",
+	                      timeout != 0,
+	                      timeout);
+
+	svSetValueBoolean (ifcfg, "IPV4_FAILURE_FATAL", !nm_setting_ip_config_get_may_fail (s_ip4));
+
+	route_metric = nm_setting_ip_config_get_route_metric (s_ip4);
+	svSetValueInt64_cond (ifcfg,
+	                      "IPV4_ROUTE_METRIC",
+	                      route_metric != -1,
+	                      route_metric);
+
+	route_table = nm_setting_ip_config_get_route_table (s_ip4);
+	svSetValueInt64_cond (ifcfg,
+	                      "IPV4_ROUTE_TABLE",
+	                      route_table != 0,
+	                      route_table);
+
+	NM_SET_OUT (out_route_content_svformat, write_route_file_svformat (svFileGetName (ifcfg), s_ip4));
+	NM_SET_OUT (out_route_content, write_route_file (s_ip4));
+
+	timeout = nm_setting_ip_config_get_dad_timeout (s_ip4);
+	if (timeout < 0) {
+		svUnsetValue (ifcfg, "ACD_TIMEOUT");
+		svUnsetValue (ifcfg, "ARPING_WAIT");
+	} else if (timeout == 0) {
+		svSetValueStr (ifcfg, "ACD_TIMEOUT", "0");
+		svSetValueStr (ifcfg, "ARPING_WAIT", "0");
+	} else {
+		svSetValueInt64 (ifcfg, "ACD_TIMEOUT", timeout);
+		/* Round the value up to next integer for initscripts */
+		svSetValueInt64 (ifcfg, "ARPING_WAIT", (timeout - 1) / 1000 + 1);
+	}
+
+	priority = nm_setting_ip_config_get_dns_priority (s_ip4);
+	if (priority)
+		svSetValueInt64 (ifcfg, "IPV4_DNS_PRIORITY", priority);
+	else
+		svUnsetValue (ifcfg, "IPV4_DNS_PRIORITY");
+
+	write_res_options (ifcfg, s_ip4, "RES_OPTIONS");
+
+	return TRUE;
+}
+
+static void
+write_ip4_aliases (NMConnection *connection, const char *base_ifcfg_path)
+{
+	NMSettingIPConfig *s_ip4;
+	gs_free char *base_ifcfg_dir = NULL, *base_ifcfg_name = NULL;
+	const char *base_name;
+	int i, num, base_ifcfg_name_len, base_name_len;
+	GDir *dir;
+
+	base_ifcfg_dir = g_path_get_dirname (base_ifcfg_path);
+	base_ifcfg_name = g_path_get_basename (base_ifcfg_path);
+	base_ifcfg_name_len = strlen (base_ifcfg_name);
+	if (!g_str_has_prefix (base_ifcfg_name, IFCFG_TAG))
+		g_return_if_reached ();
+	base_name = base_ifcfg_name + strlen (IFCFG_TAG);
+	base_name_len = strlen (base_name);
+
+	/* Remove all existing aliases for this file first */
+	dir = g_dir_open (base_ifcfg_dir, 0, NULL);
+	if (dir) {
+		const char *item;
+
+		while ((item = g_dir_read_name (dir))) {
+			char *full_path;
+
+			if (   strncmp (item, base_ifcfg_name, base_ifcfg_name_len) != 0
+			    || item[base_ifcfg_name_len] != ':')
+				continue;
+
+			full_path = g_build_filename (base_ifcfg_dir, item, NULL);
+			unlink (full_path);
+			g_free (full_path);
+		}
+
+		g_dir_close (dir);
+	}
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (!s_ip4) {
+		/* slave-type: no alias files */
+		return;
+	}
+
+	num = nm_setting_ip_config_get_num_addresses (s_ip4);
+	for (i = 0; i < num; i++) {
+		GVariant *label_var;
+		const char *label, *p;
+		char *path;
+		NMIPAddress *addr;
+		shvarFile *ifcfg;
+
+		addr = nm_setting_ip_config_get_address (s_ip4, i);
+
+		label_var = nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL);
+		if (!label_var)
+			continue;
+		label = g_variant_get_string (label_var, NULL);
+		if (   strncmp (label, base_name, base_name_len) != 0
+		    || label[base_name_len] != ':')
+			continue;
+
+		for (p = label; *p; p++) {
+			if (!g_ascii_isalnum (*p) && *p != '_' && *p != ':')
+				break;
+		}
+		if (*p)
+			continue;
+
+		path = g_strdup_printf ("%s%s", base_ifcfg_path, label + base_name_len);
+		ifcfg = svCreateFile (path);
+		g_free (path);
+
+		svSetValueStr (ifcfg, "DEVICE", label);
+
+		addr = nm_setting_ip_config_get_address (s_ip4, i);
+		svSetValueStr (ifcfg, "IPADDR", nm_ip_address_get_address (addr));
+
+		svSetValueInt64 (ifcfg, "PREFIX", nm_ip_address_get_prefix(addr));
+
+		svWriteFile (ifcfg, 0644, NULL);
+		svCloseFile (ifcfg);
+	}
+}
+
+static void
+write_ip6_setting_dhcp_hostname (NMSettingIPConfig *s_ip6, shvarFile *ifcfg)
+{
+	const char *hostname;
+
+	hostname = nm_setting_ip_config_get_dhcp_hostname (s_ip6);
+	svSetValueStr (ifcfg, "DHCPV6_HOSTNAME", hostname);
+
+	/* Missing DHCPV6_SEND_HOSTNAME means TRUE, and we prefer not write it
+	 * explicitly in that case, because it is NM-specific variable
+	 */
+	if (nm_setting_ip_config_get_dhcp_send_hostname (s_ip6))
+		svUnsetValue (ifcfg, "DHCPV6_SEND_HOSTNAME");
+	else
+		svSetValueStr (ifcfg, "DHCPV6_SEND_HOSTNAME", "no");
+}
+
+static gboolean
+write_ip6_setting (NMConnection *connection,
+                   shvarFile *ifcfg,
+                   GString **out_route6_content,
+                   GError **error)
+{
+	NMSettingIPConfig *s_ip6;
+	NMSettingIPConfig *s_ip4;
+	const char *value;
+	guint i, num, num4;
+	int priority;
+	NMIPAddress *addr;
+	const char *dns;
+	gint64 route_metric;
+	NMIPRouteTableSyncMode route_table;
+	GString *ip_str1, *ip_str2, *ip_ptr;
+	NMSettingIP6ConfigAddrGenMode addr_gen_mode;
+
+	NM_SET_OUT (out_route6_content, NULL);
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	if (!s_ip6) {
+		/* slave-type: clear IPv6 settings
+		 *
+		 * Some IPv6 setting related options are not cleared,
+		 * for no strong reason. */
+		svUnsetValue (ifcfg, "IPV6INIT");
+		svUnsetValue (ifcfg, "IPV6_AUTOCONF");
+		svUnsetValue (ifcfg, "DHCPV6C");
+		svUnsetValue (ifcfg, "DHCPv6_DUID");
+		svUnsetValue (ifcfg, "DHCPV6_HOSTNAME");
+		svUnsetValue (ifcfg, "DHCPV6_SEND_HOSTNAME");
+		svUnsetValue (ifcfg, "IPV6_DEFROUTE");
+		svUnsetValue (ifcfg, "IPV6_PEERDNS");
+		svUnsetValue (ifcfg, "IPV6_PEERROUTES");
+		svUnsetValue (ifcfg, "IPV6_FAILURE_FATAL");
+		svUnsetValue (ifcfg, "IPV6_ROUTE_METRIC");
+		svUnsetValue (ifcfg, "IPV6_ADDR_GEN_MODE");
+		svUnsetValue (ifcfg, "IPV6_RES_OPTIONS");
+		return TRUE;
+	}
+
+	value = nm_setting_ip_config_get_method (s_ip6);
+	g_assert (value);
+	svUnsetValue (ifcfg, "IPV6_DISABLED");
+	if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
+		svSetValueStr (ifcfg, "IPV6INIT", "no");
+		svUnsetValue (ifcfg, "DHCPV6C");
+		return TRUE;
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DISABLED)) {
+		svSetValueStr (ifcfg, "IPV6_DISABLED", "yes");
+		svSetValueStr (ifcfg, "IPV6INIT", "no");
+		svUnsetValue (ifcfg, "DHCPV6C");
+		svUnsetValue (ifcfg, "IPV6_AUTOCONF");
+		return TRUE;
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
+		svSetValueStr (ifcfg, "IPV6INIT", "yes");
+		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "yes");
+		svUnsetValue (ifcfg, "DHCPV6C");
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
+		svSetValueStr (ifcfg, "IPV6INIT", "yes");
+		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "no");
+		svSetValueStr (ifcfg, "DHCPV6C", "yes");
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_MANUAL)) {
+		svSetValueStr (ifcfg, "IPV6INIT", "yes");
+		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "no");
+		svUnsetValue (ifcfg, "DHCPV6C");
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)) {
+		svSetValueStr (ifcfg, "IPV6INIT", "yes");
+		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "no");
+		svUnsetValue (ifcfg, "DHCPV6C");
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
+		svSetValueStr (ifcfg, "IPV6INIT", "yes");
+		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "shared");
+		svUnsetValue (ifcfg, "DHCPV6C");
+	}
+
+	svSetValueStr (ifcfg, "DHCPV6_DUID",
+	               nm_setting_ip6_config_get_dhcp_duid (NM_SETTING_IP6_CONFIG (s_ip6)));
+
+	write_ip6_setting_dhcp_hostname (s_ip6, ifcfg);
+
+	/* Write out IP addresses */
+	num = nm_setting_ip_config_get_num_addresses (s_ip6);
+	ip_str1 = g_string_new (NULL);
+	ip_str2 = g_string_new (NULL);
+	for (i = 0; i < num; i++) {
+		if (i == 0)
+			ip_ptr = ip_str1;
+		else
+			ip_ptr = ip_str2;
+
+		addr = nm_setting_ip_config_get_address (s_ip6, i);
+
+		if (i > 1)
+			g_string_append_c (ip_ptr, ' ');  /* separate addresses in IPV6ADDR_SECONDARIES */
+		g_string_append_printf (ip_ptr, "%s/%u",
+		                        nm_ip_address_get_address (addr),
+		                        nm_ip_address_get_prefix (addr));
+	}
+	svSetValueStr (ifcfg, "IPV6ADDR", ip_str1->str);
+	svSetValueStr (ifcfg, "IPV6ADDR_SECONDARIES", ip_str2->str);
+	svSetValueStr (ifcfg, "IPV6_DEFAULTGW", nm_setting_ip_config_get_gateway (s_ip6));
+	g_string_free (ip_str1, TRUE);
+	g_string_free (ip_str2, TRUE);
+
+	/* Write out DNS - 'DNS' key is used both for IPv4 and IPv6 */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	num4 = s_ip4 ? nm_setting_ip_config_get_num_dns (s_ip4) : 0; /* from where to start with IPv6 entries */
+	num = nm_setting_ip_config_get_num_dns (s_ip6);
+	for (i = 0; i < 254; i++) {
+		char tag[64];
+
+		numbered_tag (tag, "DNS", i + num4 + 1);
+
+		if (i >= num)
+			svUnsetValue (ifcfg, tag);
+		else {
+			dns = nm_setting_ip_config_get_dns (s_ip6, i);
+			svSetValueStr (ifcfg, tag, dns);
+		}
+	}
+
+	/* Write out DNS domains */
+	num = nm_setting_ip_config_get_num_dns_searches (s_ip6);
+	if (num > 0) {
+		nm_auto_free_gstring GString *searches = NULL;
+
+		searches = g_string_new (NULL);
+		for (i = 0; i < num; i++) {
+			if (searches->len > 0)
+				g_string_append_c (searches, ' ');
+			g_string_append (searches, nm_setting_ip_config_get_dns_search (s_ip6, i));
+		}
+		svSetValueStr (ifcfg, "IPV6_DOMAIN", searches->str);
+	} else
+		svUnsetValue (ifcfg, "IPV6_DOMAIN");
+
+	/* handle IPV6_DEFROUTE */
+	/* IPV6_DEFROUTE has the opposite meaning from 'never-default' */
+	if (nm_setting_ip_config_get_never_default (s_ip6))
+		svSetValueStr (ifcfg, "IPV6_DEFROUTE", "no");
+	else
+		svSetValueStr (ifcfg, "IPV6_DEFROUTE", "yes");
+
+	svSetValueStr (ifcfg, "IPV6_PEERDNS",
+	               nm_setting_ip_config_get_ignore_auto_dns (s_ip6) ? "no" : NULL);
+
+	svSetValueStr (ifcfg, "IPV6_PEERROUTES",
+	               nm_setting_ip_config_get_ignore_auto_routes (s_ip6) ? "no" : NULL);
+
+	svSetValueStr (ifcfg, "IPV6_FAILURE_FATAL",
+	               nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes");
+
+	route_metric = nm_setting_ip_config_get_route_metric (s_ip6);
+	svSetValueInt64_cond (ifcfg,
+	                      "IPV6_ROUTE_METRIC",
+	                      route_metric != -1,
+	                      route_metric);
+
+	route_table = nm_setting_ip_config_get_route_table (s_ip6);
+	svSetValueInt64_cond (ifcfg,
+	                      "IPV6_ROUTE_TABLE",
+	                      route_table != 0,
+	                      route_table);
+
+	/* IPv6 Privacy Extensions */
+	svUnsetValue (ifcfg, "IPV6_PRIVACY");
+	svUnsetValue (ifcfg, "IPV6_PRIVACY_PREFER_PUBLIC_IP");
+	switch (nm_setting_ip6_config_get_ip6_privacy (NM_SETTING_IP6_CONFIG (s_ip6))) {
+	case NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED:
+		svSetValueStr (ifcfg, "IPV6_PRIVACY", "no");
+	break;
+	case NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR:
+		svSetValueStr (ifcfg, "IPV6_PRIVACY", "rfc3041");
+		svSetValueStr (ifcfg, "IPV6_PRIVACY_PREFER_PUBLIC_IP", "yes");
+	break;
+	case NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR:
+		svSetValueStr (ifcfg, "IPV6_PRIVACY", "rfc3041");
+	break;
+	default:
+	break;
+	}
+
+	/* IPv6 Address generation mode */
+	addr_gen_mode = nm_setting_ip6_config_get_addr_gen_mode (NM_SETTING_IP6_CONFIG (s_ip6));
+	if (addr_gen_mode != NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64) {
+		svSetValueEnum (ifcfg, "IPV6_ADDR_GEN_MODE", nm_setting_ip6_config_addr_gen_mode_get_type (),
+		                addr_gen_mode);
+	} else {
+		svUnsetValue (ifcfg, "IPV6_ADDR_GEN_MODE");
+	}
+
+	/* IPv6 tokenized interface identifier */
+	value = nm_setting_ip6_config_get_token (NM_SETTING_IP6_CONFIG (s_ip6));
+	svSetValueStr (ifcfg, "IPV6_TOKEN", value);
+
+	priority = nm_setting_ip_config_get_dns_priority (s_ip6);
+	if (priority)
+		svSetValueInt64 (ifcfg, "IPV6_DNS_PRIORITY", priority);
+	else
+		svUnsetValue (ifcfg, "IPV6_DNS_PRIORITY");
+
+	write_res_options (ifcfg, s_ip6, "IPV6_RES_OPTIONS");
+
+	NM_SET_OUT (out_route6_content, write_route_file (s_ip6));
+
+	return TRUE;
+}
+
+static void
+write_ip_routing_rules (NMConnection *connection,
+                        shvarFile *ifcfg,
+                        gboolean route_ignore)
+{
+	gsize idx;
+	int is_ipv4;
+
+	svUnsetAll (ifcfg, SV_KEY_TYPE_ROUTING_RULE4 | SV_KEY_TYPE_ROUTING_RULE6);
+
+	if (route_ignore)
+		return;
+
+	idx = 0;
+
+	for (is_ipv4 = 1; is_ipv4 >= 0; is_ipv4--) {
+		const int addr_family = is_ipv4 ? AF_INET : AF_INET6;
+		NMSettingIPConfig *s_ip;
+		guint i, num;
+
+		s_ip = nm_connection_get_setting_ip_config (connection, addr_family);
+		if (!s_ip)
+			continue;
+
+		num = nm_setting_ip_config_get_num_routing_rules (s_ip);
+		for (i = 0; i < num; i++) {
+			NMIPRoutingRule *rule = nm_setting_ip_config_get_routing_rule (s_ip, i);
+			gs_free const char *s = NULL;
+			char key[64];
+
+			s = nm_ip_routing_rule_to_string (rule,
+			                                  NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE,
+			                                  NULL,
+			                                  NULL);
+			if (!s)
+				continue;
+
+			if (is_ipv4)
+				numbered_tag (key, "ROUTING_RULE_", ++idx);
+			else
+				numbered_tag (key, "ROUTING_RULE6_", ++idx);
+			svSetValueStr (ifcfg, key, s);
+		}
+	}
+}
+
+static char *
+escape_id (const char *id)
+{
+	char *escaped = g_strdup (id);
+	char *p = escaped;
+
+	/* Escape random stuff */
+	while (*p) {
+		if (*p == ' ')
+			*p = '_';
+		else if (strchr ("\\][|/=()!:", *p))
+			*p = '-';
+		p++;
+	}
+
+	return escaped;
+}
+
+static gboolean
+do_write_construct (NMConnection *connection,
+                    const char *ifcfg_dir,
+                    const char *filename,
+                    NMSIfcfgRHWriterAllowFilenameCb allow_filename_cb,
+                    gpointer allow_filename_user_data,
+                    shvarFile **out_ifcfg,
+                    GHashTable **out_blobs,
+                    GHashTable **out_secrets,
+                    gboolean *out_route_ignore,
+                    shvarFile **out_route_content_svformat,
+                    GString **out_route_content,
+                    GString **out_route6_content,
+                    GError **error)
+{
+	NMSettingConnection *s_con;
+	nm_auto_shvar_file_close shvarFile *ifcfg = NULL;
+	gs_free char *ifcfg_name = NULL;
+	gs_free char *route_path = NULL;
+	gs_free char *route6_path = NULL;
+	const char *type;
+	gs_unref_hashtable GHashTable *blobs = NULL;
+	gs_unref_hashtable GHashTable *secrets = NULL;
+	gboolean wired;
+	gboolean no_8021x;
+	gboolean route_path_is_svformat;
+	gboolean has_complex_routes_v4;
+	gboolean has_complex_routes_v6;
+	gboolean route_ignore;
+	nm_auto_shvar_file_close shvarFile *route_content_svformat = NULL;
+	nm_auto_free_gstring GString *route_content = NULL;
+	nm_auto_free_gstring GString *route6_content = NULL;
+
+	nm_assert (NM_IS_CONNECTION (connection));
+	nm_assert (_nm_connection_verify (connection, NULL) == NM_SETTING_VERIFY_SUCCESS);
+
+	if (!nms_ifcfg_rh_writer_can_write_connection (connection, error))
+		return FALSE;
+
+	s_con = nm_connection_get_setting_connection (connection);
+
+	if (filename) {
+		/* For existing connections, 'filename' should be full path to ifcfg file */
+		ifcfg = svOpenFile (filename, error);
+		if (!ifcfg)
+			return FALSE;
+
+		ifcfg_name = g_strdup (filename);
+	} else if (ifcfg_dir) {
+		gs_free char *escaped = NULL;
+		int i_path;
+
+		escaped = escape_id (nm_setting_connection_get_id (s_con));
+
+		for (i_path = 0; i_path < 10000; i_path++) {
+			gs_free char *path_candidate = NULL;
+
+			if (i_path == 0)
+				path_candidate = g_strdup_printf ("%s/ifcfg-%s", ifcfg_dir, escaped);
+			else
+				path_candidate = g_strdup_printf ("%s/ifcfg-%s-%d", ifcfg_dir, escaped, i_path);
+
+			if (   allow_filename_cb
+			    && !allow_filename_cb (path_candidate, allow_filename_user_data))
+				continue;
+
+			if (g_file_test (path_candidate, G_FILE_TEST_EXISTS))
+				continue;
+
+			ifcfg_name = g_steal_pointer (&path_candidate);
+			break;
+		}
+
+		if (!ifcfg_name) {
+			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			                     "Failed to find usable ifcfg file name");
+			return FALSE;
+		}
+
+		ifcfg = svCreateFile (ifcfg_name);
+	} else
+		ifcfg = svCreateFile ("/tmp/ifcfg-dummy");
+
+	route_path = utils_get_route_path (svFileGetName (ifcfg));
+	if (!route_path) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Could not get route file path for '%s'", svFileGetName (ifcfg));
+		return FALSE;
+	}
+
+	route6_path = utils_get_route6_path (svFileGetName (ifcfg));
+	if (!route6_path) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Could not get route6 file path for '%s'", svFileGetName (ifcfg));
+		return FALSE;
+	}
+
+	type = nm_setting_connection_get_connection_type (s_con);
+	if (!type) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing connection type!");
+		return FALSE;
+	}
+
+	secrets = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, g_free);
+
+	wired = FALSE;
+	no_8021x = FALSE;
+	if (!strcmp (type, NM_SETTING_WIRED_SETTING_NAME)) {
+		// FIXME: can't write PPPoE at this time
+		if (nm_connection_get_setting_pppoe (connection)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Can't write connection type '%s'",
+			             NM_SETTING_PPPOE_SETTING_NAME);
+			return FALSE;
+		}
+
+		if (!write_wired_setting (connection, ifcfg, error))
+			return FALSE;
+		wired = TRUE;
+	} else if (!strcmp (type, NM_SETTING_VLAN_SETTING_NAME)) {
+		if (!write_vlan_setting (connection, ifcfg, &wired, error))
+			return FALSE;
+	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
+		if (!write_wireless_setting (connection, ifcfg, secrets, &no_8021x, error))
+			return FALSE;
+	} else if (!strcmp (type, NM_SETTING_INFINIBAND_SETTING_NAME)) {
+		if (!write_infiniband_setting (connection, ifcfg, error))
+			return FALSE;
+	} else if (!strcmp (type, NM_SETTING_BOND_SETTING_NAME)) {
+		if (!write_bond_setting (connection, ifcfg, &wired, error))
+			return FALSE;
+	} else if (!strcmp (type, NM_SETTING_TEAM_SETTING_NAME)) {
+		if (!write_team_setting (connection, ifcfg, &wired, error))
+			return FALSE;
+	} else if (!strcmp (type, NM_SETTING_BRIDGE_SETTING_NAME)) {
+		if (!write_bridge_setting (connection, ifcfg, &wired, error))
+			return FALSE;
+	} else {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Can't write connection type '%s'", type);
+		return FALSE;
+	}
+
+	if (!no_8021x) {
+		blobs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, (GDestroyNotify) g_bytes_unref);
+		if (!write_8021x_setting (connection, ifcfg, secrets, blobs, wired, error))
+			return FALSE;
+	}
+
+	if (!write_bridge_port_setting (connection, ifcfg, error))
+		return FALSE;
+
+	if (!write_team_port_setting (connection, ifcfg, error))
+		return FALSE;
+
+	if (!write_dcb_setting (connection, ifcfg, error))
+		return FALSE;
+
+	if (!write_proxy_setting (connection, ifcfg, error))
+		return FALSE;
+
+	if (!write_ethtool_setting (connection, ifcfg, error))
+		return FALSE;
+
+	if (!write_user_setting (connection, ifcfg, error))
+		return FALSE;
+
+	if (!write_match_setting (connection, ifcfg, error))
+		return FALSE;
+
+	write_sriov_setting (connection, ifcfg);
+
+	if (!write_tc_setting (connection, ifcfg, error))
+		return FALSE;
+
+	svUnsetValue (ifcfg, "DHCP_HOSTNAME");
+	svUnsetValue (ifcfg, "DHCP_FQDN");
+
+	route_path_is_svformat = utils_has_route_file_new_syntax (route_path);
+
+	has_complex_routes_v4 = utils_has_complex_routes (ifcfg_name, AF_INET);
+	has_complex_routes_v6 = utils_has_complex_routes (ifcfg_name, AF_INET6);
+
+	if (has_complex_routes_v4 || has_complex_routes_v6) {
+		NMSettingIPConfig *s_ip4, *s_ip6;
+
+		s_ip4 = nm_connection_get_setting_ip4_config (connection);
+		s_ip6 = nm_connection_get_setting_ip6_config (connection);
+		if (   (   s_ip4
+		        && nm_setting_ip_config_get_num_routes (s_ip4) > 0)
+		    || (   s_ip6
+		        && nm_setting_ip_config_get_num_routes (s_ip6) > 0)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Cannot configure static routes on a connection that has an associated 'rule%s-' file",
+			             has_complex_routes_v4 ? "" : "6");
+			return FALSE;
+		}
+		if (   (   s_ip4
+		        && nm_setting_ip_config_get_route_table (s_ip4) != 0)
+		    || (   s_ip6
+		        && nm_setting_ip_config_get_route_table (s_ip6) != 0)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Cannot configure a route table for policy routing on a connection that has an associated 'rule%s-' file",
+			             has_complex_routes_v4 ? "" : "6");
+			return FALSE;
+		}
+		if (   (   s_ip4
+		        && nm_setting_ip_config_get_num_routing_rules (s_ip4) > 0)
+		    || (   s_ip6
+		        && nm_setting_ip_config_get_num_routing_rules (s_ip6) > 0)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Cannot configure routing rules on a connection that has an associated 'rule%s-' file",
+			             has_complex_routes_v4 ? "" : "6");
+			return FALSE;
+		}
+		route_ignore = TRUE;
+	} else
+		route_ignore = FALSE;
+
+	if (!write_ip4_setting (connection,
+	                        ifcfg,
+	                        !route_ignore && route_path_is_svformat ? &route_content_svformat : NULL,
+	                        !route_ignore && route_path_is_svformat ? NULL                      :&route_content,
+	                        error))
+		return FALSE;
+
+	if (!write_ip6_setting (connection,
+	                        ifcfg,
+	                        !route_ignore ? &route6_content : NULL,
+	                        error))
+		return FALSE;
+
+	write_ip_routing_rules (connection,
+	                        ifcfg,
+	                        route_ignore);
+
+	write_connection_setting (s_con, ifcfg);
+
+	NM_SET_OUT (out_ifcfg, g_steal_pointer (&ifcfg));
+	NM_SET_OUT (out_blobs, g_steal_pointer (&blobs));
+	NM_SET_OUT (out_secrets, g_steal_pointer (&secrets));
+	NM_SET_OUT (out_route_ignore, route_ignore);
+	NM_SET_OUT (out_route_content_svformat, g_steal_pointer (&route_content_svformat));
+	NM_SET_OUT (out_route_content, g_steal_pointer (&route_content));
+	NM_SET_OUT (out_route6_content, g_steal_pointer (&route6_content));
+	return TRUE;
+}
+
+static gboolean
+do_write_to_disk (NMConnection *connection,
+                  shvarFile *ifcfg,
+                  GHashTable *blobs,
+                  GHashTable *secrets,
+                  gboolean route_ignore,
+                  shvarFile *route_content_svformat,
+                  GString *route_content,
+                  GString *route6_content,
+                  GError **error)
+{
+	/* From here on, we persist data to disk. Before, it was all in-memory
+	 * only. But we loaded the ifcfg files from disk, and managled our
+	 * new settings (in-memory). */
+
+	if (!svWriteFile (ifcfg, 0644, error))
+		return FALSE;
+
+	write_ip4_aliases (connection, svFileGetName (ifcfg));
+
+	if (!write_blobs (blobs, error))
+		return FALSE;
+
+	if (!write_secrets (ifcfg, secrets, error))
+		return FALSE;
+
+	if (!route_ignore) {
+		gs_free char *route_path = utils_get_route_path (svFileGetName (ifcfg));
+
+		if (!route_content && !route_content_svformat)
+			(void) unlink (route_path);
+		else {
+			nm_assert (route_content_svformat || route_content);
+			if (route_content_svformat) {
+				if (!svWriteFile (route_content_svformat, 0644, error))
+					return FALSE;
+			} else {
+				if (!g_file_set_contents (route_path, route_content->str, route_content->len, NULL)) {
+					g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+					             "Writing route file '%s' failed", route_path);
+					return FALSE;
+				}
+			}
+		}
+	}
+
+	if (!route_ignore) {
+		gs_free char *route6_path = utils_get_route6_path (svFileGetName (ifcfg));
+
+		if (!route6_content)
+			(void) unlink (route6_path);
+		else {
+			if (!g_file_set_contents (route6_path, route6_content->str, route6_content->len, NULL)) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+				             "Writing route6 file '%s' failed", route6_path);
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+gboolean
+nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
+                                      const char *ifcfg_dir,
+                                      const char *filename,
+                                      NMSIfcfgRHWriterAllowFilenameCb allow_filename_cb,
+                                      gpointer allow_filename_user_data,
+                                      char **out_filename,
+                                      NMConnection **out_reread,
+                                      gboolean *out_reread_same,
+                                      GError **error)
+{
+	nm_auto_shvar_file_close shvarFile *ifcfg = NULL;
+	nm_auto_free_gstring GString *route_content = NULL;
+	gboolean route_ignore = FALSE;
+	nm_auto_shvar_file_close shvarFile *route_content_svformat = NULL;
+	nm_auto_free_gstring GString *route6_content = NULL;
+	gs_unref_hashtable GHashTable *secrets = NULL;
+	gs_unref_hashtable GHashTable *blobs = NULL;
+
+	nm_assert (!out_reread || !*out_reread);
+
+	if (!do_write_construct (connection,
+	                         ifcfg_dir,
+	                         filename,
+	                         allow_filename_cb,
+	                         allow_filename_user_data,
+	                         &ifcfg,
+	                         &blobs,
+	                         &secrets,
+	                         &route_ignore,
+	                         &route_content_svformat,
+	                         &route_content,
+	                         &route6_content,
+	                         error))
+		return FALSE;
+
+	_LOGT ("write: write connection %s (%s) to file \"%s\"",
+	       nm_connection_get_id (connection),
+	       nm_connection_get_uuid (connection),
+	       svFileGetName (ifcfg));
+
+	if (!do_write_to_disk (connection,
+	                       ifcfg,
+	                       blobs,
+	                       secrets,
+	                       route_ignore,
+	                       route_content_svformat,
+	                       route_content,
+	                       route6_content,
+	                       error))
+		return FALSE;
+
+	/* Note that we just wrote the connection to disk, and re-read it from there.
+	 * That is racy if somebody else modifies the connection.
+	 * That race is why we must not tread a failure to re-read the profile
+	 * as an error.
+	 *
+	 * FIXME: a much better solution might be, to re-read the connection only based
+	 * on the in-memory representation of what we collected above. But the reader
+	 * does not yet allow to inject the configuration. */
+	if (   out_reread
+	    || out_reread_same) {
+		gs_unref_object NMConnection *reread = NULL;
+		gboolean reread_same = FALSE;
+		gs_free_error GError *local = NULL;
+		gs_free char *unhandled = NULL;
+
+		reread = connection_from_file (svFileGetName (ifcfg),
+		                               &unhandled,
+		                               &local,
+		                               NULL);
+		nm_assert ((NM_IS_CONNECTION (reread) && !local) || (!reread && local));
+
+		if (!reread) {
+			_LOGW ("write: failure to re-read connection \"%s\": %s",
+			       svFileGetName (ifcfg), local->message);
+		} else if (unhandled) {
+			g_clear_object (&reread);
+			_LOGW ("write: failure to re-read connection \"%s\": %s",
+			       svFileGetName (ifcfg), "connection is unhandled");
+		} else {
+			if (out_reread_same) {
+				reread_same = nm_connection_compare (reread, connection, NM_SETTING_COMPARE_FLAG_EXACT);
+				if (!reread_same) {
+					_LOGD ("write: connection %s (%s) was modified by persisting it to \"%s\" ",
+					       nm_connection_get_id (connection),
+					       nm_connection_get_uuid (connection),
+					       svFileGetName (ifcfg));
+				}
+			}
+		}
+
+		NM_SET_OUT (out_reread, g_steal_pointer (&reread));
+		NM_SET_OUT (out_reread_same, reread_same);
+	}
+
+	/* Only return the filename if this was a newly written ifcfg */
+	if (out_filename && !filename)
+		*out_filename = g_strdup (svFileGetName (ifcfg));
+
+	return TRUE;
+}
+
+gboolean
+nms_ifcfg_rh_writer_can_write_connection (NMConnection *connection, GError **error)
+{
+	const char *type, *id;
+
+	type = nm_connection_get_connection_type (connection);
+	if (NM_IN_STRSET (type,
+	                  NM_SETTING_VLAN_SETTING_NAME,
+	                  NM_SETTING_WIRELESS_SETTING_NAME,
+	                  NM_SETTING_INFINIBAND_SETTING_NAME,
+	                  NM_SETTING_BOND_SETTING_NAME,
+	                  NM_SETTING_TEAM_SETTING_NAME,
+	                  NM_SETTING_BRIDGE_SETTING_NAME))
+		return TRUE;
+	if (   nm_streq0 (type, NM_SETTING_WIRED_SETTING_NAME)
+	    && !nm_connection_get_setting_pppoe (connection))
+		return TRUE;
+
+	id = nm_connection_get_id (connection);
+	g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+	             "The ifcfg-rh plugin cannot write the connection %s%s%s (type %s%s%s)",
+	             NM_PRINT_FMT_QUOTE_STRING (id),
+	             NM_PRINT_FMT_QUOTE_STRING (type));
+	return FALSE;
+}
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.h b/src/settings/plugins/netplan/nms-netplan-writer.h
new file mode 100644
index 0000000000000000000000000000000000000000..fec844748bc356081946eb832fbb4ee8c213d82a
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-writer.h
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service - keyfile plugin
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ */
+
+#ifndef __NMS_IFCFG_RH_WRITER_H__
+#define __NMS_IFCFG_RH_WRITER_H__
+
+#include "nm-connection.h"
+
+
+typedef gboolean (*NMSIfcfgRHWriterAllowFilenameCb) (const char *check_filename,
+                                                     gpointer allow_filename_user_data);
+
+gboolean nms_ifcfg_rh_writer_can_write_connection (NMConnection *connection,
+                                                   GError **error);
+
+gboolean nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
+                                               const char *ifcfg_dir,
+                                               const char *filename,
+                                               NMSIfcfgRHWriterAllowFilenameCb allow_filename_cb,
+                                               gpointer allow_filename_user_data,
+                                               char **out_filename,
+                                               NMConnection **out_reread,
+                                               gboolean *out_reread_same,
+                                               GError **error);
+
+#endif /* __NMS_IFCFG_RH_WRITER_H__ */
diff --git a/src/settings/plugins/netplan/tests/meson.build b/src/settings/plugins/netplan/tests/meson.build
new file mode 100644
index 0000000000000000000000000000000000000000..dcc18d8b68c2eecf3257bb83ccf3cba201a36e53
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/meson.build
@@ -0,0 +1,17 @@
+test_unit = 'test-netplan'
+
+test_netplan_dir = meson.current_source_dir()
+
+exe = executable(
+  test_unit,
+  test_unit + '.c',
+  dependencies: test_nm_dep,
+  link_with: libnms_netplan_core,
+)
+
+test(
+  'netplan/' + test_unit,
+  test_script,
+  timeout: 90,
+  args: test_args + [exe.full_path()],
+)
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
new file mode 100644
index 0000000000000000000000000000000000000000..3cd571dfcf8e9e66090ef45485ba0193705036f2
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -0,0 +1,10485 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service - keyfile plugin
+ *
+ * Copyright (C) 2008 - 2011 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <linux/pkt_sched.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "nm-utils.h"
+#include "nm-setting-connection.h"
+#include "nm-setting-wired.h"
+#include "nm-setting-user.h"
+#include "nm-setting-wireless.h"
+#include "nm-setting-wireless-security.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-ip6-config.h"
+#include "nm-setting-8021x.h"
+#include "nm-setting-pppoe.h"
+#include "nm-setting-ppp.h"
+#include "nm-setting-vpn.h"
+#include "nm-setting-ethtool.h"
+#include "nm-setting-gsm.h"
+#include "nm-setting-cdma.h"
+#include "nm-setting-serial.h"
+#include "nm-setting-vlan.h"
+#include "nm-setting-dcb.h"
+#include "nm-core-internal.h"
+#include "nm-libnm-core-intern/nm-ethtool-utils.h"
+
+#include "NetworkManagerUtils.h"
+
+#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-common.h"
+#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-reader.h"
+#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-writer.h"
+#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-utils.h"
+
+#include "nm-test-utils-core.h"
+
+#define TEST_IFCFG_DIR          NM_BUILD_SRCDIR"/src/settings/plugins/ifcfg-rh/tests/network-scripts"
+#define TEST_SCRATCH_DIR        NM_BUILD_BUILDDIR"/src/settings/plugins/ifcfg-rh/tests/network-scripts"
+#define TEST_SCRATCH_DIR_TMP    TEST_SCRATCH_DIR"/tmp"
+
+#define TEST_SCRATCH_ALIAS_BASE TEST_SCRATCH_DIR"/ifcfg-alias0"
+
+/*****************************************************************************/
+
+#define _svOpenFile(testfile) \
+	({ \
+		shvarFile *_f; \
+		GError *_error = NULL; \
+		const char *_testfile = (testfile); \
+		\
+		g_assert (_testfile); \
+		_f = svOpenFile (_testfile, &_error); \
+		nmtst_assert_success (_f, _error); \
+		_f; \
+	})
+
+#define _svGetValue_check(f, key, expected_value) \
+	G_STMT_START { \
+		const char *_val; \
+		gs_free char *_to_free = NULL; \
+		gs_free char *_val_string = NULL; \
+		shvarFile *const _f = (f); \
+		const char *const _key = (key); \
+		\
+		_val_string = svGetValueStr_cp (_f, _key); \
+		_val = svGetValue (_f, _key, &_to_free); \
+		g_assert_cmpstr (_val, ==, (expected_value)); \
+		g_assert (   (!_val_string && (!_val || !_val[0])) \
+		          || ( _val_string && nm_streq0 (_val, _val_string))); \
+	} G_STMT_END
+
+static void
+_assert_reread_same (NMConnection *connection, NMConnection *reread)
+{
+	nmtst_assert_connection_verifies_without_normalization (reread);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+_assert_reread_same_FIXME (NMConnection *connection, NMConnection *reread)
+{
+	gs_unref_object NMConnection *connection_normalized = NULL;
+	gs_unref_hashtable GHashTable *settings = NULL;
+
+	/* FIXME: these assertion failures should not happen as we expect
+	 * that re-reading a connection after write yields the same result.
+	 *
+	 * Needs investation and fixing. */
+	nmtst_assert_connection_verifies_without_normalization (reread);
+
+	connection_normalized = nmtst_connection_duplicate_and_normalize (connection);
+
+	g_assert (!nm_connection_compare (connection_normalized, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+	g_assert (!nm_connection_diff (connection_normalized, reread, NM_SETTING_COMPARE_FLAG_EXACT, &settings));
+}
+
+/* dummy path for an "expected" file, meaning: don't check for expected
+ * written ifcfg file. */
+static const char NO_EXPECTED[1];
+
+static void
+_assert_expected_content (NMConnection *connection, const char *filename, const char *expected)
+{
+	gs_free char *content_expectd = NULL;
+	gs_free char *content_written = NULL;
+	GError *error = NULL;
+	gsize len_expectd = 0;
+	gsize len_written = 0;
+	gboolean success;
+	const char *uuid = NULL;
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (filename);
+	g_assert (g_file_test (filename, G_FILE_TEST_EXISTS));
+
+	g_assert (expected);
+	if (expected == NO_EXPECTED)
+		return;
+
+	success = g_file_get_contents (filename, &content_written, &len_written, &error);
+	nmtst_assert_success (success, error);
+
+	success = g_file_get_contents (expected, &content_expectd, &len_expectd, &error);
+	nmtst_assert_success (success, error);
+
+	{
+		gsize i, j;
+
+		for (i = 0; i < len_expectd; ) {
+			if (content_expectd[i] != '$') {
+				i++;
+				continue;
+			}
+			if (g_str_has_prefix (&content_expectd[i], "${UUID}")) {
+				GString *str;
+
+				if (!uuid) {
+					uuid = nm_connection_get_uuid (connection);
+					g_assert (uuid);
+				}
+
+				j = strlen (uuid);
+
+				str = g_string_new_len (content_expectd, len_expectd);
+				g_string_erase (str, i, NM_STRLEN ("${UUID}"));
+				g_string_insert_len (str, i, uuid, j);
+
+				g_free (content_expectd);
+				len_expectd = str->len;
+				content_expectd = g_string_free (str, FALSE);
+				i += j;
+				continue;
+			}
+
+			/* other '$' is not supported. If need be, support escaping of
+			 * '$' via '$$'. */
+			g_assert_not_reached ();
+		}
+	}
+
+	if (   len_expectd != len_written
+	    || memcmp (content_expectd, content_written, len_expectd) != 0) {
+		if (   g_getenv ("NMTST_IFCFG_RH_UPDATE_EXPECTED")
+		    || nm_streq0 (g_getenv ("NM_TEST_REGENERATE"), "1")) {
+			if (uuid) {
+				gs_free char *search = g_strdup_printf ("UUID=%s\n", uuid);
+				const char *s;
+				gsize i;
+				GString *str;
+
+				s = content_written;
+				while (TRUE) {
+					s = strstr (s, search);
+					g_assert (s);
+					if (   s == content_written
+					    || s[-1] == '\n')
+						break;
+					s += strlen (search);
+				}
+
+				i = s - content_written;
+
+				str = g_string_new_len (content_written, len_written);
+				g_string_erase (str, i, strlen (search));
+				g_string_insert (str, i, "UUID=${UUID}\n");
+
+				len_written = str->len;
+				content_written = g_string_free (str, FALSE);
+			}
+			success = g_file_set_contents (expected, content_written, len_written, &error);
+			nmtst_assert_success (success, error);
+		} else {
+			g_error ("The content of \"%s\" (%zu) differs from \"%s\" (%zu). Set NMTST_IFCFG_RH_UPDATE_EXPECTED=yes to update the files inplace\n\n>>>%s<<<\n\n>>>%s<<<\n",
+			         filename, len_written,
+			         expected, len_expectd,
+			         content_written,
+			         content_expectd);
+		}
+	}
+}
+
+#define _writer_update_connection_reread(connection, ifcfg_dir, filename, expected, out_reread, out_reread_same) \
+	G_STMT_START { \
+		gs_unref_object NMConnection *_connection = nmtst_connection_duplicate_and_normalize (connection); \
+		NMConnection **_out_reread = (out_reread); \
+		gboolean *_out_reread_same = (out_reread_same); \
+		const char *_ifcfg_dir = (ifcfg_dir); \
+		const char *_filename = (filename); \
+		const char *_expected = (expected); \
+		GError *_error = NULL; \
+		gboolean _success; \
+		\
+		g_assert (_ifcfg_dir && _ifcfg_dir[0]); \
+		g_assert (_filename && _filename[0]); \
+		\
+		_success = nms_ifcfg_rh_writer_write_connection (_connection, _ifcfg_dir, _filename, NULL, NULL, NULL, _out_reread, _out_reread_same, &_error); \
+		nmtst_assert_success (_success, _error); \
+		_assert_expected_content (_connection, _filename, _expected); \
+	} G_STMT_END
+
+#define _writer_update_connection(connection, ifcfg_dir, filename, expected) \
+	G_STMT_START { \
+		gs_unref_object NMConnection *_reread = NULL; \
+		NMConnection *_c = (connection); \
+		gboolean _reread_same = FALSE; \
+		\
+		_writer_update_connection_reread (_c, ifcfg_dir, filename, expected, &_reread, &_reread_same); \
+		_assert_reread_same (_c, _reread); \
+		g_assert (_reread_same); \
+	} G_STMT_END
+
+static NMConnection *
+_connection_from_file (const char *filename,
+                       const char *network_file,
+                       const char *test_type,
+                       char **out_unhandled)
+{
+	NMConnection *connection;
+	GError *error = NULL;
+	char *unhandled_fallback = NULL;
+
+	g_assert (!out_unhandled || !*out_unhandled);
+
+	connection = nmtst_connection_from_file (filename, network_file, test_type,
+	                                         out_unhandled ?: &unhandled_fallback, &error);
+	g_assert_no_error (error);
+	g_assert (!unhandled_fallback);
+
+	if (out_unhandled && *out_unhandled)
+		nmtst_assert_connection_verifies (connection);
+	else
+		nmtst_assert_connection_verifies_without_normalization (connection);
+	return connection;
+}
+
+static void
+_connection_from_file_fail (const char *filename,
+                            const char *network_file,
+                            const char *test_type,
+                            GError **error)
+{
+	NMConnection *connection;
+	GError *local = NULL;
+	char *unhandled = NULL;
+
+	connection = nmtst_connection_from_file (filename, network_file, test_type, &unhandled, &local);
+
+	g_assert (!connection);
+	g_assert (local);
+	g_assert (!unhandled);
+	g_propagate_error (error, local);
+}
+
+static void
+_writer_new_connection_reread (NMConnection *connection,
+                               const char *ifcfg_dir,
+                               char **out_filename,
+                               const char *expected,
+                               NMConnection **out_reread,
+                               gboolean *out_reread_same)
+{
+	gboolean success;
+	GError *error = NULL;
+	char *filename = NULL;
+	gs_unref_object NMConnection *con_verified = NULL;
+	gs_unref_object NMConnection *reread_copy = NULL;
+	NMConnection **reread = out_reread ?: ((nmtst_get_rand_uint32 () % 2) ? &reread_copy : NULL);
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (ifcfg_dir);
+
+	con_verified = nmtst_connection_duplicate_and_normalize (connection);
+
+	success = nms_ifcfg_rh_writer_write_connection (con_verified,
+	                                                ifcfg_dir,
+	                                                NULL,
+	                                                NULL,
+	                                                NULL,
+	                                                &filename,
+	                                                reread,
+	                                                out_reread_same,
+	                                                &error);
+	nmtst_assert_success (success, error);
+	g_assert (filename && filename[0]);
+
+	if (reread)
+		nmtst_assert_connection_verifies_without_normalization (*reread);
+
+	_assert_expected_content (con_verified, filename, expected);
+
+	if (out_filename)
+		*out_filename = filename;
+	else
+		g_free (filename);
+
+}
+
+static void
+_writer_new_connec_exp (NMConnection *connection,
+                        const char *ifcfg_dir,
+                        const char *expected,
+                        char **out_filename)
+{
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean reread_same = FALSE;
+
+	_writer_new_connection_reread (connection, ifcfg_dir, out_filename, expected, &reread, &reread_same);
+	_assert_reread_same (connection, reread);
+	g_assert (reread_same);
+}
+
+static void
+_writer_new_connection (NMConnection *connection,
+                        const char *ifcfg_dir,
+                        char **out_filename)
+{
+	_writer_new_connec_exp (connection, ifcfg_dir, NO_EXPECTED, out_filename);
+}
+
+static void
+_writer_new_connection_FIXME (NMConnection *connection,
+                              const char *ifcfg_dir,
+                              char **out_filename)
+{
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean reread_same = FALSE;
+
+	/* FIXME: this should not happen. Fix it to use _writer_new_connection() instead. */
+
+	_writer_new_connection_reread (connection, ifcfg_dir, out_filename, NO_EXPECTED, &reread, &reread_same);
+	_assert_reread_same_FIXME (connection, reread);
+	g_assert (!reread_same);
+}
+
+static void
+_writer_new_connection_fail (NMConnection *connection,
+                             const char *ifcfg_dir,
+                             GError **error)
+{
+	gs_unref_object NMConnection *connection_normalized = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean success;
+	GError *local = NULL;
+	char *filename = NULL;
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (ifcfg_dir);
+
+	connection_normalized = nmtst_connection_duplicate_and_normalize (connection);
+
+	success = nms_ifcfg_rh_writer_write_connection (connection_normalized,
+	                                                ifcfg_dir,
+	                                                NULL,
+	                                                NULL,
+	                                                NULL,
+	                                                &filename,
+	                                                &reread,
+	                                                NULL,
+	                                                &local);
+	nmtst_assert_no_success (success, local);
+	g_assert (!filename);
+	g_assert (!reread);
+
+	g_propagate_error (error, local);
+}
+
+/*****************************************************************************/
+
+static void
+test_read_netmask_1 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_free char *content = NULL;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMIPAddress *ip4_addr;
+	const char *FILENAME = TEST_IFCFG_DIR"/ifcfg-netmask-1";
+
+	connection = _connection_from_file (FILENAME, NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System netmask-1");
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpuint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "102.0.2.2");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 15);
+
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	content = nmtst_file_get_contents (FILENAME);
+
+	testfile = g_strdup (TEST_SCRATCH_DIR"/ifcfg-netmask-1.copy");
+
+	nmtst_file_set_contents (testfile, content);
+
+	_writer_update_connection (connection,
+	                           TEST_SCRATCH_DIR,
+	                           testfile,
+	                           TEST_IFCFG_DIR"/ifcfg-netmask-1.cexpected");
+}
+
+/*****************************************************************************/
+
+static gboolean
+verify_cert_or_key (NMSetting8021x *s_compare,
+                    const char *file,
+                    const char *privkey_password,
+                    const char *property)
+{
+	NMSetting8021x *s_8021x;
+	GError *error = NULL;
+	gboolean success = FALSE;
+	const char *expected = NULL, *setting = NULL;
+	gboolean phase2 = FALSE;
+	NMSetting8021xCKScheme scheme = NM_SETTING_802_1X_CK_SCHEME_UNKNOWN;
+
+	if (strstr (property, "phase2"))
+		phase2 = TRUE;
+
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+
+	/* Load the certificate into an empty setting */
+	if (strstr (property, "ca-cert")) {
+		if (phase2)
+			success = nm_setting_802_1x_set_phase2_ca_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
+		else
+			success = nm_setting_802_1x_set_ca_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
+	} else if (strstr (property, "client-cert")) {
+		if (phase2)
+			success = nm_setting_802_1x_set_phase2_client_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
+		else
+			success = nm_setting_802_1x_set_client_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
+	} else if (strstr (property, "private-key")) {
+		if (phase2)
+			success = nm_setting_802_1x_set_phase2_private_key (s_8021x, file, privkey_password, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
+		else
+			success = nm_setting_802_1x_set_private_key (s_8021x, file, privkey_password, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
+	}
+	g_assert_no_error (error);
+	g_assert_cmpint (success, ==, TRUE);
+
+	/* Ensure it was loaded using the PATH scheme */
+	if (strstr (property, "ca-cert")) {
+		if (phase2)
+			scheme = nm_setting_802_1x_get_phase2_ca_cert_scheme (s_8021x);
+		else
+			scheme = nm_setting_802_1x_get_ca_cert_scheme (s_8021x);
+	} else if (strstr (property, "client-cert")) {
+		if (phase2)
+			scheme = nm_setting_802_1x_get_phase2_client_cert_scheme (s_8021x);
+		else
+			scheme = nm_setting_802_1x_get_client_cert_scheme (s_8021x);
+	} else if (strstr (property, "private-key")) {
+		if (phase2)
+			scheme = nm_setting_802_1x_get_phase2_private_key_scheme (s_8021x);
+		else
+			scheme = nm_setting_802_1x_get_private_key_scheme (s_8021x);
+	}
+	g_assert_cmpint (scheme, ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
+
+	/* Grab the path back out */
+	if (strstr (property, "ca-cert")) {
+		if (phase2)
+			expected = nm_setting_802_1x_get_phase2_ca_cert_path (s_8021x);
+		else
+			expected = nm_setting_802_1x_get_ca_cert_path (s_8021x);
+	} else if (strstr (property, "client-cert")) {
+		if (phase2)
+			expected = nm_setting_802_1x_get_phase2_client_cert_path (s_8021x);
+		else
+			expected = nm_setting_802_1x_get_client_cert_path (s_8021x);
+	} else if (strstr (property, "private-key")) {
+		if (phase2)
+			expected = nm_setting_802_1x_get_phase2_private_key_path (s_8021x);
+		else
+			expected = nm_setting_802_1x_get_private_key_path (s_8021x);
+	}
+	g_assert_cmpstr (expected, ==, file);
+
+	/* Compare the path with the expected path from the real setting */
+	if (strstr (property, "ca-cert")) {
+		if (phase2)
+			setting = nm_setting_802_1x_get_phase2_ca_cert_path (s_compare);
+		else
+			setting = nm_setting_802_1x_get_ca_cert_path (s_compare);
+	} else if (strstr (property, "client-cert")) {
+		if (phase2)
+			setting = nm_setting_802_1x_get_phase2_client_cert_path (s_compare);
+		else
+			setting = nm_setting_802_1x_get_client_cert_path (s_compare);
+	} else if (strstr (property, "private-key")) {
+		if (phase2)
+			setting = nm_setting_802_1x_get_phase2_private_key_path (s_compare);
+		else
+			setting = nm_setting_802_1x_get_private_key_path (s_compare);
+	}
+	g_assert_cmpstr (setting, ==, expected);
+
+	g_object_unref (s_8021x);
+	return TRUE;
+}
+
+static void
+test_read_basic (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-minimal",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-minimal");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
+
+	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
+	 * the UUID is generated on the full path of the ifcfg file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* MAC address */
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
+
+	/* ===== IPv6 SETTING ===== */
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_miscellaneous_variables (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	char *expected_mac_blacklist[3] = { "00:16:41:11:22:88", "00:16:41:11:22:99", "6a:5d:5a:fa:dd:f0" };
+	int mac_blacklist_num, i;
+	guint64 expected_timestamp = 0;
+
+	NMTST_EXPECT_NM_WARN ("*invalid MAC in HWADDR_BLACKLIST 'XX:aa:invalid'*");
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-misc-variables",
+	                                    NULL, TYPE_ETHERNET, NULL);
+	g_test_assert_expected_messages ();
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, 100);
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* MAC blacklist */
+	mac_blacklist_num = nm_setting_wired_get_num_mac_blacklist_items (s_wired);
+	g_assert_cmpint (mac_blacklist_num, ==, 3);
+	for (i = 0; i < mac_blacklist_num; i++)
+		g_assert (nm_utils_hwaddr_matches (nm_setting_wired_get_mac_blacklist_item (s_wired, i), -1, expected_mac_blacklist[i], -1));
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_variables_corner_cases (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-variables-corner-cases-1",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-variables-corner-cases-1");
+	g_assert_cmpstr (nm_setting_connection_get_zone (s_con), ==, NULL);
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* MAC address */
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_unmanaged (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	char *unhandled_spec = NULL;
+	guint64 expected_timestamp = 0;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-nm-controlled",
+	                                    NULL, TYPE_ETHERNET,
+	                                    &unhandled_spec);
+	g_assert_cmpstr (unhandled_spec, ==, "unmanaged:mac:00:11:22:33:f8:9f");
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-nm-controlled");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	g_free (unhandled_spec);
+	g_object_unref (connection);
+}
+
+static void
+test_read_unmanaged_unrecognized (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	gs_free char *unhandled_spec = NULL;
+	guint64 expected_timestamp = 0;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-nm-controlled-unrecognized",
+	                                    NULL, NULL,
+	                                    &unhandled_spec);
+	g_assert_cmpstr (unhandled_spec, ==, "unmanaged:interface-name:=ipoac0");
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "PigeonNet");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_unrecognized (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	gs_free char *unhandled_spec = NULL;
+	guint64 expected_timestamp = 0;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-unrecognized",
+	                                    NULL, NULL,
+	                                    &unhandled_spec);
+	g_assert_cmpstr (unhandled_spec, ==, "unrecognized:mac:00:11:22:33");
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-unrecognized");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_static (gconstpointer test_data)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char *unmanaged = NULL;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0xee };
+	NMIPAddress *ip4_addr;
+	NMIPAddress *ip6_addr;
+	const char *file, *expected_id;
+	gpointer expect_ip6_p;
+
+	nmtst_test_data_unpack (test_data, &file, &expected_id, &expect_ip6_p);
+
+	g_assert (expected_id);
+
+	connection = _connection_from_file (file, NULL, TYPE_ETHERNET,
+	                                    &unmanaged);
+	g_assert_cmpstr (unmanaged, ==, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 1492);
+
+	/* MAC address */
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+	g_assert (nm_setting_ip_config_get_may_fail (s_ip4));
+
+	g_assert (nm_setting_ip_config_has_dns_options (s_ip4));
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns_options (s_ip4), ==, 0);
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "192.168.1.5");
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.1");
+
+	/* ===== IPv6 SETTING ===== */
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	if (GPOINTER_TO_INT (expect_ip6_p)) {
+		g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_MANUAL);
+		g_assert (nm_setting_ip_config_get_may_fail (s_ip6));
+
+		g_assert (nm_setting_ip_config_has_dns_options (s_ip6));
+		g_assert_cmpint (nm_setting_ip_config_get_num_dns_options (s_ip6), ==, 0);
+
+		/* DNS Addresses */
+		g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 2);
+		g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
+		g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 1), ==, "1:2:3:4::b");
+
+		/* IP addresses */
+		g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 2);
+
+		ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
+		g_assert (ip6_addr);
+		g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 64);
+		g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "dead:beaf::1");
+
+		ip6_addr = nm_setting_ip_config_get_address (s_ip6, 1);
+		g_assert (ip6_addr);
+		g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
+		g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "dead:beaf::2");
+	} else {
+		g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);
+		g_assert (!nm_setting_ip_config_has_dns_options (s_ip6));
+	}
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_static_no_prefix (gconstpointer user_data)
+{
+	guint32 expected_prefix = GPOINTER_TO_UINT (user_data);
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMIPAddress *ip4_addr;
+	char *file, *expected_id;
+
+	file = g_strdup_printf (TEST_IFCFG_DIR"/ifcfg-test-wired-static-no-prefix-%u", expected_prefix);
+	expected_id = g_strdup_printf ("System test-wired-static-no-prefix-%u", expected_prefix);
+
+	NMTST_EXPECT_NM_WARN ("*missing PREFIX, assuming*");
+	connection = _connection_from_file (file, NULL, TYPE_ETHERNET, NULL);
+	g_test_assert_expected_messages ();
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	g_assert (!nm_setting_ip_config_has_dns_options (s_ip4));
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns_options (s_ip4), ==, 0);
+
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, expected_prefix);
+
+	g_free (file);
+	g_free (expected_id);
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_dhcp (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	char *unmanaged = NULL;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0xee };
+	const char *mac;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp",
+	                                    NULL, TYPE_ETHERNET,
+	                                    &unmanaged);
+	g_assert (unmanaged == NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-dhcp");
+	g_assert_cmpuint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* MAC address */
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, "foobar");
+	g_assert (nm_setting_ip_config_get_ignore_auto_dns (s_ip4));
+	g_assert_cmpuint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_dhcp_plus_ip (void)
+{
+	NMConnection *connection;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMIPAddress *ip4_addr;
+	NMIPAddress *ip6_addr;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp-plus-ip",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_may_fail (s_ip4));
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 2);
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "1.2.3.4");
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
+
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 1);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 16);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "9.8.7.6");
+
+	/* ===== IPv6 SETTING ===== */
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_may_fail (s_ip6));
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 2);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 1), ==, "1:2:3:4::b");
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 3);
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
+	g_assert (ip6_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "1001:abba::1234");
+
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 1);
+	g_assert (ip6_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 64);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "2001:abba::2234");
+
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 2);
+	g_assert (ip6_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 96);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "3001:abba::3234");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_shared_plus_ip (void)
+{
+	NMConnection *connection;
+	NMSettingIPConfig *s_ip4;
+	NMIPAddress *ip4_addr;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-shared-plus-ip",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_SHARED);
+	g_assert (nm_setting_ip_config_get_may_fail (s_ip4));
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "10.20.30.5");
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_global_gateway (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMIPAddress *ip4_addr;
+	char *unmanaged = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-global-gateway",
+	                                    TEST_IFCFG_DIR"/network-test-wired-global-gateway",
+	                                    TYPE_ETHERNET, &unmanaged);
+	g_assert (unmanaged == NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-global-gateway");
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	/* Address #1 */
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "192.168.1.5");
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.2");
+
+	g_object_unref (connection);
+}
+
+/* Ignore GATEWAY from /etc/sysconfig/network for automatic connections */
+static void
+test_read_wired_global_gateway_ignore (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	char *unmanaged = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*ignoring GATEWAY (/etc/sysconfig/network) for * because the connection has no static addresses");
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-global-gateway-ignore",
+	                                    TEST_IFCFG_DIR"/network-test-wired-global-gateway-ignore",
+	                                    TYPE_ETHERNET, &unmanaged);
+	g_test_assert_expected_messages ();
+	g_assert (unmanaged == NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-global-gateway-ignore");
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 0);
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, NULL);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_obsolete_gateway_n (void)
+{
+	NMConnection *connection;
+	NMSettingIPConfig *s_ip4;
+	NMIPAddress *ip4_addr;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-obsolete-gateway-n",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "1.2.3.4");
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
+
+	g_object_unref (connection);
+}
+
+static void
+test_user_1 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingUser *s_user;
+
+	connection = nmtst_create_minimal_connection ("Test User 1", NULL, NM_SETTING_WIRED_SETTING_NAME, NULL);
+	s_user = NM_SETTING_USER (nm_setting_user_new ());
+
+#define _USER_SET_DATA(s_user, key, val) \
+	G_STMT_START { \
+		GError *_error = NULL; \
+		gboolean _success; \
+		\
+		_success = nm_setting_user_set_data ((s_user), (key), (val), &_error); \
+		nmtst_assert_success (_success, _error); \
+	} G_STMT_END
+
+#define _USER_SET_DATA_X(s_user, key) \
+	_USER_SET_DATA (s_user, key, "val="key"")
+
+	_USER_SET_DATA (s_user, "my.val1", "");
+	_USER_SET_DATA_X (s_user, "my.val2");
+	_USER_SET_DATA_X (s_user, "my.v__al3");
+	_USER_SET_DATA_X (s_user, "my._v");
+	_USER_SET_DATA_X (s_user, "my.v+");
+	_USER_SET_DATA_X (s_user, "my.Av");
+	_USER_SET_DATA_X (s_user, "MY.AV");
+	_USER_SET_DATA_X (s_user, "MY.8V");
+	_USER_SET_DATA_X (s_user, "MY.8-V");
+	_USER_SET_DATA_X (s_user, "MY.8_V");
+	_USER_SET_DATA_X (s_user, "MY.8+V");
+	_USER_SET_DATA_X (s_user, "MY.8/V");
+	_USER_SET_DATA_X (s_user, "MY.8=V");
+	_USER_SET_DATA_X (s_user, "MY.-");
+	_USER_SET_DATA_X (s_user, "MY._");
+	_USER_SET_DATA_X (s_user, "MY.+");
+	_USER_SET_DATA_X (s_user, "MY./");
+	_USER_SET_DATA_X (s_user, "MY.=");
+	_USER_SET_DATA_X (s_user, "my.keys.1");
+	_USER_SET_DATA_X (s_user, "my.other.KEY.42");
+
+	nm_connection_add_setting (connection, NM_SETTING (s_user));
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_User_1.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_wired_never_default (void)
+{
+	NMConnection *connection;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-never-default",
+	                                    TEST_IFCFG_DIR"/network-test-wired-never-default",
+	                                    TYPE_ETHERNET, NULL);
+
+	/* ===== WIRED SETTING ===== */
+	g_assert (nm_connection_get_setting_wired (connection));
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4));
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 0);
+
+	/* ===== IPv6 SETTING ===== */
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip6));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_defroute_no (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char *unmanaged = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-defroute-no",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (unmanaged == NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-defroute-no");
+
+	g_assert (nm_connection_get_setting_wired (connection));
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4));
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip6));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_defroute_no_gatewaydev_yes (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char *unmanaged = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-defroute-no-gatewaydev-yes",
+	                                    TEST_IFCFG_DIR"/network-test-wired-defroute-no-gatewaydev-yes",
+	                                    TYPE_ETHERNET,
+	                                    &unmanaged);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-defroute-no-gatewaydev-yes");
+
+	g_assert (nm_connection_get_setting_wired (connection));
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_static_routes (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMIPRoute *ip4_route;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-static-routes",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-static-routes");
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	/* Routes */
+	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 3);
+
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 0);
+	g_assert (ip4_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "11.22.33.0");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 24);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "192.168.1.5");
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, -1);
+
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 1);
+	g_assert (ip4_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "44.55.66.77");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "192.168.1.7");
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 3);
+	nmtst_assert_route_attribute_byte (ip4_route, NM_IP_ROUTE_ATTRIBUTE_TOS, 0x28);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, 30000);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 12);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITCWND, 13);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITRWND, 14);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 9000);
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND, TRUE);
+	nmtst_assert_route_attribute_string (ip4_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "1.1.1.1");
+
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 2);
+	g_assert (ip4_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "44.55.66.78");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "192.168.1.8");
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 3);
+	nmtst_assert_route_attribute_byte (ip4_route, NM_IP_ROUTE_ATTRIBUTE_TOS, 0x28);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, 30000);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 12);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITCWND, 13);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITRWND, 14);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 9000);
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND, TRUE);
+	nmtst_assert_route_attribute_string (ip4_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "1.1.1.1");
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, TRUE);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_static_routes_legacy (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	char *unmanaged = NULL;
+	NMIPRoute *ip4_route;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-static-routes-legacy",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-static-routes-legacy");
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	/* Routes */
+	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 4);
+
+	/* Route #1 */
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 0);
+	g_assert (ip4_route != NULL);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "21.31.41.0");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 24);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "9.9.9.9");
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 1);
+
+	/* Route #2 */
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 1);
+	g_assert (ip4_route != NULL);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "32.42.52.62");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "8.8.8.8");
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, -1);
+
+	/* Route #3 */
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 2);
+	g_assert (ip4_route != NULL);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "43.53.0.0");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 16);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "7.7.7.7");
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 3);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, 10000);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 14);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITCWND, 42);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITRWND, 20);
+	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 9000);
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW, TRUE);
+	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
+	nmtst_assert_route_attribute_string (ip4_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "1.2.3.4");
+
+	ip4_route = nm_setting_ip_config_get_route (s_ip4, 3);
+	g_assert (ip4_route != NULL);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "7.7.7.8");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, NULL);
+	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 18);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_ipv4_manual (gconstpointer data)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	char *unmanaged = NULL;
+	NMIPAddress *ip4_addr;
+	const char *file, *expected_id;
+
+	nmtst_test_data_unpack (data, &file, &expected_id);
+
+	g_assert (expected_id);
+
+	connection = _connection_from_file (file,
+	                                    NULL,
+	                                    TYPE_ETHERNET,
+	                                    &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+	g_assert_cmpint (nm_setting_ip_config_get_dad_timeout (s_ip4), ==, 2000);
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 3);
+
+	/* Address #1 */
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "1.2.3.4");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+
+	/* Address #2 */
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 1);
+	g_assert (ip4_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "9.8.7.6");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 16);
+
+	/* Address #3 */
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 2);
+	g_assert (ip4_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "3.3.3.3");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 8);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_ipv6_manual (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char *unmanaged = NULL;
+	NMIPAddress *ip6_addr;
+	NMIPRoute *ip6_route;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-ipv6-manual",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-ipv6-manual");
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
+
+	/* DNS search domains */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns_searches (s_ip4), ==, 3);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip4, 0), ==, "lorem.com");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip4, 1), ==, "ipsum.org");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip4, 2), ==, "dolor.edu");
+
+	/* ===== IPv6 SETTING ===== */
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_MANUAL);
+	g_assert (!nm_setting_ip_config_get_never_default (s_ip6));
+	g_assert (nm_setting_ip_config_get_may_fail (s_ip6));
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 3);
+
+	/* Address #1 */
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
+	g_assert (ip6_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "1001:abba::1234");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
+
+	/* Address #2 */
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 1);
+	g_assert (ip6_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "2001:abba::2234");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 64);
+
+	/* Address #3 */
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 2);
+	g_assert (ip6_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "3001:abba::3234");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 96);
+
+	/* Routes */
+	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip6), ==, 4);
+	/* Route #1 */
+	ip6_route = nm_setting_ip_config_get_route (s_ip6, 0);
+	g_assert (ip6_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "9876::1234");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 96);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, "9876::7777");
+	g_assert_cmpint (nm_ip_route_get_metric (ip6_route), ==, 2);
+	/* Route #2 */
+	ip6_route = nm_setting_ip_config_get_route (s_ip6, 1);
+	g_assert (ip6_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "::");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 0);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, "dead::beaf");
+	g_assert_cmpint (nm_ip_route_get_metric (ip6_route), ==, -1);
+	/* Route #3 */
+	ip6_route = nm_setting_ip_config_get_route (s_ip6, 2);
+	g_assert (ip6_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "abbe::cafe");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 64);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, NULL);
+	g_assert_cmpint (nm_ip_route_get_metric (ip6_route), ==, 777);
+	/* Route #4 */
+	ip6_route = nm_setting_ip_config_get_route (s_ip6, 3);
+	g_assert (ip6_route);
+	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "aaaa::cccc");
+	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 64);
+	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, "3333::4444");
+	nmtst_assert_route_attribute_uint32 (ip6_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 13);
+	nmtst_assert_route_attribute_uint32 (ip6_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 1450);
+	nmtst_assert_route_attribute_boolean (ip6_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
+	nmtst_assert_route_attribute_string (ip6_route, NM_IP_ROUTE_ATTRIBUTE_FROM, "1111::2222/48");
+	nmtst_assert_route_attribute_string (ip6_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "5555::6666");
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 2);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 1), ==, "1:2:3:4::b");
+
+	/* DNS domains - none as domains are stuffed to 'ipv4' setting */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns_searches (s_ip6), ==, 0);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_ipv6_only (gconstpointer test_data)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char *unmanaged = NULL;
+	NMIPAddress *ip6_addr;
+	const char *method;
+	const char *file, *expected_id;
+
+	nmtst_test_data_unpack (test_data, &file, &expected_id);
+
+	g_assert (expected_id);
+
+	connection = _connection_from_file (file, NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+
+	method = nm_setting_ip_config_get_method (s_ip4);
+	g_assert_cmpstr (method, ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
+
+	/* ===== IPv6 SETTING ===== */
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_MANUAL);
+
+	/* IP addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 1);
+
+	/* Address #1 */
+	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
+	g_assert (ip6_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "1001:abba::1234");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 1);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
+
+	/* DNS domains should be in IPv6, because IPv4 is disabled */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns_searches (s_ip6), ==, 3);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip6, 0), ==, "lorem.com");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip6, 1), ==, "ipsum.org");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip6, 2), ==, "dolor.edu");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_dhcp6_only (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char *unmanaged = NULL;
+	const char *method;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp6-only", NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-dhcp6-only");
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+
+	method = nm_setting_ip_config_get_method (s_ip4);
+	g_assert_cmpstr (method, ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
+
+	/* ===== IPv6 SETTING ===== */
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_DHCP);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_autoip (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingIPConfig *s_ip4;
+	char *unmanaged = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-autoip",
+	                                    NULL, TYPE_ETHERNET,
+	                                    &unmanaged);
+	g_assert (unmanaged == NULL);
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL);
+	g_assert (!nm_setting_ip_config_get_may_fail (s_ip4));
+	g_assert (nm_setting_ip_config_get_ignore_auto_dns (s_ip4));
+}
+
+static void
+test_read_onboot_no (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	char *unmanaged = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-onboot-no", NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	g_assert (!nm_setting_connection_get_autoconnect (s_con));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_noip (void)
+{
+	NMConnection *connection;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-noip", NULL, TYPE_ETHERNET, NULL);
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);
+	g_assert (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
+
+	g_object_unref (connection);
+}
+
+#define TEST_IFCFG_WIRED_8021x_PEAP_MSCHAPV2_CA_CERT TEST_IFCFG_DIR"/test_ca_cert.pem"
+
+static void
+test_read_wired_8021x_peap_mschapv2 (void)
+{
+	NMConnection *connection;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSetting8021x *s_8021x;
+	NMSetting8021x *tmp_8021x;
+	char *unmanaged = NULL;
+	GError *error = NULL;
+	gboolean success = FALSE;
+	const char *expected_ca_cert_path;
+	const char *read_ca_cert_path;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-peap-mschapv2",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "peap");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "David Smith");
+	g_assert_cmpstr (nm_setting_802_1x_get_anonymous_identity (s_8021x), ==, "somebody");
+	g_assert_cmpstr (nm_setting_802_1x_get_password (s_8021x), ==, "foobar baz");
+	g_assert_cmpstr (nm_setting_802_1x_get_phase1_peapver (s_8021x), ==, "1");
+	g_assert_cmpstr (nm_setting_802_1x_get_phase1_peaplabel (s_8021x), ==, "1");
+
+	/* CA Cert */
+	tmp_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+
+	success = nm_setting_802_1x_set_ca_cert (tmp_8021x,
+	                                         TEST_IFCFG_WIRED_8021x_PEAP_MSCHAPV2_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	g_assert_no_error (error);
+	g_assert (success == TRUE);
+
+	expected_ca_cert_path = nm_setting_802_1x_get_ca_cert_path (tmp_8021x);
+	g_assert (expected_ca_cert_path);
+
+	read_ca_cert_path = nm_setting_802_1x_get_ca_cert_path (s_8021x);
+	g_assert (read_ca_cert_path);
+
+	g_assert_cmpstr (read_ca_cert_path, ==, expected_ca_cert_path);
+
+	g_object_unref (tmp_8021x);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_8021x_tls_secret_flags (gconstpointer test_data)
+{
+	NMConnection *connection;
+	NMSettingWired *s_wired;
+	NMSetting8021x *s_8021x;
+	char *dirname, *tmp;
+	const char *ifcfg;
+	gpointer expected_flags_p;
+
+	nmtst_test_data_unpack (test_data, &ifcfg, &expected_flags_p);
+
+	connection = _connection_from_file (ifcfg, NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "tls");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "David Smith");
+	g_assert_cmpint (nm_setting_802_1x_get_private_key_password_flags (s_8021x), ==, GPOINTER_TO_INT (expected_flags_p));
+
+	dirname = g_path_get_dirname (ifcfg);
+	tmp = g_build_path ("/", dirname, "test_ca_cert.pem", NULL);
+	g_assert_cmpstr (nm_setting_802_1x_get_ca_cert_path (s_8021x), ==, tmp);
+	g_free (tmp);
+
+	tmp = g_build_path ("/", dirname, "test1_key_and_cert.pem", NULL);
+	g_assert_cmpstr (nm_setting_802_1x_get_client_cert_path (s_8021x), ==, tmp);
+	g_assert_cmpstr (nm_setting_802_1x_get_private_key_path (s_8021x), ==, tmp);
+	g_free (tmp);
+
+	g_free (dirname);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_write_802_1X_subj_matches (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSetting8021x *s_8021x;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-802-1X-subj-matches",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "peap");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Jara Cimrman");
+	g_assert_cmpstr (nm_setting_802_1x_get_subject_match (s_8021x), ==, "server1.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_subject_match (s_8021x), ==, "server2.yourdomain.tld");
+	g_assert_cmpint (nm_setting_802_1x_get_num_altsubject_matches (s_8021x), ==, 3);
+	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 0), ==, "a.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 1), ==, "b.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 2), ==, "c.yourdomain.tld");
+	g_assert_cmpint (nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x), ==, 2);
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 0), ==, "x.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 1), ==, "y.yourdomain.tld");
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-System_test-wired-802-1X-subj-matches.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	/* Check 802.1X stuff of the re-read connection. */
+	s_8021x = nm_connection_get_setting_802_1x (reread);
+	g_assert (s_8021x);
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "peap");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Jara Cimrman");
+	g_assert_cmpstr (nm_setting_802_1x_get_subject_match (s_8021x), ==, "server1.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_subject_match (s_8021x), ==, "server2.yourdomain.tld");
+	g_assert_cmpint (nm_setting_802_1x_get_num_altsubject_matches (s_8021x), ==, 3);
+	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 0), ==, "a.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 1), ==, "b.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 2), ==, "c.yourdomain.tld");
+	g_assert_cmpint (nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x), ==, 2);
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 0), ==, "x.yourdomain.tld");
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 1), ==, "y.yourdomain.tld");
+}
+
+static void
+test_read_802_1x_ttls_eapgtc (void)
+{
+	NMConnection *connection;
+	NMSetting8021x *s_8021x;
+
+	/* Test that EAP-* inner methods are correctly read into the
+	 * NMSetting8021x::autheap property.
+	 */
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-802-1x-ttls-eapgtc",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+
+	/* EAP methods */
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "ttls");
+
+	/* Auth methods */
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_auth (s_8021x), ==, NULL);
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_autheap (s_8021x), ==, "gtc");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_802_1x_tls_p12_no_client_cert (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSetting8021x *s_8021x;
+	const char *path;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-tls-p12-no-client-cert",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+
+	g_assert_cmpint (nm_setting_802_1x_get_private_key_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
+	path = nm_setting_802_1x_get_private_key_path (s_8021x);
+	g_assert (path);
+
+	g_assert_cmpint (nm_setting_802_1x_get_client_cert_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
+	g_assert_cmpstr (path, ==, nm_setting_802_1x_get_client_cert_path (s_8021x));
+}
+
+static void
+test_read_write_802_1x_password_raw (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSetting8021x *s_8021x;
+	GBytes *bytes;
+	gconstpointer data;
+	gsize size;
+
+	/* Test that the 802-1x.password-raw is correctly read and written. */
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-802-1x-password-raw",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+
+	bytes = nm_setting_802_1x_get_password_raw (s_8021x);
+	g_assert (bytes);
+	data = g_bytes_get_data (bytes, &size);
+	g_assert_cmpmem (data, size, "\x04\x08\x15\x16\x23\x42\x00\x01", 8);
+
+	g_assert_cmpint (nm_setting_802_1x_get_password_raw_flags (s_8021x),
+	                 ==,
+	                 NM_SETTING_SECRET_FLAG_NONE);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	keyfile = utils_get_keys_path (testfile);
+	g_assert (g_file_test (keyfile, G_FILE_TEST_EXISTS));
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_wired_aliases_good (gconstpointer test_data)
+{
+	const int N = GPOINTER_TO_INT (test_data);
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	int expected_num_addresses;
+	const char *expected_address_0[] = { "192.168.1.5", "192.168.1.6", "192.168.1.9", "192.168.1.99", NULL };
+	const char *expected_address_3[] = { "192.168.1.5", "192.168.1.6", NULL };
+	const char *expected_label_0[] = { NULL, "aliasem0:1", "aliasem0:2", "aliasem0:99", NULL, };
+	const char *expected_label_3[] = { NULL, "aliasem3:1", NULL, };
+	const char **expected_address;
+	const char **expected_label;
+	int i, j;
+	char path[256];
+
+	expected_address = N == 0 ? expected_address_0 : expected_address_3;
+	expected_label   = N == 0 ? expected_label_0   : expected_label_3;
+	expected_num_addresses = g_strv_length ((char **) expected_address);
+
+	nm_sprintf_buf (path, TEST_IFCFG_DIR"/ifcfg-aliasem%d", N);
+
+	connection = _connection_from_file (path, NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	if (N == 0)
+		g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System aliasem0");
+	else
+		g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System aliasem3");
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, expected_num_addresses);
+
+	/* Addresses */
+	for (i = 0; i < expected_num_addresses; i++) {
+		NMIPAddress *ip4_addr;
+		const char *addr;
+		GVariant *label;
+
+		ip4_addr = nm_setting_ip_config_get_address (s_ip4, i);
+		g_assert (ip4_addr != NULL);
+
+		addr = nm_ip_address_get_address (ip4_addr);
+		g_assert (nm_utils_ipaddr_valid (AF_INET, addr));
+
+		for (j = 0; j < expected_num_addresses; j++) {
+			if (!g_strcmp0 (addr, expected_address[j]))
+				break;
+		}
+		g_assert (j < expected_num_addresses);
+
+		g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+		label = nm_ip_address_get_attribute (ip4_addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL);
+		if (expected_label[j])
+			g_assert_cmpstr (g_variant_get_string (label, NULL), ==, expected_label[j]);
+		else
+			g_assert (label == NULL);
+
+		expected_address[j] = NULL;
+		expected_label[j] = NULL;
+	}
+
+	/* Gateway */
+	g_assert (!nm_setting_ip_config_get_never_default (s_ip4));
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.1");
+
+	for (i = 0; i < expected_num_addresses; i++)
+		g_assert (!expected_address[i]);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_aliases_bad (const char *base, const char *expected_id)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMIPAddress *ip4_addr;
+
+	g_assert (expected_id);
+
+	connection = _connection_from_file (base, NULL, TYPE_ETHERNET, NULL);
+	g_test_assert_expected_messages ();
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
+
+	/* Addresses */
+	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr != NULL);
+	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "192.168.1.5");
+	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
+	g_assert (nm_ip_address_get_attribute (ip4_addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL) == NULL);
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.1");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_aliases_bad_1 (void)
+{
+	NMTST_EXPECT_NM_WARN ("*aliasem1:1*has no DEVICE*");
+	test_read_wired_aliases_bad (TEST_IFCFG_DIR"/ifcfg-aliasem1", "System aliasem1");
+}
+
+static void
+test_read_wired_aliases_bad_2 (void)
+{
+	NMTST_EXPECT_NM_WARN ("*aliasem2:1*has invalid DEVICE*");
+	test_read_wired_aliases_bad (TEST_IFCFG_DIR"/ifcfg-aliasem2", "System aliasem2");
+}
+
+static void
+test_read_dns_options (void)
+{
+	NMConnection *connection;
+	NMSettingIPConfig *s_ip4, *s_ip6;
+	char *unmanaged = NULL;
+	const char *option;
+	const char *options4[] = { "ndots:3", "single-request-reopen" };
+	const char *options6[] = { "inet6" };
+	guint32 i, num;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-dns-options",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert_cmpstr (unmanaged, ==, NULL);
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+
+	num = nm_setting_ip_config_get_num_dns_options (s_ip4);
+	g_assert_cmpint (num, ==, G_N_ELEMENTS (options4));
+
+	for (i = 0; i < num; i++) {
+		option = nm_setting_ip_config_get_dns_option (s_ip4, i);
+		g_assert_cmpstr (options4[i], ==, option);
+	}
+
+	num = nm_setting_ip_config_get_num_dns_options (s_ip6);
+	g_assert_cmpint (num, ==, G_N_ELEMENTS (options6));
+
+	for (i = 0; i < num; i++) {
+		option = nm_setting_ip_config_get_dns_option (s_ip6, i);
+		g_assert_cmpstr (options6[i], ==, option);
+	}
+
+	g_object_unref (connection);
+}
+
+static void
+test_clear_master (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_free char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	char *unmanaged = NULL;
+	shvarFile *f;
+
+	/* 1. load the bridge slave connection from disk */
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-component",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert_cmpstr (unmanaged, ==, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "br0");
+	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, "bridge");
+
+	/* 2. write the connection to a new file */
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-System_test-bridge-component-a.cexpected",
+	                        &testfile);
+
+	/* 3. clear master and slave-type */
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_MASTER, NULL,
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NULL,
+	              NULL);
+
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, NULL);
+	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NULL);
+
+	nmtst_assert_connection_verifies_after_normalization (connection, 0, 0);
+
+	/* 4. update the connection on disk */
+	_writer_update_connection (connection,
+	                           TEST_SCRATCH_DIR,
+	                           testfile,
+	                           TEST_IFCFG_DIR"/ifcfg-System_test-bridge-component-b.cexpected");
+	keyfile = utils_get_keys_path (testfile);
+	g_assert (!g_file_test (keyfile, G_FILE_TEST_EXISTS));
+
+	/* 5. check that BRIDGE variable has been removed */
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "BRIDGE", NULL);
+	svCloseFile (f);
+}
+
+static void
+test_write_dns_options (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	static const char *mac = "31:33:33:37:be:cd";
+	guint32 mtu = 1492;
+	NMIPAddress *addr;
+	NMIPAddress *addr6;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test DNS options",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_MTU, mtu,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nm_setting_ip_config_add_dns_option (s_ip4, "debug");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 206,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	nm_setting_ip_config_add_dns_option (s_ip6, "timeout:3");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_wifi_open (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4, *s_ip6;
+	GBytes *ssid;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
+	const char *expected_ssid = "blahblah";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-open)");
+
+	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
+	 * the UUID is generated on the full path of the ifcfg file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+	g_assert_cmpint (nm_setting_connection_get_autoconnect_priority (s_con), ==, -1);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* MAC address */
+	mac = nm_setting_wireless_get_mac_address (s_wireless);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
+
+	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
+	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 1);
+
+	/* ===== Wi-Fi SECURITY SETTING ===== */
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec == NULL);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpint (nm_setting_ip_config_get_route_metric (s_ip4), ==, 104);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert( s_ip6);
+	g_assert_cmpint (nm_setting_ip_config_get_route_metric (s_ip6), ==, 106);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_open_auto (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-auto",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-open-auto)");
+
+	/* ===== WIRELESS SETTING ===== */
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_open_ssid_hex (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	GBytes *ssid;
+	const char *expected_ssid = "blahblah";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-hex",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-open-ssid-hex)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_open_ssid_hex_bad (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	GBytes *ssid;
+	const char *expected_ssid = "0x626cxx";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-bad-hex",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System 0x626cxx (test-wifi-open-ssid-bad-hex)");
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+}
+
+static void
+test_read_wifi_open_ssid_bad (gconstpointer data)
+{
+	_connection_from_file_fail ((const char *) data, NULL, TYPE_WIRELESS, NULL);
+}
+
+static void
+test_read_wifi_open_ssid_quoted (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	GBytes *ssid;
+	const char *expected_ssid = "foo\"bar\\";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-quoted",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System foo\"bar\\ (test-wifi-open-ssid-quoted)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	GBytes *ssid;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
+	const char *expected_ssid = "blahblah";
+	NMWepKeyType key_type;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wep)");
+
+	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
+	 * the UUID is generated on the full path of the ifcfg file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* MAC address */
+	mac = nm_setting_wireless_get_mac_address (s_wireless);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
+
+	/* MTU */
+	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
+	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 1);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
+	g_assert_cmpstr (nm_setting_wireless_security_get_auth_alg (s_wsec), ==, "shared");
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
+
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
+
+	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "0123456789abcdef0123456789");
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_adhoc (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	GBytes *ssid;
+	const char *expected_ssid = "blahblah";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-adhoc",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wep-adhoc)");
+
+	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
+	 * the UUID is generated on the full path of the ifcfg file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	g_assert (!nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "adhoc");
+	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 11);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
+	g_assert (!nm_setting_wireless_security_get_auth_alg (s_wsec));
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
+
+	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "0123456789abcdef0123456789");
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* Ignore auto DNS */
+	g_assert (nm_setting_ip_config_get_ignore_auto_dns (s_ip4));
+
+	/* DNS Addresses */
+	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
+	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_passphrase (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-passphrase",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_key_type (s_wsec), ==, NM_WEP_KEY_TYPE_UNKNOWN);
+	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "foobar222blahblah");
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_40_ascii (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMWepKeyType key_type;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-40-ascii",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
+
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
+
+	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "Lorem");
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_104_ascii (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMWepKeyType key_type;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-104-ascii",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
+
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
+
+	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "LoremIpsumSit");
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_leap (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-leap",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-leap)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "ieee8021x");
+	g_assert_cmpstr (nm_setting_wireless_security_get_auth_alg (s_wsec), ==, "leap");
+	g_assert_cmpstr (nm_setting_wireless_security_get_leap_username (s_wsec), ==, "Bill Smith");
+	g_assert_cmpstr (nm_setting_wireless_security_get_leap_password (s_wsec), ==, "foobarblah");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_leap_secret_flags (gconstpointer test_data)
+{
+	NMConnection *connection;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	const char *file;
+	gpointer expected_flags_p;
+
+	nmtst_test_data_unpack (test_data, &file, &expected_flags_p);
+
+	connection = _connection_from_file (file, NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== WIRELESS SETTING ===== */
+	s_wifi = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wifi);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+
+	g_assert (g_strcmp0 (nm_setting_wireless_security_get_key_mgmt (s_wsec), "ieee8021x") == 0);
+	g_assert (g_strcmp0 (nm_setting_wireless_security_get_auth_alg (s_wsec), "leap") == 0);
+	g_assert (g_strcmp0 (nm_setting_wireless_security_get_leap_username (s_wsec), "Bill Smith") == 0);
+	/* password blank as it's not system-owned */
+	g_assert (nm_setting_wireless_security_get_leap_password_flags (s_wsec) == GPOINTER_TO_INT (expected_flags_p));
+	g_assert (nm_setting_wireless_security_get_leap_password (s_wsec) == NULL);
+
+	g_object_unref (connection);
+}
+
+static void
+test_ifcfg_no_trailing_newline (void)
+{
+	shvarFile *sv;
+
+	sv = _svOpenFile (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk");
+	_svGetValue_check (sv, "LAST_ENTRY", "no-newline");
+	svCloseFile (sv);
+}
+
+static void
+test_read_wifi_wpa_psk (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	GBytes *ssid;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
+	const char *expected_ssid = "blahblah";
+	guint32 n, i;
+	gboolean found_pair_tkip = FALSE;
+	gboolean found_pair_ccmp = FALSE;
+	gboolean found_group_tkip = FALSE;
+	gboolean found_group_ccmp = FALSE;
+	gboolean found_group_wep40 = FALSE;
+	gboolean found_group_wep104 = FALSE;
+	gboolean found_proto_wpa = FALSE;
+	gboolean found_proto_rsn = FALSE;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk)");
+
+	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
+	 * the UUID is generated on the full path of the ifcfg file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	mac = nm_setting_wireless_get_mac_address (s_wireless);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
+
+	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
+	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 1);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "wpa-psk");
+	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "I wonder what the king is doing tonight?");
+	g_assert (!nm_setting_wireless_security_get_auth_alg (s_wsec));
+
+	/* Pairwise ciphers */
+	n = nm_setting_wireless_security_get_num_pairwise (s_wsec);
+	g_assert_cmpint (n, ==, 2);
+	for (i = 0; i < n; i++) {
+		const char * tmp = nm_setting_wireless_security_get_pairwise (s_wsec, i);
+		g_assert (tmp);
+		if (strcmp (tmp, "tkip") == 0)
+			found_pair_tkip = TRUE;
+		else if (strcmp (tmp, "ccmp") == 0)
+			found_pair_ccmp = TRUE;
+	}
+	g_assert (found_pair_tkip);
+	g_assert (found_pair_ccmp);
+
+	/* Group ciphers */
+	n = nm_setting_wireless_security_get_num_groups (s_wsec);
+	g_assert_cmpint (n, ==, 4);
+	for (i = 0; i < n; i++) {
+		const char *tmp = nm_setting_wireless_security_get_group (s_wsec, i);
+		g_assert (tmp);
+		if (strcmp (tmp, "tkip") == 0)
+			found_group_tkip = TRUE;
+		else if (strcmp (tmp, "ccmp") == 0)
+			found_group_ccmp = TRUE;
+		else if (strcmp (tmp, "wep40") == 0)
+			found_group_wep40 = TRUE;
+		else if (strcmp (tmp, "wep104") == 0)
+			found_group_wep104 = TRUE;
+	}
+	g_assert (found_group_tkip);
+	g_assert (found_group_ccmp);
+	g_assert (found_group_wep40);
+	g_assert (found_group_wep104);
+
+	/* Protocols */
+	n = nm_setting_wireless_security_get_num_protos (s_wsec);
+	g_assert_cmpint (n, ==, 2);
+	for (i = 0; i < n; i++) {
+		const char *tmp = nm_setting_wireless_security_get_proto (s_wsec, i);
+		g_assert (tmp);
+		if (strcmp (tmp, "wpa") == 0)
+			found_proto_wpa = TRUE;
+		else if (strcmp (tmp, "rsn") == 0)
+			found_proto_rsn = TRUE;
+	}
+	g_assert (found_proto_wpa);
+	g_assert (found_proto_rsn);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_sae (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	GBytes *ssid;
+	const char *expected_ssid = "blahblah";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-sae",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-sae)");
+
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
+
+	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "sae");
+	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "The king is dead.");
+	g_assert (!nm_setting_wireless_security_get_auth_alg (s_wsec));
+}
+
+static void
+test_read_wifi_wpa_psk_2 (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-2",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System ipsum (test-wifi-wpa-psk-2)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "They're really saying I love you. >>`<< '");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wpa_psk_unquoted (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-unquoted",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk-unquoted)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "54336845e2f3f321c4c7");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wpa_psk_unquoted2 (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-unquoted2",
+	                                    NULL, TYPE_WIRELESS, NULL);
+}
+
+static void
+test_read_wifi_wpa_psk_adhoc (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+
+	connection = _connection_from_file(TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-adhoc",
+	                                   NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk-adhoc)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "adhoc");
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "wpa-psk");
+	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "I wonder what the king is doing tonight?");
+
+	g_assert_cmpint (nm_setting_wireless_security_get_num_pairwise (s_wsec), ==, 1);
+	g_assert_cmpstr (nm_setting_wireless_security_get_pairwise (s_wsec, 0), ==, "ccmp");
+
+	g_assert_cmpint (nm_setting_wireless_security_get_num_groups (s_wsec), ==, 1);
+	g_assert_cmpstr (nm_setting_wireless_security_get_group (s_wsec, 0), ==, "ccmp");
+
+	g_assert_cmpint (nm_setting_wireless_security_get_num_protos (s_wsec), ==, 1);
+	g_assert_cmpstr (nm_setting_wireless_security_get_proto (s_wsec, 0), ==, "rsn");
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wpa_psk_hex (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	GBytes *ssid;
+	const char *expected_ssid = "blahblah";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-hex",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk-hex)");
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_assert (ssid);
+	g_assert (nm_utils_gbytes_equal_mem (ssid, expected_ssid, strlen (expected_ssid)));
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "wpa-psk");
+	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "1da190379817bc360dda52e85c388c439a21ea5c7bf819c64e9da051807deae6");
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	g_object_unref (connection);
+}
+
+#define TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT TEST_IFCFG_DIR"/test_ca_cert.pem"
+#define TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT TEST_IFCFG_DIR"/test1_key_and_cert.pem"
+#define TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY TEST_IFCFG_DIR"/test1_key_and_cert.pem"
+
+static void
+test_read_wifi_wpa_eap_tls (void)
+{
+	NMConnection *connection;
+	NMSettingWireless *s_wireless;
+	NMSettingIPConfig *s_ip4;
+	NMSetting8021x *s_8021x;
+	char *unmanaged = NULL;
+	const char *expected_privkey_password = "test1";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-eap-tls",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "tls");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Bill Smith");
+
+	/* CA Cert */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
+	                    NULL,
+	                    NM_SETTING_802_1X_CA_CERT);
+
+	/* Client Cert */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
+	                    NULL,
+	                    NM_SETTING_802_1X_CLIENT_CERT);
+
+	/* Private Key Password */
+	g_assert_cmpstr (nm_setting_802_1x_get_private_key_password (s_8021x), ==, expected_privkey_password);
+
+	/* Private key */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
+	                    expected_privkey_password,
+	                    NM_SETTING_802_1X_PRIVATE_KEY);
+
+	g_object_unref (connection);
+}
+
+/* Also use TLS defines from the previous test */
+
+static void
+test_read_wifi_wpa_eap_ttls_tls (void)
+{
+	NMConnection *connection;
+	NMSettingWireless *s_wireless;
+	NMSettingIPConfig *s_ip4;
+	NMSetting8021x *s_8021x;
+	char *unmanaged = NULL;
+	const char *expected_privkey_password = "test1";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-eap-ttls-tls",
+	                                    NULL, TYPE_WIRELESS, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "ttls");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Chuck Shumer");
+
+	/* CA Cert */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_DIR"/test_ca_cert.pem",
+	                    NULL,
+	                    NM_SETTING_802_1X_CA_CERT);
+
+	/* Inner auth method */
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_autheap (s_8021x), ==, "tls");
+
+	/* Inner CA Cert */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
+	                    NULL,
+	                    NM_SETTING_802_1X_PHASE2_CA_CERT);
+
+	/* Inner Client Cert */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
+	                    NULL,
+	                    NM_SETTING_802_1X_PHASE2_CLIENT_CERT);
+
+	/* Inner Private Key Password */
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_private_key_password (s_8021x), ==, expected_privkey_password);
+
+	/* Inner private key */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
+	                    expected_privkey_password,
+	                    NM_SETTING_802_1X_PHASE2_PRIVATE_KEY);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_dynamic_wep_leap (void)
+{
+	NMConnection *connection;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-dynamic-wep-leap",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wifi = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wifi);
+
+	/* ===== Wi-Fi SECURITY SETTING ===== */
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+
+	/* Key management */
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "ieee8021x");
+
+	/* Auth alg should be NULL (open) for dynamic WEP with LEAP as the EAP method;
+	 * only "old-school" LEAP uses 'leap' for the auth alg.
+	 */
+	g_assert_cmpstr (nm_setting_wireless_security_get_auth_alg (s_wsec), ==, NULL);
+
+	/* Expect no old-school LEAP username/password, that'll be in the 802.1x setting */
+	g_assert_cmpstr (nm_setting_wireless_security_get_leap_username (s_wsec), ==, NULL);
+	g_assert_cmpstr (nm_setting_wireless_security_get_leap_password (s_wsec), ==, NULL);
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+
+	/* EAP method should be "leap" */
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "leap");
+
+	/* username & password */
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "bill smith");
+	g_assert_cmpstr (nm_setting_802_1x_get_password (s_8021x), ==, "foobar baz");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_eap_ttls_chap (void)
+{
+	NMConnection *connection;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSetting8021x *s_8021x;
+	char *unmanaged = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-eap-ttls-chap",
+	                                    NULL, TYPE_WIRELESS, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* ===== 802.1x SETTING ===== */
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "ieee8021x");
+
+	/* ===== 802.1x SETTING ===== */
+	s_8021x = nm_connection_get_setting_802_1x (connection);
+	g_assert (s_8021x);
+
+	/* EAP methods */
+	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
+	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "ttls");
+
+	/* CA Cert */
+	verify_cert_or_key (s_8021x,
+	                    TEST_IFCFG_DIR"/test_ca_cert.pem",
+	                    NULL,
+	                    NM_SETTING_802_1X_CA_CERT);
+
+	g_assert_cmpstr (nm_setting_802_1x_get_phase2_auth (s_8021x), ==, "chap");
+	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "David Smith");
+	g_assert_cmpstr (nm_setting_802_1x_get_password (s_8021x), ==, "foobar baz");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_wake_on_lan (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-wake-on-lan",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_wake_on_lan (s_wired),
+	                 ==,
+	                 NM_SETTING_WIRED_WAKE_ON_LAN_ARP |
+	                 NM_SETTING_WIRED_WAKE_ON_LAN_PHY |
+	                 NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC);
+
+	g_assert_cmpstr (nm_setting_wired_get_wake_on_lan_password (s_wired),
+	                 ==,
+	                 "00:11:22:33:44:55");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_auto_negotiate_off (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-wake-on-lan",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	g_assert (!nm_setting_wired_get_auto_negotiate (s_wired));
+	g_assert_cmpint (nm_setting_wired_get_speed (s_wired), ==, 100);
+	g_assert_cmpstr (nm_setting_wired_get_duplex (s_wired), ==, "full");
+}
+
+static void
+test_read_wired_auto_negotiate_on (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-auto-negotiate-on",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	g_assert (nm_setting_wired_get_auto_negotiate (s_wired));
+	g_assert_cmpint (nm_setting_wired_get_speed (s_wired), ==, 0);
+	g_assert_cmpstr (nm_setting_wired_get_duplex (s_wired), ==, NULL);
+}
+
+static void
+test_read_wired_unknown_ethtool_opt (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-unknown-ethtool-opt",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	g_assert (!nm_setting_wired_get_auto_negotiate (s_wired));
+	g_assert (!nm_setting_wired_get_speed (s_wired));
+	g_assert (!nm_setting_wired_get_duplex (s_wired));
+
+	g_assert_cmpint (nm_setting_wired_get_wake_on_lan (s_wired),
+	                 ==,
+	                 NM_SETTING_WIRED_WAKE_ON_LAN_ARP |
+	                 NM_SETTING_WIRED_WAKE_ON_LAN_PHY |
+	                 NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC);
+	g_assert_cmpstr (nm_setting_wired_get_wake_on_lan_password (s_wired),
+	                 ==,
+	                 "00:11:22:33:44:55");
+}
+
+static void
+test_read_wifi_hidden (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-hidden",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRELESS_SETTING_NAME);
+
+	s_wifi = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wifi);
+	g_assert (nm_setting_wireless_get_hidden (s_wifi) == TRUE);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_wifi_hidden (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	shvarFile *f;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Hidden",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_HIDDEN, TRUE,
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_WiFi_Hidden.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "SSID_HIDDEN", "yes");
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_wifi_mac_random (gconstpointer user_data)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	gs_free char *path = NULL;
+	NMSettingWireless *s_wifi;
+	const char *name;
+	gpointer value_p;
+	NMSettingMacRandomization value;
+
+	nmtst_test_data_unpack (user_data, &name, &value_p);
+	value = GPOINTER_TO_INT (value_p);
+
+	path = g_strdup_printf (TEST_IFCFG_DIR"/ifcfg-test-wifi-mac-random-%s", name);
+	connection = _connection_from_file (path, NULL, TYPE_WIRELESS, NULL);
+
+	s_wifi = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wifi);
+	g_assert_cmpint (nm_setting_wireless_get_mac_address_randomization (s_wifi), ==, value);
+}
+
+static void
+test_write_wifi_mac_random (gconstpointer user_data)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	char *val;
+	shvarFile *f;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
+	const char *name, *write_expected;
+	gpointer value_p;
+	NMSettingMacRandomization value;
+	char cexpected[NM_STRLEN (TEST_IFCFG_DIR) + 100];
+
+	nmtst_test_data_unpack (user_data, &name, &value_p, &write_expected);
+	value = GPOINTER_TO_INT (value_p);
+
+	g_assert (write_expected);
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	val = g_strdup_printf ("Test Write Wi-Fi MAC %s", name);
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, val,
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+	g_free (val);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, value,
+	              NULL);
+	g_bytes_unref (ssid);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        nm_sprintf_buf (cexpected, TEST_IFCFG_DIR"/ifcfg-Test_Write_WiFi_MAC_%s.cexpected", name),
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "MAC_ADDRESS_RANDOMIZATION", write_expected);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_wake_on_lan (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingWiredWakeOnLan wol;
+	char *val;
+	shvarFile *f;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Wake-on-LAN",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	wol = NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST |
+	      NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST |
+	      NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC;
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_WAKE_ON_LAN, wol,
+	              NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD, "00:00:00:11:22:33",
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Wake-on-LAN.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	val = svGetValueStr_cp (f, "ETHTOOL_OPTS");
+	g_assert (val);
+	g_assert (strstr (val, "wol"));
+	g_assert (strstr (val, "sopass 00:00:00:11:22:33"));
+	g_free (val);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_auto_negotiate_off (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingWired *s_wired;
+	char *val;
+	shvarFile *f;
+
+	connection = nmtst_create_minimal_connection ("Test Write Wired Auto-Negotiate", NULL, NM_SETTING_WIRED_SETTING_NAME, NULL);
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_AUTO_NEGOTIATE, FALSE,
+	              NM_SETTING_WIRED_DUPLEX, "half",
+	              NM_SETTING_WIRED_SPEED, 10,
+	              NULL);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Auto-Negotiate.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	val = svGetValueStr_cp (f, "ETHTOOL_OPTS");
+	g_assert (val);
+	g_assert (strstr (val, "autoneg off"));
+	g_assert (strstr (val, "speed 10"));
+	g_assert (strstr (val, "duplex half"));
+	g_free (val);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_auto_negotiate_on (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingWired *s_wired;
+	NMSettingEthtool *s_ethtool;
+	char *val;
+	shvarFile *f;
+
+	connection = nmtst_create_minimal_connection ("Test Write Wired Auto-Negotiate", NULL, NM_SETTING_WIRED_SETTING_NAME, NULL);
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_AUTO_NEGOTIATE, TRUE,
+	              NULL);
+
+	s_ethtool = NM_SETTING_ETHTOOL (nm_setting_ethtool_new ());
+	nm_setting_ethtool_set_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_TX, NM_TERNARY_TRUE);
+	nm_setting_ethtool_set_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN, NM_TERNARY_FALSE);
+	nm_connection_add_setting (connection, NM_SETTING (s_ethtool));
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-test_write_wired_auto_negotiate_on.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	val = svGetValueStr_cp (f, "ETHTOOL_OPTS");
+	g_assert (val);
+	g_assert (strstr (val, "autoneg on"));
+	g_assert (!strstr (val, "speed"));
+	g_assert (!strstr (val, "duplex"));
+	g_free (val);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_verifies_without_normalization (reread);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	s_ethtool = NM_SETTING_ETHTOOL (nm_connection_get_setting (reread, NM_TYPE_SETTING_ETHTOOL));
+	g_assert (s_ethtool);
+	g_assert_cmpint (nm_setting_ethtool_get_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_TX), ==, NM_TERNARY_TRUE);
+	g_assert_cmpint (nm_setting_ethtool_get_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN), ==, NM_TERNARY_FALSE);
+	g_assert_cmpint (nm_setting_ethtool_get_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_TXVLAN), ==, NM_TERNARY_DEFAULT);
+}
+
+static void
+test_read_wifi_band_a (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-band-a",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRELESS_SETTING_NAME);
+
+	s_wifi = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wifi);
+	g_assert_cmpstr (nm_setting_wireless_get_band (s_wifi), ==, "a");
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_wifi_band_a (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	shvarFile *f;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Band A",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_BAND, "a",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_WiFi_Band_A.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "BAND", "a");
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_wifi_band_a_channel_mismatch (void)
+{
+	gs_free_error GError *error = NULL;
+
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-wifi-band-a-channel-mismatch",
+	                            NULL, TYPE_WIRELESS, &error);
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+}
+
+static void
+test_read_wifi_band_bg_channel_mismatch (void)
+{
+	gs_free_error GError *error = NULL;
+
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-wifi-band-bg-channel-mismatch",
+	                            NULL, TYPE_WIRELESS, &error);
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+}
+
+static void
+test_read_wired_qeth_static (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	char *unmanaged = NULL;
+	const char * const *subchannels;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-qeth-static",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-qeth-static");
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	g_assert (!nm_setting_wired_get_mac_address (s_wired));
+
+	/* Subchannels */
+	subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
+	g_assert (subchannels);
+	g_assert (subchannels[0] && subchannels[1] && subchannels[2] && !subchannels[3]);
+
+	g_assert_cmpstr (subchannels[0], ==, "0.0.0600");
+	g_assert_cmpstr (subchannels[1], ==, "0.0.0601");
+	g_assert_cmpstr (subchannels[2], ==, "0.0.0602");
+
+	g_assert_cmpstr (nm_setting_wired_get_s390_nettype (s_wired), ==, "qeth");
+	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "portname"), ==, "OSAPORT");
+	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "portno"), ==, "0");
+	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "layer2"), ==, "1");
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wired_ctc_static (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	char *unmanaged = NULL;
+	const char * const *subchannels;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-ctc-static",
+	                                    NULL, TYPE_ETHERNET, &unmanaged);
+	g_assert (unmanaged == NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con != NULL);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-ctc-static");
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired != NULL);
+
+	g_assert (nm_setting_wired_get_mac_address (s_wired) == NULL);
+
+	/* Subchannels */
+	subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
+	g_assert (subchannels != NULL);
+	g_assert (subchannels[0] && subchannels[1] && !subchannels[2]);
+
+	g_assert_cmpstr (subchannels[0], ==, "0.0.1b00");
+	g_assert_cmpstr (subchannels[1], ==, "0.0.1b01");
+
+	g_assert_cmpstr (nm_setting_wired_get_s390_nettype (s_wired), ==, "ctc");
+	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "ctcprot"), ==, "0");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_no_keys (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMWepKeyType key_type;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-no-keys",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System foobar (test-wifi-wep-no-keys)");
+
+	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
+	 * the UUID is generated on the full path of the ifcfg file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wireless);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+
+	/* Key management */
+	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
+
+	/* WEP key index */
+	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
+
+	/* WEP key type */
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
+
+	/* WEP key index 0; we don't expect it to be filled */
+	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 0));
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_permissions (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	gboolean success;
+	guint32 num;
+	const char *tmp;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-permissions",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	num = nm_setting_connection_get_num_permissions (s_con);
+	g_assert_cmpint (num, ==, 3);
+
+	/* verify each permission */
+	tmp = NULL;
+	success = nm_setting_connection_get_permission (s_con, 0, NULL, &tmp, NULL);
+	g_assert (success);
+	g_assert_cmpstr (tmp, ==, "dcbw");
+
+	tmp = NULL;
+	success = nm_setting_connection_get_permission (s_con, 1, NULL, &tmp, NULL);
+	g_assert (success);
+	g_assert_cmpstr (tmp, ==, "ssmith");
+
+	tmp = NULL;
+	success = nm_setting_connection_get_permission (s_con, 2, NULL, &tmp, NULL);
+	g_assert (success);
+	g_assert_cmpstr (tmp, ==, "johnny5");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_wifi_wep_agent_keys (void)
+{
+	NMConnection *connection;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMWepKeyType key_type;
+	NMSettingSecretFlags flags;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-agent-keys",
+	                                    NULL, TYPE_WIRELESS, NULL);
+
+	/* Ensure the connection is still marked for wifi security even though
+	 * we don't have any WEP keys because they are agent owned.
+	 */
+
+	/* ===== WIRELESS SETTING ===== */
+	s_wifi = nm_connection_get_setting_wireless (connection);
+	g_assert (s_wifi);
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+	s_wsec = nm_connection_get_setting_wireless_security (connection);
+	g_assert (s_wsec);
+
+	g_assert (strcmp (nm_setting_wireless_security_get_key_mgmt (s_wsec), "none") == 0);
+	g_assert (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec) == 0);
+
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
+
+	/* We don't expect WEP key0 to be filled */
+	g_assert (nm_setting_wireless_security_get_wep_key (s_wsec, 0) == NULL);
+
+	flags = nm_setting_wireless_security_get_wep_key_flags (s_wsec);
+	g_assert (flags & NM_SETTING_SECRET_FLAG_AGENT_OWNED);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_wired_static (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *route6file = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4, *reread_s_ip4;
+	NMSettingIPConfig *s_ip6, *reread_s_ip6;
+	NMIPAddress *addr;
+	NMIPAddress *addr6;
+	NMIPRoute *route6;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES, 1,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
+	              NM_SETTING_WIRED_MTU, (guint32) 1492,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
+
+	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
+	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 206,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	addr6 = nm_ip_address_new (AF_INET6, "2003:1234:abcd::2", 22, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	addr6 = nm_ip_address_new (AF_INET6, "3003:1234:abcd::3", 33, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	/* Add routes */
+	route6 = nm_ip_route_new (AF_INET6,
+	                          "2222:aaaa:bbbb:cccc::", 64,
+	                          "2222:aaaa:bbbb:cccc:dddd:eeee:5555:6666", 99, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip6, route6);
+	nm_ip_route_unref (route6);
+
+	route6 = nm_ip_route_new (AF_INET6, "::", 128, "2222:aaaa::9999", 1, &error);
+	g_assert_no_error (error);
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_CWND, g_variant_new_uint32 (100));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_MTU, g_variant_new_uint32 (1280));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND, g_variant_new_boolean (TRUE));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_FROM, g_variant_new_string ("2222::bbbb/32"));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_SRC, g_variant_new_string ("::42"));
+	nm_setting_ip_config_add_route (s_ip6, route6);
+	nm_ip_route_unref (route6);
+
+	/* DNS servers */
+	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
+	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
+
+	/* DNS domains */
+	nm_setting_ip_config_add_dns_search (s_ip6, "foobar6.com");
+	nm_setting_ip_config_add_dns_search (s_ip6, "lab6.foobar.com");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+	route6file = utils_get_route6_path (testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	reread_s_ip4 = nm_connection_get_setting_ip4_config (reread);
+	reread_s_ip6 = nm_connection_get_setting_ip6_config (reread);
+
+	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip4), ==, 204);
+	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip6), ==, 206);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
+static void
+test_write_wired_static_with_generic (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *route6file = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4, *reread_s_ip4;
+	NMSettingIPConfig *s_ip6, *reread_s_ip6;
+	NMIPAddress *addr;
+	NMIPAddress *addr6;
+	NMIPRoute *route6;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES, 1,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
+	              NM_SETTING_WIRED_MTU, (guint32) 1492,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
+
+	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
+	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 206,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	addr6 = nm_ip_address_new (AF_INET6, "2003:1234:abcd::2", 22, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	addr6 = nm_ip_address_new (AF_INET6, "3003:1234:abcd::3", 33, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	/* Add routes */
+	route6 = nm_ip_route_new (AF_INET6,
+	                          "2222:aaaa:bbbb:cccc::", 64,
+	                          "2222:aaaa:bbbb:cccc:dddd:eeee:5555:6666", 99, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip6, route6);
+	nm_ip_route_unref (route6);
+
+	route6 = nm_ip_route_new (AF_INET6, "::", 128, "2222:aaaa::9999", 1, &error);
+	g_assert_no_error (error);
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_CWND, g_variant_new_uint32 (100));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_MTU, g_variant_new_uint32 (1280));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND, g_variant_new_boolean (TRUE));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_FROM, g_variant_new_string ("2222::bbbb/32"));
+	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_SRC, g_variant_new_string ("::42"));
+	nm_setting_ip_config_add_route (s_ip6, route6);
+	nm_ip_route_unref (route6);
+
+	/* DNS servers */
+	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
+	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
+
+	/* DNS domains */
+	nm_setting_ip_config_add_dns_search (s_ip6, "foobar6.com");
+	nm_setting_ip_config_add_dns_search (s_ip6, "lab6.foobar.com");
+
+	nm_connection_add_setting (connection, nm_setting_generic_new ());
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_FIXME (connection,
+	                              TEST_SCRATCH_DIR,
+	                              &testfile);
+	route6file = utils_get_route6_path (testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	reread_s_ip4 = nm_connection_get_setting_ip4_config (reread);
+	reread_s_ip6 = nm_connection_get_setting_ip6_config (reread);
+
+	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip4), ==, 204);
+	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip6), ==, 206);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	{
+		gs_unref_hashtable GHashTable *diffs = NULL;
+
+		g_assert (!nm_connection_diff (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT, &diffs));
+		g_assert (diffs);
+		g_assert (g_hash_table_size (diffs) == 1);
+		g_assert (g_hash_table_lookup (diffs, "generic"));
+		g_assert (!nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+	}
+	g_assert (!nm_connection_get_setting (reread, NM_TYPE_SETTING_GENERIC));
+	nm_connection_add_setting (reread, nm_setting_generic_new ());
+	{
+		gs_unref_hashtable GHashTable *diffs = NULL;
+
+		g_assert (nm_connection_diff (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT, &diffs));
+		g_assert (!diffs);
+		g_assert (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+	}
+}
+
+static void
+test_write_wired_dhcp (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired DHCP",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, "random-client-id-00:22:33",
+	              NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, "awesome-hostname",
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, TRUE,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static NMIPRoutingRule *
+_ip_routing_rule_new (int addr_family,
+                      const char *str)
+{
+	NMIPRoutingRuleAsStringFlags flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE;
+	gs_free_error GError *local = NULL;
+	NMIPRoutingRule *rule;
+
+	if (addr_family != AF_UNSPEC) {
+		if (addr_family == AF_INET)
+			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET;
+		else {
+			g_assert (addr_family == AF_INET6);
+			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6;
+		}
+	}
+
+	rule = nm_ip_routing_rule_from_string (str,
+	                                         NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
+	                                       | flags,
+	                                       NULL,
+	                                       nmtst_get_rand_bool () ? &local : NULL);
+	nmtst_assert_success (rule, local);
+
+	if (addr_family != AF_UNSPEC)
+		g_assert_cmpint (nm_ip_routing_rule_get_addr_family (rule), ==, addr_family);
+	return rule;
+}
+
+static void
+_ip_routing_rule_add_to_setting (NMSettingIPConfig *s_ip,
+                                 const char *str)
+{
+	nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
+
+	rule = _ip_routing_rule_new (nm_setting_ip_config_get_addr_family (s_ip), str);
+	nm_setting_ip_config_add_routing_rule (s_ip, rule);
+}
+
+static void
+test_write_routing_rules (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = nm_simple_connection_new ();
+
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Routing Rules",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	_ip_routing_rule_add_to_setting (s_ip4, "pref 10 from 0.0.0.0/0 table 1");
+	_ip_routing_rule_add_to_setting (s_ip4, "priority 10 to 192.167.8.0/24 table 2");
+	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 table 10");
+	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 to 1:2:3::5/24 table 22");
+	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 to 1:3:3::5/128 table 55");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Routing_Rules.cexpected",
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_match (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingMatch *s_match;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired with Match setting",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	/* Match setting */
+	s_match = (NMSettingMatch *) nm_setting_match_new ();
+	nm_setting_match_add_interface_name (s_match, "ens*");
+	nm_setting_match_add_interface_name (s_match, "eth 1?");
+	nm_setting_match_add_interface_name (s_match, "!veth*");
+	nm_connection_add_setting (connection, NM_SETTING (s_match));
+
+	nmtst_assert_connection_verifies (connection);
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_match.cexpected",
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_dhcp_plus_ip (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp-plus-ip",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_write_wired_dhcp_send_hostname (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char * dhcp_hostname = "kamil-patka";
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp-send-hostname",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* Check dhcp-hostname and dhcp-send-hostname */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip4);
+	g_assert (s_ip6);
+	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) == TRUE);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, "svata-pulec");
+	g_assert (!nm_setting_ip_config_get_dhcp_hostname (s_ip6));
+
+	/* Set dhcp-send-hostname=false dhcp-hostname="kamil-patka" and write the connection. */
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, dhcp_hostname, NULL);
+	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, dhcp_hostname, NULL);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	/* Check dhcp-hostname and dhcp-send-hostname from the re-read connection. */
+	s_ip4 = nm_connection_get_setting_ip4_config (reread);
+	s_ip6 = nm_connection_get_setting_ip6_config (reread);
+	g_assert (s_ip4);
+	g_assert (s_ip6);
+	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) == FALSE);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, dhcp_hostname);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
+}
+
+static void
+test_read_wired_dhcpv6_hostname_fallback (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingIPConfig *s_ip6;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcpv6-hostname-fallback",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip6);
+	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip6) == TRUE);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, "fully.qualified.domain");
+}
+
+static void
+test_write_wired_static_ip6_only (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMIPAddress *addr6;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static IP6 Only",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd", NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_DISABLED,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	/* DNS server */
+	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_ip6_disabled (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = nmtst_create_minimal_connection ("Test Write Wired Disabled IP6",
+	                                              NULL,
+	                                              NM_SETTING_WIRED_SETTING_NAME,
+	                                              &s_con);
+
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_DISABLED,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_IFCFG_DIR"/ifcfg-test-ip6-disabled.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+/* Test writing an IPv6 config with varying gateway address.
+ * For missing gateway (::), we expect no IPV6_DEFAULTGW to be written
+ * to ifcfg-rh.
+ *
+ * As user_data pass the IPv6 address of the gateway as string. NULL means
+ * not to explicitly set the gateway in the configuration before writing it.
+ * That way, the gateway actually defaults to "::".
+ */
+static void
+test_write_wired_static_ip6_only_gw (gconstpointer user_data)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMIPAddress *addr6;
+	GError *error = NULL;
+	char *id = NULL;
+	gs_free char *written_ifcfg_gateway = NULL;
+	const char *gateway6 = user_data;
+	shvarFile *ifcfg;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	id = g_strdup_printf ("Test Write Wired Static IP6 Only With Gateway %s", gateway6 ?: "NULL");
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, id,
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+	g_free (id);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd", NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_DISABLED,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, gateway6,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	/* DNS server */
+	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	ifcfg = _svOpenFile (testfile);
+	written_ifcfg_gateway = svGetValueStr_cp (ifcfg, "IPV6_DEFAULTGW");
+	svCloseFile (ifcfg);
+
+	/* access the gateway from the loaded connection. */
+	s_ip6 = nm_connection_get_setting_ip6_config (reread);
+	g_assert (s_ip6 && nm_setting_ip_config_get_num_addresses (s_ip6)==1);
+	addr6 = nm_setting_ip_config_get_address (s_ip6, 0);
+	g_assert (addr6);
+
+	/* assert that the gateway was written and reloaded as expected */
+	if (!gateway6 || !strcmp (gateway6, "::")) {
+		g_assert (nm_setting_ip_config_get_gateway (s_ip6) == NULL);
+		g_assert (written_ifcfg_gateway == NULL);
+	} else {
+		g_assert (nm_setting_ip_config_get_gateway (s_ip6) != NULL);
+		g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip6), ==, gateway6);
+		g_assert_cmpstr (written_ifcfg_gateway, ==, gateway6);
+	}
+}
+
+static void
+test_read_write_static_routes_legacy (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *routefile = NULL;
+	gs_free char *route6file = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	const char *tmp;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-static-routes-legacy",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	/* ID */
+	tmp = nm_setting_connection_get_id (s_con);
+	g_assert (tmp);
+
+	/* Autoconnect */
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	g_assert (!nm_setting_ip_config_get_never_default (s_ip4));
+
+	/* Save the ifcfg; use a special different scratch dir to ensure that
+	 * we can clean up after the written connection in both the original
+	 * source tree and for 'make distcheck'.
+	 */
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_IFCFG_DIR"/ifcfg-test-static-routes-legacy.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	routefile = utils_get_route_path (testfile);
+	route6file = utils_get_route6_path (testfile);
+	g_assert (!g_file_test (route6file, G_FILE_TEST_EXISTS));
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_static_routes (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *routefile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMIPAddress *addr;
+	NMIPRoute *route;
+	GError *error = NULL;
+	gboolean reread_same = FALSE;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static Routes",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
+	              NM_SETTING_WIRED_MTU, (guint32) 1492,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_DAD_TIMEOUT, 400,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* Write out routes */
+	route = nm_ip_route_new (AF_INET, "1.2.3.0", 24, "222.173.190.239", 0, &error);
+	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
+	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (TRUE));
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip4, route);
+	nm_ip_route_unref (route);
+
+	route = nm_ip_route_new (AF_INET, "3.2.1.0", 24, "202.254.186.190", 77, &error);
+	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (30000));
+	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip4, route);
+	nm_ip_route_unref (route);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
+
+	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
+	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_reread (connection,
+	                               TEST_SCRATCH_DIR,
+	                               &testfile,
+	                               TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Static_Routes.cexpected",
+	                               &reread,
+	                               &reread_same);
+	/* ifcfg does not support setting onlink=0. It gets lost during write+re-read.
+	 * Assert that it's missing, and patch it to check whether the rest of the
+	 * connection equals. */
+	g_assert (!reread_same);
+	nmtst_assert_connection_verifies_without_normalization (reread);
+	s_ip4 = nm_connection_get_setting_ip4_config (reread);
+	g_assert (s_ip4);
+	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 2);
+	route = nm_setting_ip_config_get_route (s_ip4, 1);
+	g_assert (route);
+	g_assert (!nm_ip_route_get_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK));
+	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	routefile = utils_get_route_path (testfile);
+}
+
+static void
+test_write_wired_dhcp_8021x_peap_mschapv2 (void)
+{
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSetting8021x *s_8021x;
+	gboolean success;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired DHCP 802.1x PEAP MSCHAPv2",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	/* 802.1x setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY, "Bob Saget",
+	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "barney",
+	              NM_SETTING_802_1X_PASSWORD, "Kids, it was back in October 2008...",
+	              NM_SETTING_802_1X_PHASE1_PEAPVER, "1",
+	              NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1",
+	              NM_SETTING_802_1X_PHASE2_AUTH, "mschapv2",
+	              NULL);
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "peap");
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_IFCFG_WIRED_8021x_PEAP_MSCHAPV2_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	keyfile = utils_get_keys_path (testfile);
+}
+
+static void
+test_write_wired_8021x_tls (gconstpointer test_data)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_free char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSetting8021x *s_8021x;
+	gboolean success;
+	GError *error = NULL;
+	NMSetting8021xCKFormat format = NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
+	const char *pw;
+	char *tmp;
+	gpointer scheme_p, flags_p;
+	NMSetting8021xCKScheme scheme;
+	NMSettingSecretFlags flags;
+
+	nmtst_test_data_unpack (test_data, &scheme_p, &flags_p);
+	scheme = GPOINTER_TO_INT (scheme_p);
+	flags = GPOINTER_TO_INT (flags_p);
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired 802.1x TLS Blobs",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	/* 802.1x setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, "Bill Smith", NULL);
+	nm_setting_802_1x_add_eap_method (s_8021x, "tls");
+
+	/* CA cert */
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_IFCFG_DIR"/test_ca_cert.pem",
+	                                         scheme,
+	                                         &format,
+	                                         &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (format == NM_SETTING_802_1X_CK_FORMAT_X509);
+
+	/* Client cert */
+	format = NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
+	success = nm_setting_802_1x_set_client_cert (s_8021x,
+	                                             TEST_IFCFG_DIR"/test1_key_and_cert.pem",
+	                                             scheme,
+	                                             &format,
+	                                             &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (format == NM_SETTING_802_1X_CK_FORMAT_X509);
+
+	/* Private key */
+	format = NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
+	success = nm_setting_802_1x_set_private_key (s_8021x,
+	                                             TEST_IFCFG_DIR"/test1_key_and_cert.pem",
+	                                             "test1",
+	                                             scheme,
+	                                             &format,
+	                                             &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (format == NM_SETTING_802_1X_CK_FORMAT_RAW_KEY);
+
+	/* Set secret flags */
+	g_object_set (s_8021x, NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS, flags, NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_FIXME (connection,
+	                              TEST_SCRATCH_DIR,
+	                              &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	nmtst_file_unlink_if_exists (keyfile);
+
+	/* Ensure the reread connection's certificates and private key are paths; no
+	 * matter what scheme was used in the original connection they will be read
+	 * back in as paths.
+	 */
+	s_8021x = nm_connection_get_setting_802_1x (reread);
+	g_assert (s_8021x);
+	g_assert_cmpint (nm_setting_802_1x_get_ca_cert_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
+	g_assert_cmpint (nm_setting_802_1x_get_client_cert_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
+	g_assert_cmpint (nm_setting_802_1x_get_private_key_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
+
+	g_assert_cmpint (nm_setting_802_1x_get_private_key_password_flags (s_8021x), ==, flags);
+	pw = nm_setting_802_1x_get_private_key_password (s_8021x);
+	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
+		/* Ensure the private key password is still set */
+		g_assert (pw != NULL);
+		g_assert_cmpstr (pw, ==, "test1");
+	} else {
+		/* If the secret isn't owned by system settings, make sure its no longer there */
+		g_assert (pw == NULL);
+	}
+
+	if (scheme == NM_SETTING_802_1X_CK_SCHEME_PATH) {
+		/* Do a direct compare if using the path scheme since then the
+		 * certificate and key properties should be the same.  If using blob
+		 * scheme the original connection cert/key properties will be blobs
+		 * but the re-read connection is always path scheme, so we wouldn't
+		 * expect it to compare successfully.
+		 */
+		if (flags != NM_SETTING_SECRET_FLAG_NONE) {
+			/* Clear original connection's private key password because flags
+			 * say it's not system-owned, and therefore it should not show up
+			 * in the re-read connection.
+			 */
+			s_8021x = nm_connection_get_setting_802_1x (connection);
+			g_object_set (s_8021x, NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD, NULL, NULL);
+		}
+
+		nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+	}
+
+	/* Clean up created certs and keys */
+	tmp = utils_cert_path (testfile, "ca-cert", "der");
+	nmtst_file_unlink_if_exists (tmp);
+	g_free (tmp);
+
+	tmp = utils_cert_path (testfile, "client-cert", "der");
+	nmtst_file_unlink_if_exists (tmp);
+	g_free (tmp);
+
+	tmp = utils_cert_path (testfile, "private-key", "pem");
+	nmtst_file_unlink_if_exists (tmp);
+	g_free (tmp);
+}
+
+static void
+test_write_wired_aliases (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	int num_addresses = 4;
+	const char *ip[] = { "1.1.1.1", "1.1.1.2", "1.1.1.3", "1.1.1.4" };
+	const char *label[] = { NULL, "alias0:2", NULL, "alias0:3" };
+	NMIPAddress *addr;
+	GError *error = NULL;
+	shvarFile *ifcfg;
+	int i, j;
+
+	nmtst_file_unlink_if_exists (TEST_SCRATCH_ALIAS_BASE ":2");
+	nmtst_file_unlink_if_exists (TEST_SCRATCH_ALIAS_BASE ":3");
+	nmtst_file_unlink_if_exists (TEST_SCRATCH_ALIAS_BASE ":5");
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "alias0",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	for (i = 0; i < num_addresses; i++) {
+		addr = nm_ip_address_new (AF_INET, ip[i], 24, &error);
+		g_assert_no_error (error);
+		if (label[i])
+			nm_ip_address_set_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL, g_variant_new_string (label[i]));
+		nm_setting_ip_config_add_address (s_ip4, addr);
+		nm_ip_address_unref (addr);
+	}
+
+	nmtst_assert_connection_verifies (connection);
+
+	/* Create some pre-existing alias files, to make sure they get overwritten / deleted. */
+	ifcfg = svCreateFile (TEST_SCRATCH_ALIAS_BASE ":2");
+	svSetValueStr (ifcfg, "DEVICE", "alias0:2");
+	svSetValueStr (ifcfg, "IPADDR", "192.168.1.2");
+	svWriteFile (ifcfg, 0644, NULL);
+	svCloseFile (ifcfg);
+	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":2", G_FILE_TEST_EXISTS));
+
+	ifcfg = svCreateFile (TEST_SCRATCH_ALIAS_BASE ":5");
+	svSetValueStr (ifcfg, "DEVICE", "alias0:5");
+	svSetValueStr (ifcfg, "IPADDR", "192.168.1.5");
+	svWriteFile (ifcfg, 0644, NULL);
+	svCloseFile (ifcfg);
+	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":5", G_FILE_TEST_EXISTS));
+
+	_writer_new_connection_FIXME (connection,
+	                              TEST_SCRATCH_DIR,
+	                              &testfile);
+
+	/* Re-check the alias files */
+	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":2", G_FILE_TEST_EXISTS));
+	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":3", G_FILE_TEST_EXISTS));
+	g_assert (!g_file_test (TEST_SCRATCH_ALIAS_BASE ":5", G_FILE_TEST_EXISTS));
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+	nmtst_file_unlink (TEST_SCRATCH_ALIAS_BASE ":2");
+	nmtst_file_unlink (TEST_SCRATCH_ALIAS_BASE ":3");
+
+	/* nm_connection_compare() is not guaranteed to succeed, because the
+	 * aliases get read back in essentially random order. So just
+	 * verify the aliases manually.
+	 */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (nm_setting_ip_config_get_num_addresses (s_ip4) == num_addresses);
+
+	/* Addresses */
+	for (i = 0; i < num_addresses; i++) {
+		const char *addrstr;
+
+		addr = nm_setting_ip_config_get_address (s_ip4, i);
+		g_assert (addr != NULL);
+
+		addrstr = nm_ip_address_get_address (addr);
+		for (j = 0; j < num_addresses; j++) {
+			if (!g_strcmp0 (addrstr, ip[j]))
+				break;
+		}
+		if (j >= num_addresses)
+			g_assert_not_reached ();
+		else {
+			g_assert_cmpint (nm_ip_address_get_prefix (addr), ==, 24);
+			if (label[j])
+				g_assert_cmpstr (g_variant_get_string (nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL), NULL), ==, label[j]);
+			else
+				g_assert (nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL) == NULL);
+			ip[j] = NULL;
+		}
+	}
+
+	for (i = 0; i < num_addresses; i++)
+		g_assert (!ip[i]);
+
+	/* Gateway */
+	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
+}
+
+static void
+test_write_gateway (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	GError *error = NULL;
+	shvarFile *f;
+	NMIPAddress *addr;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Static Addresses Gateway",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.254",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	addr = nm_ip_address_new (AF_INET, "2.2.2.5", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "IPADDR", "1.1.1.3");
+	_svGetValue_check (f, "IPADDR1", "2.2.2.5");
+	_svGetValue_check (f, "IPADDR0", NULL);
+	_svGetValue_check (f, "PREFIX", "24");
+	_svGetValue_check (f, "PREFIX1", "24");
+	_svGetValue_check (f, "PREFIX0", NULL);
+	_svGetValue_check (f, "GATEWAY", "1.1.1.254");
+	_svGetValue_check (f, "GATEWAY0", NULL);
+	_svGetValue_check (f, "GATEWAY1", NULL);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_open (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
+	shvarFile *ifcfg;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi Open",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_BSSID, "11:22:33:44:55:66",
+	              NM_SETTING_WIRELESS_MAC_ADDRESS, "aa:bb:cc:dd:ee:ff",
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_BAND, "bg",
+	              NM_SETTING_WIRELESS_CHANNEL, (guint32) 9,
+	              NM_SETTING_WIRELESS_MTU, (guint32) 1345,
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	ifcfg = _svOpenFile (testfile);
+	_svGetValue_check (ifcfg, "ESSID", "Test SSID");
+	svCloseFile (ifcfg);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_open_hex_ssid (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd };
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi Open Hex SSID",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wep (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	struct stat statbuf;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 2,
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "0123456789abcdef0123456789");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 1, "11111111111111111111111111");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 2, "aaaaaaaaaaaaaaaaaaaaaaaaaa");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 3, "BBBBBBBBBBBBBBBBBBBBBBBBBB");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
+	g_assert (S_ISREG (statbuf.st_mode));
+	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wep_adhoc (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	struct stat statbuf;
+	NMIPAddress *addr;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP AdHoc",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "adhoc",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "0123456789abcdef0123456789");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NULL);
+
+	/* IP Address */
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
+	g_assert (S_ISREG (statbuf.st_mode));
+	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wep_passphrase (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	struct stat statbuf;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP Passphrase",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0,
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "asdfdjaslfjasd;flasjdfl;aksdf");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
+	g_assert (S_ISREG (statbuf.st_mode));
+	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wep_40_ascii (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah40";
+	struct stat statbuf;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP 40 ASCII",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 2,
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_KEY,
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "lorem");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 1, "ipsum");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 2, "dolor");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 3, "donec");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
+	g_assert (S_ISREG (statbuf.st_mode));
+	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wep_104_ascii (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah104";
+	struct stat statbuf;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP 104 ASCII",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0,
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_UNKNOWN,
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open",
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "LoremIpsumSit");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 1, "AlfaBetaGamma");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 2, "WEP-104 ASCII");
+	nm_setting_wireless_security_set_wep_key (s_wsec, 3, "thisismyascii");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wifi_WEP_104_ASCII.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
+	g_assert (S_ISREG (statbuf.st_mode));
+	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_leap (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	struct stat statbuf;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi LEAP",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
+	              NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, "Bill Smith",
+	              NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, "foobar22",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wifi_LEAP.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
+	g_assert (S_ISREG (statbuf.st_mode));
+	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_leap_secret_flags (gconstpointer data)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_free char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	NMSettingSecretFlags flags = GPOINTER_TO_UINT (data);
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi LEAP Secret Flags",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
+	              NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, "Bill Smith",
+	              NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, "foobar22",
+	              NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_FIXME (connection,
+	                              TEST_SCRATCH_DIR,
+	                              &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	/* No key should be written out since the secret is not system owned */
+	keyfile = utils_get_keys_path (testfile);
+	g_assert (g_file_test (keyfile, G_FILE_TEST_EXISTS) == FALSE);
+
+	/* Remove the LEAP password from the original connection since it wont' be
+	 * in the reread connection, as the password is not system owned.
+	 */
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, NULL, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_psk (gconstpointer test_data)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	struct {
+		const char *name, *psk;
+		gpointer wep_group_p, wpa_p, wpa2_p;
+	} args;
+
+	nmtst_test_data_unpack (test_data, &args.name, &args.wep_group_p, &args.wpa_p, &args.wpa2_p, &args.psk);
+
+	g_assert (args.psk);
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, args.name,
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, args.psk,
+	              NM_SETTING_WIRELESS_SECURITY_PMF, (int) NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED,
+	              NULL);
+
+	if (GPOINTER_TO_INT (args.wep_group_p)) {
+		nm_setting_wireless_security_add_group (s_wsec, "wep40");
+		nm_setting_wireless_security_add_group (s_wsec, "wep104");
+	}
+	if (GPOINTER_TO_INT (args.wpa_p)) {
+		nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+		nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+		nm_setting_wireless_security_add_group (s_wsec, "tkip");
+	}
+	if (GPOINTER_TO_INT (args.wpa2_p)) {
+		nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+		nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+		nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+	}
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_psk_adhoc (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	NMIPAddress *addr;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA PSK",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "adhoc",
+	              NM_SETTING_WIRELESS_CHANNEL, 11,
+	              NM_SETTING_WIRELESS_BAND, "bg",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, "7d308b11df1b4243b0f78e5f3fc68cdbb9a264ed0edf4c188edf329ff5b467f0",
+	              NULL);
+
+	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NULL);
+
+	/* IP Address */
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 25, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_eap_tls (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	gboolean success;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TLS",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap",
+	              NM_SETTING_WIRELESS_SECURITY_FILS, (int) NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,
+	              NULL);
+	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	nm_setting_wireless_security_add_group (s_wsec, "tkip");
+
+	/* Wireless security setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, "Bill Smith", NULL);
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_PHASE1_AUTH_FLAGS,
+	              (guint) (NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE |
+	                       NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE),
+	              NULL);
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "tls");
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	success = nm_setting_802_1x_set_client_cert (s_8021x,
+	                                             TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
+	                                             NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                             NULL,
+	                                             &error);
+	nmtst_assert_success (success, error);
+
+	success = nm_setting_802_1x_set_private_key (s_8021x,
+	                                             TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
+	                                             "test1",
+	                                             NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                             NULL,
+	                                             &error);
+	nmtst_assert_success (success, error);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_eap_ttls_tls (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	gboolean success;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TTLS (TLS)",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
+	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+
+	/* Wireless security setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "ttls");
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
+	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "foobar22",
+	              NM_SETTING_802_1X_PHASE2_AUTHEAP, "tls",
+	              NULL);
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	/* Phase 2 TLS stuff */
+
+	/* phase2 CA cert */
+	success = nm_setting_802_1x_set_phase2_ca_cert (s_8021x,
+	                                                TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
+	                                                NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                                NULL,
+	                                                &error);
+	nmtst_assert_success (success, error);
+
+	/* phase2 client cert */
+	success = nm_setting_802_1x_set_phase2_client_cert (s_8021x,
+	                                                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
+	                                                    NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                                    NULL,
+	                                                    &error);
+	nmtst_assert_success (success, error);
+
+	/* phase2 private key */
+	success = nm_setting_802_1x_set_phase2_private_key (s_8021x,
+	                                                    TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
+	                                                    "test1",
+	                                                    NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                                    NULL,
+	                                                    &error);
+	nmtst_assert_success (success, error);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_eap_ttls_mschapv2 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	gboolean success;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TTLS (MSCHAPv2)",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
+	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	nm_setting_wireless_security_add_group (s_wsec, "tkip");
+	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+
+	/* Wireless security setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "ttls");
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
+	              NM_SETTING_802_1X_PASSWORD, ";alkdfja;dslkfjsad;lkfjsadf",
+	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "foobar22",
+	              NM_SETTING_802_1X_PHASE2_AUTHEAP, "mschapv2",
+	              NULL);
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	keyfile = utils_get_keys_path (testfile);
+}
+
+static void
+test_write_wifi_wpa_then_open (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_free char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	/* Test that writing out a WPA config then changing that to an open
+	 * config doesn't leave various WPA-related keys lying around in the ifcfg.
+	 */
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "random wifi connection",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, "some cool PSK",
+	              NULL);
+
+	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	nm_setting_wireless_security_add_group (s_wsec, "tkip");
+
+	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	g_object_unref (reread);
+
+	nmtst_connection_normalize (connection);
+
+	/* Now change the connection to open and recheck */
+	nm_connection_remove_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY);
+
+	/* Write it back out */
+	_writer_update_connection (connection,
+	                           TEST_SCRATCH_DIR,
+	                           testfile,
+	                           TEST_IFCFG_DIR"/ifcfg-random_wifi_connection.cexpected");
+	keyfile = utils_get_keys_path (testfile);
+	g_assert (!g_file_test (keyfile, G_FILE_TEST_EXISTS));
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_then_wep_with_perms (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	gboolean success;
+	GBytes *ssid;
+	char **perms;
+	const char *ssid_data = "SomeSSID";
+
+	/* Test that writing out a WPA config then changing that to a WEP
+	 * config works and doesn't cause infinite loop or other issues.
+	 */
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	perms = g_strsplit ("user:superman:", ",", -1);
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "random wifi connection 2",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_PERMISSIONS, perms,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+	g_strfreev (perms);
+	g_assert_cmpint (nm_setting_connection_get_num_permissions (s_con), ==, 1);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, "My cool PSK",
+	              NULL);
+
+	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	nm_setting_wireless_security_add_group (s_wsec, "tkip");
+
+	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	g_object_unref (reread);
+
+	nmtst_connection_normalize (connection);
+
+	/* Now change the connection to WEP and recheck */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "abraka  dabra");
+
+	/* Write it back out */
+	_writer_update_connection (connection,
+	                           TEST_SCRATCH_DIR,
+	                           testfile,
+	                           TEST_IFCFG_DIR"/ifcfg-random_wifi_connection_2.cexpected");
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	nmtst_connection_normalize (connection);
+	success = nm_connection_compare (connection, reread,
+	                                 NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS |
+	                                 NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS);
+	g_assert (success);
+
+	keyfile = utils_get_keys_path (testfile);
+}
+
+static void
+test_write_wifi_dynamic_wep_leap (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+	shvarFile *ifcfg;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi Dynamic WEP LEAP",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x", NULL);
+
+	/* Wireless security setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "leap");
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
+	              NM_SETTING_802_1X_PASSWORD, ";alkdfja;dslkfjsad;lkfjsadf",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	keyfile = utils_get_keys_path (testfile);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	/* Check and make sure that an "old-school" LEAP (Network EAP) connection
+	 * did not get written.  Check first that the auth alg is not set to "LEAP"
+	 * and next that the only IEEE 802.1x EAP method is "LEAP".
+	 */
+	ifcfg = _svOpenFile (testfile);
+	_svGetValue_check (ifcfg, "SECURITYMODE", NULL);
+	_svGetValue_check (ifcfg, "IEEE_8021X_EAP_METHODS", "LEAP");
+	svCloseFile (ifcfg);
+}
+
+static void
+test_write_wired_qeth_dhcp (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char **subchans;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired qeth Static",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	subchans = g_strsplit ("0.0.600,0.0.601,0.0.602", ",", -1);
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_S390_SUBCHANNELS, subchans,
+	              NM_SETTING_WIRED_S390_NETTYPE, "qeth",
+	              NULL);
+	g_strfreev (subchans);
+
+	nm_setting_wired_add_s390_option (s_wired, "portname", "FOOBAR");
+	nm_setting_wired_add_s390_option (s_wired, "portno", "1");
+	nm_setting_wired_add_s390_option (s_wired, "layer2", "0");
+	nm_setting_wired_add_s390_option (s_wired, "protocol", "blahbalh");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_ctc_dhcp (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	char **subchans;
+	shvarFile *ifcfg;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired ctc Static",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	subchans = g_strsplit ("0.0.600,0.0.601", ",", -1);
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_S390_SUBCHANNELS, subchans,
+	              NM_SETTING_WIRED_S390_NETTYPE, "ctc",
+	              NULL);
+	g_strfreev (subchans);
+	nm_setting_wired_add_s390_option (s_wired, "ctcprot", "0");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	/* Ensure the CTCPROT item gets written out as its own option */
+	ifcfg = _svOpenFile (testfile);
+
+	_svGetValue_check (ifcfg, "CTCPROT", "0");
+
+	/* And that it's not in the generic OPTIONS string */
+	_svGetValue_check (ifcfg, "OPTIONS", NULL);
+
+	svCloseFile (ifcfg);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_permissions (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Permissions",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	nm_setting_connection_add_permission (s_con, "user", "blahblah", NULL);
+	nm_setting_connection_add_permission (s_con, "user", "foobar", NULL);
+	nm_setting_connection_add_permission (s_con, "user", "asdfasdf", NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Permissions.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wep_agent_keys (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char *str_ssid = "foobarbaz";
+	GBytes *ssid;
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection != NULL);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP Agent Owned",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (str_ssid, strlen (str_ssid));
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+	g_bytes_unref (ssid);
+
+	/* Wifi security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, NM_SETTING_SECRET_FLAG_AGENT_OWNED,
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "asdfdjaslfjasd;flasjdfl;aksdf");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_FIXME (connection,
+	                              TEST_SCRATCH_DIR,
+	                              &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
+
+	/* Remove the WEP key from the original, because it should not have been
+	 * written out to disk as it was agent-owned.  The new connection should
+	 * not have any WEP keys set.
+	 * Also the new connection should not have WEP key type set.
+	 */
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, NULL);
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_UNKNOWN,
+	              NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wired_pppoe (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingPppoe *s_pppoe;
+	NMSettingPpp *s_ppp;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired PPPoE",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* PPPoE setting */
+	s_pppoe = (NMSettingPppoe *) nm_setting_pppoe_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_pppoe));
+
+	g_object_set (G_OBJECT (s_pppoe),
+	              NM_SETTING_PPPOE_SERVICE, "stupid-service",
+	              NM_SETTING_PPPOE_USERNAME, "Bill Smith",
+	              NM_SETTING_PPPOE_PASSWORD, "test1",
+	              NULL);
+
+	/* PPP setting */
+	s_ppp = (NMSettingPpp *) nm_setting_ppp_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ppp));
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_fail (connection,
+	                             TEST_SCRATCH_DIR,
+	                             NULL);
+
+	g_object_unref (connection);
+	g_clear_error (&error);
+}
+
+static void
+test_write_vpn (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMSettingVpn *s_vpn;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write VPN",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_VPN_SETTING_NAME,
+	              NULL);
+
+	/* VPN setting */
+	s_vpn = (NMSettingVpn *) nm_setting_vpn_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_vpn));
+
+	g_object_set (s_vpn,
+	              NM_SETTING_VPN_SERVICE_TYPE, "awesomevpn",
+	              NM_SETTING_VPN_USER_NAME, "Bill Smith",
+	              NULL);
+
+	nm_setting_vpn_add_data_item (s_vpn, "server", "vpn.somewhere.com");
+	nm_setting_vpn_add_secret (s_vpn, "password", "sup3rs3cr3t");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_fail (connection,
+	                             TEST_SCRATCH_DIR,
+	                             NULL);
+
+	g_object_unref (connection);
+	g_clear_error (&error);
+}
+
+static void
+test_write_mobile_broadband (gconstpointer data)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMSettingGsm *s_gsm;
+	NMSettingCdma *s_cdma;
+	NMSettingPpp *s_ppp;
+	NMSettingSerial *s_serial;
+	GError *error = NULL;
+	gboolean gsm = GPOINTER_TO_UINT (data);
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, gsm ? "Test Write GSM" : "Test Write CDMA",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, gsm ? NM_SETTING_GSM_SETTING_NAME : NM_SETTING_CDMA_SETTING_NAME,
+	              NULL);
+
+	if (gsm) {
+		/* GSM setting */
+		s_gsm = (NMSettingGsm *) nm_setting_gsm_new ();
+		nm_connection_add_setting (connection, NM_SETTING (s_gsm));
+	} else {
+		/* CDMA setting */
+		s_cdma = (NMSettingCdma *) nm_setting_cdma_new ();
+		nm_connection_add_setting (connection, NM_SETTING (s_cdma));
+
+		g_object_set (s_cdma, NM_SETTING_CDMA_NUMBER, "#777", NULL);
+	}
+
+	/* Serial setting */
+	s_serial = (NMSettingSerial *) nm_setting_serial_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_serial));
+
+	g_object_set (s_serial,
+	              NM_SETTING_SERIAL_BAUD, 115200,
+	              NM_SETTING_SERIAL_BITS, 8,
+	              NM_SETTING_SERIAL_PARITY, NM_SETTING_SERIAL_PARITY_NONE,
+	              NM_SETTING_SERIAL_STOPBITS, 1,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* PPP setting */
+	s_ppp = (NMSettingPpp *) nm_setting_ppp_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ppp));
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_fail (connection,
+	                             TEST_SCRATCH_DIR,
+	                             NULL);
+
+	g_object_unref (connection);
+	g_clear_error (&error);
+}
+
+static void
+test_read_bridge_main (void)
+{
+	NMConnection *connection;
+	NMSettingBridge *s_bridge;
+	NMSettingWired *s_wired;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-main",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "br0");
+
+	/* ===== Bridging SETTING ===== */
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	g_assert (s_bridge);
+	g_assert_cmpuint (nm_setting_bridge_get_forward_delay (s_bridge), ==, 2);
+	g_assert (nm_setting_bridge_get_stp (s_bridge));
+	g_assert_cmpuint (nm_setting_bridge_get_priority (s_bridge), ==, 32744);
+	g_assert_cmpuint (nm_setting_bridge_get_hello_time (s_bridge), ==, 7);
+	g_assert_cmpuint (nm_setting_bridge_get_max_age (s_bridge), ==, 39);
+	g_assert_cmpuint (nm_setting_bridge_get_ageing_time (s_bridge), ==, 235352);
+	g_assert_cmpuint (nm_setting_bridge_get_group_forward_mask (s_bridge), ==, 24);
+	g_assert (!nm_setting_bridge_get_multicast_snooping (s_bridge));
+	g_assert_cmpint (nm_setting_bridge_get_vlan_filtering (s_bridge), ==, TRUE);
+	g_assert_cmpint (nm_setting_bridge_get_vlan_default_pvid (s_bridge), ==, 99);
+
+	/* MAC address */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	mac = nm_setting_wired_get_cloned_mac_address (s_wired);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_bridge_main (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingBridge *s_bridge;
+	NMSettingIPConfig *s_ip4, *s_ip6;
+	NMSettingWired *s_wired;
+	NMIPAddress *addr;
+	static const char *mac = "31:33:33:37:be:cd";
+	GError *error = NULL;
+	gs_unref_ptrarray GPtrArray *vlans = NULL;
+	NMBridgeVlan *vlan;
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Main",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "br0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+
+	/* bridge setting */
+	s_bridge = (NMSettingBridge *) nm_setting_bridge_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_bridge));
+
+	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+	vlan = nm_bridge_vlan_new (10, 16);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (22, 22);
+	nm_bridge_vlan_set_pvid (vlan, TRUE);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (44, 0);
+	g_ptr_array_add (vlans, vlan);
+
+	g_object_set (s_bridge,
+	              NM_SETTING_BRIDGE_MAC_ADDRESS, mac,
+	              NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, 19008,
+	              NM_SETTING_BRIDGE_VLAN_FILTERING, TRUE,
+	              NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, 4000,
+	              NM_SETTING_BRIDGE_VLANS, vlans,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_BRIDGE, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_bridge_component (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingBridgePort *s_port;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-component",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "br0");
+	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BRIDGE_SETTING_NAME);
+
+	s_port = nm_connection_get_setting_bridge_port (connection);
+	g_assert (s_port);
+	g_assert (nm_setting_bridge_port_get_hairpin_mode (s_port));
+	g_assert_cmpuint (nm_setting_bridge_port_get_priority (s_port), ==, 28);
+	g_assert_cmpuint (nm_setting_bridge_port_get_path_cost (s_port), ==, 100);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_bridge_component (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSetting *s_port;
+	static const char *mac = "31:33:33:37:be:cd";
+	guint32 mtu = 1492;
+	gs_unref_ptrarray GPtrArray *vlans = NULL;
+	NMBridgeVlan *vlan;
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Component",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "br0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_MTU, mtu,
+	              NULL);
+
+	/* Bridge port */
+	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+	vlan = nm_bridge_vlan_new (1, 0);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (4, 4094);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (2, 2);
+	nm_bridge_vlan_set_pvid (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+
+	s_port = nm_setting_bridge_port_new ();
+	nm_connection_add_setting (connection, s_port);
+	g_object_set (s_port,
+	              NM_SETTING_BRIDGE_PORT_PRIORITY, 50,
+	              NM_SETTING_BRIDGE_PORT_PATH_COST, 33,
+	              NM_SETTING_BRIDGE_PORT_VLANS, vlans,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Bridge_Component.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_bridge_missing_stp (void)
+{
+	NMConnection *connection;
+	NMSettingBridge *s_bridge;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-missing-stp",
+	                                    NULL, TYPE_BRIDGE, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "br0");
+
+	/* ===== Bridging SETTING ===== */
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	g_assert (s_bridge);
+	g_assert (nm_setting_bridge_get_stp (s_bridge) == FALSE);
+
+	g_object_unref (connection);
+}
+
+#define TEST_IFCFG_VLAN_INTERFACE TEST_IFCFG_DIR"/ifcfg-test-vlan-interface"
+
+static void
+test_read_vlan_interface (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+	guint32 from = 0, to = 0;
+
+	connection = _connection_from_file (TEST_IFCFG_VLAN_INTERFACE,
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan43");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 43);
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==,
+	                 NM_VLAN_FLAG_GVRP | NM_VLAN_FLAG_LOOSE_BINDING | NM_VLAN_FLAG_REORDER_HEADERS);
+
+	/* Ingress map */
+	g_assert_cmpint (nm_setting_vlan_get_num_priorities (s_vlan, NM_VLAN_INGRESS_MAP), ==, 2);
+
+	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_INGRESS_MAP, 0, &from, &to));
+	g_assert_cmpint (from, ==, 0);
+	g_assert_cmpint (to, ==, 1);
+
+	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_INGRESS_MAP, 1, &from, &to));
+	g_assert_cmpint (from, ==, 2);
+	g_assert_cmpint (to, ==, 5);
+
+	/* Egress map */
+	g_assert_cmpint (nm_setting_vlan_get_num_priorities (s_vlan, NM_VLAN_EGRESS_MAP), ==, 3);
+
+	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_EGRESS_MAP, 0, &from, &to));
+	g_assert_cmpint (from, ==, 3);
+	g_assert_cmpint (to, ==, 1);
+
+	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_EGRESS_MAP, 1, &from, &to));
+	g_assert_cmpint (from, ==, 12);
+	g_assert_cmpint (to, ==, 3);
+
+	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_EGRESS_MAP, 2, &from, &to));
+	g_assert_cmpint (from, ==, 14);
+	g_assert_cmpint (to, ==, 7);
+
+	g_object_unref (connection);
+}
+
+#define TEST_IFCFG_VLAN_ONLY_VLANID TEST_IFCFG_DIR"/ifcfg-test-vlan-only-vlanid"
+
+static void
+test_read_vlan_only_vlan_id (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	connection = _connection_from_file (TEST_IFCFG_VLAN_ONLY_VLANID, NULL, TYPE_ETHERNET, NULL);
+
+	g_assert (nm_connection_get_interface_name (connection) == NULL);
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 43);
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_REORDER_HEADERS);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_vlan_only_device (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-only-device",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "eth0.9");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 9);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_vlan_physdev (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-physdev",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan0.3");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 3);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_vlan_reorder_hdr_1 (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	NMTST_EXPECT_NM_WARN ("*REORDER_HDR key is deprecated, use VLAN_FLAGS*");
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-reorder-hdr-1",
+	                                        NULL, TYPE_ETHERNET, NULL);
+	g_test_assert_expected_messages ();
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan0.3");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 3);
+	/* Check that REORDER_HDR=0 is ignored */
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_REORDER_HEADERS);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_vlan_reorder_hdr_2 (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-reorder-hdr-2",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan0.3");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 3);
+	/* Check that VLAN_FLAGS=NO_REORDER_HDR works */
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_LOOSE_BINDING);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_vlan_flags_1 (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-flags-1",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "super-vlan");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 44);
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==,
+	                                            NM_VLAN_FLAG_LOOSE_BINDING |
+	                                            NM_VLAN_FLAG_REORDER_HEADERS);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_vlan_flags_2 (void)
+{
+	NMConnection *connection;
+	NMSettingVlan *s_vlan;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-flags-2",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "super-vlan");
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 44);
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==,
+	                                            NM_VLAN_FLAG_GVRP |
+	                                            NM_VLAN_FLAG_LOOSE_BINDING |
+	                                            NM_VLAN_FLAG_REORDER_HEADERS);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_vlan (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_VLAN_INTERFACE,
+	                                    NULL, TYPE_VLAN, NULL);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Vlan_test-vlan-interface.cexpected",
+	                        &testfile);
+}
+
+static void
+test_write_vlan_flags (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-flags-2",
+	                                    NULL, TYPE_VLAN, NULL);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_vlan_only_vlanid (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+
+	connection = _connection_from_file (TEST_IFCFG_VLAN_ONLY_VLANID,
+	                                    NULL, TYPE_VLAN, NULL);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_vlan_reorder_hdr (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingVlan *s_vlan;
+	NMSettingWired *s_wired;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write VLAN reorder_hdr",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_VLAN_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* VLAN setting */
+	s_vlan = (NMSettingVlan *) nm_setting_vlan_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_vlan));
+
+	g_object_set (s_vlan,
+	              NM_SETTING_VLAN_PARENT, "eth0",
+	              NM_SETTING_VLAN_ID, 444,
+	              NM_SETTING_VLAN_FLAGS, 1,
+	              NULL);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_VLAN_reorder_hdr.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_ethernet_missing_ipv6 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Ethernet Without IPv6 Setting",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, "random-client-id-00:22:33",
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, TRUE,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, TRUE,
+	              NULL);
+
+	/* IP6 setting */
+	/*
+	 * We intentionally don't add IPv6 setting here. ifcfg-rh plugin should regard
+	 * missing IPv6 as IPv6 with NM_SETTING_IP6_CONFIG_METHOD_AUTO method.
+	 */
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_ibft_ignored (void)
+{
+	gs_free_error GError *error = NULL;
+
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-ibft",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+}
+
+static void
+test_read_bond_main (void)
+{
+	NMConnection *connection;
+	NMSettingBond *s_bond;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-main",
+	                                    NULL, TYPE_ETHERNET,NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "bond0");
+
+	/* ===== Bonding SETTING ===== */
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	g_assert (s_bond);
+
+	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MIIMON), ==, "100");
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_bond_eth_type (void)
+{
+	NMConnection *connection;
+	NMSettingBond *s_bond;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-eth-type",
+	                                    NULL, TYPE_ETHERNET,NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "bond0");
+
+	/* ===== Bonding SETTING ===== */
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	g_assert (s_bond);
+
+	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MIIMON), ==, "213");
+	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE), ==, "1");
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_bond_main (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSettingWired *s_wired;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond Main",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "bond0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* bond setting */
+	s_bond = (NMSettingBond *) nm_setting_bond_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_bond));
+
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, "5");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, "10");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, "100");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Bond_Main.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_BOND, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_bond_slave (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-slave",
+	                                    NULL, TYPE_ETHERNET, NULL);
+	g_test_assert_expected_messages ();
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "bond0");
+
+	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BOND_SETTING_NAME);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_bond_slave (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	static const char *mac = "31:33:33:37:be:cd";
+	guint32 mtu = 1492;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond Slave",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "bond0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_MTU, mtu,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_infiniband (void)
+{
+	NMConnection *connection;
+	NMSettingInfiniband *s_infiniband;
+	char *unmanaged = NULL;
+	const char *mac;
+	char expected_mac_address[INFINIBAND_ALEN] = { 0x80, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22 };
+	const char *transport_mode;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-infiniband",
+	                                    NULL, TYPE_INFINIBAND, &unmanaged);
+	g_assert (!unmanaged);
+
+	/* ===== INFINIBAND SETTING ===== */
+
+	s_infiniband = nm_connection_get_setting_infiniband (connection);
+	g_assert (s_infiniband);
+
+	/* MAC address */
+	mac = nm_setting_infiniband_get_mac_address (s_infiniband);
+	g_assert (mac);
+	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
+
+	/* Transport mode */
+	transport_mode = nm_setting_infiniband_get_transport_mode (s_infiniband);
+	g_assert (transport_mode);
+	g_assert_cmpstr (transport_mode, ==, "connected");
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_infiniband (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingInfiniband *s_infiniband;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char *mac = "80:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22";
+	guint32 mtu = 65520;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write InfiniBand",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_INFINIBAND_SETTING_NAME,
+	              NULL);
+
+	/* InfiniBand setting */
+	s_infiniband = (NMSettingInfiniband *) nm_setting_infiniband_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_infiniband));
+
+	g_object_set (s_infiniband,
+	              NM_SETTING_INFINIBAND_MAC_ADDRESS, mac,
+	              NM_SETTING_INFINIBAND_MTU, mtu,
+	              NM_SETTING_INFINIBAND_TRANSPORT_MODE, "connected",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_INFINIBAND, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_bond_slave_ib (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-slave-ib",
+	                                    NULL, NULL, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "bond0");
+	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BOND_SETTING_NAME);
+}
+
+static void
+test_write_bond_slave_ib (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingInfiniband *s_infiniband;
+	static const char *mac = "80:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22";
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond Slave InfiniBand",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_INFINIBAND_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "bond0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	/* InfiniBand setting */
+	s_infiniband = (NMSettingInfiniband *) nm_setting_infiniband_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_infiniband));
+
+	g_object_set (s_infiniband,
+	              NM_SETTING_INFINIBAND_MAC_ADDRESS, mac,
+	              NM_SETTING_INFINIBAND_MTU, 2044,
+	              NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram",
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_bond_opts_mode_numeric (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-mode-numeric",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "bond0");
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_BOND_SETTING_NAME);
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	g_assert (s_bond);
+	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MODE), ==, "802.3ad");
+
+	g_object_unref (connection);
+}
+
+#define DCB_ALL_FLAGS (NM_SETTING_DCB_FLAG_ENABLE | \
+                       NM_SETTING_DCB_FLAG_ADVERTISE | \
+                       NM_SETTING_DCB_FLAG_WILLING)
+
+static void
+test_read_dcb_basic (void)
+{
+	NMConnection *connection;
+	NMSettingDcb *s_dcb;
+	guint i;
+	guint expected_group_ids[8] = { 0, 0, 0, 0, 1, 1, 1, 0xF };
+	guint expected_group_bandwidths[8] = { 25, 0, 0, 75, 0, 0, 0, 0 };
+	guint expected_bandwidths[8] = { 5, 10, 30, 25, 10, 50, 5, 0 };
+	gboolean expected_strict[8] = { FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE };
+	guint expected_traffic_classes[8] = { 7, 6, 5, 4, 3, 2, 1, 0 };
+	gboolean expected_pfcs[8] = { TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE };
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-dcb",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_dcb = nm_connection_get_setting_dcb (connection);
+	g_assert (s_dcb);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_flags (s_dcb), ==, DCB_ALL_FLAGS);
+	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_priority (s_dcb), ==, 7);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_iscsi_flags (s_dcb), ==, DCB_ALL_FLAGS);
+		g_assert_cmpint (nm_setting_dcb_get_app_iscsi_priority (s_dcb), ==, 6);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_fip_flags (s_dcb), ==, DCB_ALL_FLAGS);
+	g_assert_cmpint (nm_setting_dcb_get_app_fip_priority (s_dcb), ==, 2);
+
+	g_assert_cmpint (nm_setting_dcb_get_priority_flow_control_flags (s_dcb), ==, (NM_SETTING_DCB_FLAG_ENABLE | NM_SETTING_DCB_FLAG_ADVERTISE));
+	for (i = 0; i < 8; i++)
+		g_assert_cmpint (nm_setting_dcb_get_priority_flow_control (s_dcb, i), ==, expected_pfcs[i]);
+
+	g_assert_cmpint (nm_setting_dcb_get_priority_group_flags (s_dcb), ==, DCB_ALL_FLAGS);
+
+	/* Group IDs */
+	for (i = 0; i < 8; i++)
+		g_assert_cmpint (nm_setting_dcb_get_priority_group_id (s_dcb, i), ==, expected_group_ids[i]);
+
+	/* Group bandwidth */
+	for (i = 0; i < 8; i++)
+		g_assert_cmpint (nm_setting_dcb_get_priority_group_bandwidth (s_dcb, i), ==, expected_group_bandwidths[i]);
+
+	/* User priority bandwidth */
+	for (i = 0; i < 8; i++)
+		g_assert_cmpint (nm_setting_dcb_get_priority_bandwidth (s_dcb, i), ==, expected_bandwidths[i]);
+
+	/* Strict bandwidth */
+	for (i = 0; i < 8; i++)
+		g_assert_cmpint (nm_setting_dcb_get_priority_strict_bandwidth (s_dcb, i), ==, expected_strict[i]);
+
+	/* Traffic class */
+	for (i = 0; i < 8; i++)
+		g_assert_cmpint (nm_setting_dcb_get_priority_traffic_class (s_dcb, i), ==, expected_traffic_classes[i]);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_dcb_basic (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingDcb *s_dcb;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	guint i;
+	const guint group_ids[8] = { 4, 0xF, 6, 0xF, 1, 7, 3, 0xF };
+	const guint group_bandwidths[8] = { 10, 20, 15, 10, 2, 3, 35, 5 };
+	const guint bandwidths[8] = { 10, 20, 30, 40, 50, 10, 0, 25 };
+	const gboolean strict[8] = { TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE };
+	const guint traffic_classes[8] = { 3, 4, 7, 2, 1, 0, 5, 6 };
+	const gboolean pfcs[8] = { TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE };
+
+	connection = nm_simple_connection_new ();
+
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (G_OBJECT (s_con),
+	              NM_SETTING_CONNECTION_ID, "dcb-test",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP stuff */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	g_object_set (G_OBJECT (s_ip4), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	g_object_set (G_OBJECT (s_ip6), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	/* DCB */
+	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_dcb));
+
+	g_object_set (G_OBJECT (s_dcb),
+	              NM_SETTING_DCB_APP_FCOE_FLAGS, DCB_ALL_FLAGS,
+	              NM_SETTING_DCB_APP_FCOE_PRIORITY, 5,
+	              NM_SETTING_DCB_APP_ISCSI_FLAGS, DCB_ALL_FLAGS,
+	              NM_SETTING_DCB_APP_ISCSI_PRIORITY, 1,
+	              NM_SETTING_DCB_APP_FIP_FLAGS, DCB_ALL_FLAGS,
+	              NM_SETTING_DCB_APP_FIP_PRIORITY, 3,
+	              NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS, DCB_ALL_FLAGS,
+	              NM_SETTING_DCB_PRIORITY_GROUP_FLAGS, DCB_ALL_FLAGS,
+	              NULL);
+
+	for (i = 0; i < 8; i++) {
+		nm_setting_dcb_set_priority_flow_control (s_dcb, i, pfcs[i]);
+		nm_setting_dcb_set_priority_group_id (s_dcb, i, group_ids[i]);
+		nm_setting_dcb_set_priority_group_bandwidth (s_dcb, i, group_bandwidths[i]);
+		nm_setting_dcb_set_priority_bandwidth (s_dcb, i, bandwidths[i]);
+		nm_setting_dcb_set_priority_strict_bandwidth (s_dcb, i, strict[i]);
+		nm_setting_dcb_set_priority_traffic_class (s_dcb, i, traffic_classes[i]);
+	}
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"//ifcfg-dcb-test.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_dcb_default_app_priorities (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingDcb *s_dcb;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-dcb-default-app-priorities",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_dcb = nm_connection_get_setting_dcb (connection);
+	g_assert (s_dcb);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
+	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_priority (s_dcb), ==, -1);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_iscsi_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
+	g_assert_cmpint (nm_setting_dcb_get_app_iscsi_priority (s_dcb), ==, -1);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_fip_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
+	g_assert_cmpint (nm_setting_dcb_get_app_fip_priority (s_dcb), ==, -1);
+}
+
+static void
+test_read_dcb_bad_booleans (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_STRICT value*not all 0s and 1s*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-bad-booleans",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "invalid boolean digit"));
+}
+
+static void
+test_read_dcb_short_booleans (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*DCB_PG_STRICT value*8 characters*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-short-booleans",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "boolean array must be 8 characters"));
+}
+
+static void
+test_read_dcb_bad_uints (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_UP2TC value*not 0 - 7*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-bad-uints",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "invalid uint digit"));
+}
+
+static void
+test_read_dcb_short_uints (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*DCB_PG_UP2TC value*8 characters*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-short-uints",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "uint array must be 8 characters"));
+}
+
+static void
+test_read_dcb_bad_percent (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_PCT percentage value*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-bad-percent",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "invalid percent element"));
+}
+
+static void
+test_read_dcb_short_percent (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_PCT percentage list value*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-short-percent",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "percent array must be 8 elements"));
+}
+
+static void
+test_read_dcb_pgpct_not_100 (void)
+{
+	gs_free_error GError *error = NULL;
+
+	NMTST_EXPECT_NM_WARN ("*DCB_PG_PCT percentages do not equal 100*");
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-pgpct-not-100",
+	                            NULL, TYPE_ETHERNET, &error);
+	g_test_assert_expected_messages ();
+
+	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
+	g_assert (strstr (error->message, "invalid percentage sum"));
+}
+
+static void
+test_read_fcoe_mode (gconstpointer user_data)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	gs_free char *file = NULL;
+	const char *expected_mode = user_data;
+	NMSettingDcb *s_dcb;
+
+	file = g_strdup_printf (TEST_IFCFG_DIR"/ifcfg-test-fcoe-%s", expected_mode);
+	connection = _connection_from_file (file, NULL, TYPE_ETHERNET, NULL);
+
+	s_dcb = nm_connection_get_setting_dcb (connection);
+	g_assert (s_dcb);
+
+	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
+	g_assert_cmpstr (nm_setting_dcb_get_app_fcoe_mode (s_dcb), ==, expected_mode);
+}
+
+static void
+test_write_fcoe_mode (gconstpointer user_data)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	const char *expected_mode = user_data;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingDcb *s_dcb;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	shvarFile *ifcfg;
+
+	connection = nm_simple_connection_new ();
+
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (G_OBJECT (s_con),
+	              NM_SETTING_CONNECTION_ID, "fcoe-test",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP stuff */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	g_object_set (G_OBJECT (s_ip4), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	g_object_set (G_OBJECT (s_ip6), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	/* DCB */
+	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_dcb));
+
+	g_object_set (G_OBJECT (s_dcb),
+	              NM_SETTING_DCB_APP_FCOE_FLAGS, NM_SETTING_DCB_FLAG_ENABLE,
+	              NM_SETTING_DCB_APP_FCOE_MODE, expected_mode,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	ifcfg = _svOpenFile (testfile);
+	_svGetValue_check (ifcfg, "DCB_APP_FCOE_MODE", expected_mode);
+	svCloseFile (ifcfg);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_team_master (gconstpointer user_data)
+{
+	const char *const PATH_NAME = user_data;
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingTeam *s_team;
+	const char *expected_config = "{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}";
+
+	connection = _connection_from_file (PATH_NAME, NULL, TYPE_ETHERNET, NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "team0");
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_TEAM_SETTING_NAME);
+
+	s_team = nm_connection_get_setting_team (connection);
+	g_assert (s_team);
+	g_assert_cmpstr (nm_setting_team_get_config (s_team), ==, expected_config);
+
+	g_object_unref (connection);
+}
+
+static void
+test_read_team_master_invalid (gconstpointer user_data)
+{
+	const char *const PATH_NAME = user_data;
+	gs_free_error GError *error = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+
+	if (WITH_JSON_VALIDATION) {
+		_connection_from_file_fail (PATH_NAME, NULL, TYPE_ETHERNET, &error);
+
+		g_assert_error (error, NM_CONNECTION_ERROR, NM_CONNECTION_ERROR_INVALID_PROPERTY);
+		g_assert (strstr (error->message, _("invalid json")));
+	} else
+		connection = _connection_from_file (PATH_NAME, NULL, TYPE_ETHERNET, NULL);
+}
+
+static void
+test_write_team_master (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingTeam *s_team;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char *expected_config = "{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}";
+	shvarFile *f;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Team Master",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "team0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_TEAM_SETTING_NAME,
+	              NULL);
+
+	/* Team setting */
+	s_team = (NMSettingTeam *) nm_setting_team_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_team));
+
+	g_object_set (s_team,
+	              NM_SETTING_TEAM_CONFIG, expected_config,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "DEVICETYPE", "Team");
+	_svGetValue_check (f, "TEAM_CONFIG", expected_config);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_team_port (gconstpointer user_data)
+{
+	const char *const PATH_NAME = user_data;
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingTeamPort *s_team_port;
+	const char *expected_config = "{\"p4p1\": {\"prio\": -10, \"sticky\": true}}";
+
+	connection = _connection_from_file (PATH_NAME, NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "team0");
+
+	s_team_port = nm_connection_get_setting_team_port (connection);
+	g_assert (s_team_port);
+	g_assert_cmpstr (nm_setting_team_port_get_config (s_team_port), ==, expected_config);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_team_port (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingTeamPort *s_team_port;
+	NMSettingWired *s_wired;
+	const char *expected_config = "{\"p4p1\": {\"prio\": -10, \"sticky\": true}}";
+	shvarFile *f;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Team Port",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "team0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
+	              NULL);
+
+	/* Team setting */
+	s_team_port = (NMSettingTeamPort *) nm_setting_team_port_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_team_port));
+	g_object_set (s_team_port, NM_SETTING_TEAM_PORT_CONFIG, expected_config, NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Team_Port.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "TYPE", NULL);
+	_svGetValue_check (f, "DEVICETYPE", "TeamPort");
+	_svGetValue_check (f, "TEAM_PORT_CONFIG", expected_config);
+	_svGetValue_check (f, "TEAM_MASTER", "team0");
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET,
+	                                NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_team_infiniband_port (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingTeamPort *s_team_port;
+	NMSettingInfiniband *s_inf;
+	const char *expected_config = "{\"inf1\": {\"prio\": -10, \"sticky\": true}}";
+	shvarFile *f;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Team Infiniband Port",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_INFINIBAND_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "team0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "inf1",
+	              NULL);
+
+	/* Team setting */
+	s_team_port = (NMSettingTeamPort *) nm_setting_team_port_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_team_port));
+	g_object_set (s_team_port, NM_SETTING_TEAM_PORT_CONFIG, expected_config, NULL);
+
+	/* Infiniband setting */
+	s_inf = (NMSettingInfiniband *) nm_setting_infiniband_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_inf));
+	g_object_set (s_inf, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram", NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Team_Infiniband_Port.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "TYPE", "InfiniBand");
+	_svGetValue_check (f, "DEVICETYPE", "TeamPort");
+	_svGetValue_check (f, "TEAM_PORT_CONFIG", expected_config);
+	_svGetValue_check (f, "TEAM_MASTER", "team0");
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET,
+	                                NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_read_team_port_empty_config (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-team-port-empty-config",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "team0");
+
+	/* Normalization adds a team-port setting */
+	g_assert (nm_connection_get_setting_team_port (connection));
+
+	/* empty/missing config */
+	g_assert (!nm_setting_team_port_get_config (nm_connection_get_setting_team_port (connection)));
+
+	g_object_unref (connection);
+}
+
+static void
+test_team_reread_slave (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection_1 = NULL;
+	gs_unref_object NMConnection *connection_2 = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean reread_same = FALSE;
+	NMSettingConnection *s_con;
+
+	connection_1 = nmtst_create_connection_from_keyfile (
+	        "[connection]\n"
+	        "id=team-slave-enp31s0f1-142\n"
+	        "uuid=74f435bb-ede4-415a-9d48-f580b60eba04\n"
+	        "type=vlan\n"
+	        "autoconnect=false\n"
+	        "interface-name=enp31s0f1-142\n"
+	        "master=team142\n"
+	        "permissions=\n"
+	        "slave-type=team\n"
+	        "\n"
+	        "[vlan]\n"
+	        "egress-priority-map=\n"
+	        "flags=1\n"
+	        "id=142\n"
+	        "ingress-priority-map=\n"
+	        "parent=enp31s0f1\n"
+	        , "/test_team_reread_slave");
+
+	/* to double-check keyfile syntax, re-create the connection by hand. */
+	connection_2 = nmtst_create_minimal_connection ("team-slave-enp31s0f1-142", "74f435bb-ede4-415a-9d48-f580b60eba04", NM_SETTING_VLAN_SETTING_NAME, &s_con);
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "enp31s0f1-142",
+	              NM_SETTING_CONNECTION_MASTER, "team142",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, "team",
+	              NULL);
+	g_object_set (nm_connection_get_setting_vlan (connection_2),
+	              NM_SETTING_VLAN_FLAGS, 1,
+	              NM_SETTING_VLAN_ID, 142,
+	              NM_SETTING_VLAN_PARENT, "enp31s0f1",
+	              NULL);
+	nm_connection_add_setting (connection_2, nm_setting_team_port_new ());
+	nmtst_connection_normalize (connection_2);
+
+	nmtst_assert_connection_equals (connection_1, FALSE, connection_2, FALSE);
+
+	_writer_new_connection_reread ((nmtst_get_rand_uint32 () % 2) ? connection_1 : connection_2,
+	                               TEST_SCRATCH_DIR,
+	                               &testfile,
+	                               TEST_IFCFG_DIR"/ifcfg-team-slave-enp31s0f1-142.cexpected",
+	                               &reread,
+	                               &reread_same);
+	_assert_reread_same ((nmtst_get_rand_uint32 () % 2) ? connection_1 : connection_2, reread);
+	g_assert (reread_same);
+	g_clear_object (&reread);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_VLAN,
+	                                NULL);
+	nmtst_assert_connection_equals ((nmtst_get_rand_uint32 () % 2) ? connection_1 : connection_2, FALSE,
+	                                reread, FALSE);
+}
+
+static void
+test_read_proxy_basic (void)
+{
+	NMConnection *connection;
+	NMSettingProxy *s_proxy;
+
+	/* Test basic proxy configuration */
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-read-proxy-basic",
+	                                    NULL, TYPE_ETHERNET, NULL);
+
+	/* ===== Proxy setting ===== */
+	s_proxy = nm_connection_get_setting_proxy (connection);
+	g_assert (s_proxy);
+
+	/* Proxy method */
+	g_assert_cmpint (nm_setting_proxy_get_method (s_proxy), ==, NM_SETTING_PROXY_METHOD_AUTO);
+	g_assert (nm_setting_proxy_get_browser_only (s_proxy));
+	g_assert_cmpstr (nm_setting_proxy_get_pac_url (s_proxy), ==, "http://wpad.mycompany.com/wpad.dat");
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_proxy_basic (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingProxy *s_proxy;
+	const char *expected_url = "https://wpad.neverland.org/wpad.dat";
+	shvarFile *f;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Proxy Basic",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Proxy setting */
+	s_proxy = (NMSettingProxy *) nm_setting_proxy_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_proxy));
+	g_object_set (s_proxy, NM_SETTING_PROXY_METHOD, NM_SETTING_PROXY_METHOD_AUTO, NULL);
+	g_object_set (s_proxy, NM_SETTING_PROXY_PAC_URL, expected_url, NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Proxy_Basic.cexpected",
+	                        &testfile);
+
+	f = _svOpenFile (testfile);
+	_svGetValue_check (f, "TYPE", "Ethernet");
+	_svGetValue_check (f, "PROXY_METHOD", "auto");
+	_svGetValue_check (f, "PAC_URL", expected_url);
+	svCloseFile (f);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET,
+	                                NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+/*****************************************************************************/
+
+static const char *
+_svUnescape (const char *str, char **to_free)
+{
+	const char *s;
+	gs_free char *str_free = NULL;
+
+	g_assert (str);
+	g_assert (to_free);
+
+	if (str[0] == '\0') {
+		/* avoid static string "" */
+		str = (str_free = g_strdup (str));
+	}
+
+	s = svUnescape (str, to_free);
+	if (*to_free) {
+		g_assert (s == *to_free);
+		g_assert (s[0]);
+	} else {
+		g_assert (   s == NULL
+		          || (!s[0] && (s <  str || s >  strchr (str, '\0')))
+		          || ( s[0] &&  s >= str && s <= strchr (str, '\0') ));
+	}
+	return s;
+}
+
+typedef struct {
+	const char *val;
+	const char *exp;
+	bool can_concat:1;
+	bool needs_ascii_separator:1;
+} UnescapeTestData;
+
+static void
+do_svUnescape_assert (const char *str, const char *expected)
+{
+	gs_free char *to_free = NULL;
+	const char *s;
+
+	s = _svUnescape (str, &to_free);
+	g_assert_cmpstr (s, ==, expected);
+
+	/* check we can make a round-trip */
+	if (expected) {
+		gs_free char *s1_free = NULL;
+		gs_free char *s2_free = NULL;
+		const char *s1, *s2;
+
+		s1 = svEscape (expected, &s1_free);
+		g_assert (s1);
+
+		s2 = _svUnescape (s1, &s2_free);
+		g_assert (s2);
+
+		g_assert_cmpstr (s2, ==, expected);
+	}
+}
+
+static void
+do_svUnescape_combine_ansi_append (GString *str_val, GString *str_exp, const UnescapeTestData *data, gboolean honor_needs_ascii_separator)
+{
+	g_string_append (str_val, data->val);
+	g_string_append (str_exp, data->exp);
+	if (honor_needs_ascii_separator && data->needs_ascii_separator) {
+		/* the string has an open escape sequence. We must ensure that when
+		 * combining it with another sequence, that they don't merge into
+		 * something diffent. for example "\xa" + "a" must not result in
+		 * "\xaa". Instead, we add a space in between to get "\xa a". */
+		g_string_append (str_val, " ");
+		g_string_append (str_exp, " ");
+	}
+}
+
+static void
+do_svUnescape_combine_ansi (GString *str_val, GString *str_exp, const UnescapeTestData *data_ansi, gsize data_len, gssize idx)
+{
+	gsize i, j;
+
+	g_string_set_size (str_val, 0);
+	g_string_set_size (str_exp, 0);
+	g_string_append (str_val, "$'");
+	if (idx < 0) {
+		for (i = -idx; i > 0; i--) {
+			j = nmtst_get_rand_uint32 () % data_len;
+			if (!data_ansi[j].can_concat) {
+				i++;
+				continue;
+			}
+			do_svUnescape_combine_ansi_append (str_val, str_exp, &data_ansi[j], i > 1);
+		}
+	} else {
+		g_assert_cmpint (idx, <, data_len);
+		do_svUnescape_combine_ansi_append (str_val, str_exp, &data_ansi[idx], FALSE);
+	}
+	g_string_append (str_val, "'");
+}
+
+static void
+test_svUnescape (void)
+{
+#define V0(v_value, v_expected) { .val = ""v_value"", .exp = v_expected, .can_concat = FALSE, }
+#define V1(v_value, v_expected) { .val = ""v_value"", .exp = v_expected, .can_concat = !!v_expected, }
+#define V2(v_value, v_expected) { .val = ""v_value"", .exp = v_expected, .can_concat = TRUE, .needs_ascii_separator = TRUE, }
+	const UnescapeTestData data_full[] = {
+		V1 ("", ""),
+		V0 ("'", NULL),
+		V1 ("'x'", "x"),
+		V1 ("'  '", "  "),
+		V1 ("'x'", "x"),
+		V0 ("\"", NULL),
+		V0 ("\\", NULL),
+		V0 (" ", ""),
+		V0 ("   ", ""),
+		V0 ("a;   #", "a"),
+		V0 (" ;   #", ""),
+		V0 (";   ", ""),
+		V0 ("; ;", NULL),
+		V0 (" ; a #", NULL),
+		V0 (" ; a;;  #", NULL),
+		V0 ("a; ; #", NULL),
+		V0 ("\t  # ", ""),
+		V0 ("\t  #a", ""),
+		V0 ("\t  #a\r", ""),
+		V0 ("\r", ""),
+		V1 ("\\\"", "\""),
+		V1 ("\\`", "`"),
+		V1 ("\\$", "$"),
+		V1 ("\\\\", "\\"),
+		V1 ("\\a", "a"),
+		V1 ("\\b", "b"),
+		V1 ("\\'", "'"),
+		V1 ("\\~", "~"),
+		V1 ("\\\t", "\t"),
+		V1 ("\"\\\"\"", "\""),
+		V1 ("\"\\`\"", "`"),
+		V1 ("\"\\$\"", "$"),
+		V1 ("\"\\\\\"", "\\"),
+		V1 ("\"\\a\"", "\\a"),
+		V1 ("\"\\b\"", "\\b"),
+		V1 ("\"\\\t\"", "\\\t"),
+		V0 ("ab\r", "ab"),
+		V0 ("a'b'\r ", "ab"),
+		V0 ("a'b' \r", "ab"),
+		V0 ("a#b", "a#b"),
+		V0 ("#b", "#b"),
+		V1 ("\'some string\'", "some string"),
+		V0 ("Bob outside LAN", NULL),
+		V1 ("x", "x"),
+		V1 ("'{ \"device\": \"team0\", \"link_watch\": { \"name\": \"ethtool\" } }'",
+		    "{ \"device\": \"team0\", \"link_watch\": { \"name\": \"ethtool\" } }"),
+		V1 ("'{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}'",
+		    "{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}"),
+		V1 ("x\"\"b", "xb"),
+		V1 ("x\"c\"b", "xcb"),
+		V1 ("\"c\"b", "cb"),
+		V1 ("\"c\"\\'b", "c'b"),
+		V1 ("$''", ""),
+		V1 ("$'\\n'", "\n"),
+		V0 ("$'\\'", NULL),
+		V1 ("$'\\x'", "\\x"),
+		V1 ("$'\\xa'", "\xa"),
+		V0 ("$'\\x0'", ""),
+		V1 ("$'\\x12'", "\x12"),
+		V1 ("$'\\x12A'", "\x12""A"),
+		V1 ("$'\\x12t'", "\x12t"),
+		V1 ("\"aa\\\"\"", "aa\""),
+		V1 ("\"aa\\\"b\"c", "aa\"bc"),
+		V1 ("\"aa\\\"\"b", "aa\"b"),
+
+		/* the following is not shell behavior, but kept for backward compatibility
+		 * with old svEscape(). */
+		V0 ("\"\\'\"", "'"),
+		V0 ("\"\\~\"", "~"),
+		V0 ("\"b\\~b\"", "b~b"),
+		V0 ("\"\\~\\~\"", "~~"),
+		V0 ("\"\\~\\'\"", "~'"),
+
+		/* the following is shell-behavior, because it doesn't look like written
+		 * by old svEscape(). */
+		V1 ("\"\\~~\"", "\\~~"),
+		V1 ("\"\\a\\'\"", "\\a\\'"),
+		V1 ("x\"\\~\"", "x\\~"),
+		V1 ("\"\\'\"''", "\\'"),
+		V0 ("\"b\\~b\" ", "b\\~b"),
+		V1 ("\"b\\~b\"x", "b\\~bx"),
+	};
+	const UnescapeTestData data_ansi[] = {
+		/* strings inside $''. They cannot be compared directly, but must
+		 * be wrapped by do_svUnescape_combine_ansi(). */
+		V1 ("", ""),
+		V1 ("a", "a"),
+		V1 ("b", "b"),
+		V1 ("x", "x"),
+		V1 (" ", " "),
+		V1 ("\\a", "\a"),
+		V1 ("\\b", "\b"),
+		V1 ("\\e", "\e"),
+		V1 ("\\E", "\E"),
+		V1 ("\\f", "\f"),
+		V1 ("\\n", "\n"),
+		V1 ("\\r", "\r"),
+		V1 ("\\t", "\t"),
+		V1 ("\\v", "\v"),
+		V1 ("\\\\", "\\"),
+		V1 ("\\'", "'"),
+		V1 ("\\\"", "\""),
+		V1 ("\\?", "\?"),
+		V1 ("\\?", "?"),
+		V2 ("\\8", "\\8"),
+		V2 ("\\1", "\1"),
+		V1 ("\\1A", "\1A"),
+		V1 ("\\18", "\18"),
+		V2 ("\\01", "\1"),
+		V1 ("\\001", "\1"),
+		V0 ("\\008", ""),
+		V1 ("\\018", "\0018"),
+		V0 ("\\08", ""),
+		V1 ("\\18", "\0018"),
+		V1 ("\\x", "\\x"),
+		V2 ("\\xa", "\xa"),
+		V1 ("\\x12", "\x12"),
+		V1 ("\\x12A", "\x12""A"),
+		V1 ("\\x12a", "\x12""a"),
+		V1 ("\\x12t", "\x12t"),
+		V1 ("\\x1a", "\x1a"),
+		V1 ("\\x1A", "\x1A"),
+		V1 ("\\ut", "\\ut"),
+		V2 ("\\ua", "\xa"),
+		V1 ("\\uat", "\xat"),
+		V2 ("\\uab", "\xc2\xab"),
+		V1 ("\\uabt", "\xc2\xabt"),
+		V2 ("\\uabc", "\xe0\xaa\xbc"),
+		V1 ("\\uabct", "\xe0\xaa\xbct"),
+		V2 ("\\uabcd", "\xea\xaf\x8d"),
+		V1 ("\\uabcdt", "\xea\xaf\x8dt"),
+		V2 ("\\uabcde", "\xea\xaf\x8d""e"),
+		V1 ("\\uabcdet", "\xea\xaf\x8d""et"),
+		V1 ("\\Ut", "\\Ut"),
+		V2 ("\\Ua", "\xa"),
+		V1 ("\\Uat", "\xat"),
+		V2 ("\\Uab", "\xc2\xab"),
+		V1 ("\\Uabt", "\xc2\xabt"),
+		V2 ("\\Uabc", "\xe0\xaa\xbc"),
+		V1 ("\\Uabct", "\xe0\xaa\xbct"),
+		V2 ("\\Uabcd", "\xea\xaf\x8d"),
+		V1 ("\\Uabcdt", "\xea\xaf\x8dt"),
+		V2 ("\\Uabcde", "\xf2\xab\xb3\x9e"),
+		V1 ("\\Uabcdet", "\xf2\xab\xb3\x9et"),
+		V2 ("\\Uabcde0", "\xf8\xaa\xbc\xb7\xa0"),
+		V1 ("\\Uabcde0t", "\xf8\xaa\xbc\xb7\xa0t"),
+		V2 ("\\Uabcde01", "\xfc\x8a\xaf\x8d\xb8\x81"),
+		V1 ("\\Uabcde01t", "\xfc\x8a\xaf\x8d\xb8\x81t"),
+		V2 ("\\U0abcde01", "\xfc\x8a\xaf\x8d\xb8\x81"),
+		V1 ("\\U0abcde01t", "\xfc\x8a\xaf\x8d\xb8\x81t"),
+		V1 ("\\U00abcde01", "\xf8\xaa\xbc\xb7\xa0""1"),
+		V1 ("\\U00abcde01t", "\xf8\xaa\xbc\xb7\xa0""1t"),
+
+		/* control-x sequence is not supported */
+		V1 ("\\c", "\\c"),
+		V1 ("\\c1", "\\c1"),
+	};
+#undef V0
+#undef V1
+#undef V2
+	gsize i;
+	nm_auto_free_gstring GString *str_val = g_string_new (NULL);
+	nm_auto_free_gstring GString *str_val2 = g_string_new (NULL);
+	nm_auto_free_gstring GString *str_exp = g_string_new (NULL);
+	nm_auto_free_gstring GString *str_exp2 = g_string_new (NULL);
+
+	do_svUnescape_assert ( "'  ''  '", "    ");
+
+	for (i = 0; i < G_N_ELEMENTS (data_full); i++)
+		do_svUnescape_assert (data_full[i].val, data_full[i].exp);
+
+	for (i = 0; i < G_N_ELEMENTS (data_ansi); i++) {
+		do_svUnescape_combine_ansi (str_val, str_exp, data_ansi, G_N_ELEMENTS (data_ansi), i);
+		do_svUnescape_assert (str_val->str, str_exp->str);
+	}
+
+	/* different values can be just concatenated... */
+	for (i = 0; i < 200; i++) {
+		gsize num_concat = (nmtst_get_rand_uint32 () % 5) + 2;
+
+		g_string_set_size (str_val, 0);
+		g_string_set_size (str_exp, 0);
+
+		while (num_concat > 0) {
+			gsize idx;
+
+			if ((nmtst_get_rand_uint32 () % 3 == 0)) {
+				do_svUnescape_combine_ansi (str_val2, str_exp2, data_ansi, G_N_ELEMENTS (data_ansi), -((int) ((nmtst_get_rand_uint32 () % 5) + 1)));
+				continue;
+			}
+
+			idx = nmtst_get_rand_uint32 () % G_N_ELEMENTS (data_full);
+			if (!data_full[idx].can_concat)
+				continue;
+			g_string_append (str_val, data_full[idx].val);
+			g_string_append (str_exp, data_full[idx].exp);
+			num_concat--;
+		}
+
+		switch (nmtst_get_rand_uint32 () % 3) {
+		case 0:
+			g_string_append (str_val, " ");
+			break;
+		case 1:
+			g_string_append (str_val, "    ");
+			break;
+		}
+		switch (nmtst_get_rand_uint32 () % 3) {
+		case 0:
+			g_string_append (str_val, " #");
+			break;
+		case 1:
+			g_string_append (str_val, " #foo");
+			break;
+		}
+		do_svUnescape_assert (str_val->str, str_exp->str);
+	}
+}
+
+/*****************************************************************************/
+
+static void
+test_write_unknown (gconstpointer test_data)
+{
+	nmtst_auto_unlinkfile char *filename_tmp_1 = g_strdup (TEST_SCRATCH_DIR_TMP"/tmp-1");
+	const char *testfile = test_data;
+	gs_free char *testfile_expected = g_strconcat (testfile, ".expected", NULL);
+	shvarFile *sv;
+	gs_free_error GError *error = NULL;
+	gboolean success;
+	gs_free char *file_contents_out = NULL;
+	gs_free char *file_contents_exp = NULL;
+
+	sv = _svOpenFile (testfile);
+
+	_nmtst_svFileSetName (sv, filename_tmp_1);
+	_nmtst_svFileSetModified (sv);
+
+	if (g_str_has_suffix (testfile, "ifcfg-test-write-unknown-4")) {
+		_svGetValue_check (sv, "NAME", "l4x");
+		_svGetValue_check (sv, "NAME2", "");
+		_svGetValue_check (sv, "NAME3", "name3-value");
+
+		svSetValue (sv, "NAME", "set-by-test1");
+		svSetValue (sv, "NAME2", NULL);
+		svSetValue (sv, "NAME2", "set-by-test2");
+		svSetValue (sv, "NAME3", "set-by-test3");
+
+		_svGetValue_check (sv, "some_key", NULL);
+		_svGetValue_check (sv, "some_key1", "");
+		_svGetValue_check (sv, "some_key2", "");
+		_svGetValue_check (sv, "some_key3", "x");
+
+		_svGetValue_check (sv, "NAME", "set-by-test1");
+		_svGetValue_check (sv, "NAME2", "set-by-test2");
+		_svGetValue_check (sv, "NAME3", "set-by-test3");
+	}
+
+	success = svWriteFile (sv, 0644, &error);
+	nmtst_assert_success (success, error);
+
+	file_contents_out = nmtst_file_get_contents (filename_tmp_1);
+	file_contents_exp = nmtst_file_get_contents (testfile_expected);
+
+	g_assert_cmpstr (file_contents_out, ==, file_contents_exp);
+
+	svCloseFile (sv);
+}
+
+/*****************************************************************************/
+
+static void
+test_read_vlan_trailing_spaces (void)
+{
+	const char *testfile = TEST_IFCFG_DIR"/ifcfg-test-vlan-trailing-spaces";
+	NMConnection *connection;
+	gboolean success;
+	GError *error = NULL;
+	NMSettingVlan *s_vlan;
+	char *contents = NULL;
+
+	/* Ensure there is whitespace at the end of the VLAN interface name,
+	 * to prevent the whitespace getting stripped off and committed mistakenly
+	 * by something in the future.
+	 */
+	success = g_file_get_contents (testfile, &contents, NULL, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (contents && contents[0]);
+	g_assert (strstr (contents, "DEVICE=\"vlan201\"  \n"));
+	g_free (contents);
+
+	connection = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan201");
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "enccw0.0.fb00");
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 201);
+	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_REORDER_HEADERS);
+
+	g_object_unref (connection);
+}
+
+/*****************************************************************************/
+
+static void
+test_sit_read_ignore (void)
+{
+	gs_free_error GError *error = NULL;
+
+	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-sit-ignore",
+	                            NULL, TYPE_ETHERNET, &error);
+	nmtst_assert_error (error, 0, 0, "*Ignoring unsupported connection due to IPV6TUNNELIPV4*");
+}
+
+/*****************************************************************************/
+
+static void
+do_test_utils_name (const char *desc,
+                    const char *path,
+                    gboolean only_ifcfg,
+                    const char *expected)
+{
+	const char *result;
+
+	result = utils_get_ifcfg_name (path, only_ifcfg);
+	g_assert_cmpstr (result, ==, expected);
+}
+
+static void
+test_utils_name (void)
+{
+	do_test_utils_name ("get-ifcfg-name-bad", "/foo/bar/adfasdfadf", FALSE, NULL);
+	do_test_utils_name ("get-ifcfg-name-good", "/foo/bar/ifcfg-FooBar", FALSE, "FooBar");
+	do_test_utils_name ("get-ifcfg-name-keys", "/foo/bar/keys-BlahLbah", FALSE, "BlahLbah");
+	do_test_utils_name ("get-ifcfg-name-route", "/foo/bar/route-Lalalala", FALSE, "Lalalala");
+	do_test_utils_name ("get-ifcfg-name-only-ifcfg-route", "/foo/bar/route-Lalalala", TRUE, NULL);
+	do_test_utils_name ("get-ifcfg-name-only-ifcfg-keys", "/foo/bar/keys-Lalalala", TRUE, NULL);
+	do_test_utils_name ("get-ifcfg-name-no-path-ifcfg", "ifcfg-Lalalala", FALSE, "Lalalala");
+	do_test_utils_name ("get-ifcfg-name-no-path-keys", "keys-Lalalala", FALSE, "Lalalala");
+	do_test_utils_name ("get-ifcfg-name-no-path-route", "route-Lalalala", FALSE, "Lalalala");
+
+	do_test_utils_name ("get-ifcfg-name-bad2-ifcfg", "/foo/bar/asdfasifcfg-Foobar", FALSE, NULL);
+	do_test_utils_name ("get-ifcfg-name-bad2-keys", "/foo/bar/asdfaskeys-Foobar", FALSE, NULL);
+	do_test_utils_name ("get-ifcfg-name-bad2-route", "/foo/bar/asdfasroute-Foobar", FALSE, NULL);
+}
+
+/*****************************************************************************/
+
+static void
+do_test_utils_path_ifcfg (const char *desc,
+                          const char *path,
+                          const char *expected)
+{
+	char *result;
+
+	result = utils_get_ifcfg_path (path);
+	g_assert_cmpstr (result, ==, expected);
+	g_free (result);
+}
+
+static void
+do_test_utils_path_keys (const char *desc,
+                         const char *path,
+                         const char *expected)
+{
+	char *result;
+
+	result = utils_get_keys_path (path);
+	g_assert_cmpstr (result, ==, expected);
+	g_free (result);
+}
+
+static void
+do_test_utils_path_route (const char *desc,
+                          const char *path,
+                          const char *expected)
+{
+	char *result;
+
+	result = utils_get_route_path (path);
+	g_assert_cmpstr (result, ==, expected);
+	g_free (result);
+}
+
+static void
+test_utils_path (void)
+{
+	do_test_utils_path_ifcfg ("ifcfg-path-bad", "/foo/bar/adfasdfasdf", NULL);
+	do_test_utils_path_ifcfg ("ifcfg-path-from-keys-no-path", "keys-BlahBlah", "ifcfg-BlahBlah");
+	do_test_utils_path_ifcfg ("ifcfg-path-from-keys", "/foo/bar/keys-BlahBlah", "/foo/bar/ifcfg-BlahBlah");
+	do_test_utils_path_ifcfg ("ifcfg-path-from-route", "/foo/bar/route-BlahBlah", "/foo/bar/ifcfg-BlahBlah");
+
+	do_test_utils_path_keys ("keys-path-bad", "/foo/bar/asdfasdfasdfasdf", NULL);
+	do_test_utils_path_keys ("keys-path-from-ifcfg-no-path", "ifcfg-FooBar", "keys-FooBar");
+	do_test_utils_path_keys ("keys-path-from-ifcfg", "/foo/bar/ifcfg-FooBar", "/foo/bar/keys-FooBar");
+	do_test_utils_path_keys ("keys-path-from-route", "/foo/bar/route-FooBar", "/foo/bar/keys-FooBar");
+
+	do_test_utils_path_route ("route-path-bad", "/foo/bar/asdfasdfasdfasdf", NULL);
+	do_test_utils_path_route ("route-path-from-ifcfg-no-path", "ifcfg-FooBar", "route-FooBar");
+	do_test_utils_path_route ("route-path-from-ifcfg", "/foo/bar/ifcfg-FooBar", "/foo/bar/route-FooBar");
+	do_test_utils_path_route ("route-path-from-keys", "/foo/bar/keys-FooBar", "/foo/bar/route-FooBar");
+}
+
+/*****************************************************************************/
+
+static void
+do_test_utils_ignored (const char *desc, const char *path, gboolean expected_ignored)
+{
+	gboolean result;
+
+	result = utils_should_ignore_file (path, FALSE);
+	g_assert (result == expected_ignored);
+}
+
+static void
+test_utils_ignore (void)
+{
+	do_test_utils_ignored ("ignored-ifcfg", "ifcfg-FooBar", FALSE);
+	do_test_utils_ignored ("ignored-keys", "keys-FooBar", FALSE);
+	do_test_utils_ignored ("ignored-route", "route-FooBar", FALSE);
+	do_test_utils_ignored ("ignored-bak", "ifcfg-FooBar" BAK_TAG, TRUE);
+	do_test_utils_ignored ("ignored-tilde", "ifcfg-FooBar" TILDE_TAG, TRUE);
+	do_test_utils_ignored ("ignored-orig", "ifcfg-FooBar" ORIG_TAG, TRUE);
+	do_test_utils_ignored ("ignored-rej", "ifcfg-FooBar" REJ_TAG, TRUE);
+	do_test_utils_ignored ("ignored-rpmnew", "ifcfg-FooBar" RPMNEW_TAG, TRUE);
+	do_test_utils_ignored ("ignored-augnew", "ifcfg-FooBar" AUGNEW_TAG, TRUE);
+	do_test_utils_ignored ("ignored-augtmp", "ifcfg-FooBar" AUGTMP_TAG, TRUE);
+}
+
+/*****************************************************************************/
+
+static void
+test_sriov_read (void)
+{
+	gs_unref_object NMConnection *connection = NULL;
+	NMSettingSriov *s_sriov;
+	NMSriovVF *vf;
+	GVariant *variant;
+	GError *error = NULL;
+	char *str;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR "/ifcfg-test-sriov",
+	                                    NULL, TYPE_ETHERNET,NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "eth0");
+
+	s_sriov = NM_SETTING_SRIOV (nm_connection_get_setting (connection, NM_TYPE_SETTING_SRIOV));
+	g_assert (s_sriov);
+
+	g_assert_cmpint (nm_setting_sriov_get_total_vfs (s_sriov), ==, 16);
+	g_assert_cmpint (nm_setting_sriov_get_num_vfs (s_sriov), ==, 3);
+	g_assert_cmpint (nm_setting_sriov_get_autoprobe_drivers (s_sriov), ==, NM_TERNARY_FALSE);
+
+	/* VF 3 */
+	vf = nm_setting_sriov_get_vf (s_sriov, 0);
+	g_assert (vf);
+	g_assert_cmpint (nm_sriov_vf_get_index (vf), ==, 3);
+
+	variant = nm_sriov_vf_get_attribute (vf, NM_SRIOV_VF_ATTRIBUTE_MAC);
+	g_assert (variant);
+	g_assert (g_variant_is_of_type (variant, G_VARIANT_TYPE_STRING));
+	g_assert_cmpstr (g_variant_get_string (variant, NULL), ==, "55:44:33:22:11:00");
+
+	variant = nm_sriov_vf_get_attribute (vf, NM_SRIOV_VF_ATTRIBUTE_SPOOF_CHECK);
+	g_assert (variant);
+	g_assert (g_variant_is_of_type (variant, G_VARIANT_TYPE_BOOLEAN));
+	g_assert_cmpint (g_variant_get_boolean (variant), ==, TRUE);
+
+	/* VF 12 */
+	vf = nm_setting_sriov_get_vf (s_sriov, 1);
+	str = nm_utils_sriov_vf_to_str (vf, FALSE, &error);
+	g_assert_no_error (error);
+	g_assert_cmpstr (str, ==, "12 min-tx-rate=100 trust=false vlans=1.200.ad");
+	g_free (str);
+
+	/* VF 15 */
+	vf = nm_setting_sriov_get_vf (s_sriov, 2);
+	str = nm_utils_sriov_vf_to_str (vf, FALSE, &error);
+	g_assert_no_error (error);
+	g_assert_cmpstr (str, ==, "15 mac=01:23:45:67:89:ab max-tx-rate=200 vlans=2");
+	g_free (str);
+}
+
+static void
+test_sriov_write (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSettingWired *s_wired;
+	NMSettingSriov *s_sriov;
+	NMSriovVF *vf;
+	gs_unref_ptrarray GPtrArray *vfs = NULL;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write SR-IOV config",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	/* SRIOV setting */
+	s_sriov = (NMSettingSriov *) nm_setting_sriov_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_sriov));
+
+	vfs = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_sriov_vf_unref);
+
+	vf = nm_utils_sriov_vf_from_str ("2 mac=55:55:55:55:55:55 vlans=3.10.ad;10", &error);
+	nmtst_assert_success (vf, error);
+	g_ptr_array_add (vfs, vf);
+
+	vf = nm_utils_sriov_vf_from_str ("19 spoof-check=true", &error);
+	nmtst_assert_success (vf, error);
+	g_ptr_array_add (vfs, vf);
+
+	g_object_set (s_sriov,
+	              NM_SETTING_SRIOV_TOTAL_VFS, 64,
+	              NM_SETTING_SRIOV_VFS, vfs,
+	              NM_SETTING_SRIOV_AUTOPROBE_DRIVERS, NM_TERNARY_TRUE,
+	              NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR "/ifcfg-test-sriov-write.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+/*****************************************************************************/
+
+static void
+test_tc_read (void)
+{
+	NMConnection *connection;
+	NMSettingTCConfig *s_tc;
+	NMTCQdisc *qdisc;
+	NMTCTfilter *filter;
+	char *str;
+
+	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-tc",
+	                                    NULL, TYPE_ETHERNET,NULL);
+
+	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "eth0");
+
+	s_tc = nm_connection_get_setting_tc_config (connection);
+	g_assert (s_tc);
+
+	g_assert_cmpint (nm_setting_tc_config_get_num_qdiscs (s_tc), ==, 1);
+	qdisc = nm_setting_tc_config_get_qdisc (s_tc, 0);
+	g_assert (qdisc);
+	g_assert_cmpint (nm_tc_qdisc_get_parent (qdisc), ==, TC_H_ROOT);
+	g_assert_cmpint (nm_tc_qdisc_get_handle (qdisc), ==, TC_H_UNSPEC);
+	g_assert_cmpstr (nm_tc_qdisc_get_kind (qdisc), ==, "fq_codel");
+
+	g_assert_cmpint (nm_setting_tc_config_get_num_tfilters (s_tc), ==, 1);
+	filter = nm_setting_tc_config_get_tfilter (s_tc, 0);
+	g_assert (filter);
+	str = nm_utils_tc_tfilter_to_str (filter, NULL);
+	g_assert_cmpstr (str, ==, "parent 1234: matchall action simple sdata Hello");
+	g_free (str);
+
+	g_object_unref (connection);
+}
+
+static void
+test_tc_write (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSettingWired *s_wired;
+	NMSettingTCConfig *s_tc;
+	NMTCQdisc *qdisc;
+	NMTCTfilter *tfilter;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write TC config",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	/* TC setting */
+	s_tc = (NMSettingTCConfig *) nm_setting_tc_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_tc));
+
+	qdisc = nm_tc_qdisc_new ("pfifo_fast", TC_H_MAKE (0x2468 << 16, 0x2), &error);
+	g_assert_no_error (error);
+	nm_setting_tc_config_add_qdisc (s_tc, qdisc);
+	nm_tc_qdisc_unref (qdisc);
+
+	tfilter = nm_utils_tc_tfilter_from_str ("parent 1234: matchall action simple sdata Hello", &error);
+	g_assert_no_error (error);
+	nm_setting_tc_config_add_tfilter (s_tc, tfilter);
+	nm_tc_tfilter_unref (tfilter);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_IFCFG_DIR"/ifcfg-test-tc-write.cexpected",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, TYPE_BOND, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+/*****************************************************************************/
+
+#define TPATH "/settings/plugins/ifcfg-rh/"
+
+#define TEST_IFCFG_WIFI_OPEN_SSID_LONG_QUOTED TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-long-quoted"
+#define TEST_IFCFG_WIFI_OPEN_SSID_LONG_HEX TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-long-hex"
+
+#define DEFAULT_HEX_PSK "7d308b11df1b4243b0f78e5f3fc68cdbb9a264ed0edf4c188edf329ff5b467f0"
+
+NMTST_DEFINE ();
+
+int main (int argc, char **argv)
+{
+	int errsv;
+
+	nmtst_init_assert_logging (&argc, &argv, "INFO", "DEFAULT");
+
+	if (g_mkdir_with_parents (TEST_SCRATCH_DIR_TMP, 0755) != 0) {
+		errsv = errno;
+		g_error ("failure to create test directory \"%s\": %s", TEST_SCRATCH_DIR_TMP, nm_strerror_native (errsv));
+	}
+
+	g_test_add_func (TPATH "svUnescape", test_svUnescape);
+
+	g_test_add_data_func (TPATH "write-unknown/1", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-1", test_write_unknown);
+	g_test_add_data_func (TPATH "write-unknown/2", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-2", test_write_unknown);
+	g_test_add_data_func (TPATH "write-unknown/3", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-3", test_write_unknown);
+	g_test_add_data_func (TPATH "write-unknown/4", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-4", test_write_unknown);
+
+	g_test_add_func (TPATH "vlan-trailing-spaces", test_read_vlan_trailing_spaces);
+
+	g_test_add_func (TPATH "unmanaged", test_read_unmanaged);
+	g_test_add_func (TPATH "unmanaged-unrecognized", test_read_unmanaged_unrecognized);
+	g_test_add_func (TPATH "unrecognized", test_read_unrecognized);
+	g_test_add_func (TPATH "basic", test_read_basic);
+	g_test_add_func (TPATH "miscellaneous-variables", test_read_miscellaneous_variables);
+	g_test_add_func (TPATH "variables-corner-cases", test_read_variables_corner_cases);
+	g_test_add_data_func (TPATH "no-prefix/8", GUINT_TO_POINTER (8), test_read_wired_static_no_prefix);
+	g_test_add_data_func (TPATH "no-prefix/16", GUINT_TO_POINTER (16), test_read_wired_static_no_prefix);
+	g_test_add_data_func (TPATH "no-prefix/24", GUINT_TO_POINTER (24), test_read_wired_static_no_prefix);
+	g_test_add_data_func (TPATH "static-ip6-only-gw/_NULL_", NULL, test_write_wired_static_ip6_only_gw);
+	g_test_add_data_func (TPATH "static-ip6-only-gw/::", "::", test_write_wired_static_ip6_only_gw);
+	g_test_add_data_func (TPATH "static-ip6-only-gw/2001:db8:8:4::2", "2001:db8:8:4::2", test_write_wired_static_ip6_only_gw);
+	g_test_add_data_func (TPATH "static-ip6-only-gw/::ffff:255.255.255.255", "::ffff:255.255.255.255", test_write_wired_static_ip6_only_gw);
+	g_test_add_func (TPATH "ip6/disabled", test_write_ip6_disabled);
+	g_test_add_func (TPATH "read-dns-options", test_read_dns_options);
+	g_test_add_func (TPATH "clear-master", test_clear_master);
+
+	nmtst_add_test_func (TPATH "read-static",           test_read_wired_static, TEST_IFCFG_DIR"/ifcfg-test-wired-static",           "System test-wired-static",           GINT_TO_POINTER (TRUE));
+	nmtst_add_test_func (TPATH "read-static-bootproto", test_read_wired_static, TEST_IFCFG_DIR"/ifcfg-test-wired-static-bootproto", "System test-wired-static-bootproto", GINT_TO_POINTER (FALSE));
+
+	g_test_add_func (TPATH "read-netmask-1", test_read_netmask_1);
+
+	g_test_add_func (TPATH "read-dhcp", test_read_wired_dhcp);
+	g_test_add_func (TPATH "read-dhcp-plus-ip", test_read_wired_dhcp_plus_ip);
+	g_test_add_func (TPATH "read-shared-plus-ip", test_read_wired_shared_plus_ip);
+	g_test_add_func (TPATH "read-dhcp-send-hostname", test_read_write_wired_dhcp_send_hostname);
+	g_test_add_func (TPATH "read-dhcpv6-hostname-fallback", test_read_wired_dhcpv6_hostname_fallback);
+	g_test_add_func (TPATH "read-global-gateway", test_read_wired_global_gateway);
+	g_test_add_func (TPATH "read-global-gateway-ignore", test_read_wired_global_gateway_ignore);
+	g_test_add_func (TPATH "read-obsolete-gateway-n", test_read_wired_obsolete_gateway_n);
+	g_test_add_func (TPATH "read-never-default", test_read_wired_never_default);
+	g_test_add_func (TPATH "read-defroute-no", test_read_wired_defroute_no);
+	g_test_add_func (TPATH "read-defroute-no-gatewaydev-yes", test_read_wired_defroute_no_gatewaydev_yes);
+	g_test_add_func (TPATH "routes/read-static", test_read_wired_static_routes);
+	g_test_add_func (TPATH "routes/read-static-legacy", test_read_wired_static_routes_legacy);
+
+	nmtst_add_test_func (TPATH "wired/read/manual/1", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-1", "System test-wired-ipv4-manual-1");
+	nmtst_add_test_func (TPATH "wired/read/manual/2", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-2", "System test-wired-ipv4-manual-2");
+	nmtst_add_test_func (TPATH "wired/read/manual/3", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-3", "System test-wired-ipv4-manual-3");
+	nmtst_add_test_func (TPATH "wired/read/manual/4", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-4", "System test-wired-ipv4-manual-4");
+
+	g_test_add_func (TPATH "user/1", test_user_1);
+
+	g_test_add_func (TPATH "wired/ipv6-manual", test_read_wired_ipv6_manual);
+
+	nmtst_add_test_func (TPATH "wired-ipv6-only/0", test_read_wired_ipv6_only, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv6-only",   "System test-wired-ipv6-only");
+	nmtst_add_test_func (TPATH "wired-ipv6-only/1", test_read_wired_ipv6_only, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv6-only-1", "System test-wired-ipv6-only-1");
+
+	g_test_add_func (TPATH "wired/dhcpv6-only", test_read_wired_dhcp6_only);
+	g_test_add_func (TPATH "wired/autoip", test_read_wired_autoip);
+	g_test_add_func (TPATH "wired/onboot/no", test_read_onboot_no);
+	g_test_add_func (TPATH "wired/no-ip", test_read_noip);
+	g_test_add_func (TPATH "802-1x/peap/mschapv2", test_read_wired_8021x_peap_mschapv2);
+
+	nmtst_add_test_func (TPATH "test-wired-8021x-tls/agent",  test_read_wired_8021x_tls_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-tls-agent", GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED));
+	nmtst_add_test_func (TPATH "test-wired-8021x-tls/always", test_read_wired_8021x_tls_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-tls-always", GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED));
+
+	g_test_add_func (TPATH "802-1x/subj-matches", test_read_write_802_1X_subj_matches);
+	g_test_add_func (TPATH "802-1x/ttls-eapgtc", test_read_802_1x_ttls_eapgtc);
+	g_test_add_func (TPATH "802-1x/password_raw", test_read_write_802_1x_password_raw);
+	g_test_add_func (TPATH "802-1x/tls-p12-no-client-cert", test_read_802_1x_tls_p12_no_client_cert);
+
+	g_test_add_data_func (TPATH "wired/read/aliases/good/0", GINT_TO_POINTER (0), test_read_wired_aliases_good);
+	g_test_add_data_func (TPATH "wired/read/aliases/good/3", GINT_TO_POINTER (3), test_read_wired_aliases_good);
+	g_test_add_func (TPATH "wired/read/aliases/bad1", test_read_wired_aliases_bad_1);
+	g_test_add_func (TPATH "wired/read/aliases/bad2", test_read_wired_aliases_bad_2);
+	g_test_add_func (TPATH "wifi/read/open", test_read_wifi_open);
+	g_test_add_func (TPATH "wifi/read/open/auto", test_read_wifi_open_auto);
+	g_test_add_func (TPATH "wifi/read/open/hex-ssid", test_read_wifi_open_ssid_hex);
+	g_test_add_func (TPATH "wifi/read/open-ssid/bad-hex", test_read_wifi_open_ssid_hex_bad);
+	g_test_add_data_func (TPATH "wifi/read/open-ssid/long-hex", TEST_IFCFG_WIFI_OPEN_SSID_LONG_HEX, test_read_wifi_open_ssid_bad);
+	g_test_add_data_func (TPATH "wifi/read/open-ssid/long-quoted", TEST_IFCFG_WIFI_OPEN_SSID_LONG_QUOTED, test_read_wifi_open_ssid_bad);
+	g_test_add_func (TPATH "wifi/read/open/quoted-ssid", test_read_wifi_open_ssid_quoted);
+	g_test_add_func (TPATH "wifi/read/wep", test_read_wifi_wep);
+	g_test_add_func (TPATH "wifi/read/wep/adhoc", test_read_wifi_wep_adhoc);
+	g_test_add_func (TPATH "wifi/read/wep/passphrase", test_read_wifi_wep_passphrase);
+	g_test_add_func (TPATH "wifi/read/wep/40-ascii", test_read_wifi_wep_40_ascii);
+	g_test_add_func (TPATH "wifi/read/wep/104-ascii", test_read_wifi_wep_104_ascii);
+	g_test_add_func (TPATH "wifi/read/leap", test_read_wifi_leap);
+
+	nmtst_add_test_func (TPATH "wifi-leap-secret-flags/agent", test_read_wifi_leap_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wifi-leap-agent",      GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED));
+	nmtst_add_test_func (TPATH "wifi-leap-secret-flags/ask",   test_read_wifi_leap_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wifi-leap-always-ask", GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED));
+
+	g_test_add_func (TPATH "wifi/read/wpa-psk", test_read_wifi_wpa_psk);
+	g_test_add_func (TPATH "wifi/read/wpa-psk/2", test_read_wifi_wpa_psk_2);
+	g_test_add_func (TPATH "wifi/read/wpa-psk/unquoted", test_read_wifi_wpa_psk_unquoted);
+	g_test_add_func (TPATH "wifi/read/wpa-psk/unquoted2", test_read_wifi_wpa_psk_unquoted2);
+	g_test_add_func (TPATH "wifi/read/wpa-psk/adhoc", test_read_wifi_wpa_psk_adhoc);
+	g_test_add_func (TPATH "wifi/read/wpa-psk/hex", test_read_wifi_wpa_psk_hex);
+	g_test_add_func (TPATH "wifi/read/sae", test_read_wifi_sae);
+	g_test_add_func (TPATH "wifi/read/dynamic-wep/leap", test_read_wifi_dynamic_wep_leap);
+	g_test_add_func (TPATH "wifi/read/wpa/eap/tls", test_read_wifi_wpa_eap_tls);
+	g_test_add_func (TPATH "wifi/read/wpa/eap/ttls/tls", test_read_wifi_wpa_eap_ttls_tls);
+	g_test_add_func (TPATH "wifi/read/dynamic-wep/eap/ttls/chap", test_read_wifi_wep_eap_ttls_chap);
+	g_test_add_func (TPATH "wifi/read-band-a", test_read_wifi_band_a);
+	g_test_add_func (TPATH "wifi/read-band-a-channel-mismatch", test_read_wifi_band_a_channel_mismatch);
+	g_test_add_func (TPATH "wifi/read-band-bg-channel-mismatch", test_read_wifi_band_bg_channel_mismatch);
+	g_test_add_func (TPATH "wifi/read-hidden", test_read_wifi_hidden);
+
+	nmtst_add_test_func (TPATH "wifi/read-mac-random-always",   test_read_wifi_mac_random,  "always",  GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_ALWAYS));
+	nmtst_add_test_func (TPATH "wifi/read-mac-random-never",    test_read_wifi_mac_random,  "never",   GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_NEVER));
+	nmtst_add_test_func (TPATH "wifi/read-mac-random-default",  test_read_wifi_mac_random,  "default", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_DEFAULT));
+	nmtst_add_test_func (TPATH "wifi/read-mac-random-missing",  test_read_wifi_mac_random,  "missing", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_DEFAULT));
+
+	nmtst_add_test_func (TPATH "wifi/write-mac-random-always",  test_write_wifi_mac_random, "always",  GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_ALWAYS),  "always");
+	nmtst_add_test_func (TPATH "wifi/write-mac-random-never",   test_write_wifi_mac_random, "never",   GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_NEVER),   "never");
+	nmtst_add_test_func (TPATH "wifi/write-mac-random-default", test_write_wifi_mac_random, "default", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_DEFAULT), "default");
+	nmtst_add_test_func (TPATH "wifi/write-mac-random-missing", test_write_wifi_mac_random, "missing", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_NEVER),   "never");
+
+	g_test_add_func (TPATH "wifi/read/wep-no-keys", test_read_wifi_wep_no_keys);
+	g_test_add_func (TPATH "wifi/read/wep-agent-keys", test_read_wifi_wep_agent_keys);
+	g_test_add_func (TPATH "infiniband/read", test_read_infiniband);
+	g_test_add_func (TPATH "vlan/read", test_read_vlan_interface);
+	g_test_add_func (TPATH "vlan/read-flags-1", test_read_vlan_flags_1);
+	g_test_add_func (TPATH "vlan/read-flags-2", test_read_vlan_flags_2);
+	g_test_add_func (TPATH "vlan/read/only-vlanid", test_read_vlan_only_vlan_id);
+	g_test_add_func (TPATH "vlan/read/only-device", test_read_vlan_only_device);
+	g_test_add_func (TPATH "vlan/read/physdev", test_read_vlan_physdev);
+	g_test_add_func (TPATH "vlan/read/reorder-hdr-1", test_read_vlan_reorder_hdr_1);
+	g_test_add_func (TPATH "vlan/read/reorder-hdr-2", test_read_vlan_reorder_hdr_2);
+	g_test_add_func (TPATH "wired/read/read-wake-on-lan", test_read_wired_wake_on_lan);
+	g_test_add_func (TPATH "wired/read/read-auto-negotiate-off", test_read_wired_auto_negotiate_off);
+	g_test_add_func (TPATH "wired/read/read-auto-negotiate-on", test_read_wired_auto_negotiate_on);
+	g_test_add_func (TPATH "wired/read/unkwnown-ethtool-opt", test_read_wired_unknown_ethtool_opt);
+
+	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
+	g_test_add_func (TPATH "wired/write/static-with-generic", test_write_wired_static_with_generic);
+	g_test_add_func (TPATH "wired/write/static-ip6-only", test_write_wired_static_ip6_only);
+	g_test_add_func (TPATH "wired/write-static-routes", test_write_wired_static_routes);
+	g_test_add_func (TPATH "wired/read-write-static-routes-legacy", test_read_write_static_routes_legacy);
+	g_test_add_func (TPATH "wired/write/dhcp", test_write_wired_dhcp);
+	g_test_add_func (TPATH "wired/write-dhcp-plus-ip", test_write_wired_dhcp_plus_ip);
+	g_test_add_func (TPATH "wired/write/dhcp-8021x-peap-mschapv2", test_write_wired_dhcp_8021x_peap_mschapv2);
+	g_test_add_func (TPATH "wired/write/match", test_write_wired_match);
+	g_test_add_func (TPATH "wired/write/routing-rules", test_write_routing_rules);
+
+#define _add_test_write_wired_8021x_tls(testpath, scheme, flags) \
+	nmtst_add_test_func (testpath, test_write_wired_8021x_tls, GINT_TO_POINTER (scheme), GINT_TO_POINTER (flags))
+	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/1", NM_SETTING_802_1X_CK_SCHEME_PATH, NM_SETTING_SECRET_FLAG_AGENT_OWNED);
+	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/2", NM_SETTING_802_1X_CK_SCHEME_PATH, NM_SETTING_SECRET_FLAG_NOT_SAVED);
+	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/3", NM_SETTING_802_1X_CK_SCHEME_PATH, NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED);
+	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/4", NM_SETTING_802_1X_CK_SCHEME_BLOB, NM_SETTING_SECRET_FLAG_NONE);
+
+	g_test_add_func (TPATH "wired/write-aliases", test_write_wired_aliases);
+	g_test_add_func (TPATH "ipv4/write-static-addresses-GATEWAY", test_write_gateway);
+	g_test_add_func (TPATH "wired/write-wake-on-lan", test_write_wired_wake_on_lan);
+	g_test_add_func (TPATH "wired/write-auto-negotiate-off", test_write_wired_auto_negotiate_off);
+	g_test_add_func (TPATH "wired/write-auto-negotiate-on", test_write_wired_auto_negotiate_on);
+	g_test_add_func (TPATH "wifi/write/open", test_write_wifi_open);
+	g_test_add_func (TPATH "wifi/write/open/hex-ssid", test_write_wifi_open_hex_ssid);
+	g_test_add_func (TPATH "wifi/write/wep", test_write_wifi_wep);
+	g_test_add_func (TPATH "wifi/write/wep/adhoc", test_write_wifi_wep_adhoc);
+	g_test_add_func (TPATH "wifi/write/wep/passphrase", test_write_wifi_wep_passphrase);
+	g_test_add_func (TPATH "wifi/write/wep/40-ascii", test_write_wifi_wep_40_ascii);
+	g_test_add_func (TPATH "wifi/write/wep/104-ascii", test_write_wifi_wep_104_ascii);
+	g_test_add_func (TPATH "wifi/write/leap", test_write_wifi_leap);
+	g_test_add_data_func (TPATH "wifi/write/leap/flags/agent",
+	                      GUINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED),
+	                      test_write_wifi_leap_secret_flags);
+	g_test_add_data_func (TPATH "wifi/write/leap/flags/not-saved",
+	                      GUINT_TO_POINTER (NM_SETTING_SECRET_FLAG_NOT_SAVED),
+	                      test_write_wifi_leap_secret_flags);
+	g_test_add_data_func (TPATH "wifi/write/leap/flags/agent-and-not-saved",
+	                      GUINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED),
+	                      test_write_wifi_leap_secret_flags);
+
+#define _add_test_write_wifi_wpa_psk(testpath, name, wep_group, wpa, wpa2, psk) \
+	nmtst_add_test_func (testpath, test_write_wifi_wpa_psk, name, GPOINTER_TO_INT (wep_group), GPOINTER_TO_INT (wpa), GPOINTER_TO_INT (wpa2), psk)
+	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-psk-write",                            "Test Write Wifi WPA PSK",                               FALSE, TRUE,  FALSE, DEFAULT_HEX_PSK);
+	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa2-psk-write",                           "Test Write Wifi WPA2 PSK",                              FALSE, FALSE, TRUE,  DEFAULT_HEX_PSK);
+	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-wpa2-psk-write",                       "Test Write Wifi WPA WPA2 PSK",                          FALSE, TRUE,  TRUE,  DEFAULT_HEX_PSK);
+	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wep-wpa-wpa2-psk-write",                   "Test Write Wifi WEP WPA WPA2 PSK",                      TRUE,  TRUE,  TRUE,  DEFAULT_HEX_PSK);
+	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-wpa2-psk-passphrase-write",            "Test Write Wifi WPA WPA2 PSK Passphrase",               FALSE, TRUE,  TRUE,  "really insecure passphrase04!");
+	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-wpa2-psk-passphrase-write-spec-chars", "Test Write Wifi WPA WPA2 PSK Passphrase Special Chars", FALSE, TRUE,  TRUE,  "blah`oops\"grr'$*@~!%\\");
+
+	g_test_add_func (TPATH "wifi/write/wpa/psk/adhoc", test_write_wifi_wpa_psk_adhoc);
+	g_test_add_func (TPATH "wifi/write/wpa/eap/tls", test_write_wifi_wpa_eap_tls);
+	g_test_add_func (TPATH "wifi/write/wpa/eap/ttls/tls", test_write_wifi_wpa_eap_ttls_tls);
+	g_test_add_func (TPATH "wifi/write/wpa/eap/ttls/mschapv2", test_write_wifi_wpa_eap_ttls_mschapv2);
+	g_test_add_func (TPATH "wifi/write/dynamic-wep/leap", test_write_wifi_dynamic_wep_leap);
+	g_test_add_func (TPATH "wifi/write-wpa-then-open", test_write_wifi_wpa_then_open);
+	g_test_add_func (TPATH "wifi/write-wpa-then-wep-with-perms", test_write_wifi_wpa_then_wep_with_perms);
+	g_test_add_func (TPATH "wifi/write-hidden", test_write_wifi_hidden);
+	g_test_add_func (TPATH "wifi/write-band-a", test_write_wifi_band_a);
+
+	g_test_add_func (TPATH "s390/read-qeth-static", test_read_wired_qeth_static);
+	g_test_add_func (TPATH "s390/write-qeth-dhcp", test_write_wired_qeth_dhcp);
+	g_test_add_func (TPATH "s390/read-ctc-static", test_read_wired_ctc_static);
+	g_test_add_func (TPATH "s390/write-ctc-dhcp", test_write_wired_ctc_dhcp);
+
+	g_test_add_func (TPATH "permissions/read", test_read_permissions);
+	g_test_add_func (TPATH "permissions/write", test_write_permissions);
+	g_test_add_func (TPATH "wifi/write-wep-agent-keys", test_write_wifi_wep_agent_keys);
+	g_test_add_func (TPATH "infiniband/write", test_write_infiniband);
+	g_test_add_func (TPATH "vlan/write", test_write_vlan);
+	g_test_add_func (TPATH "vlan/write-flags", test_write_vlan_flags);
+	g_test_add_func (TPATH "vlan/write-only-vlanid", test_write_vlan_only_vlanid);
+	g_test_add_func (TPATH "vlan/write-vlan-reorder-hdr", test_write_vlan_reorder_hdr);
+	g_test_add_func (TPATH "wired/write-missing-ipv6", test_write_ethernet_missing_ipv6);
+	g_test_add_func (TPATH "write-dns-options", test_write_dns_options);
+
+	g_test_add_func (TPATH "ibft/ignored", test_read_ibft_ignored);
+
+	g_test_add_func (TPATH "dcb/read-basic", test_read_dcb_basic);
+	g_test_add_func (TPATH "dcb/write-basic", test_write_dcb_basic);
+	g_test_add_func (TPATH "dcb/default-app-priorities", test_read_dcb_default_app_priorities);
+	g_test_add_func (TPATH "dcb/bad-booleans", test_read_dcb_bad_booleans);
+	g_test_add_func (TPATH "dcb/short-booleans", test_read_dcb_short_booleans);
+	g_test_add_func (TPATH "dcb/bad-uints", test_read_dcb_bad_uints);
+	g_test_add_func (TPATH "dcb/short-uints", test_read_dcb_short_uints);
+	g_test_add_func (TPATH "dcb/bad-percent", test_read_dcb_bad_percent);
+	g_test_add_func (TPATH "dcb/short-percent", test_read_dcb_short_percent);
+	g_test_add_func (TPATH "dcb/pgpct-not-100", test_read_dcb_pgpct_not_100);
+	g_test_add_data_func (TPATH "fcoe/fabric", (gpointer) NM_SETTING_DCB_FCOE_MODE_FABRIC, test_read_fcoe_mode);
+	g_test_add_data_func (TPATH "fcoe/vn2vn", (gpointer) NM_SETTING_DCB_FCOE_MODE_VN2VN, test_read_fcoe_mode);
+	g_test_add_data_func (TPATH "fcoe/write-fabric", (gpointer) NM_SETTING_DCB_FCOE_MODE_FABRIC, test_write_fcoe_mode);
+	g_test_add_data_func (TPATH "fcoe/write-vn2vn", (gpointer) NM_SETTING_DCB_FCOE_MODE_VN2VN, test_write_fcoe_mode);
+
+	g_test_add_func (TPATH "bond/read-master", test_read_bond_main);
+	g_test_add_func (TPATH "bond/read-master-eth-type", test_read_bond_eth_type);
+	g_test_add_func (TPATH "bond/read-slave", test_read_bond_slave);
+	g_test_add_func (TPATH "bond/read-slave-ib", test_read_bond_slave_ib);
+	g_test_add_func (TPATH "bond/write-master", test_write_bond_main);
+	g_test_add_func (TPATH "bond/write-slave", test_write_bond_slave);
+	g_test_add_func (TPATH "bond/write-slave-ib", test_write_bond_slave_ib);
+	g_test_add_func (TPATH "bond/bonding-opts-numeric-mode", test_read_bond_opts_mode_numeric);
+
+	g_test_add_func (TPATH "bridge/read-master", test_read_bridge_main);
+	g_test_add_func (TPATH "bridge/write-master", test_write_bridge_main);
+	g_test_add_func (TPATH "bridge/read-component", test_read_bridge_component);
+	g_test_add_func (TPATH "bridge/write-component", test_write_bridge_component);
+	g_test_add_func (TPATH "bridge/read-missing-stp", test_read_bridge_missing_stp);
+
+	g_test_add_data_func (TPATH "team/read-master-1", TEST_IFCFG_DIR"/ifcfg-test-team-master-1", test_read_team_master);
+	g_test_add_data_func (TPATH "team/read-master-2", TEST_IFCFG_DIR"/ifcfg-test-team-master-2", test_read_team_master);
+	g_test_add_data_func (TPATH "team/read-master-invalid", TEST_IFCFG_DIR"/ifcfg-test-team-master-invalid", test_read_team_master_invalid);
+	g_test_add_func (TPATH "team/write-master", test_write_team_master);
+	g_test_add_data_func (TPATH "team/read-port-1", TEST_IFCFG_DIR"/ifcfg-test-team-port-1", test_read_team_port);
+	g_test_add_data_func (TPATH "team/read-port-2", TEST_IFCFG_DIR"/ifcfg-test-team-port-2", test_read_team_port);
+	g_test_add_func (TPATH "team/write-port", test_write_team_port);
+	g_test_add_func (TPATH "team/write-infiniband-port", test_write_team_infiniband_port);
+	g_test_add_func (TPATH "team/read-port-empty-config", test_read_team_port_empty_config);
+	g_test_add_func (TPATH "team/reread-slave", test_team_reread_slave);
+
+	g_test_add_func (TPATH "proxy/read-proxy-basic", test_read_proxy_basic);
+	g_test_add_func (TPATH "proxy/write-proxy-basic", test_write_proxy_basic);
+
+	g_test_add_func (TPATH "sit/read/ignore", test_sit_read_ignore);
+
+	/* Stuff we expect to fail for now */
+	g_test_add_func (TPATH "pppoe/write-wired", test_write_wired_pppoe);
+	g_test_add_func (TPATH "vpn/write", test_write_vpn);
+	g_test_add_data_func (TPATH "wwan/write-gsm", GUINT_TO_POINTER (TRUE), test_write_mobile_broadband);
+	g_test_add_data_func (TPATH "wwan/write-cdma", GUINT_TO_POINTER (FALSE), test_write_mobile_broadband);
+
+	g_test_add_func (TPATH "no-trailing-newline", test_ifcfg_no_trailing_newline);
+
+	g_test_add_func (TPATH "utils/name", test_utils_name);
+	g_test_add_func (TPATH "utils/path", test_utils_path);
+	g_test_add_func (TPATH "utils/ignore", test_utils_ignore);
+
+	g_test_add_func (TPATH "sriov/read", test_sriov_read);
+	g_test_add_func (TPATH "sriov/write", test_sriov_write);
+
+	g_test_add_func (TPATH "tc/read", test_tc_read);
+	g_test_add_func (TPATH "tc/write", test_tc_write);
+
+	return g_test_run ();
+}
-- 
2.25.1


From fc4c99372e09577918388f4303b52d7e07162e57 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Fri, 1 Nov 2019 13:37:22 -0400
Subject: [PATCH 02/78] first pass netplan plugin

---
 Makefile.am                                   |    55 +
 src/settings/plugins/netplan/meson.build      |     4 -
 .../plugins/netplan/nms-netplan-plugin.c      |   690 +-
 .../plugins/netplan/nms-netplan-plugin.h      |    32 +-
 .../plugins/netplan/nms-netplan-reader.c      |  1357 +-
 .../plugins/netplan/nms-netplan-reader.h      |    10 +-
 .../plugins/netplan/nms-netplan-storage.c     |   263 +
 .../plugins/netplan/nms-netplan-storage.h     |   198 +
 .../plugins/netplan/nms-netplan-utils.c       |   188 +-
 .../plugins/netplan/nms-netplan-utils.h       |    96 +-
 .../plugins/netplan/nms-netplan-writer.c      |  1965 ++-
 .../plugins/netplan/nms-netplan-writer.h      |    36 +-
 .../plugins/netplan/tests/meson.build         |    17 -
 .../plugins/netplan/tests/test-netplan.c      | 10485 ----------------
 14 files changed, 2253 insertions(+), 13143 deletions(-)
 create mode 100644 src/settings/plugins/netplan/nms-netplan-storage.c
 create mode 100644 src/settings/plugins/netplan/nms-netplan-storage.h
 delete mode 100644 src/settings/plugins/netplan/tests/meson.build
 delete mode 100644 src/settings/plugins/netplan/tests/test-netplan.c

diff --git a/Makefile.am b/Makefile.am
index b37aa4e712311cb23a675af70ec1287fcd3d63f5..d098587d5e431c406c5b5c8ee13ef199570810dc 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2857,6 +2857,61 @@ EXTRA_DIST += \
 	\
 	src/settings/plugins/keyfile/tests/meson.build
 
+###############################################################################
+# src/settings/plugins/netplan
+###############################################################################
+
+if CONFIG_PLUGIN_NETPLAN
+
+core_plugins += src/settings/plugins/netplan/libnm-settings-plugin-netplan.la
+
+noinst_LTLIBRARIES += \
+	src/settings/plugins/netplan/libnms-netplan-core.la
+
+###############################################################################
+
+src_settings_plugins_netplan_libnms_netplan_core_la_SOURCES = \
+	src/settings/plugins/netplan/nms-netplan-common.h \
+	src/settings/plugins/netplan/nms-netplan-utils.c \
+	src/settings/plugins/netplan/nms-netplan-utils.h \
+	src/settings/plugins/netplan/nms-netplan-reader.c \
+	src/settings/plugins/netplan/nms-netplan-reader.h \
+	src/settings/plugins/netplan/nms-netplan-writer.c \
+	src/settings/plugins/netplan/nms-netplan-writer.h \
+	$(NULL)
+
+src_settings_plugins_netplan_libnms_netplan_core_la_CPPFLAGS = $(src_cppflags_base)
+
+$(src_settings_plugins_netplan_libnms_netplan_core_la_OBJECTS): $(libnm_core_lib_h_pub_mkenums)
+
+###############################################################################
+
+src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_SOURCES = \
+	src/settings/plugins/netplan/nms-netplan-storage.c \
+	src/settings/plugins/netplan/nms-netplan-storage.h \
+	src/settings/plugins/netplan/nms-netplan-plugin.c \
+	src/settings/plugins/netplan/nms-netplan-plugin.h \
+	$(NULL)
+
+src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_CPPFLAGS = $(src_cppflags_base)
+
+src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_LDFLAGS = \
+	-module -avoid-version \
+	-Wl,--version-script="$(srcdir)/linker-script-settings.ver" \
+	$(SANITIZER_EXEC_LDFLAGS)
+
+src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_LIBADD = \
+	src/settings/plugins/netplan/libnms-netplan-core.la
+
+$(src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_OBJECTS): $(libnm_core_lib_h_pub_mkenums)
+
+check-local-symbols-settings-netplan: src/settings/plugins/netplan/libnm-settings-plugin-netplan.la
+	$(call check_so_symbols,$(builddir)/src/settings/plugins/netplan/.libs/libnm-settings-plugin-netplan.so)
+
+check_local += check-local-symbols-settings-netplan
+
+endif
+
 ###############################################################################
 # src/settings/plugins/ifcfg-rh
 ###############################################################################
diff --git a/src/settings/plugins/netplan/meson.build b/src/settings/plugins/netplan/meson.build
index 365ae1a9c50980c1d14d56db9d76dedfb8e9aec7..692a863b851e3d34e5741e27fb7979f06f2f0250 100644
--- a/src/settings/plugins/netplan/meson.build
+++ b/src/settings/plugins/netplan/meson.build
@@ -42,7 +42,3 @@ run_target(
 check-local-symbols-settings-ifupdown: src/settings/plugins/ifupdown/libnm-settings-plugin-ifupdown.la
   $(call check_so_symbols,$(builddir)/src/settings/plugins/ifupdown/.libs/libnm-settings-plugin-ifupdown.so)
 '''
-
-if enable_tests
-  subdir('tests')
-endif
diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.c b/src/settings/plugins/netplan/nms-netplan-plugin.c
index f438755d98958623d6d0dc06086a83610c0f3072..bff4a10098b07079825c4682bcca9549b2323092 100644
--- a/src/settings/plugins/netplan/nms-netplan-plugin.c
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.c
@@ -1,15 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0+
-/* NetworkManager system settings service
+/* NetworkManager netplan settings plugin
  *
- * Dan Williams <dcbw@redhat.com>
- * SÃ¸ren Sandmann <sandmann@daimi.au.dk>
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
  *
- * Copyright (C) 2007 - 2011 Red Hat, Inc.
+ * Copyright (C) 2019 Canonical Ltd.
  */
 
 #include "nm-default.h"
 
-#include "nms-ifcfg-rh-plugin.h"
+#include "nms-netplan-plugin.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -26,48 +25,35 @@
 #include "settings/nm-settings-utils.h"
 #include "NetworkManagerUtils.h"
 
-#include "nms-ifcfg-rh-storage.h"
-#include "nms-ifcfg-rh-common.h"
-#include "nms-ifcfg-rh-utils.h"
-#include "nms-ifcfg-rh-reader.h"
-#include "nms-ifcfg-rh-writer.h"
-
-#define IFCFGRH1_BUS_NAME                               "com.redhat.ifcfgrh1"
-#define IFCFGRH1_OBJECT_PATH                            "/com/redhat/ifcfgrh1"
-#define IFCFGRH1_IFACE1_NAME                            "com.redhat.ifcfgrh1"
-#define IFCFGRH1_IFACE1_METHOD_GET_IFCFG_DETAILS        "GetIfcfgDetails"
+#include "nms-netplan-storage.h"
+#include "nms-netplan-utils.h"
+#include "nms-netplan-reader.h"
+#include "nms-netplan-writer.h"
 
 /*****************************************************************************/
 
 typedef struct {
 	NMConfig *config;
 
-	struct {
-		GDBusConnection *connection;
-		GCancellable *cancellable;
-		gulong signal_id;
-		guint regist_id;
-	} dbus;
-
 	NMSettUtilStorages storages;
 
 	GHashTable *unmanaged_specs;
 	GHashTable *unrecognized_specs;
 
-} NMSIfcfgRHPluginPrivate;
+} NMSNetplanPluginPrivate;
 
-struct _NMSIfcfgRHPlugin {
+struct _NMSNetplanPlugin {
 	NMSettingsPlugin parent;
-	NMSIfcfgRHPluginPrivate _priv;
+	NMSNetplanPluginPrivate _priv;
 };
 
-struct _NMSIfcfgRHPluginClass {
+struct _NMSNetplanPluginClass {
 	NMSettingsPluginClass parent;
 };
 
-G_DEFINE_TYPE (NMSIfcfgRHPlugin, nms_ifcfg_rh_plugin, NM_TYPE_SETTINGS_PLUGIN)
+G_DEFINE_TYPE (NMSNetplanPlugin, nms_netplan_plugin, NM_TYPE_SETTINGS_PLUGIN)
 
-#define NMS_IFCFG_RH_PLUGIN_GET_PRIVATE(self) _NM_GET_PRIVATE (self, NMSIfcfgRHPlugin, NMS_IS_IFCFG_RH_PLUGIN, NMSettingsPlugin)
+#define NMS_NETPLAN_PLUGIN_GET_PRIVATE(self) _NM_GET_PRIVATE (self, NMSNetplanPlugin, NMS_IS_NETPLAN_PLUGIN, NMSettingsPlugin)
 
 /*****************************************************************************/
 
@@ -76,28 +62,27 @@ G_DEFINE_TYPE (NMSIfcfgRHPlugin, nms_ifcfg_rh_plugin, NM_TYPE_SETTINGS_PLUGIN)
     G_STMT_START { \
         nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
                 "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
-                "ifcfg-rh: " \
+                "netplan: " \
                 _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
     } G_STMT_END
 
 /*****************************************************************************/
 
-static void _unhandled_specs_reset (NMSIfcfgRHPlugin *self);
-
-static void _unhandled_specs_merge_storages (NMSIfcfgRHPlugin *self,
+static void _unhandled_specs_merge_storages (NMSNetplanPlugin *self,
                                              NMSettUtilStorages *storages);
+static void _unhandled_specs_reset (NMSNetplanPlugin *self);
 
 /*****************************************************************************/
 
 static void
-nm_assert_self (NMSIfcfgRHPlugin *self, gboolean unhandled_specs_consistent)
+nm_assert_self (NMSNetplanPlugin *self, gboolean unhandled_specs_consistent)
 {
-	nm_assert (NMS_IS_IFCFG_RH_PLUGIN (self));
+	nm_assert (NMS_IS_NETPLAN_PLUGIN (self));
 
 #if NM_MORE_ASSERTS > 5
 	{
-		NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-		NMSIfcfgRHStorage *storage;
+		NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
+		NMSNetplanStorage *storage;
 		gsize n_uuid;
 		gs_unref_hashtable GHashTable *h_unmanaged = NULL;
 		gs_unref_hashtable GHashTable *h_unrecognized = NULL;
@@ -113,11 +98,11 @@ nm_assert_self (NMSIfcfgRHPlugin *self, gboolean unhandled_specs_consistent)
 			const char *uuid;
 			const char *filename;
 
-			filename = nms_ifcfg_rh_storage_get_filename (storage);
+			filename = nms_netplan_storage_get_filename (storage);
 
-			nm_assert (filename && NM_STR_HAS_PREFIX (filename, IFCFG_DIR"/"));
+			nm_assert (filename && NM_STR_HAS_PREFIX (filename, NETPLAN_DIR"/"));
 
-			uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+			uuid = nms_netplan_storage_get_uuid (storage);
 
 			nm_assert ((!!uuid) + (!!storage->unmanaged_spec) + (!!storage->unrecognized_spec) == 1);
 
@@ -164,8 +149,8 @@ nm_assert_self (NMSIfcfgRHPlugin *self, gboolean unhandled_specs_consistent)
 
 /*****************************************************************************/
 
-static NMSIfcfgRHStorage *
-_load_file (NMSIfcfgRHPlugin *self,
+static NMSNetplanStorage *
+_load_file (NMSNetplanPlugin *self,
             const char *filename,
             GError **error)
 {
@@ -207,29 +192,29 @@ _load_file (NMSIfcfgRHPlugin *self,
 		const char *unmanaged_spec;
 		const char *unrecognized_spec;
 
-		if (!nms_ifcfg_rh_util_parse_unhandled_spec (unhandled_spec,
-		                                             &unmanaged_spec,
-		                                             &unrecognized_spec)) {
+		if (!nms_netplan_util_parse_unhandled_spec (unhandled_spec,
+		                                            &unmanaged_spec,
+		                                            &unrecognized_spec)) {
 			nm_utils_error_set (error, NM_UTILS_ERROR_UNKNOWN,
 			                    "invalid unhandled spec \"%s\"",
 			                    unhandled_spec);
 			nm_assert_not_reached ();
 			return NULL;
 		}
-		return nms_ifcfg_rh_storage_new_unhandled (self,
-		                                           filename,
-		                                           unmanaged_spec,
-		                                           unrecognized_spec);
+		return nms_netplan_storage_new_unhandled (self,
+		                                          filename,
+		                                          unmanaged_spec,
+		                                          unrecognized_spec);
 	}
 
-	return nms_ifcfg_rh_storage_new_connection (self,
-	                                            filename,
-	                                            g_steal_pointer (&connection),
-	                                            &st.st_mtim);
+	return nms_netplan_storage_new_connection (self,
+	                                           g_steal_pointer (&connection),
+	                                           filename,
+	                                           NMS_NETPLAN_STORAGE_TYPE_ETC);
 }
 
 static void
-_load_dir (NMSIfcfgRHPlugin *self,
+_load_dir (NMSNetplanPlugin *self,
            NMSettUtilStorages *storages)
 {
 	gs_unref_hashtable GHashTable *dupl_filenames = NULL;
@@ -237,9 +222,9 @@ _load_dir (NMSIfcfgRHPlugin *self,
 	const char *f_filename;
 	GDir *dir;
 
-	dir = g_dir_open (IFCFG_DIR, 0, &local);
+	dir = g_dir_open (NETPLAN_DIR, 0, &local);
 	if (!dir) {
-		_LOGT ("Could not read directory '%s': %s", IFCFG_DIR, local->message);
+		_LOGT ("Could not read directory '%s': %s", NETPLAN_DIR, local->message);
 		return;
 	}
 
@@ -247,22 +232,18 @@ _load_dir (NMSIfcfgRHPlugin *self,
 
 	while ((f_filename = g_dir_read_name (dir))) {
 		gs_free char *full_path = NULL;
-		NMSIfcfgRHStorage *storage;
-		char *full_filename;
+		NMSNetplanStorage *storage;
 
-		full_path = g_build_filename (IFCFG_DIR, f_filename, NULL);
-		full_filename = utils_detect_ifcfg_path (full_path, TRUE);
-		if (!full_filename)
+		full_path = g_build_filename (NETPLAN_DIR, f_filename, NULL);
+		if (!full_path)
 			continue;
 
-		if (!g_hash_table_add (dupl_filenames, full_filename))
+		if (!g_hash_table_add (dupl_filenames, full_path))
 			continue;
 
-		nm_assert (!nm_sett_util_storages_lookup_by_filename (storages, full_filename));
+		nm_assert (!nm_sett_util_storages_lookup_by_filename (storages, full_path));
 
-		storage = _load_file (self,
-		                      full_filename,
-		                      NULL);
+		storage = _load_file (self, full_path, NULL);
 		if (storage)
 			nm_sett_util_storages_add_take (storages, storage);
 	}
@@ -270,21 +251,21 @@ _load_dir (NMSIfcfgRHPlugin *self,
 }
 
 static void
-_storages_consolidate (NMSIfcfgRHPlugin *self,
+_storages_consolidate (NMSNetplanPlugin *self,
                        NMSettUtilStorages *storages_new,
                        gboolean replace_all,
                        GHashTable *storages_replaced,
                        NMSettingsPluginConnectionLoadCallback callback,
                        gpointer user_data)
 {
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 	CList lst_conn_info_deleted = C_LIST_INIT (lst_conn_info_deleted);
 	gs_unref_ptrarray GPtrArray *storages_modified = NULL;
 	CList storages_deleted;
-	NMSIfcfgRHStorage *storage_safe;
-	NMSIfcfgRHStorage *storage_new;
-	NMSIfcfgRHStorage *storage_old;
-	NMSIfcfgRHStorage *storage;
+	NMSNetplanStorage *storage_safe;
+	NMSNetplanStorage *storage_new;
+	NMSNetplanStorage *storage_old;
+	NMSNetplanStorage *storage;
 	guint i;
 
 	/* when we reload all files, we must signal add/update/modify of profiles one-by-one.
@@ -299,46 +280,43 @@ _storages_consolidate (NMSIfcfgRHPlugin *self,
 	storages_modified = g_ptr_array_new_with_free_func (g_object_unref);
 	c_list_init (&storages_deleted);
 
-	c_list_for_each_entry (storage_old, &priv->storages._storage_lst_head, parent._storage_lst)
-		storage_old->dirty = TRUE;
-
 	c_list_for_each_entry_safe (storage_new, storage_safe, &storages_new->_storage_lst_head, parent._storage_lst) {
-		storage_old = nm_sett_util_storages_lookup_by_filename (&priv->storages, nms_ifcfg_rh_storage_get_filename (storage_new));
+		storage_old = nm_sett_util_storages_lookup_by_filename (&priv->storages, nms_netplan_storage_get_filename (storage_new));
 
 		nm_sett_util_storages_steal (storages_new, storage_new);
 
 		if (   !storage_old
-		    || !nms_ifcfg_rh_storage_equal_type (storage_new, storage_old)) {
+		    || !nms_netplan_storage_equal_type (storage_new, storage_old)) {
 			if (storage_old) {
 				nm_sett_util_storages_steal (&priv->storages, storage_old);
-				if (nms_ifcfg_rh_storage_get_uuid_opt (storage_old))
+				if (nms_netplan_storage_get_uuid (storage_old))
 					c_list_link_tail (&storages_deleted, &storage_old->parent._storage_lst);
 				else
-					nms_ifcfg_rh_storage_destroy (storage_old);
+					nms_netplan_storage_destroy (storage_old);
 			}
-			storage_new->dirty = FALSE;
+			storage_new->is_dirty = FALSE;
 			nm_sett_util_storages_add_take (&priv->storages, storage_new);
 			g_ptr_array_add (storages_modified, g_object_ref (storage_new));
 			continue;
 		}
 
-		storage_old->dirty = FALSE;
-		nms_ifcfg_rh_storage_copy_content (storage_old, storage_new);
-		nms_ifcfg_rh_storage_destroy (storage_new);
+		storage_old->is_dirty = FALSE;
+		nms_netplan_storage_copy_content (storage_old, storage_new);
+		nms_netplan_storage_destroy (storage_new);
 		g_ptr_array_add (storages_modified, g_object_ref (storage_old));
 	}
 
 	c_list_for_each_entry_safe (storage_old, storage_safe, &priv->storages._storage_lst_head, parent._storage_lst) {
-		if (!storage_old->dirty)
+		if (!storage_old->is_dirty)
 			continue;
 		if (   replace_all
 		    || (   storages_replaced
 		        && g_hash_table_contains (storages_replaced, storage_old))) {
 			nm_sett_util_storages_steal (&priv->storages, storage_old);
-			if (nms_ifcfg_rh_storage_get_uuid_opt (storage_old))
+			if (nms_netplan_storage_get_uuid (storage_old))
 				c_list_link_tail (&storages_deleted, &storage_old->parent._storage_lst);
 			else
-				nms_ifcfg_rh_storage_destroy (storage_old);
+				nms_netplan_storage_destroy (storage_old);
 		}
 	}
 
@@ -346,47 +324,47 @@ _storages_consolidate (NMSIfcfgRHPlugin *self,
 
 	for (i = 0; i < storages_modified->len; i++) {
 		storage = storages_modified->pdata[i];
-		storage->dirty = TRUE;
+		storage->is_dirty = TRUE;
 	}
 
 	for (i = 0; i < storages_modified->len; i++) {
 		gs_unref_object NMConnection *connection = NULL;
 		storage = storages_modified->pdata[i];
 
-		if (!storage->dirty) {
+		if (!storage->is_dirty) {
 			/* the entry is no longer dirty. In the meantime we already emited
 			 * another signal for it. */
 			continue;
 		}
-		storage->dirty = FALSE;
-		if (storage != nm_sett_util_storages_lookup_by_filename (&priv->storages, nms_ifcfg_rh_storage_get_filename (storage))) {
+		storage->is_dirty = FALSE;
+		if (storage != nm_sett_util_storages_lookup_by_filename (&priv->storages, nms_netplan_storage_get_filename (storage))) {
 			/* hm? The profile was deleted in the meantime? That is only possible
 			 * if the signal handler called again into the plugin. In any case, the event
 			 * was already emitted. Skip. */
 			continue;
 		}
 
-		connection = nms_ifcfg_rh_storage_steal_connection (storage);
+		connection = nms_netplan_storage_steal_connection (storage);
 		if (!connection) {
-			nm_assert (!nms_ifcfg_rh_storage_get_uuid_opt (storage));
+			nm_assert (!nms_netplan_storage_get_uuid (storage));
 			continue;
 		}
 
 		nm_assert (NM_IS_CONNECTION (connection));
-		nm_assert (nms_ifcfg_rh_storage_get_uuid_opt (storage));
+		nm_assert (nms_netplan_storage_get_uuid (storage));
 		callback (NM_SETTINGS_PLUGIN (self),
 		          NM_SETTINGS_STORAGE (storage),
 		          connection,
 		          user_data);
 	}
 
-	while ((storage = c_list_first_entry (&storages_deleted, NMSIfcfgRHStorage, parent._storage_lst))) {
+	while ((storage = c_list_first_entry (&storages_deleted, NMSNetplanStorage, parent._storage_lst))) {
 		c_list_unlink (&storage->parent._storage_lst);
 		callback (NM_SETTINGS_PLUGIN (self),
 		          NM_SETTINGS_STORAGE (storage),
 		          NULL,
 		          user_data);
-		nms_ifcfg_rh_storage_destroy (storage);
+		nms_netplan_storage_destroy (storage);
 	}
 }
 
@@ -399,9 +377,9 @@ load_connections (NMSettingsPlugin *plugin,
                   NMSettingsPluginConnectionLoadCallback callback,
                   gpointer user_data)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	nm_auto_clear_sett_util_storages NMSettUtilStorages storages_new = NM_SETT_UTIL_STORAGES_INIT (storages_new, nms_ifcfg_rh_storage_destroy);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
+	nm_auto_clear_sett_util_storages NMSettUtilStorages storages_new = NM_SETT_UTIL_STORAGES_INIT (storages_new, nms_netplan_storage_destroy);
 	gs_unref_hashtable GHashTable *dupl_filenames = NULL;
 	gs_unref_hashtable GHashTable *storages_replaced = NULL;
 	gs_unref_hashtable GHashTable *loaded_uuids = NULL;
@@ -425,27 +403,12 @@ load_connections (NMSettingsPlugin *plugin,
 		const char *uuid;
 		gs_free char *full_filename_keep = NULL;
 		NMSettingsPluginConnectionLoadEntry *dupl_content_entry;
-		gs_unref_object NMSIfcfgRHStorage *storage = NULL;
+		gs_unref_object NMSNetplanStorage *storage = NULL;
 
 		if (entry->handled)
 			continue;
 
-		if (entry->filename[0] != '/')
-			continue;
-
-		full_filename_keep = utils_detect_ifcfg_path (entry->filename, FALSE);
-
-		if (!full_filename_keep) {
-			if (nm_utils_file_is_in_path (entry->filename, IFCFG_DIR)) {
-				nm_utils_error_set (&entry->error,
-				                    NM_UTILS_ERROR_UNKNOWN,
-				                    ("path is not a valid name for an ifcfg-rh file"));
-				entry->handled = TRUE;
-			}
-			continue;
-		}
-
-		if ((dupl_content_entry = g_hash_table_lookup (dupl_filenames, full_filename_keep))) {
+		if ((dupl_content_entry = g_hash_table_lookup (dupl_filenames, entry->filename))) {
 			/* we already visited this file. */
 			entry->handled = dupl_content_entry->handled;
 			if (dupl_content_entry->error) {
@@ -459,8 +422,8 @@ load_connections (NMSettingsPlugin *plugin,
 
 		entry->handled = TRUE;
 
-		full_filename = full_filename_keep;
-		if (!g_hash_table_insert (dupl_filenames, g_steal_pointer (&full_filename_keep), entry))
+		full_filename = entry->filename;
+		if (!g_hash_table_insert (dupl_filenames, g_strdup (full_filename), entry))
 			nm_assert_not_reached ();
 
 		storage = _load_file (self,
@@ -468,7 +431,7 @@ load_connections (NMSettingsPlugin *plugin,
 		                      &local);
 		if (!storage) {
 			if (nm_utils_file_stat (full_filename, NULL) == -ENOENT) {
-				NMSIfcfgRHStorage *storage2;
+				NMSNetplanStorage *storage2;
 
 				/* the file does not exist. We take that as indication to unload the file
 				 * that was previously loaded... */
@@ -481,7 +444,7 @@ load_connections (NMSettingsPlugin *plugin,
 			continue;
 		}
 
-		uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+		uuid = nms_netplan_storage_get_uuid (storage);
 		if (uuid)
 			g_hash_table_add (loaded_uuids, (char *) uuid);
 
@@ -491,7 +454,7 @@ load_connections (NMSettingsPlugin *plugin,
 	/* now we visit all UUIDs that are about to change... */
 	g_hash_table_iter_init (&h_iter, loaded_uuids);
 	while (g_hash_table_iter_next (&h_iter, (gpointer *) &loaded_uuid, NULL)) {
-		NMSIfcfgRHStorage *storage;
+		NMSNetplanStorage *storage;
 		NMSettUtilStorageByUuidHead *sbuh;
 
 		sbuh = nm_sett_util_storages_lookup_by_uuid (&priv->storages, loaded_uuid);
@@ -499,8 +462,8 @@ load_connections (NMSettingsPlugin *plugin,
 			continue;
 
 		c_list_for_each_entry (storage, &sbuh->_storage_by_uuid_lst_head, parent._storage_by_uuid_lst) {
-			const char *full_filename = nms_ifcfg_rh_storage_get_filename (storage);
-			gs_unref_object NMSIfcfgRHStorage *storage_new = NULL;
+			const char *full_filename = nms_netplan_storage_get_filename (storage);
+			gs_unref_object NMSNetplanStorage *storage_new = NULL;
 			gs_free_error GError *local = NULL;
 
 			if (g_hash_table_contains (dupl_filenames, full_filename)) {
@@ -516,7 +479,7 @@ load_connections (NMSettingsPlugin *plugin,
 			                          full_filename,
 			                          &local);
 			if (   storage_new
-			    && !nm_streq0 (loaded_uuid, nms_ifcfg_rh_storage_get_uuid_opt (storage_new))) {
+			    && !nm_streq0 (loaded_uuid, nms_netplan_storage_get_uuid (storage_new))) {
 				/* the file now references a different UUID. We are not told to reload
 				 * that file, so this means the existing storage (with the previous
 				 * filename and UUID tuple) is no longer valid. */
@@ -545,8 +508,8 @@ reload_connections (NMSettingsPlugin *plugin,
                     NMSettingsPluginConnectionLoadCallback callback,
                     gpointer user_data)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
-	nm_auto_clear_sett_util_storages NMSettUtilStorages storages_new = NM_SETT_UTIL_STORAGES_INIT (storages_new, nms_ifcfg_rh_storage_destroy);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
+	nm_auto_clear_sett_util_storages NMSettUtilStorages storages_new = NM_SETT_UTIL_STORAGES_INIT (storages_new, nms_netplan_storage_destroy);
 
 	nm_assert_self (self, TRUE);
 
@@ -565,7 +528,7 @@ reload_connections (NMSettingsPlugin *plugin,
 static void
 load_connections_done (NMSettingsPlugin *plugin)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
 
 	/* at the beginning of a load, we emit a change signal for unmanaged/unrecognized
 	 * specs that contain the sum of before and after (_unhandled_specs_merge_storages()).
@@ -588,9 +551,9 @@ add_connection (NMSettingsPlugin *plugin,
                 NMConnection **out_connection,
                 GError **error)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	gs_unref_object NMSIfcfgRHStorage *storage = NULL;
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
+	gs_unref_object NMSNetplanStorage *storage = NULL;
 	gs_unref_object NMConnection *reread = NULL;
 	gs_free char *full_filename = NULL;
 	GError *local = NULL;
@@ -602,15 +565,17 @@ add_connection (NMSettingsPlugin *plugin,
 	nm_assert (out_storage && !*out_storage);
 	nm_assert (out_connection && !*out_connection);
 
-	if (!nms_ifcfg_rh_writer_write_connection (connection,
-	                                           IFCFG_DIR,
-	                                           NULL,
-	                                           nm_sett_util_allow_filename_cb,
-	                                           NM_SETT_UTIL_ALLOW_FILENAME_DATA (&priv->storages, NULL),
-	                                           &full_filename,
-	                                           &reread,
-	                                           &reread_same,
-	                                           &local)) {
+	_LOGT ("MATT: called to save netplan config");
+
+	if (!nms_netplan_writer_write_connection (connection,
+	                                          NETPLAN_DIR,
+	                                          NULL,
+	                                          nm_sett_util_allow_filename_cb,
+	                                          NM_SETT_UTIL_ALLOW_FILENAME_DATA (&priv->storages, NULL),
+	                                          &full_filename,
+	                                          &reread,
+	                                          &reread_same,
+	                                          &local)) {
 		_LOGT ("commit: %s (%s): failed to add: %s",
 		       nm_connection_get_uuid (connection),
 		       nm_connection_get_id (connection),
@@ -630,14 +595,14 @@ add_connection (NMSettingsPlugin *plugin,
 	       nm_connection_get_id (reread),
 	       full_filename);
 
-	storage = nms_ifcfg_rh_storage_new_connection (self,
-	                                               full_filename,
-	                                               g_steal_pointer (&reread),
-	                                               nm_sett_util_stat_mtime (full_filename, FALSE, &mtime));
+	storage = nms_netplan_storage_new_connection (self,
+	                                              g_steal_pointer (&reread),
+	                                              full_filename,
+	                                              NMS_NETPLAN_STORAGE_TYPE_ETC);
 
 	nm_sett_util_storages_add_take (&priv->storages, g_object_ref (storage));
 
-	*out_connection = nms_ifcfg_rh_storage_steal_connection (storage);
+	*out_connection = nms_netplan_storage_steal_connection (storage);
 	*out_storage = NM_SETTINGS_STORAGE (g_steal_pointer (&storage));
 
 	nm_assert_self (self, TRUE);
@@ -653,9 +618,9 @@ update_connection (NMSettingsPlugin *plugin,
                    NMConnection **out_connection,
                    GError **error)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	NMSIfcfgRHStorage *storage = NMS_IFCFG_RH_STORAGE (storage_x);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
+	NMSNetplanStorage *storage = NMS_NETPLAN_STORAGE (storage_x);
 	const char *full_filename;
 	const char *uuid;
 	GError *local = NULL;
@@ -663,30 +628,32 @@ update_connection (NMSettingsPlugin *plugin,
 	gboolean reread_same;
 	struct timespec mtime;
 
+	_LOGT ("MATT: called to update netplan config");
+
 	nm_assert_self (self, TRUE);
 	nm_assert (NM_IS_CONNECTION (connection));
-	nm_assert (NMS_IS_IFCFG_RH_STORAGE (storage));
+	nm_assert (NMS_IS_NETPLAN_STORAGE (storage));
 	nm_assert (_nm_connection_verify (connection, NULL) == NM_SETTING_VERIFY_SUCCESS);
 	nm_assert (!error || !*error);
 
-	uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
+	uuid = nms_netplan_storage_get_uuid (storage);
 
 	nm_assert (uuid && nm_streq0 (uuid, nm_connection_get_uuid (connection)));
 
-	full_filename = nms_ifcfg_rh_storage_get_filename (storage);
+	full_filename = nms_netplan_storage_get_filename (storage);
 
 	nm_assert (full_filename);
 	nm_assert (storage == nm_sett_util_storages_lookup_by_filename (&priv->storages, full_filename));
 
-	if (!nms_ifcfg_rh_writer_write_connection (connection,
-	                                           IFCFG_DIR,
-	                                           full_filename,
-	                                           nm_sett_util_allow_filename_cb,
-	                                           NM_SETT_UTIL_ALLOW_FILENAME_DATA (&priv->storages, full_filename),
-	                                           NULL,
-	                                           &reread,
-	                                           &reread_same,
-	                                           &local)) {
+	if (!nms_netplan_writer_write_connection (connection,
+	                                          NETPLAN_DIR,
+	                                          full_filename,
+	                                          nm_sett_util_allow_filename_cb,
+	                                          NM_SETT_UTIL_ALLOW_FILENAME_DATA (&priv->storages, full_filename),
+	                                          NULL,
+	                                          &reread,
+	                                          &reread_same,
+	                                          &local)) {
 		_LOGT ("commit: failure to write %s (%s) to \"%s\": %s",
 		       nm_connection_get_uuid (connection),
 		       nm_connection_get_id (connection),
@@ -705,8 +672,6 @@ update_connection (NMSettingsPlugin *plugin,
 	       uuid,
 	       nm_connection_get_id (connection));
 
-	storage->stat_mtime = *nm_sett_util_stat_mtime (full_filename, FALSE, &mtime);
-
 	*out_storage = NM_SETTINGS_STORAGE (g_object_ref (storage));
 	*out_connection = g_steal_pointer (&reread);
 
@@ -720,63 +685,31 @@ delete_connection (NMSettingsPlugin *plugin,
                    NMSettingsStorage *storage_x,
                    GError **error)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (plugin);
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	NMSIfcfgRHStorage *storage = NMS_IFCFG_RH_STORAGE (storage_x);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
+	NMSNetplanStorage *storage = NMS_NETPLAN_STORAGE (storage_x);
 	const char *operation_message;
 	const char *full_filename;
+	int errsv;
 
 	nm_assert_self (self, TRUE);
 	nm_assert (!error || !*error);
-	nm_assert (NMS_IS_IFCFG_RH_STORAGE (storage));
+	nm_assert (NMS_IS_NETPLAN_STORAGE (storage));
 
-	full_filename = nms_ifcfg_rh_storage_get_filename (storage);
+	full_filename = nms_netplan_storage_get_filename (storage);
 	nm_assert (full_filename);
 
-	nm_assert (nms_ifcfg_rh_storage_get_uuid_opt (storage));
+	nm_assert (nms_netplan_storage_get_uuid (storage));
 
 	nm_assert (storage == nm_sett_util_storages_lookup_by_filename (&priv->storages, full_filename));
 
-	{
-		gs_free char *keyfile = utils_get_keys_path (full_filename);
-		gs_free char *routefile = utils_get_route_path (full_filename);
-		gs_free char *route6file = utils_get_route6_path (full_filename);
-		const char *const files[] = { full_filename, keyfile, routefile, route6file };
-		gboolean any_deleted = FALSE;
-		gboolean any_failure = FALSE;
-		int i;
-
-		for (i = 0; i < G_N_ELEMENTS (files); i++) {
-			int errsv;
-
-			if (unlink (files[i]) == 0) {
-				any_deleted = TRUE;
-				continue;
-			}
-			errsv = errno;
-			if (errsv == ENOENT)
-				continue;
-
-			_LOGW ("commit: failure to delete file \"%s\": %s",
-			       files[i],
-			       nm_strerror_native (errsv));
-			any_failure = TRUE;
-		}
-		if (any_failure)
-			operation_message = "failed to delete files from disk";
-		else if (any_deleted)
-			operation_message = "deleted from disk";
-		else
-			operation_message = "does not exist on disk";
-	}
-
 	_LOGT ("commit: deleted \"%s\", profile %s (%s)",
 	       full_filename,
-	       nms_ifcfg_rh_storage_get_uuid_opt (storage),
+	       nms_netplan_storage_get_uuid (storage),
 	       operation_message);
 
 	nm_sett_util_storages_steal (&priv->storages, storage);
-	nms_ifcfg_rh_storage_destroy (storage);
+	nms_netplan_storage_destroy (storage);
 
 	nm_assert_self (self, TRUE);
 
@@ -786,12 +719,12 @@ delete_connection (NMSettingsPlugin *plugin,
 /*****************************************************************************/
 
 static void
-_unhandled_specs_reset (NMSIfcfgRHPlugin *self)
+_unhandled_specs_reset (NMSNetplanPlugin *self)
 {
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 	gs_unref_hashtable GHashTable *unmanaged_specs = NULL;
 	gs_unref_hashtable GHashTable *unrecognized_specs = NULL;
-	NMSIfcfgRHStorage *storage;
+	NMSNetplanStorage *storage;
 
 	unmanaged_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
 	unrecognized_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
@@ -819,13 +752,13 @@ _unhandled_specs_reset (NMSIfcfgRHPlugin *self)
 }
 
 static void
-_unhandled_specs_merge_storages (NMSIfcfgRHPlugin *self,
+_unhandled_specs_merge_storages (NMSNetplanPlugin *self,
                                  NMSettUtilStorages *storages)
 {
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 	gboolean unmanaged_changed = FALSE;
 	gboolean unrecognized_changed = FALSE;
-	NMSIfcfgRHStorage *storage;
+	NMSNetplanStorage *storage;
 
 	c_list_for_each_entry (storage, &storages->_storage_lst_head, parent._storage_lst) {
 		if (   storage->unmanaged_spec
@@ -864,374 +797,57 @@ _unhandled_specs_from_hashtable (GHashTable *hash)
 static GSList *
 get_unmanaged_specs (NMSettingsPlugin *plugin)
 {
-	return _unhandled_specs_from_hashtable (NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (plugin)->unmanaged_specs);
+	return _unhandled_specs_from_hashtable (NMS_NETPLAN_PLUGIN_GET_PRIVATE (plugin)->unmanaged_specs);
 }
 
 static GSList *
 get_unrecognized_specs (NMSettingsPlugin *plugin)
 {
-	return _unhandled_specs_from_hashtable (NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (plugin)->unrecognized_specs);
+	return _unhandled_specs_from_hashtable (NMS_NETPLAN_PLUGIN_GET_PRIVATE (plugin)->unrecognized_specs);
 }
 
 /*****************************************************************************/
 
 static void
-impl_ifcfgrh_get_ifcfg_details (NMSIfcfgRHPlugin *self,
-                                GDBusMethodInvocation *context,
-                                const char *in_ifcfg)
+nms_netplan_plugin_init (NMSNetplanPlugin *self)
 {
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	gs_free char *ifcfg_path = NULL;
-	NMSIfcfgRHStorage *storage;
-	const char *uuid;
-	const char *path;
-
-	if (in_ifcfg[0] != '/') {
-		g_dbus_method_invocation_return_error (context,
-		                                       NM_SETTINGS_ERROR,
-		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                                       "ifcfg path '%s' is not absolute", in_ifcfg);
-		return;
-	}
-
-	ifcfg_path = utils_detect_ifcfg_path (in_ifcfg, TRUE);
-	if (!ifcfg_path) {
-		g_dbus_method_invocation_return_error (context,
-		                                       NM_SETTINGS_ERROR,
-		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                                       "ifcfg path '%s' is not an ifcfg base file", in_ifcfg);
-		return;
-	}
-
-	storage = nm_sett_util_storages_lookup_by_filename (&priv->storages, ifcfg_path);
-	if (!storage) {
-		g_dbus_method_invocation_return_error (context,
-		                                       NM_SETTINGS_ERROR,
-		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                                       "ifcfg file '%s' unknown", in_ifcfg);
-		return;
-	}
-
-	uuid = nms_ifcfg_rh_storage_get_uuid_opt (storage);
-	if (!uuid) {
-		g_dbus_method_invocation_return_error (context,
-		                                       NM_SETTINGS_ERROR,
-		                                       NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                                       "ifcfg file '%s' not managed by NetworkManager", in_ifcfg);
-		return;
-	}
-
-	/* It is ugly that the ifcfg-rh plugin needs to call back into NMSettings this
-	 * way.
-	 * There are alternatives (like invoking a signal), but they are all significant
-	 * extra code (and performance overhead). So the quick and dirty solution here
-	 * is likely to be simpler than getting this right (also from point of readability!).
-	 */
-	path = nm_settings_get_dbus_path_for_uuid (nm_settings_get (), uuid);
-
-	if (!path) {
-		g_dbus_method_invocation_return_error (context,
-		                                       NM_SETTINGS_ERROR,
-		                                       NM_SETTINGS_ERROR_FAILED,
-		                                       "unable to get the connection D-Bus path");
-		return;
-	}
-
-	g_dbus_method_invocation_return_value (context,
-	                                       g_variant_new ("(so)", uuid, path));
-}
-
-/*****************************************************************************/
-
-static void
-_dbus_clear (NMSIfcfgRHPlugin *self)
-{
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	guint id;
-
-	nm_clear_g_signal_handler (priv->dbus.connection, &priv->dbus.signal_id);
-
-	nm_clear_g_cancellable (&priv->dbus.cancellable);
-
-	if ((id = nm_steal_int (&priv->dbus.regist_id))) {
-		if (!g_dbus_connection_unregister_object (priv->dbus.connection, id))
-			_LOGW ("dbus: unexpected failure to unregister object");
-	}
-
-	g_clear_object (&priv->dbus.connection);
-}
-
-static void
-_dbus_connection_closed (GDBusConnection *connection,
-                         gboolean         remote_peer_vanished,
-                         GError          *error,
-                         gpointer         user_data)
-{
-	_LOGW ("dbus: %s bus closed", IFCFGRH1_BUS_NAME);
-	_dbus_clear (NMS_IFCFG_RH_PLUGIN (user_data));
-
-	/* Retry or recover? */
-}
-
-static void
-_method_call (GDBusConnection *connection,
-              const char *sender,
-              const char *object_path,
-              const char *interface_name,
-              const char *method_name,
-              GVariant *parameters,
-              GDBusMethodInvocation *invocation,
-              gpointer user_data)
-{
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (user_data);
-
-	if (nm_streq (interface_name, IFCFGRH1_IFACE1_NAME)) {
-		if (nm_streq (method_name, IFCFGRH1_IFACE1_METHOD_GET_IFCFG_DETAILS)) {
-			const char *ifcfg;
-
-			g_variant_get (parameters, "(&s)", &ifcfg);
-			impl_ifcfgrh_get_ifcfg_details (self, invocation, ifcfg);
-			return;
-		}
-	}
-
-	g_dbus_method_invocation_return_error (invocation,
-	                                       G_DBUS_ERROR,
-	                                       G_DBUS_ERROR_UNKNOWN_METHOD,
-	                                       "Unknown method %s",
-	                                       method_name);
-}
-
-static GDBusInterfaceInfo *const interface_info = NM_DEFINE_GDBUS_INTERFACE_INFO (
-	IFCFGRH1_IFACE1_NAME,
-	.methods = NM_DEFINE_GDBUS_METHOD_INFOS (
-		NM_DEFINE_GDBUS_METHOD_INFO (
-			IFCFGRH1_IFACE1_METHOD_GET_IFCFG_DETAILS,
-			.in_args = NM_DEFINE_GDBUS_ARG_INFOS (
-				NM_DEFINE_GDBUS_ARG_INFO ("ifcfg", "s"),
-			),
-			.out_args = NM_DEFINE_GDBUS_ARG_INFOS (
-				NM_DEFINE_GDBUS_ARG_INFO ("uuid", "s"),
-				NM_DEFINE_GDBUS_ARG_INFO ("path", "o"),
-			),
-		),
-	),
-);
-
-static void
-_dbus_request_name_done (GObject *source_object,
-                         GAsyncResult *res,
-                         gpointer user_data)
-{
-	GDBusConnection *connection = G_DBUS_CONNECTION (source_object);
-	NMSIfcfgRHPlugin *self;
-	NMSIfcfgRHPluginPrivate *priv;
-	gs_free_error GError *error = NULL;
-	gs_unref_variant GVariant *ret = NULL;
-	guint32 result;
-
-	ret = g_dbus_connection_call_finish (connection, res, &error);
-	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-		return;
-
-	self = NMS_IFCFG_RH_PLUGIN (user_data);
-	priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-
-	g_clear_object (&priv->dbus.cancellable);
-
-	if (!ret) {
-		_LOGW ("dbus: couldn't acquire D-Bus service: %s", error->message);
-		_dbus_clear (self);
-		return;
-	}
-
-	g_variant_get (ret, "(u)", &result);
-
-	if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		_LOGW ("dbus: couldn't acquire ifcfgrh1 D-Bus service (already taken)");
-		_dbus_clear (self);
-		return;
-	}
-
-	{
-		static const GDBusInterfaceVTable interface_vtable = {
-			.method_call = _method_call,
-		};
-
-		priv->dbus.regist_id = g_dbus_connection_register_object (connection,
-		                                                          IFCFGRH1_OBJECT_PATH,
-		                                                          interface_info,
-		                                                          NM_UNCONST_PTR (GDBusInterfaceVTable, &interface_vtable),
-		                                                          self,
-		                                                          NULL,
-		                                                          &error);
-		if (!priv->dbus.regist_id) {
-			_LOGW ("dbus: couldn't register D-Bus service: %s", error->message);
-			_dbus_clear (self);
-			return;
-		}
-	}
-
-	_LOGD ("dbus: acquired D-Bus service %s and exported %s object",
-	       IFCFGRH1_BUS_NAME,
-	       IFCFGRH1_OBJECT_PATH);
-}
-
-static void
-_dbus_create_done (GObject *source_object,
-                   GAsyncResult *res,
-                   gpointer user_data)
-{
-	NMSIfcfgRHPlugin *self;
-	NMSIfcfgRHPluginPrivate *priv;
-	gs_free_error GError *error = NULL;
-	GDBusConnection *connection;
-
-	connection = g_dbus_connection_new_for_address_finish (res, &error);
-	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-		return;
-
-	self = NMS_IFCFG_RH_PLUGIN (user_data);
-	priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-
-	g_clear_object (&priv->dbus.cancellable);
-
-	if (!connection) {
-		_LOGW ("dbus: couldn't initialize system bus: %s", error->message);
-		return;
-	}
-
-	priv->dbus.connection = connection;
-	priv->dbus.cancellable = g_cancellable_new ();
-
-	priv->dbus.signal_id = g_signal_connect (priv->dbus.connection,
-	                                         "closed",
-	                                         G_CALLBACK (_dbus_connection_closed),
-	                                         self);
-
-	g_dbus_connection_call (priv->dbus.connection,
-	                        DBUS_SERVICE_DBUS,
-	                        DBUS_PATH_DBUS,
-	                        DBUS_INTERFACE_DBUS,
-	                        "RequestName",
-	                        g_variant_new ("(su)",
-	                                       IFCFGRH1_BUS_NAME,
-	                                       DBUS_NAME_FLAG_DO_NOT_QUEUE),
-	                        G_VARIANT_TYPE ("(u)"),
-	                        G_DBUS_CALL_FLAGS_NONE,
-	                        -1,
-	                        priv->dbus.cancellable,
-	                        _dbus_request_name_done,
-	                        self);
-}
-
-static void
-_dbus_setup (NMSIfcfgRHPlugin *self)
-{
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	gs_free char *address = NULL;
-	gs_free_error GError *error = NULL;
-
-	_dbus_clear (self);
-
-	address = g_dbus_address_get_for_bus_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
-	if (address == NULL) {
-		_LOGW ("dbus: failed getting address for system bus: %s", error->message);
-		return;
-	}
-
-	priv->dbus.cancellable = g_cancellable_new ();
-
-	g_dbus_connection_new_for_address (address,
-	                                   G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT
-	                                   | G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
-	                                   NULL,
-	                                   priv->dbus.cancellable,
-	                                   _dbus_create_done,
-	                                   self);
-}
-
-static void
-config_changed_cb (NMConfig *config,
-                   NMConfigData *config_data,
-                   NMConfigChangeFlags changes,
-                   NMConfigData *old_data,
-                   NMSIfcfgRHPlugin *self)
-{
-	NMSIfcfgRHPluginPrivate *priv;
-
-	/* If the dbus connection for some reason is borked the D-Bus service
-	 * won't be offered.
-	 *
-	 * On SIGHUP and SIGUSR1 try to re-connect to D-Bus. So in the unlikely
-	 * event that the D-Bus connection is broken, that allows for recovery
-	 * without need for restarting NetworkManager. */
-	if (!NM_FLAGS_ANY (changes,   NM_CONFIG_CHANGE_CAUSE_SIGHUP
-	                            | NM_CONFIG_CHANGE_CAUSE_SIGUSR1))
-		return;
-
-	priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-	if (   !priv->dbus.connection
-	    && !priv->dbus.cancellable)
-		_dbus_setup (self);
-}
-
-/*****************************************************************************/
-
-static void
-nms_ifcfg_rh_plugin_init (NMSIfcfgRHPlugin *self)
-{
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 
 	priv->config = g_object_ref (nm_config_get ());
 
 	priv->unmanaged_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
 	priv->unrecognized_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
 
-	priv->storages = (NMSettUtilStorages) NM_SETT_UTIL_STORAGES_INIT (priv->storages, nms_ifcfg_rh_storage_destroy);
+	priv->storages = (NMSettUtilStorages) NM_SETT_UTIL_STORAGES_INIT (priv->storages, nms_netplan_storage_destroy);
 }
 
 static void
 constructed (GObject *object)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (object);
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-
-	G_OBJECT_CLASS (nms_ifcfg_rh_plugin_parent_class)->constructed (object);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (object);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 
-	g_signal_connect (priv->config,
-	                  NM_CONFIG_SIGNAL_CONFIG_CHANGED,
-	                  G_CALLBACK (config_changed_cb),
-	                  self);
-
-	_dbus_setup (self);
+	G_OBJECT_CLASS (nms_netplan_plugin_parent_class)->constructed (object);
 }
 
 static void
 dispose (GObject *object)
 {
-	NMSIfcfgRHPlugin *self = NMS_IFCFG_RH_PLUGIN (object);
-	NMSIfcfgRHPluginPrivate *priv = NMS_IFCFG_RH_PLUGIN_GET_PRIVATE (self);
-
-	if (priv->config)
-		g_signal_handlers_disconnect_by_func (priv->config, config_changed_cb, self);
-
-	/* FIXME(shutdown) we need a stop method so that we can unregistering the D-Bus service
-	 * when NMSettings is shutting down, and not when the instance gets destroyed. */
-	_dbus_clear (self);
+	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (object);
+	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 
 	nm_sett_util_storages_clear (&priv->storages);
 
 	g_clear_object (&priv->config);
 
-	G_OBJECT_CLASS (nms_ifcfg_rh_plugin_parent_class)->dispose (object);
+	G_OBJECT_CLASS (nms_netplan_plugin_parent_class)->dispose (object);
 
 	nm_clear_pointer (&priv->unmanaged_specs, g_hash_table_destroy);
 	nm_clear_pointer (&priv->unrecognized_specs, g_hash_table_destroy);
 }
 
 static void
-nms_ifcfg_rh_plugin_class_init (NMSIfcfgRHPluginClass *klass)
+nms_netplan_plugin_class_init (NMSNetplanPluginClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMSettingsPluginClass *plugin_class = NM_SETTINGS_PLUGIN_CLASS (klass);
@@ -1239,7 +855,7 @@ nms_ifcfg_rh_plugin_class_init (NMSIfcfgRHPluginClass *klass)
 	object_class->constructed = constructed;
 	object_class->dispose     = dispose;
 
-	plugin_class->plugin_name            = "ifcfg-rh";
+	plugin_class->plugin_name            = "netplan";
 	plugin_class->get_unmanaged_specs    = get_unmanaged_specs;
 	plugin_class->get_unrecognized_specs = get_unrecognized_specs;
 	plugin_class->reload_connections     = reload_connections;
@@ -1255,5 +871,5 @@ nms_ifcfg_rh_plugin_class_init (NMSIfcfgRHPluginClass *klass)
 G_MODULE_EXPORT NMSettingsPlugin *
 nm_settings_plugin_factory (void)
 {
-	return g_object_new (NMS_TYPE_IFCFG_RH_PLUGIN, NULL);
+	return g_object_new (NMS_TYPE_NETPLAN_PLUGIN, NULL);
 }
diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.h b/src/settings/plugins/netplan/nms-netplan-plugin.h
index a226b323049f42da29a4a001d28874bb6e687a55..b98f05e0013043b2f2d712295c97ef7407de7047 100644
--- a/src/settings/plugins/netplan/nms-netplan-plugin.h
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.h
@@ -1,25 +1,25 @@
 // SPDX-License-Identifier: GPL-2.0+
-/* NetworkManager system settings service
+/* NetworkManager netplan settings plugin
  *
- * Dan Williams <dcbw@redhat.com>
- * SÃ¸ren Sandmann <sandmann@daimi.au.dk>
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
  *
- * Copyright (C) 2007 - 2008 Red Hat, Inc.
+ * Copyright (C) 2019 Canonical Ltd.
  */
 
-#ifndef __NMS_IFCFG_RH_PLUGIN_H__
-#define __NMS_IFCFG_RH_PLUGIN_H__
+#ifndef __NMS_NETPLAN_PLUGIN_H__
+#define __NMS_NETPLAN_PLUGIN_H__
 
-#define NMS_TYPE_IFCFG_RH_PLUGIN            (nms_ifcfg_rh_plugin_get_type ())
-#define NMS_IFCFG_RH_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NMS_TYPE_IFCFG_RH_PLUGIN, NMSIfcfgRHPlugin))
-#define NMS_IFCFG_RH_PLUGIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NMS_TYPE_IFCFG_RH_PLUGIN, NMSIfcfgRHPluginClass))
-#define NMS_IS_IFCFG_RH_PLUGIN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NMS_TYPE_IFCFG_RH_PLUGIN))
-#define NMS_IS_IFCFG_RH_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NMS_TYPE_IFCFG_RH_PLUGIN))
-#define NMS_IFCFG_RH_PLUGIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NMS_TYPE_IFCFG_RH_PLUGIN, NMSIfcfgRHPluginClass))
+#define NETPLAN_DIR				SYSCONFDIR "/netplan"
+#define NMS_TYPE_NETPLAN_PLUGIN            (nms_netplan_plugin_get_type ())
+#define NMS_NETPLAN_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NMS_TYPE_NETPLAN_PLUGIN, NMSNetplanPlugin))
+#define NMS_NETPLAN_PLUGIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NMS_TYPE_NETPLAN_PLUGIN, NMSPluginClass))
+#define NMS_IS_NETPLAN_PLUGIN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NMS_TYPE_NETPLAN_PLUGIN))
+#define NMS_IS_NETPLAN_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NMS_TYPE_NETPLAN_PLUGIN))
+#define NMS_NETPLAN_PLUGIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NMS_TYPE_NETPLAN_PLUGIN, NMSNetplanPluginClass))
 
-typedef struct _NMSIfcfgRHPlugin NMSIfcfgRHPlugin;
-typedef struct _NMSIfcfgRHPluginClass NMSIfcfgRHPluginClass;
+typedef struct _NMSNetplanPlugin NMSNetplanPlugin;
+typedef struct _NMSNetplanPluginClass NMSNetplanPluginClass;
 
-GType nms_ifcfg_rh_plugin_get_type (void);
+GType nms_netplan_plugin_get_type (void);
 
-#endif /* __NMS_IFCFG_RH_PLUGIN_H__ */
+#endif /* __NMS_NETPLAN_PLUGIN_H__ */
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index f348ca473a2102dc3231d1485dc52250384783c1..77605aee70e415d93b80751f9b44536658bc8b44 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1,12 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0+
 /* NetworkManager system settings service
  *
- * Copyright 2008 - 2017 Red Hat, Inc.
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
  */
 
 #include "nm-default.h"
 
-#include "nms-ifcfg-rh-reader.h"
+#include "nms-netplan-reader.h"
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -44,14 +46,12 @@
 #include "platform/nm-platform.h"
 #include "NetworkManagerUtils.h"
 
-#include "nms-ifcfg-rh-common.h"
-#include "nms-ifcfg-rh-utils.h"
-#include "shvar.h"
+#include "nms-netplan-utils.h"
 
 /*****************************************************************************/
 
 #define _NMLOG_DOMAIN      LOGD_SETTINGS
-#define _NMLOG_PREFIX_NAME "ifcfg-rh"
+#define _NMLOG_PREFIX_NAME "netplan"
 #define _NMLOG(level, ...) \
     G_STMT_START { \
         nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
@@ -64,14 +64,16 @@
 
 /*****************************************************************************/
 
+#if 0
+
 static char *
-get_full_file_path (const char *ifcfg_path, const char *file_path)
+get_full_file_path (const char *netplan_path, const char *file_path)
 {
 	const char *base = file_path;
 	gs_free char *dirname = NULL;
 	char *p;
 
-	g_return_val_if_fail (ifcfg_path != NULL, NULL);
+	g_return_val_if_fail (netplan_path != NULL, NULL);
 	g_return_val_if_fail (file_path != NULL, NULL);
 
 	if (file_path[0] == '/')
@@ -81,14 +83,14 @@ get_full_file_path (const char *ifcfg_path, const char *file_path)
 	if (p)
 		base = p + 1;
 
-	dirname = g_path_get_dirname (ifcfg_path);
+	dirname = g_path_get_dirname (netplan_path);
 	return g_build_path ("/", dirname, base, NULL);
 }
 
 /*****************************************************************************/
 
 static NMSettingSecretFlags
-_secret_read_ifcfg_flags (shvarFile *ifcfg, const char *flags_key)
+_secret_read_netplan_flags (shvarFile *netplan, const char *flags_key)
 {
 	NMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;
 	gs_free char *val_free = NULL;
@@ -97,7 +99,7 @@ _secret_read_ifcfg_flags (shvarFile *ifcfg, const char *flags_key)
 	nm_assert (flags_key);
 	nm_assert (g_str_has_suffix (flags_key, "_FLAGS"));
 
-	val = svGetValueStr (ifcfg, flags_key, &val_free);
+	val = svGetValueStr (netplan, flags_key, &val_free);
 	if (val) {
 		if (strstr (val, SECRET_FLAG_AGENT))
 			flags |= NM_SETTING_SECRET_FLAG_AGENT_OWNED;
@@ -110,42 +112,42 @@ _secret_read_ifcfg_flags (shvarFile *ifcfg, const char *flags_key)
 }
 
 static void
-_secret_read_ifcfg (shvarFile *ifcfg,
-                    shvarFile *keys_ifcfg,
-                    const char *name,
-                    char **value,
-                    NMSettingSecretFlags *flags)
+_secret_read_netplan (shvarFile *netplan,
+                      shvarFile *keys_netplan,
+                      const char *name,
+                      char **value,
+                      NMSettingSecretFlags *flags)
 {
 	char flags_key[250];
 
 	nm_sprintf_buf (flags_key, "%s_FLAGS", name);
 
-	*flags = _secret_read_ifcfg_flags (ifcfg, flags_key);
+	*flags = _secret_read_netplan_flags (netplan, flags_key);
 
 	if (*flags != NM_SETTING_SECRET_FLAG_NONE)
 		*value = NULL;
 	else {
-		*value = svGetValue_cp (ifcfg, name);
-		if (!*value && keys_ifcfg)
-			*value = svGetValue_cp (keys_ifcfg, name);
-	}
-}
-
+		*value = svGetValue_cp (netplan, name);
+  		if (!*value && keys_netplan)
+			*  value = svGetV  alue_cp (keys_netplan, name);
+    	}
+    }
+  
 static void
-_secret_set_from_ifcfg (gpointer setting,
-                        shvarFile *ifcfg,
-                        shvarFile *keys_ifcfg,
-                        const char *ifcfg_key,
-                        const char *property_name)
-{
+_secret_set_from_netplan (gpointer setting,
+                          shvarFile *netplan,
+                          shvarFile *keys_netplan,
+                          const char *netplan_key,
+                          const char *property_name)
+  {
 	nm_auto_free_secret char *secret = NULL;
 	NMSettingSecretFlags flags;
 	char flags_key[250];
 
 	nm_assert (NM_IS_SETTING (setting));
 
-	_secret_read_ifcfg (ifcfg, keys_ifcfg, ifcfg_key, &secret, &flags);
-
+	_secret_read_netplan (netplan, keys_netplan, netplan_key, &secret, &flags);
+  
 	g_object_set (setting,
 	              property_name,
 	              secret,
@@ -155,7 +157,7 @@ _secret_set_from_ifcfg (gpointer setting,
 }
 
 static gboolean
-_secret_password_raw_to_bytes (const char *ifcfg_key,
+_secret_password_raw_to_bytes (const char *netplan_key,
                                const char *password_raw,
                                GBytes **out_bytes,
                                GError **error)
@@ -175,7 +177,7 @@ _secret_password_raw_to_bytes (const char *ifcfg_key,
 	if (!nm_utils_hexstr2bin_full (password_raw, FALSE, FALSE, ":", 0, secret->bin, secret->len, &len)) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Invalid hex password in %s",
-		             ifcfg_key);
+		             netplan_key);
 		return FALSE;
 	}
 
@@ -186,7 +188,7 @@ _secret_password_raw_to_bytes (const char *ifcfg_key,
 /*****************************************************************************/
 
 static GBytes *
-_cert_get_cert_bytes (const char *ifcfg_path,
+_cert_get_cert_bytes (const char *netplan_path,
                       const char *value,
                       GError **error)
 {
@@ -195,13 +197,13 @@ _cert_get_cert_bytes (const char *ifcfg_path,
 	if (NM_STR_HAS_PREFIX (value, "pkcs11:"))
 		return _nm_setting_802_1x_cert_value_to_bytes (NM_SETTING_802_1X_CK_SCHEME_PKCS11, (guint8 *) value, -1, error);
 
-	path = get_full_file_path (ifcfg_path, value);
+	path = get_full_file_path (netplan_path, value);
 	return _nm_setting_802_1x_cert_value_to_bytes (NM_SETTING_802_1X_CK_SCHEME_PATH, (guint8 *) path, -1, error);
 }
 
 static gboolean
-_cert_get_cert (shvarFile *ifcfg,
-                const char *ifcfg_key,
+_cert_get_cert (shvarFile *netplan,
+                const char *netplan_key,
                 GBytes **out_cert,
                 NMSetting8021xCKScheme *out_scheme,
                 GError **error)
@@ -212,14 +214,14 @@ _cert_get_cert (shvarFile *ifcfg,
 	GError *local = NULL;
 	NMSetting8021xCKScheme scheme;
 
-	val = svGetValueStr (ifcfg, ifcfg_key, &val_free);
+	val = svGetValueStr (netplan, netplan_key, &val_free);
 	if (!val) {
 		NM_SET_OUT (out_cert, NULL);
 		NM_SET_OUT (out_scheme, NM_SETTING_802_1X_CK_SCHEME_UNKNOWN);
 		return TRUE;
 	}
 
-	cert = _cert_get_cert_bytes (svFileGetName (ifcfg), val, &local);
+	cert = _cert_get_cert_bytes (svFileGetName (netplan), val, &local);
 	if (!cert)
 		goto err;
 
@@ -236,24 +238,24 @@ err:
 	             NM_SETTINGS_ERROR,
 	             NM_SETTINGS_ERROR_INVALID_CONNECTION,
 	             "invalid certificate %s: %s",
-	             ifcfg_key,
+	             netplan_key,
 	             local->message);
 	g_error_free (local);
 	return FALSE;
 }
 
 static gboolean
-_cert_set_from_ifcfg (gpointer setting,
-                      shvarFile *ifcfg,
-                      const char *ifcfg_key,
-                      const char *property_name,
-                      GBytes **out_cert,
-                      GError **error)
+_cert_set_from_netplan (gpointer setting,
+                        shvarFile *netplan,
+                        const char *netplan_key,
+                        const char *property_name,
+                        GBytes **out_cert,
+                        GError **error)
 {
 	gs_unref_bytes GBytes *cert = NULL;
 
-	if (!_cert_get_cert (ifcfg,
-	                     ifcfg_key,
+	if (!_cert_get_cert (netplan,
+	                     netplan_key,
 	                     &cert,
 	                     NULL,
 	                     error))
@@ -268,16 +270,16 @@ _cert_set_from_ifcfg (gpointer setting,
 /*****************************************************************************/
 
 static void
-check_if_bond_slave (shvarFile *ifcfg,
+check_if_bond_slave (shvarFile *netplan,
                      NMSettingConnection *s_con)
 {
 	gs_free char *value = NULL;
 	const char *v;
 	const char *master;
 
-	v = svGetValueStr (ifcfg, "MASTER_UUID", &value);
+	v = svGetValueStr (netplan, "MASTER_UUID", &value);
 	if (!v)
-		v = svGetValueStr (ifcfg, "MASTER", &value);
+		v = svGetValueStr (netplan, "MASTER", &value);
 
 	if (v) {
 		master = nm_setting_connection_get_master (s_con);
@@ -299,16 +301,16 @@ check_if_bond_slave (shvarFile *ifcfg,
 }
 
 static void
-check_if_team_slave (shvarFile *ifcfg,
+check_if_team_slave (shvarFile *netplan,
                      NMSettingConnection *s_con)
 {
 	gs_free char *value = NULL;
 	const char *v;
 	const char *master;
 
-	v = svGetValueStr (ifcfg, "TEAM_MASTER_UUID", &value);
+	v = svGetValueStr (netplan, "TEAM_MASTER_UUID", &value);
 	if (!v)
-		v = svGetValueStr (ifcfg, "TEAM_MASTER", &value);
+		v = svGetValueStr (netplan, "TEAM_MASTER", &value);
 	if (!v)
 		return;
 
@@ -326,15 +328,15 @@ check_if_team_slave (shvarFile *ifcfg,
 }
 
 static char *
-make_connection_name (shvarFile *ifcfg,
-                      const char *ifcfg_name,
+make_connection_name (shvarFile *netplan,
+                      const char *netplan_name,
                       const char *suggested,
                       const char *prefix)
 {
 	char *full_name = NULL, *name;
 
-	/* If the ifcfg file already has a NAME, always use that */
-	name = svGetValueStr_cp (ifcfg, "NAME");
+	/* If the netplan file already has a NAME, always use that */
+	name = svGetValueStr_cp (netplan, "NAME");
 	if (name)
 		return name;
 
@@ -343,27 +345,27 @@ make_connection_name (shvarFile *ifcfg,
 		prefix = "System";
 
 	/* For cosmetic reasons, if the suggested name is the same as
-	 * the ifcfg files name, don't use it.  Mainly for wifi so that
+	 * the netplan files name, don't use it.  Mainly for wifi so that
 	 * the SSID is shown in the connection ID instead of just "wlan0".
 	 */
-	if (suggested && strcmp (ifcfg_name, suggested))
-		full_name = g_strdup_printf ("%s %s (%s)", prefix, suggested, ifcfg_name);
+	if (suggested && strcmp (netplan_name, suggested))
+		full_name = g_strdup_printf ("%s %s (%s)", prefix, suggested, netplan_name);
 	else
-		full_name = g_strdup_printf ("%s %s", prefix, ifcfg_name);
+		full_name = g_strdup_printf ("%s %s", prefix, netplan_name);
 
 	return full_name;
 }
 
 static NMSetting *
 make_connection_setting (const char *file,
-                         shvarFile *ifcfg,
+                         shvarFile *netplan,
                          const char *type,
                          const char *suggested,
                          const char *prefix)
 {
 	NMSettingConnection *s_con;
 	NMSettingConnectionLldp lldp;
-	const char *ifcfg_name = NULL;
+	const char *netplan_name = NULL;
 	gs_free char *new_id = NULL;
 	const char *uuid;
 	gs_free char *uuid_free = NULL;
@@ -373,29 +375,29 @@ make_connection_setting (const char *file,
 	const char *const *iter;
 	int vint64, i_val;
 
-	ifcfg_name = utils_get_ifcfg_name (file, TRUE);
-	if (!ifcfg_name)
+	netplan_name = utils_get_netplan_name (file, TRUE);
+	if (!netplan_name)
 		return NULL;
 
 	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
 
-	new_id = make_connection_name (ifcfg, ifcfg_name, suggested, prefix);
+	new_id = make_connection_name (netplan, netplan_name, suggested, prefix);
 	g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
 
 	/* Try for a UUID key before falling back to hashing the file name */
-	uuid = svGetValueStr (ifcfg, "UUID", &uuid_free);
+	uuid = svGetValueStr (netplan, "UUID", &uuid_free);
 	if (!uuid) {
-		uuid_free = nm_utils_uuid_generate_from_string (svFileGetName (ifcfg), -1, NM_UTILS_UUID_TYPE_LEGACY, NULL);
+		uuid_free = nm_utils_uuid_generate_from_string (svFileGetName (netplan), -1, NM_UTILS_UUID_TYPE_LEGACY, NULL);
 		uuid = uuid_free;
 	}
 
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_TYPE, type,
 	              NM_SETTING_CONNECTION_UUID, uuid,
-	              NM_SETTING_CONNECTION_STABLE_ID, svGetValue (ifcfg, "STABLE_ID", &stable_id),
+	              NM_SETTING_CONNECTION_STABLE_ID, svGetValue (netplan, "STABLE_ID", &stable_id),
 	              NULL);
 
-	v = svGetValueStr (ifcfg, "DEVICE", &value);
+	v = svGetValueStr (netplan, "DEVICE", &value);
 	if (v) {
 		GError *error = NULL;
 
@@ -410,7 +412,7 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "LLDP", &value);
+	v = svGetValueStr (netplan, "LLDP", &value);
 	if (nm_streq0 (v, "rx"))
 		lldp = NM_SETTING_CONNECTION_LLDP_ENABLE_RX;
 	else
@@ -419,25 +421,25 @@ make_connection_setting (const char *file,
 	/* Missing ONBOOT is treated as "ONBOOT=true" by the old network service */
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_AUTOCONNECT,
-	              svGetValueBoolean (ifcfg, "ONBOOT", TRUE),
+	              svGetValueBoolean (netplan, "ONBOOT", TRUE),
 	              NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY,
-	              (int) svGetValueInt64 (ifcfg, "AUTOCONNECT_PRIORITY", 10,
+	              (int) svGetValueInt64 (netplan, "AUTOCONNECT_PRIORITY", 10,
 	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN,
 	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX,
 	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT),
 	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES,
-	              (int) svGetValueInt64 (ifcfg, "AUTOCONNECT_RETRIES", 10,
+	              (int) svGetValueInt64 (netplan, "AUTOCONNECT_RETRIES", 10,
 	                                      -1, G_MAXINT32, -1),
 	              NM_SETTING_CONNECTION_MULTI_CONNECT,
-	              (gint) svGetValueInt64 (ifcfg, "MULTI_CONNECT", 10,
+	              (gint) svGetValueInt64 (netplan, "MULTI_CONNECT", 10,
 	                                      G_MININT32, G_MAXINT32, NM_CONNECTION_MULTI_CONNECT_DEFAULT),
 	              NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES,
-	              svGetValueBoolean (ifcfg, "AUTOCONNECT_SLAVES", NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT),
+	              svGetValueBoolean (netplan, "AUTOCONNECT_SLAVES", NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT),
 	              NM_SETTING_CONNECTION_LLDP, lldp,
 	              NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "USERS", &value);
+	v = svGetValueStr (netplan, "USERS", &value);
 	if (v) {
 		gs_free const char **items = NULL;
 
@@ -449,11 +451,11 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "ZONE", &value);
+	v = svGetValueStr (netplan, "ZONE", &value);
 	g_object_set (s_con, NM_SETTING_CONNECTION_ZONE, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "SECONDARY_UUIDS", &value);
+	v = svGetValueStr (netplan, "SECONDARY_UUIDS", &value);
 	if (v) {
 		gs_free const char **items = NULL;
 
@@ -465,9 +467,9 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "BRIDGE_UUID", &value);
+	v = svGetValueStr (netplan, "BRIDGE_UUID", &value);
 	if (!v)
-		v = svGetValueStr (ifcfg, "BRIDGE", &value);
+		v = svGetValueStr (netplan, "BRIDGE", &value);
 	if (v) {
 		const char *old_value;
 
@@ -481,13 +483,13 @@ make_connection_setting (const char *file,
 		}
 	}
 
-	check_if_bond_slave (ifcfg, s_con);
-	check_if_team_slave (ifcfg, s_con);
+	check_if_bond_slave (netplan, s_con);
+	check_if_team_slave (netplan, s_con);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "OVS_PORT_UUID", &value);
+	v = svGetValueStr (netplan, "OVS_PORT_UUID", &value);
 	if (!v)
-		v = svGetValueStr (ifcfg, "OVS_PORT", &value);
+		v = svGetValueStr (netplan, "OVS_PORT", &value);
 	if (v) {
 		const char *old_value;
 
@@ -502,7 +504,7 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "GATEWAY_PING_TIMEOUT", &value);
+	v = svGetValueStr (netplan, "GATEWAY_PING_TIMEOUT", &value);
 	if (v) {
 		gint64 tmp;
 
@@ -517,7 +519,7 @@ make_connection_setting (const char *file,
 			PARSE_WARNING ("invalid GATEWAY_PING_TIMEOUT time");
 	}
 
-	switch (svGetValueBoolean (ifcfg, "CONNECTION_METERED", -1)) {
+	switch (svGetValueBoolean (netplan, "CONNECTION_METERED", -1)) {
 	case TRUE:
 		g_object_set (s_con, NM_SETTING_CONNECTION_METERED, NM_METERED_YES, NULL);
 		break;
@@ -526,11 +528,11 @@ make_connection_setting (const char *file,
 		break;
 	}
 
-	vint64 = svGetValueInt64 (ifcfg, "AUTH_RETRIES", 10, -1, G_MAXINT32, -1);
+	vint64 = svGetValueInt64 (netplan, "AUTH_RETRIES", 10, -1, G_MAXINT32, -1);
 	g_object_set (s_con, NM_SETTING_CONNECTION_AUTH_RETRIES, (int) vint64, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DEVTIMEOUT", &value);
+	v = svGetValueStr (netplan, "DEVTIMEOUT", &value);
 	if (v) {
 		vint64 = _nm_utils_ascii_str_to_int64 (v, 10, 0, ((gint64) G_MAXINT32) / 1000, -1);
 		if (vint64 != -1)
@@ -561,14 +563,14 @@ make_connection_setting (const char *file,
 	}
 
 	i_val = NM_SETTING_CONNECTION_MDNS_DEFAULT;
-	if (!svGetValueEnum (ifcfg, "MDNS",
+	if (!svGetValueEnum (netplan, "MDNS",
 	                     nm_setting_connection_mdns_get_type (),
 	                     &i_val, NULL))
 		PARSE_WARNING ("invalid MDNS setting");
 	g_object_set (s_con, NM_SETTING_CONNECTION_MDNS, i_val, NULL);
 
 	i_val = NM_SETTING_CONNECTION_LLMNR_DEFAULT;
-	if (!svGetValueEnum (ifcfg, "LLMNR",
+	if (!svGetValueEnum (netplan, "LLMNR",
 	                     nm_setting_connection_llmnr_get_type (),
 	                     &i_val, NULL))
 		PARSE_WARNING ("invalid LLMNR setting");
@@ -578,7 +580,7 @@ make_connection_setting (const char *file,
 }
 
 static gboolean
-read_ip4_address (shvarFile *ifcfg,
+read_ip4_address (shvarFile *netplan,
                   const char *tag,
                   gboolean *out_has_key,
                   guint32 *out_addr,
@@ -588,11 +590,11 @@ read_ip4_address (shvarFile *ifcfg,
 	const char *value;
 	in_addr_t a;
 
-	nm_assert (ifcfg);
+	nm_assert (netplan);
 	nm_assert (tag);
 	nm_assert (!error || !*error);
 
-	value = svGetValueStr (ifcfg, tag, &value_to_free);
+	value = svGetValueStr (netplan, tag, &value_to_free);
 	if (!value) {
 		NM_SET_OUT (out_has_key, FALSE);
 		NM_SET_OUT (out_addr, 0);
@@ -611,7 +613,7 @@ read_ip4_address (shvarFile *ifcfg,
 }
 
 static gboolean
-is_any_ip4_address_defined (shvarFile *ifcfg, int *idx)
+is_any_ip4_address_defined (shvarFile *netplan, int *idx)
 {
 	int i, ignore, *ret_idx;
 
@@ -621,17 +623,17 @@ is_any_ip4_address_defined (shvarFile *ifcfg, int *idx)
 		gs_free char *value = NULL;
 		char tag[256];
 
-		if (svGetValueStr (ifcfg, numbered_tag (tag, "IPADDR", i), &value)) {
+		if (svGetValueStr (netplan, numbered_tag (tag, "IPADDR", i), &value)) {
 			*ret_idx = i;
 			return TRUE;
 		}
 
-		if (svGetValueStr (ifcfg, numbered_tag (tag, "PREFIX", i), &value)) {
+		if (svGetValueStr (netplan, numbered_tag (tag, "PREFIX", i), &value)) {
 			*ret_idx = i;
 			return TRUE;
 		}
 
-		if (svGetValueStr (ifcfg, numbered_tag (tag, "NETMASK", i), &value)) {
+		if (svGetValueStr (netplan, numbered_tag (tag, "NETMASK", i), &value)) {
 			*ret_idx = i;
 			return TRUE;
 		}
@@ -641,7 +643,7 @@ is_any_ip4_address_defined (shvarFile *ifcfg, int *idx)
 
 /* Returns TRUE on missing address or valid address */
 static gboolean
-read_full_ip4_address (shvarFile *ifcfg,
+read_full_ip4_address (shvarFile *netplan,
                        gint32 which,
                        NMIPAddress *base_addr,
                        NMIPAddress **out_address,
@@ -659,13 +661,13 @@ read_full_ip4_address (shvarFile *ifcfg,
 	char inet_buf[NM_UTILS_INET_ADDRSTRLEN];
 
 	g_return_val_if_fail (which >= -1, FALSE);
-	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (netplan != NULL, FALSE);
 	g_return_val_if_fail (out_address != NULL, FALSE);
 	g_return_val_if_fail (*out_address == NULL, FALSE);
 	g_return_val_if_fail (!error || !*error, FALSE);
 
 	/* IP address */
-	if (!read_ip4_address (ifcfg,
+	if (!read_ip4_address (netplan,
 	                       numbered_tag (tag, "IPADDR", which),
 	                       &has_key, &ipaddr, error))
 		return FALSE;
@@ -677,7 +679,7 @@ read_full_ip4_address (shvarFile *ifcfg,
 
 	/* Gateway */
 	if (out_gateway && !*out_gateway) {
-		if (!read_ip4_address (ifcfg,
+		if (!read_ip4_address (netplan,
 		                       numbered_tag (tag, "GATEWAY", which),
 		                       &has_key, &a, error))
 			return FALSE;
@@ -687,7 +689,7 @@ read_full_ip4_address (shvarFile *ifcfg,
 
 	/* Prefix */
 	numbered_tag (prefix_tag, "PREFIX", which);
-	v = svGetValueStr (ifcfg, prefix_tag, &value);
+	v = svGetValueStr (netplan, prefix_tag, &value);
 	if (v) {
 		prefix = _nm_utils_ascii_str_to_int64 (v, 10, 0, 32, -1);
 		if (prefix < 0) {
@@ -697,7 +699,7 @@ read_full_ip4_address (shvarFile *ifcfg,
 		}
 	} else {
 		/* Fall back to NETMASK if no PREFIX was specified */
-		if (!read_ip4_address (ifcfg,
+		if (!read_ip4_address (netplan,
 		                       numbered_tag (tag, "NETMASK", which),
 		                       &has_key, &a, error))
 			return FALSE;
@@ -1177,7 +1179,7 @@ next:
 
 /* Returns TRUE on missing route or valid route */
 static gboolean
-read_one_ip4_route (shvarFile *ifcfg,
+read_one_ip4_route (shvarFile *netplan,
                     guint32 which,
                     NMIPRoute **out_route,
                     GError **error)
@@ -1193,12 +1195,12 @@ read_one_ip4_route (shvarFile *ifcfg,
 	gint64 prefix, metric;
 	char inet_buf[NM_UTILS_INET_ADDRSTRLEN];
 
-	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (netplan != NULL, FALSE);
 	g_return_val_if_fail (out_route && !*out_route, FALSE);
 	g_return_val_if_fail (!error || !*error, FALSE);
 
 	/* Destination */
-	if (!read_ip4_address (ifcfg,
+	if (!read_ip4_address (netplan,
 	                       numbered_tag (tag, "ADDRESS", which),
 	                       &has_key, &dest, error))
 		return FALSE;
@@ -1209,14 +1211,14 @@ read_one_ip4_route (shvarFile *ifcfg,
 	}
 
 	/* Next hop */
-	if (!read_ip4_address (ifcfg,
+	if (!read_ip4_address (netplan,
 	                       numbered_tag (tag, "GATEWAY", which),
 	                       NULL, &next_hop, error))
 		return FALSE;
 	/* We don't make distinction between missing GATEWAY IP and 0.0.0.0 */
 
 	/* Prefix */
-	if (!read_ip4_address (ifcfg,
+	if (!read_ip4_address (netplan,
 	                       numbered_tag (netmask_tag, "NETMASK", which),
 	                       &has_key, &netmask, error))
 		return FALSE;
@@ -1235,7 +1237,7 @@ read_one_ip4_route (shvarFile *ifcfg,
 
 	/* Metric */
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, numbered_tag (tag, "METRIC", which), &value);
+	v = svGetValueStr (netplan, numbered_tag (tag, "METRIC", which), &value);
 	if (v) {
 		metric = _nm_utils_ascii_str_to_int64 (v, 10, 0, G_MAXUINT32, -1);
 		if (metric < 0) {
@@ -1252,7 +1254,7 @@ read_one_ip4_route (shvarFile *ifcfg,
 
 	/* Options */
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, numbered_tag (tag, "OPTIONS", which), &value);
+	v = svGetValueStr (netplan, numbered_tag (tag, "OPTIONS", which), &value);
 	if (v) {
 		if (parse_route_line (v, AF_INET, *out_route, NULL, error) < 0) {
 			g_clear_pointer (out_route, nm_ip_route_unref);
@@ -1342,7 +1344,7 @@ parse_dns_options (NMSettingIPConfig *ip_config, const char *value)
 }
 
 static gboolean
-parse_full_ip6_address (shvarFile *ifcfg,
+parse_full_ip6_address (shvarFile *netplan,
                         const char *addr_str,
                         int i,
                         NMIPAddress **out_address,
@@ -1378,7 +1380,7 @@ parse_full_ip6_address (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_user_setting (shvarFile *ifcfg)
+make_user_setting (shvarFile *netplan)
 {
 	gboolean has_user_data = FALSE;
 	gs_unref_object NMSettingUser *s_user = NULL;
@@ -1387,7 +1389,7 @@ make_user_setting (shvarFile *ifcfg)
 	const char *key;
 	nm_auto_free_gstring GString *str = NULL;
 
-	keys = svGetKeys (ifcfg, SV_KEY_TYPE_USER);
+	keys = svGetKeys (netplan, SV_KEY_TYPE_USER);
 	if (!keys)
 		return NULL;
 
@@ -1396,7 +1398,7 @@ make_user_setting (shvarFile *ifcfg)
 		const char *value;
 		gs_free char *value_to_free = NULL;
 
-		value = svGetValue (ifcfg, key, &value_to_free);
+		value = svGetValue (netplan, key, &value_to_free);
 
 		if (!value)
 			continue;
@@ -1406,7 +1408,7 @@ make_user_setting (shvarFile *ifcfg)
 		else
 			g_string_set_size (str, 0);
 
-		if (!nms_ifcfg_rh_utils_user_key_decode (key + NM_STRLEN ("NM_USER_"), str))
+		if (!nms_netplan_utils_user_key_decode (key + NM_STRLEN ("NM_USER_"), str))
 			continue;
 
 		if (!s_user)
@@ -1423,7 +1425,7 @@ make_user_setting (shvarFile *ifcfg)
 }
 
 static NMSetting *
-make_match_setting (shvarFile *ifcfg)
+make_match_setting (shvarFile *netplan)
 {
 	NMSettingMatch *s_match = NULL;
 	gs_free const char **strv = NULL;
@@ -1431,7 +1433,7 @@ make_match_setting (shvarFile *ifcfg)
 	const char *v;
 	gsize i;
 
-	v = svGetValueStr (ifcfg, "MATCH_INTERFACE_NAME", &value);
+	v = svGetValueStr (netplan, "MATCH_INTERFACE_NAME", &value);
 	if (!v)
 		return NULL;
 
@@ -1448,14 +1450,14 @@ make_match_setting (shvarFile *ifcfg)
 }
 
 static NMSetting *
-make_proxy_setting (shvarFile *ifcfg)
+make_proxy_setting (shvarFile *netplan)
 {
 	NMSettingProxy *s_proxy = NULL;
 	gs_free char *value = NULL;
 	const char *v;
 	NMSettingProxyMethod method;
 
-	v = svGetValueStr (ifcfg, "PROXY_METHOD", &value);
+	v = svGetValueStr (netplan, "PROXY_METHOD", &value);
 	if (!v)
 		return NULL;
 
@@ -1473,12 +1475,12 @@ make_proxy_setting (shvarFile *ifcfg)
 		              NULL);
 
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "PAC_URL", &value);
+		v = svGetValueStr (netplan, "PAC_URL", &value);
 		if (v)
 			g_object_set (s_proxy, NM_SETTING_PROXY_PAC_URL, v, NULL);
 
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "PAC_SCRIPT", &value);
+		v = svGetValueStr (netplan, "PAC_SCRIPT", &value);
 		if (v)
 			g_object_set (s_proxy, NM_SETTING_PROXY_PAC_SCRIPT, v, NULL);
 
@@ -1490,15 +1492,15 @@ make_proxy_setting (shvarFile *ifcfg)
 		break;
 	}
 
-	if (svGetValueBoolean (ifcfg, "BROWSER_ONLY", FALSE))
+	if (svGetValueBoolean (netplan, "BROWSER_ONLY", FALSE))
 		g_object_set (s_proxy, NM_SETTING_PROXY_BROWSER_ONLY, TRUE, NULL);
 
 	return NM_SETTING (s_proxy);
 }
 
 static NMSetting *
-make_ip4_setting (shvarFile *ifcfg,
-                  shvarFile *network_ifcfg,
+make_ip4_setting (shvarFile *netplan,
+                  shvarFile *network_netplan,
                   gboolean routes_read,
                   gboolean *out_has_defroute,
                   GError **error)
@@ -1514,7 +1516,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	int i;
 	guint32 a;
 	gboolean has_key;
-	shvarFile *route_ifcfg;
+	shvarFile *route_netplan;
 	gboolean never_default;
 	gint64 timeout;
 	int priority;
@@ -1530,7 +1532,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	 * specified is DEFROUTE=yes which means that this connection can be used
 	 * as a default route
 	 */
-	i = svGetValueBoolean (ifcfg, "DEFROUTE", -1);
+	i = svGetValueBoolean (netplan, "DEFROUTE", -1);
 	if (i == -1)
 		never_default = FALSE;
 	else {
@@ -1539,14 +1541,14 @@ make_ip4_setting (shvarFile *ifcfg,
 	}
 
 	/* Then check if GATEWAYDEV; it's global and overrides DEFROUTE */
-	if (network_ifcfg) {
+	if (network_netplan) {
 		gs_free char *gatewaydev_value = NULL;
 		const char *gatewaydev;
 
-		/* Get the connection ifcfg device name and the global gateway device */
-		v = svGetValueStr (ifcfg, "DEVICE", &value);
-		gatewaydev = svGetValueStr (network_ifcfg, "GATEWAYDEV", &gatewaydev_value);
-		dns_options = svGetValue (network_ifcfg, "RES_OPTIONS", &dns_options_free);
+		/* Get the connection netplan device name and the global gateway device */
+		v = svGetValueStr (netplan, "DEVICE", &value);
+		gatewaydev = svGetValueStr (network_netplan, "GATEWAYDEV", &gatewaydev_value);
+		dns_options = svGetValue (network_netplan, "RES_OPTIONS", &dns_options_free);
 
 		/* If there was a global gateway device specified, then only connections
 		 * for that device can be the default connection.
@@ -1557,17 +1559,17 @@ make_ip4_setting (shvarFile *ifcfg,
 		nm_clear_g_free (&value);
 	}
 
-	v = svGetValueStr (ifcfg, "BOOTPROTO", &value);
+	v = svGetValueStr (netplan, "BOOTPROTO", &value);
 
 	if (!v || !*v || !g_ascii_strcasecmp (v, "none")) {
-		if (is_any_ip4_address_defined (ifcfg, NULL))
+		if (is_any_ip4_address_defined (netplan, NULL))
 			method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
 		else
 			method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
 	} else if (!g_ascii_strcasecmp (v, "bootp") || !g_ascii_strcasecmp (v, "dhcp")) {
 		method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
 	} else if (!g_ascii_strcasecmp (v, "static")) {
-		if (is_any_ip4_address_defined (ifcfg, NULL))
+		if (is_any_ip4_address_defined (netplan, NULL))
 			method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
 		else
 			method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
@@ -1582,7 +1584,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	}
 
 	/* the route table (policy routing) is ignored if we don't handle routes. */
-	route_table = svGetValueInt64 (ifcfg, "IPV4_ROUTE_TABLE", 10,
+	route_table = svGetValueInt64 (netplan, "IPV4_ROUTE_TABLE", 10,
 	                               0, G_MAXUINT32, 0);
 	if (   route_table != 0
 	    && !routes_read) {
@@ -1592,11 +1594,11 @@ make_ip4_setting (shvarFile *ifcfg,
 
 	g_object_set (s_ip4,
 	              NM_SETTING_IP_CONFIG_METHOD, method,
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (ifcfg, "PEERDNS", TRUE),
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (ifcfg, "PEERROUTES", TRUE),
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (netplan, "PEERDNS", TRUE),
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (netplan, "PEERROUTES", TRUE),
 	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, never_default,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (ifcfg, "IPV4_FAILURE_FATAL", FALSE),
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (ifcfg, "IPV4_ROUTE_METRIC", 10,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (netplan, "IPV4_FAILURE_FATAL", FALSE),
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (netplan, "IPV4_ROUTE_METRIC", 10,
 	                                                                  -1, G_MAXUINT32, -1),
 	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, (guint) route_table,
 	              NULL);
@@ -1606,12 +1608,12 @@ make_ip4_setting (shvarFile *ifcfg,
 
 	/* Handle DHCP settings */
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DHCP_HOSTNAME", &value);
+	v = svGetValueStr (netplan, "DHCP_HOSTNAME", &value);
 	if (v)
 		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DHCP_FQDN", &value);
+	v = svGetValueStr (netplan, "DHCP_FQDN", &value);
 	if (v) {
 		g_object_set (s_ip4,
 		              NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, NULL,
@@ -1620,12 +1622,12 @@ make_ip4_setting (shvarFile *ifcfg,
 	}
 
 	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, svGetValueBoolean (ifcfg, "DHCP_SEND_HOSTNAME", TRUE),
-	              NM_SETTING_IP_CONFIG_DHCP_TIMEOUT, svGetValueInt64 (ifcfg, "IPV4_DHCP_TIMEOUT", 10, 0, G_MAXINT32, 0),
+	              NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, svGetValueBoolean (netplan, "DHCP_SEND_HOSTNAME", TRUE),
+	              NM_SETTING_IP_CONFIG_DHCP_TIMEOUT, svGetValueInt64 (netplan, "IPV4_DHCP_TIMEOUT", 10, 0, G_MAXINT32, 0),
 	              NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DHCP_CLIENT_ID", &value);
+	v = svGetValueStr (netplan, "DHCP_CLIENT_ID", &value);
 	if (v)
 		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, v, NULL);
 
@@ -1639,7 +1641,7 @@ make_ip4_setting (shvarFile *ifcfg,
 
 		/* gateway will only be set if still unset. Hence, we don't leak gateway
 		 * here by calling read_full_ip4_address() repeatedly */
-		if (!read_full_ip4_address (ifcfg, i, NULL, &addr, &gateway, error))
+		if (!read_full_ip4_address (netplan, i, NULL, &addr, &gateway, error))
 			return NULL;
 
 		if (!addr) {
@@ -1657,15 +1659,15 @@ make_ip4_setting (shvarFile *ifcfg,
 
 	/* Gateway */
 	if (!gateway) {
-		if (network_ifcfg) {
+		if (network_netplan) {
 			gboolean read_success;
 
-			read_success = read_ip4_address (network_ifcfg, "GATEWAY", &has_key, &a, error);
+			read_success = read_ip4_address (network_netplan, "GATEWAY", &has_key, &a, error);
 			if (!read_success)
 				return NULL;
 			if (has_key) {
 				if (nm_setting_ip_config_get_num_addresses (s_ip4) == 0) {
-					gs_free char *f = g_path_get_basename (svFileGetName (ifcfg));
+					gs_free char *f = g_path_get_basename (svFileGetName (netplan));
 					PARSE_WARNING ("ignoring GATEWAY (/etc/sysconfig/network) for %s "
 					               "because the connection has no static addresses", f);
 				} else
@@ -1681,7 +1683,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	/* We used to skip saving a lot of unused properties for the ipv4 shared method.
 	 * We want now to persist them but... unfortunately loading DNS or DOMAIN options
 	 * would cause a fail in the ipv4 verify() function. As we don't want any regression
-	 * in the unlikely event that someone has a working ifcfg file for an IPv4 shared ip
+	 * in the unlikely event that someone has a working netplan file for an IPv4 shared ip
 	 * connection with a crafted "DNS" entry... don't load it. So we will avoid failing
 	 * the connection) */
 	if (!nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED)) {
@@ -1693,7 +1695,7 @@ make_ip4_setting (shvarFile *ifcfg,
 
 			numbered_tag (tag, "DNS", i);
 			nm_clear_g_free (&value);
-			v = svGetValueStr (ifcfg, tag, &value);
+			v = svGetValueStr (netplan, tag, &value);
 			if (v) {
 				if (nm_utils_ipaddr_valid (AF_INET, v)) {
 					if (!nm_setting_ip_config_add_dns (s_ip4, v))
@@ -1709,7 +1711,7 @@ make_ip4_setting (shvarFile *ifcfg,
 
 		/* DNS searches */
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "DOMAIN", &value);
+		v = svGetValueStr (netplan, "DOMAIN", &value);
 		if (v) {
 			gs_free const char **searches = NULL;
 
@@ -1725,30 +1727,30 @@ make_ip4_setting (shvarFile *ifcfg,
 
 	/* DNS options */
 	nm_clear_g_free (&value);
-	parse_dns_options (s_ip4, svGetValue (ifcfg, "RES_OPTIONS", &value));
+	parse_dns_options (s_ip4, svGetValue (netplan, "RES_OPTIONS", &value));
 	parse_dns_options (s_ip4, dns_options);
 
 	/* DNS priority */
-	priority = svGetValueInt64 (ifcfg, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
+	priority = svGetValueInt64 (netplan, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
 	g_object_set (s_ip4,
 	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
 	              priority,
 	              NULL);
 
 	/* Static routes  - route-<name> file */
-	route_path = utils_get_route_path (svFileGetName (ifcfg));
+	route_path = utils_get_route_path (svFileGetName (netplan));
 
 	if (!routes_read) {
 		/* NOP */
 	} else if (utils_has_route_file_new_syntax (route_path)) {
 		/* Parse route file in new syntax */
-		route_ifcfg = utils_get_route_ifcfg (svFileGetName (ifcfg), FALSE);
-		if (route_ifcfg) {
+		route_netplan = utils_get_route_netplan (svFileGetName (netplan), FALSE);
+		if (route_netplan) {
 			for (i = 0;; i++) {
 				NMIPRoute *route = NULL;
 
-				if (!read_one_ip4_route (route_ifcfg, i, &route, error)) {
-					svCloseFile (route_ifcfg);
+				if (!read_one_ip4_route (route_netplan, i, &route, error)) {
+					svCloseFile (route_netplan);
 					return NULL;
 				}
 
@@ -1759,7 +1761,7 @@ make_ip4_setting (shvarFile *ifcfg,
 					PARSE_WARNING ("duplicate IP4 route");
 				nm_ip_route_unref (route);
 			}
-			svCloseFile (route_ifcfg);
+			svCloseFile (route_netplan);
 		}
 	} else {
 		if (!read_route_file (AF_INET, route_path, s_ip4, error))
@@ -1770,7 +1772,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	if (   !nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED)
 	    && !nm_setting_ip_config_get_num_dns_searches (s_ip4)) {
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "SEARCH", &value);
+		v = svGetValueStr (netplan, "SEARCH", &value);
 		if (v) {
 			gs_free const char **searches = NULL;
 
@@ -1784,9 +1786,9 @@ make_ip4_setting (shvarFile *ifcfg,
 		}
 	}
 
-	timeout = svGetValueInt64 (ifcfg, "ACD_TIMEOUT", 10, -1, NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX, -2);
+	timeout = svGetValueInt64 (netplan, "ACD_TIMEOUT", 10, -1, NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX, -2);
 	if (timeout == -2) {
-		timeout = svGetValueInt64 (ifcfg, "ARPING_WAIT", 10, -1,
+		timeout = svGetValueInt64 (netplan, "ARPING_WAIT", 10, -1,
 		                           NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX / 1000, -1);
 		if (timeout > 0)
 			timeout *= 1000;
@@ -1830,13 +1832,13 @@ read_aliases (NMSettingIPConfig *s_ip4, gboolean read_defroute, const char *file
 			const char *device;
 			const char *p;
 
-			if (!utils_is_ifcfg_alias_file (item, base))
+			if (!utils_is_netplan_alias_file (item, base))
 				continue;
 
 			full_path = g_build_filename (dirname, item, NULL);
 
 			p = strchr (item, ':');
-			g_assert (p != NULL); /* we know this is true from utils_is_ifcfg_alias_file() */
+			g_assert (p != NULL); /* we know this is true from utils_is_netplan_alias_file() */
 			for (p++; *p; p++) {
 				if (!g_ascii_isalnum (*p) && *p != '_')
 					break;
@@ -1858,8 +1860,8 @@ read_aliases (NMSettingIPConfig *s_ip4, gboolean read_defroute, const char *file
 				PARSE_WARNING ("alias file '%s' has no DEVICE", full_path);
 				continue;
 			}
-			/* We know that item starts with IFCFG_TAG from utils_is_ifcfg_alias_file() */
-			if (strcmp (device, item + strlen (IFCFG_TAG)) != 0) {
+			/* We know that item starts with NETPLAN_TAG from utils_is_netplan_alias_file() */
+			if (strcmp (device, item + strlen (NETPLAN_TAG)) != 0) {
 				PARSE_WARNING ("alias file '%s' has invalid DEVICE (%s) for filename",
 				               full_path, device);
 				continue;
@@ -1906,8 +1908,8 @@ read_aliases (NMSettingIPConfig *s_ip4, gboolean read_defroute, const char *file
 }
 
 static NMSetting *
-make_ip6_setting (shvarFile *ifcfg,
-                  shvarFile *network_ifcfg,
+make_ip6_setting (shvarFile *netplan,
+                  shvarFile *network_netplan,
                   gboolean routes_read,
                   GError **error)
 {
@@ -1940,23 +1942,23 @@ make_ip6_setting (shvarFile *ifcfg,
 	 * specified is IPV6_DEFROUTE=yes which means that this connection can be used
 	 * as a default route
 	 */
-	never_default = !svGetValueBoolean (ifcfg, "IPV6_DEFROUTE", TRUE);
+	never_default = !svGetValueBoolean (netplan, "IPV6_DEFROUTE", TRUE);
 
 	/* Then check if IPV6_DEFAULTGW or IPV6_DEFAULTDEV is specified;
 	 * they are global and override IPV6_DEFROUTE
 	 * When both are set, the device specified in IPV6_DEFAULTGW takes preference.
 	 */
-	if (network_ifcfg) {
+	if (network_netplan) {
 		const char *ipv6_defaultgw, *ipv6_defaultdev;
 		gs_free char *ipv6_defaultgw_to_free = NULL;
 		gs_free char *ipv6_defaultdev_to_free = NULL;
 		const char *default_dev = NULL;
 
-		/* Get the connection ifcfg device name and the global default route device */
+		/* Get the connection netplan device name and the global default route device */
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "DEVICE", &value);
-		ipv6_defaultgw = svGetValueStr (network_ifcfg, "IPV6_DEFAULTGW", &ipv6_defaultgw_to_free);
-		ipv6_defaultdev = svGetValueStr (network_ifcfg, "IPV6_DEFAULTDEV", &ipv6_defaultdev_to_free);
+		v = svGetValueStr (netplan, "DEVICE", &value);
+		ipv6_defaultgw = svGetValueStr (network_netplan, "IPV6_DEFAULTGW", &ipv6_defaultgw_to_free);
+		ipv6_defaultdev = svGetValueStr (network_netplan, "IPV6_DEFAULTDEV", &ipv6_defaultdev_to_free);
 
 		if (ipv6_defaultgw) {
 			default_dev = strchr (ipv6_defaultgw, '%');
@@ -1975,13 +1977,13 @@ make_ip6_setting (shvarFile *ifcfg,
 
 	/* Find out method property */
 	/* Is IPV6 enabled? Set method to "ignored", when not enabled */
-	disabled = svGetValueBoolean(ifcfg, "IPV6_DISABLED", FALSE);
+	disabled = svGetValueBoolean(netplan, "IPV6_DISABLED", FALSE);
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IPV6INIT", &value);
-	ipv6init = svGetValueBoolean (ifcfg, "IPV6INIT", FALSE);
+	v = svGetValueStr (netplan, "IPV6INIT", &value);
+	ipv6init = svGetValueBoolean (netplan, "IPV6INIT", FALSE);
 	if (!v) {
-		if (network_ifcfg)
-			ipv6init = svGetValueBoolean (network_ifcfg, "IPV6INIT", FALSE);
+		if (network_netplan)
+			ipv6init = svGetValueBoolean (network_netplan, "IPV6INIT", FALSE);
 	}
 
 	if (disabled)
@@ -1989,10 +1991,10 @@ make_ip6_setting (shvarFile *ifcfg,
 	else if (!ipv6init)
 		method = NM_SETTING_IP6_CONFIG_METHOD_IGNORE;
 	else {
-		ipv6forwarding = svGetValueBoolean (ifcfg, "IPV6FORWARDING", FALSE);
+		ipv6forwarding = svGetValueBoolean (netplan, "IPV6FORWARDING", FALSE);
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "IPV6_AUTOCONF", &value);
-		dhcp6 = svGetValueBoolean (ifcfg, "DHCPV6C", FALSE);
+		v = svGetValueStr (netplan, "IPV6_AUTOCONF", &value);
+		dhcp6 = svGetValueBoolean (netplan, "DHCPV6C", FALSE);
 
 		if (!g_strcmp0 (v, "shared"))
 			method = NM_SETTING_IP6_CONFIG_METHOD_SHARED;
@@ -2003,10 +2005,10 @@ make_ip6_setting (shvarFile *ifcfg,
 		else {
 			/* IPV6_AUTOCONF=no and no IPv6 address -> method 'link-local' */
 			nm_clear_g_free (&value);
-			v = svGetValueStr (ifcfg, "IPV6ADDR", &value);
+			v = svGetValueStr (netplan, "IPV6ADDR", &value);
 			if (!v) {
 				nm_clear_g_free (&value);
-				v = svGetValueStr (ifcfg, "IPV6ADDR_SECONDARIES", &value);
+				v = svGetValueStr (netplan, "IPV6ADDR_SECONDARIES", &value);
 			}
 
 			if (!v)
@@ -2017,14 +2019,14 @@ make_ip6_setting (shvarFile *ifcfg,
 
 	/* Read IPv6 Privacy Extensions configuration */
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IPV6_PRIVACY", &value);
+	v = svGetValueStr (netplan, "IPV6_PRIVACY", &value);
 	if (v) {
 		ip6_privacy = svParseBoolean (v, FALSE);
 		if (!ip6_privacy)
 			ip6_privacy = (g_strcmp0 (v, "rfc4941") == 0) ||
 			              (g_strcmp0 (v, "rfc3041") == 0);
 	}
-	ip6_privacy_prefer_public_ip = svGetValueBoolean (ifcfg, "IPV6_PRIVACY_PREFER_PUBLIC_IP", FALSE);
+	ip6_privacy_prefer_public_ip = svGetValueBoolean (netplan, "IPV6_PRIVACY_PREFER_PUBLIC_IP", FALSE);
 	ip6_privacy_val = v ?
 	                      (ip6_privacy ?
 	                          (ip6_privacy_prefer_public_ip ? NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR : NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR) :
@@ -2032,7 +2034,7 @@ make_ip6_setting (shvarFile *ifcfg,
 	                      NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN;
 
 	/* the route table (policy routing) is ignored if we don't handle routes. */
-	route_table = svGetValueInt64 (ifcfg, "IPV6_ROUTE_TABLE", 10,
+	route_table = svGetValueInt64 (netplan, "IPV6_ROUTE_TABLE", 10,
 	                               0, G_MAXUINT32, 0);
 	if (   route_table != 0
 	    && !routes_read) {
@@ -2042,11 +2044,11 @@ make_ip6_setting (shvarFile *ifcfg,
 
 	g_object_set (s_ip6,
 	              NM_SETTING_IP_CONFIG_METHOD, method,
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (ifcfg, "IPV6_PEERDNS", TRUE),
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (ifcfg, "IPV6_PEERROUTES", TRUE),
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (netplan, "IPV6_PEERDNS", TRUE),
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (netplan, "IPV6_PEERROUTES", TRUE),
 	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, never_default,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (ifcfg, "IPV6_FAILURE_FATAL", FALSE),
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (ifcfg, "IPV6_ROUTE_METRIC", 10,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (netplan, "IPV6_FAILURE_FATAL", FALSE),
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (netplan, "IPV6_ROUTE_METRIC", 10,
 	                                                                  -1, G_MAXUINT32, -1),
 	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, (guint) route_table,
 	              NM_SETTING_IP6_CONFIG_IP6_PRIVACY, ip6_privacy_val,
@@ -2058,19 +2060,19 @@ make_ip6_setting (shvarFile *ifcfg,
 		return NM_SETTING (g_steal_pointer (&s_ip6));
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DHCPV6_DUID", &value);
+	v = svGetValueStr (netplan, "DHCPV6_DUID", &value);
 	if (v)
 		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_DHCP_DUID, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DHCPV6_HOSTNAME", &value);
+	v = svGetValueStr (netplan, "DHCPV6_HOSTNAME", &value);
 	/* Use DHCP_HOSTNAME as fallback if it is in FQDN format and ipv6.method is
-	 * auto or dhcp: this is required to support old ifcfg files
+	 * auto or dhcp: this is required to support old netplan files
 	 */
 	if (!v && (   !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
 		       || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_DHCP))) {
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "DHCP_HOSTNAME", &value);
+		v = svGetValueStr (netplan, "DHCP_HOSTNAME", &value);
 		if (v && !strchr (v, '.'))
 			v = NULL;
 	}
@@ -2078,15 +2080,15 @@ make_ip6_setting (shvarFile *ifcfg,
 		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, v, NULL);
 
 	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME,
-	              svGetValueBoolean (ifcfg, "DHCPV6_SEND_HOSTNAME", TRUE), NULL);
+	              svGetValueBoolean (netplan, "DHCPV6_SEND_HOSTNAME", TRUE), NULL);
 
 	/* Read static IP addresses.
 	 * Read them even for AUTO and DHCP methods - in this case the addresses are
 	 * added to the automatic ones. Note that this is not currently supported by
 	 * the legacy 'network' service (ifup-eth).
 	 */
-	ipv6addr = svGetValueStr (ifcfg, "IPV6ADDR", &ipv6addr_to_free);
-	ipv6addr_secondaries = svGetValueStr (ifcfg, "IPV6ADDR_SECONDARIES", &ipv6addr_secondaries_to_free);
+	ipv6addr = svGetValueStr (netplan, "IPV6ADDR", &ipv6addr_to_free);
+	ipv6addr_secondaries = svGetValueStr (netplan, "IPV6ADDR_SECONDARIES", &ipv6addr_secondaries_to_free);
 
 	nm_clear_g_free (&value);
 	value = g_strjoin (ipv6addr && ipv6addr_secondaries ? " " : NULL,
@@ -2098,7 +2100,7 @@ make_ip6_setting (shvarFile *ifcfg,
 	for (iter = list, i = 0; iter && *iter; iter++, i++) {
 		NMIPAddress *addr = NULL;
 
-		if (!parse_full_ip6_address (ifcfg, *iter, i, &addr, error))
+		if (!parse_full_ip6_address (netplan, *iter, i, &addr, error))
 			return NULL;
 
 		if (!nm_setting_ip_config_add_address (s_ip6, addr))
@@ -2109,12 +2111,12 @@ make_ip6_setting (shvarFile *ifcfg,
 	/* Gateway */
 	if (nm_setting_ip_config_get_num_addresses (s_ip6)) {
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, "IPV6_DEFAULTGW", &value);
+		v = svGetValueStr (netplan, "IPV6_DEFAULTGW", &value);
 		if (!v) {
-			/* If no gateway in the ifcfg, try global /etc/sysconfig/network instead */
-			if (network_ifcfg) {
+			/* If no gateway in the netplan, try global /etc/sysconfig/network instead */
+			if (network_netplan) {
 				nm_clear_g_free (&value);
-				v = svGetValueStr (network_ifcfg, "IPV6_DEFAULTGW", &value);
+				v = svGetValueStr (network_netplan, "IPV6_DEFAULTGW", &value);
 			}
 		}
 		if (v) {
@@ -2132,7 +2134,7 @@ make_ip6_setting (shvarFile *ifcfg,
 	}
 
 	i_val = NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64;
-	if (!svGetValueEnum (ifcfg, "IPV6_ADDR_GEN_MODE",
+	if (!svGetValueEnum (netplan, "IPV6_ADDR_GEN_MODE",
 	                     nm_setting_ip6_config_addr_gen_mode_get_type (),
 	                     &i_val, &local)) {
 		PARSE_WARNING ("%s", local->message);
@@ -2142,7 +2144,7 @@ make_ip6_setting (shvarFile *ifcfg,
 
 	/* IPv6 tokenized interface identifier */
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IPV6_TOKEN", &value);
+	v = svGetValueStr (netplan, "IPV6_TOKEN", &value);
 	if (v)
 		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_TOKEN, v, NULL);
 
@@ -2154,7 +2156,7 @@ make_ip6_setting (shvarFile *ifcfg,
 
 		numbered_tag (tag, "DNS", i);
 		nm_clear_g_free (&value);
-		v = svGetValueStr (ifcfg, tag, &value);
+		v = svGetValueStr (netplan, tag, &value);
 		if (!v) {
 			/* all done */
 			break;
@@ -2177,14 +2179,14 @@ make_ip6_setting (shvarFile *ifcfg,
 		gs_free char *route6_path = NULL;
 
 		/* Read static routes from route6-<interface> file */
-		route6_path = utils_get_route6_path (svFileGetName (ifcfg));
+		route6_path = utils_get_route6_path (svFileGetName (netplan));
 		if (!read_route_file (AF_INET6, route6_path, s_ip6, error))
 			return NULL;
 	}
 
 	/* DNS searches */
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IPV6_DOMAIN", &value);
+	v = svGetValueStr (netplan, "IPV6_DOMAIN", &value);
 	if (v) {
 		gs_free const char **searches = NULL;
 
@@ -2199,10 +2201,10 @@ make_ip6_setting (shvarFile *ifcfg,
 
 	/* DNS options */
 	nm_clear_g_free (&value);
-	parse_dns_options (s_ip6, svGetValue (ifcfg, "IPV6_RES_OPTIONS", &value));
+	parse_dns_options (s_ip6, svGetValue (netplan, "IPV6_RES_OPTIONS", &value));
 
 	/* DNS priority */
-	priority = svGetValueInt64 (ifcfg, "IPV6_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
+	priority = svGetValueInt64 (netplan, "IPV6_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
 	g_object_set (s_ip6,
 	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
 	              priority,
@@ -2212,7 +2214,7 @@ make_ip6_setting (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_sriov_setting (shvarFile *ifcfg)
+make_sriov_setting (shvarFile *netplan)
 {
 	gs_unref_hashtable GHashTable *keys = NULL;
 	gs_unref_ptrarray GPtrArray *vfs = NULL;
@@ -2221,16 +2223,16 @@ make_sriov_setting (shvarFile *ifcfg)
 	gint64 total_vfs;
 
 
-	total_vfs = svGetValueInt64 (ifcfg, "SRIOV_TOTAL_VFS", 10, 0, G_MAXUINT32, -1);
+	total_vfs = svGetValueInt64 (netplan, "SRIOV_TOTAL_VFS", 10, 0, G_MAXUINT32, -1);
 
-	autoprobe_drivers = svGetValueInt64 (ifcfg,
+	autoprobe_drivers = svGetValueInt64 (netplan,
 	                                     "SRIOV_AUTOPROBE_DRIVERS",
 	                                     10,
 	                                     NM_TERNARY_DEFAULT,
 	                                     NM_TERNARY_TRUE,
 	                                     -2);
 
-	keys = svGetKeys (ifcfg, SV_KEY_TYPE_SRIOV_VF);
+	keys = svGetKeys (netplan, SV_KEY_TYPE_SRIOV_VF);
 	if (keys) {
 		GHashTableIter iter;
 		const char *key;
@@ -2244,7 +2246,7 @@ make_sriov_setting (shvarFile *ifcfg)
 
 			nm_assert (g_str_has_prefix (key, "SRIOV_VF"));
 
-			value = svGetValue (ifcfg, key, &value_to_free);
+			value = svGetValue (netplan, key, &value_to_free);
 			if (!value)
 				continue;
 
@@ -2283,7 +2285,7 @@ make_sriov_setting (shvarFile *ifcfg)
 }
 
 static NMSetting *
-make_tc_setting (shvarFile *ifcfg)
+make_tc_setting (shvarFile *netplan)
 {
 	NMSettingTCConfig *s_tc = NULL;
 	char tag[256];
@@ -2297,7 +2299,7 @@ make_tc_setting (shvarFile *ifcfg)
 		const char *value = NULL;
 		GError *local = NULL;
 
-		value = svGetValueStr (ifcfg, numbered_tag (tag, "QDISC", i), &value_to_free);
+		value = svGetValueStr (netplan, numbered_tag (tag, "QDISC", i), &value_to_free);
 		if (!value)
 			break;
 
@@ -2319,7 +2321,7 @@ make_tc_setting (shvarFile *ifcfg)
 		const char *value = NULL;
 		GError *local = NULL;
 
-		value = svGetValueStr (ifcfg, numbered_tag (tag, "FILTER", i), &value_to_free);
+		value = svGetValueStr (netplan, numbered_tag (tag, "FILTER", i), &value_to_free);
 		if (!value)
 			break;
 
@@ -2368,22 +2370,22 @@ static DcbFlagsProperty dcb_flags_props[] = {
 };
 
 static NMSettingDcbFlags
-read_dcb_flags (shvarFile *ifcfg, DcbFlagsProperty *property)
+read_dcb_flags (shvarFile *netplan, DcbFlagsProperty *property)
 {
 	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
 
-	if (svGetValueBoolean (ifcfg, property->enable_key, FALSE))
+	if (svGetValueBoolean (netplan, property->enable_key, FALSE))
 		flags |= NM_SETTING_DCB_FLAG_ENABLE;
-	if (svGetValueBoolean (ifcfg, property->advertise_key, FALSE))
+	if (svGetValueBoolean (netplan, property->advertise_key, FALSE))
 		flags |= NM_SETTING_DCB_FLAG_ADVERTISE;
-	if (svGetValueBoolean (ifcfg, property->willing_key, FALSE))
+	if (svGetValueBoolean (netplan, property->willing_key, FALSE))
 		flags |= NM_SETTING_DCB_FLAG_WILLING;
 
 	return flags;
 }
 
 static gboolean
-read_dcb_app (shvarFile *ifcfg,
+read_dcb_app (shvarFile *netplan,
               NMSettingDcb *s_dcb,
               const char *app,
               DcbFlagsProperty *flags_prop,
@@ -2397,11 +2399,11 @@ read_dcb_app (shvarFile *ifcfg,
 	int priority = -1;
 	char key[255];
 
-	flags = read_dcb_flags (ifcfg, flags_prop);
+	flags = read_dcb_flags (netplan, flags_prop);
 
 	/* Priority */
 	nm_sprintf_buf (key, "DCB_APP_%s_PRIORITY", app);
-	v = svGetValueStr (ifcfg, key, &value);
+	v = svGetValueStr (netplan, key, &value);
 	if (v) {
 		priority = _nm_utils_ascii_str_to_int64 (v, 0, 0, 7, -1);
 		if (priority < 0) {
@@ -2428,7 +2430,7 @@ read_dcb_app (shvarFile *ifcfg,
 typedef void (*DcbSetBoolFunc) (NMSettingDcb *, guint, gboolean);
 
 static gboolean
-read_dcb_bool_array (shvarFile *ifcfg,
+read_dcb_bool_array (shvarFile *netplan,
                      NMSettingDcb *s_dcb,
                      NMSettingDcbFlags flags,
                      const char *prop,
@@ -2440,7 +2442,7 @@ read_dcb_bool_array (shvarFile *ifcfg,
 	const char *v;
 	guint i;
 
-	v = svGetValueStr (ifcfg, prop, &value);
+	v = svGetValueStr (netplan, prop, &value);
 	if (!v)
 		return TRUE;
 
@@ -2472,7 +2474,7 @@ read_dcb_bool_array (shvarFile *ifcfg,
 typedef void (*DcbSetUintFunc) (NMSettingDcb *, guint, guint);
 
 static gboolean
-read_dcb_uint_array (shvarFile *ifcfg,
+read_dcb_uint_array (shvarFile *netplan,
                      NMSettingDcb *s_dcb,
                      NMSettingDcbFlags flags,
                      const char *prop,
@@ -2484,7 +2486,7 @@ read_dcb_uint_array (shvarFile *ifcfg,
 	gs_free char *val = NULL;
 	guint i;
 
-	val = svGetValueStr_cp (ifcfg, prop);
+	val = svGetValueStr_cp (netplan, prop);
 	if (!val)
 		return TRUE;
 
@@ -2519,7 +2521,7 @@ read_dcb_uint_array (shvarFile *ifcfg,
 }
 
 static gboolean
-read_dcb_percent_array (shvarFile *ifcfg,
+read_dcb_percent_array (shvarFile *netplan,
                         NMSettingDcb *s_dcb,
                         NMSettingDcbFlags flags,
                         const char *prop,
@@ -2533,7 +2535,7 @@ read_dcb_percent_array (shvarFile *ifcfg,
 	const char *const *iter;
 	guint i, sum = 0;
 
-	val = svGetValueStr_cp (ifcfg, prop);
+	val = svGetValueStr_cp (netplan, prop);
 	if (!val)
 		return TRUE;
 
@@ -2575,7 +2577,7 @@ read_dcb_percent_array (shvarFile *ifcfg,
 }
 
 static gboolean
-make_dcb_setting (shvarFile *ifcfg,
+make_dcb_setting (shvarFile *netplan,
                   NMSetting **out_setting,
                   GError **error)
 {
@@ -2585,14 +2587,14 @@ make_dcb_setting (shvarFile *ifcfg,
 
 	g_return_val_if_fail (out_setting != NULL, FALSE);
 
-	dcb_on = !!svGetValueBoolean (ifcfg, "DCB", FALSE);
+	dcb_on = !!svGetValueBoolean (netplan, "DCB", FALSE);
 	if (!dcb_on)
 		return TRUE;
 
 	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
 
 	/* FCOE */
-	if (!read_dcb_app (ifcfg, s_dcb, "FCOE",
+	if (!read_dcb_app (netplan, s_dcb, "FCOE",
 	                   &dcb_flags_props[DCB_APP_FCOE_FLAGS],
 	                   NM_SETTING_DCB_APP_FCOE_PRIORITY,
 	                   error)) {
@@ -2601,7 +2603,7 @@ make_dcb_setting (shvarFile *ifcfg,
 	if (nm_setting_dcb_get_app_fcoe_flags (s_dcb) & NM_SETTING_DCB_FLAG_ENABLE) {
 		gs_free char *val = NULL;
 
-		val = svGetValueStr_cp (ifcfg, KEY_DCB_APP_FCOE_MODE);
+		val = svGetValueStr_cp (netplan, KEY_DCB_APP_FCOE_MODE);
 		if (val) {
 			if (NM_IN_STRSET (val, NM_SETTING_DCB_FCOE_MODE_FABRIC,
 			                       NM_SETTING_DCB_FCOE_MODE_VN2VN))
@@ -2616,7 +2618,7 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* iSCSI */
-	if (!read_dcb_app (ifcfg, s_dcb, "ISCSI",
+	if (!read_dcb_app (netplan, s_dcb, "ISCSI",
 	                   &dcb_flags_props[DCB_APP_ISCSI_FLAGS],
 	                   NM_SETTING_DCB_APP_ISCSI_PRIORITY,
 	                   error)) {
@@ -2624,7 +2626,7 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* FIP */
-	if (!read_dcb_app (ifcfg, s_dcb, "FIP",
+	if (!read_dcb_app (netplan, s_dcb, "FIP",
 	                   &dcb_flags_props[DCB_APP_FIP_FLAGS],
 	                   NM_SETTING_DCB_APP_FIP_PRIORITY,
 	                   error)) {
@@ -2632,10 +2634,10 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* Priority Flow Control */
-	flags = read_dcb_flags (ifcfg, &dcb_flags_props[DCB_PFC_FLAGS]);
+	flags = read_dcb_flags (netplan, &dcb_flags_props[DCB_PFC_FLAGS]);
 	g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS, flags, NULL);
 
-	if (!read_dcb_bool_array (ifcfg,
+	if (!read_dcb_bool_array (netplan,
 	                          s_dcb,
 	                          flags,
 	                          KEY_DCB_PFC_UP,
@@ -2646,10 +2648,10 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* Priority Groups */
-	flags = read_dcb_flags (ifcfg, &dcb_flags_props[DCB_PG_FLAGS]);
+	flags = read_dcb_flags (netplan, &dcb_flags_props[DCB_PG_FLAGS]);
 	g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_PRIORITY_GROUP_FLAGS, flags, NULL);
 
-	if (!read_dcb_uint_array (ifcfg,
+	if (!read_dcb_uint_array (netplan,
 	                          s_dcb,
 	                          flags,
 	                          KEY_DCB_PG_ID,
@@ -2661,7 +2663,7 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* Group bandwidth */
-	if (!read_dcb_percent_array (ifcfg,
+	if (!read_dcb_percent_array (netplan,
 	                             s_dcb,
 	                             flags,
 	                             KEY_DCB_PG_PCT,
@@ -2673,7 +2675,7 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* Priority bandwidth */
-	if (!read_dcb_percent_array (ifcfg,
+	if (!read_dcb_percent_array (netplan,
 	                             s_dcb,
 	                             flags,
 	                             KEY_DCB_PG_UPPCT,
@@ -2685,7 +2687,7 @@ make_dcb_setting (shvarFile *ifcfg,
 	}
 
 	/* Strict Bandwidth */
-	if (!read_dcb_bool_array (ifcfg,
+	if (!read_dcb_bool_array (netplan,
 	                          s_dcb,
 	                          flags,
 	                          KEY_DCB_PG_STRICT,
@@ -2695,7 +2697,7 @@ make_dcb_setting (shvarFile *ifcfg,
 		return FALSE;
 	}
 
-	if (!read_dcb_uint_array (ifcfg,
+	if (!read_dcb_uint_array (netplan,
 	                          s_dcb,
 	                          flags,
 	                          KEY_DCB_PG_UP2TC,
@@ -2711,7 +2713,7 @@ make_dcb_setting (shvarFile *ifcfg,
 }
 
 static gboolean
-add_one_wep_key (shvarFile *ifcfg,
+add_one_wep_key (shvarFile *netplan,
                  const char *shvar_key,
                  guint8 key_idx,
                  gboolean passphrase,
@@ -2722,12 +2724,12 @@ add_one_wep_key (shvarFile *ifcfg,
 	const char *value;
 	const char *key = NULL;
 
-	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (netplan != NULL, FALSE);
 	g_return_val_if_fail (shvar_key != NULL, FALSE);
 	g_return_val_if_fail (key_idx <= 3, FALSE);
 	g_return_val_if_fail (s_wsec != NULL, FALSE);
 
-	value = svGetValueStr (ifcfg, shvar_key, &value_free);
+	value = svGetValueStr (netplan, shvar_key, &value_free);
 	if (!value)
 		return TRUE;
 
@@ -2774,33 +2776,33 @@ add_one_wep_key (shvarFile *ifcfg,
 }
 
 static gboolean
-read_wep_keys (shvarFile *ifcfg,
+read_wep_keys (shvarFile *netplan,
                NMWepKeyType key_type,
                guint8 def_idx,
                NMSettingWirelessSecurity *s_wsec,
                GError **error)
 {
 	if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
-		if (!add_one_wep_key (ifcfg, "KEY1", 0, FALSE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY1", 0, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY2", 1, FALSE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY2", 1, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY3", 2, FALSE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY3", 2, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY4", 3, FALSE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY4", 3, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY", def_idx, FALSE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY", def_idx, FALSE, s_wsec, error))
 			return FALSE;
 	}
 
 	if (key_type != NM_WEP_KEY_TYPE_KEY) {
-		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
 			return FALSE;
 	}
 
@@ -2808,21 +2810,21 @@ read_wep_keys (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_wep_setting (shvarFile *ifcfg,
+make_wep_setting (shvarFile *netplan,
                   const char *file,
                   GError **error)
 {
 	gs_unref_object NMSettingWirelessSecurity *s_wsec = NULL;
 	gs_free char *value = NULL;
-	shvarFile *keys_ifcfg = NULL;
-	int default_key_idx = 0;
-	gboolean has_default_key = FALSE;
-	NMSettingSecretFlags key_flags;
+  	shvarFile *keys_netplan = NULL;
+	int default_key_idx   = 0;
+	gboolean has_defaul  t_key = FALSE;
+	NMSettingSecretFlag  s key_flags;
 
 	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
 
-	value = svGetValueStr_cp (ifcfg, "DEFAULTKEY");
+	value = svGetValueStr_cp (netplan, "DEFAULTKEY");
 	if (value) {
 		default_key_idx = _nm_utils_ascii_str_to_int64 (value, 0, 1, 4, 0);
 		if (default_key_idx == 0) {
@@ -2837,16 +2839,16 @@ make_wep_setting (shvarFile *ifcfg,
 	}
 
 	/* Read WEP key flags */
-	key_flags = _secret_read_ifcfg_flags (ifcfg, "WEP_KEY_FLAGS");
+	key_flags = _secret_read_netplan_flags (netplan, "WEP_KEY_FLAGS");
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, key_flags, NULL);
 
-	/* Read keys in the ifcfg file if they are system-owned */
+	/* Read keys in the netplan file if they are system-owned */
 	if (key_flags == NM_SETTING_SECRET_FLAG_NONE) {
 		NMWepKeyType key_type;
 		const char *v;
 		gs_free char *to_free = NULL;
 
-		v = svGetValueStr (ifcfg, "KEY_TYPE", &to_free);
+		v = svGetValueStr (netplan, "KEY_TYPE", &to_free);
 		if (!v)
 			key_type = NM_WEP_KEY_TYPE_UNKNOWN;
 		else if (nm_streq (v, "key"))
@@ -2859,26 +2861,26 @@ make_wep_setting (shvarFile *ifcfg,
 			return FALSE;
 		}
 
-		if (!read_wep_keys (ifcfg, key_type, default_key_idx, s_wsec, error))
+		if (!read_wep_keys (netplan, key_type, default_key_idx, s_wsec, error))
 			return NULL;
 
 		/* Try to get keys from the "shadow" key file */
-		keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
-		if (keys_ifcfg) {
-			if (!read_wep_keys (keys_ifcfg, key_type, default_key_idx, s_wsec, error)) {
-				svCloseFile (keys_ifcfg);
-				return NULL;
-			}
-			svCloseFile (keys_ifcfg);
-			g_assert (error == NULL || *error == NULL);
-		}
-
+		ke  ys_netplan = utils_get_keys_netplan (file, FALSE);
+  		if (keys_netpl  an) {
+			i  f (!read_wep_k    eys (keys_netplan, key_type, default_key_idx, s_wsec, error)) {
+  				svCloseFile (k      eys_netplan);
+				return   NUL    L;
+		    	}
+  			svCloseFile (ke  ys_netplan);
+			g_assert (error =  = NULL || *error == NULL);
+	  	}
+  
 		g_object_set (G_OBJECT (s_wsec),
 		              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, key_type,
 		              NULL);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "SECURITYMODE");
+	value = svGetValueStr_cp (netplan, "SECURITYMODE");
 	if (value) {
 		gs_free char *lcase = NULL;
 
@@ -2924,7 +2926,7 @@ make_wep_setting (shvarFile *ifcfg,
 }
 
 static gboolean
-fill_wpa_ciphers (shvarFile *ifcfg,
+fill_wpa_ciphers (shvarFile *netplan,
                   NMSettingWirelessSecurity *wsec,
                   gboolean group,
                   gboolean adhoc)
@@ -2935,7 +2937,7 @@ fill_wpa_ciphers (shvarFile *ifcfg,
 	const char *const *iter;
 	int i = 0;
 
-	p = svGetValueStr (ifcfg, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
+	p = svGetValueStr (netplan, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
 	if (!p)
 		return TRUE;
 
@@ -2968,15 +2970,15 @@ fill_wpa_ciphers (shvarFile *ifcfg,
 #define WPA_PMK_LEN 32
 
 static char *
-parse_wpa_psk (shvarFile *ifcfg,
+parse_wpa_psk (shvarFile *netplan,
                const char *file,
                GBytes *ssid,
                GError **error)
 {
-	shvarFile *keys_ifcfg;
+  	shvarFile *keys_netplan;
 	gs_free char *psk = NULL;
 	size_t plen;
-
+  
 	/* Passphrase must be between 10 and 66 characters in length because WPA
 	 * hex keys are exactly 64 characters (no quoting), and WPA passphrases
 	 * are between 8 and 63 characters (inclusive), plus optional quoting if
@@ -2984,15 +2986,15 @@ parse_wpa_psk (shvarFile *ifcfg,
 	 */
 
 	/* Try to get keys from the "shadow" key file */
-	keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
-	if (keys_ifcfg) {
-		psk = svGetValueStr_cp (keys_ifcfg, "WPA_PSK");
-		svCloseFile (keys_ifcfg);
-	}
-
-	/* Fall back to the original ifcfg */
+	key  s_netplan = utils_get_keys_netplan (file, FALSE);
+  	if (keys_netplan) {
+		psk = svGetValue  (keys_netplan, "WPA_PSK");
+  		svCloseFile (keys_netplan);
+      	}
+    
+	/* Fall back to the   original netplan */
 	if (!psk)
-		psk = svGetValueStr_cp (ifcfg, "WPA_PSK");
+		psk = svGetValueStr_cp (netplan, "WPA_PSK");
 
 	if (!psk)
 		return NULL;
@@ -3020,8 +3022,8 @@ parse_wpa_psk (shvarFile *ifcfg,
 
 static gboolean
 eap_simple_reader (const char *eap_method,
-                   shvarFile *ifcfg,
-                   shvarFile *keys_ifcfg,
+                   shvarFile *netplan,
+                   shvarFile *keys_netplan,
                    NMSetting8021x *s_8021x,
                    gboolean phase2,
                    GError **error)
@@ -3033,19 +3035,19 @@ eap_simple_reader (const char *eap_method,
 
 	g_object_set (s_8021x,
 	              NM_SETTING_802_1X_IDENTITY,
-	              svGetValueStr (ifcfg, "IEEE_8021X_IDENTITY", &identity_free),
+	              svGetValueStr (netplan, "IEEE_8021X_IDENTITY", &identity_free),
 	              NULL);
 
-	_secret_set_from_ifcfg (s_8021x,
-	                        ifcfg,
-	                        keys_ifcfg,
-	                        "IEEE_8021X_PASSWORD",
-	                        NM_SETTING_802_1X_PASSWORD);
-
-	_secret_read_ifcfg (ifcfg, keys_ifcfg, "IEEE_8021X_PASSWORD_RAW", &password_raw_str, &flags);
+	_secret_set_from_netplan (s_8021x,
+	                          netplan,
+	                          keys_netplan,
+	                          "IEEE_8021X_PASSWORD",
+	                          NM_SETTING_802_1X_PASSWORD);
+  
+	_secret_read_netplan (netplan, keys_netplan, "IEEE_8021X_PASSWORD_RAW", &password_raw_str, &flags);
 	if (!_secret_password_raw_to_bytes ("IEEE_8021X_PASSWORD_RAW",
-	                                    password_raw_str,
-	                                    &password_raw_bytes,
+	                                      password_raw_str,
+	                                      &password_raw_bytes,
 	                                    error))
 		return FALSE;
 
@@ -3061,8 +3063,8 @@ eap_simple_reader (const char *eap_method,
 
 static gboolean
 eap_tls_reader (const char *eap_method,
-                shvarFile *ifcfg,
-                shvarFile *keys_ifcfg,
+                shvarFile *netplan,
+                  shvarFile *keys_netplan,
                 NMSetting8021x *s_8021x,
                 gboolean phase2,
                 GError **error)
@@ -3077,53 +3079,53 @@ eap_tls_reader (const char *eap_method,
 
 	g_object_set (s_8021x,
 	              NM_SETTING_802_1X_IDENTITY,
-	              svGetValueStr (ifcfg, "IEEE_8021X_IDENTITY", &identity_free),
+	              svGetValueStr (netplan, "IEEE_8021X_IDENTITY", &identity_free),
 	              NULL);
 
 	/* CA certificate */
-	if (!_cert_set_from_ifcfg (s_8021x,
-	                           ifcfg,
-	                           phase2 ? "IEEE_8021X_INNER_CA_CERT" : "IEEE_8021X_CA_CERT",
-	                           phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT : NM_SETTING_802_1X_CA_CERT,
-	                           NULL,
-	                           error))
+	if (!_cert_set_from_netplan (s_8021x,
+	                             netplan,
+	                             phase2 ? "IEEE_8021X_INNER_CA_CERT" : "IEEE_8021X_CA_CERT",
+	                             phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT : NM_SETTING_802_1X_CA_CERT,
+	                             NULL,
+	                             error))
 		return FALSE;
-	_secret_set_from_ifcfg (s_8021x,
-	                        ifcfg,
-	                        keys_ifcfg,
-	                        phase2 ? "IEEE_8021X_INNER_CA_CERT_PASSWORD" : "IEEE_8021X_CA_CERT_PASSWORD",
-	                        phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD : NM_SETTING_802_1X_CA_CERT_PASSWORD);
-
+	_secret_set_from_netplan (s_8021x,
+	                          netplan,
+	                          keys_netplan,
+	                          phase2 ? "IEEE_8021X_INNER_CA_CERT_PASSWORD" : "IEEE_8021X_CA_CERT_PASSWORD",
+	                          phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD : NM_SETTING_802_1X_CA_CERT_PASSWORD);
+  
 	/* Private key */
-	if (!_cert_set_from_ifcfg (s_8021x,
-	                           ifcfg,
-	                           phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY" : "IEEE_8021X_PRIVATE_KEY",
-	                           phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY : NM_SETTING_802_1X_PRIVATE_KEY,
-	                           &privkey,
-	                           error))
+	if (!_cert_set_from_netplan (s_8021x,
+	                             netplan,
+	                             phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY" : "IEEE_8021X_PRIVATE_KEY",
+	                             phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY : NM_SETTING_802_1X_PRIVATE_KEY,
+	                             &privkey,
+	                             error))
 		return FALSE;
-	_secret_set_from_ifcfg (s_8021x,
-	                        ifcfg,
-	                        keys_ifcfg,
-	                        phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY_PASSWORD" : "IEEE_8021X_PRIVATE_KEY_PASSWORD",
-	                        phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD : NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD);
-
+	_secret_set_from_netplan (s_8021x,
+	                          netplan,
+	                          keys_netplan,
+	                          phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY_PASSWORD" : "IEEE_8021X_PRIVATE_KEY_PASSWORD",
+	                          phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD : NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD);
+  
 	/* Client certificate */
 	client_cert_var = phase2 ? "IEEE_8021X_INNER_CLIENT_CERT" : "IEEE_8021X_CLIENT_CERT";
 	client_cert_prop = phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT : NM_SETTING_802_1X_CLIENT_CERT;
-	if (!_cert_set_from_ifcfg (s_8021x,
-	                           ifcfg,
-	                           client_cert_var,
-	                           client_cert_prop,
-	                           &client_cert,
-	                           error))
+	if (!_cert_set_from_netplan (s_8021x,
+	                             netplan,
+	                             client_cert_var,
+	                             client_cert_prop,
+	                             &client_cert,
+	                             error))
 		return FALSE;
-	_secret_set_from_ifcfg (s_8021x,
-	                        ifcfg,
-	                        keys_ifcfg,
-	                        phase2 ? "IEEE_8021X_INNER_CLIENT_CERT_PASSWORD" : "IEEE_8021X_CLIENT_CERT_PASSWORD",
-	                        phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD : NM_SETTING_802_1X_CLIENT_CERT_PASSWORD);
-
+	_secret_set_from_netplan (s_8021x,
+	                          netplan,
+	                          keys_netplan,
+	                          phase2 ? "IEEE_8021X_INNER_CLIENT_CERT_PASSWORD" : "IEEE_8021X_CLIENT_CERT_PASSWORD",
+	                          phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD : NM_SETTING_802_1X_CLIENT_CERT_PASSWORD);
+  
 	/* In the past when the private key and client certificate
 	 * were the same PKCS #12 file we used to write only the
 	 * private key variable. Still support that even if it means
@@ -3132,7 +3134,7 @@ eap_tls_reader (const char *eap_method,
 	 */
 	if (   !client_cert
 	    && privkey
-	    && !svGetValue (ifcfg, client_cert_var, &value_to_free)) {
+	    && !svGetValue (netplan, client_cert_var, &value_to_free)) {
 		if (phase2)
 			format = nm_setting_802_1x_get_phase2_private_key_format (s_8021x);
 		else
@@ -3147,32 +3149,32 @@ eap_tls_reader (const char *eap_method,
 
 static gboolean
 eap_peap_reader (const char *eap_method,
-                 shvarFile *ifcfg,
-                 shvarFile *keys_ifcfg,
-                 NMSetting8021x *s_8021x,
-                 gboolean phase2,
-                 GError **error)
+                 shvarFile *netplan,
+                   shvarFile *keys_netplan,
+                 NMS  etting8021x *s_8021x,
+                 gbo  olean phase2,
+                 GEr  ror **error)
 {
 	gs_free char *value = NULL;
 	const char *v;
 	gs_free const char **list = NULL;
 	const char *const *iter;
 
-	if (!_cert_set_from_ifcfg (s_8021x,
-	                           ifcfg,
-	                           "IEEE_8021X_CA_CERT",
-	                           NM_SETTING_802_1X_CA_CERT,
-	                           NULL,
-	                           error))
+	if (!_cert_set_from_netplan (s_8021x,
+	                             netplan,
+	                             "IEEE_8021X_CA_CERT",
+	                             NM_SETTING_802_1X_CA_CERT,
+	                             NULL,
+	                             error))
 		return FALSE;
-	_secret_set_from_ifcfg (s_8021x,
-	                        ifcfg,
-	                        keys_ifcfg,
-	                        "IEEE_8021X_CA_CERT_PASSWORD",
-	                        NM_SETTING_802_1X_CA_CERT_PASSWORD);
-
+	_secret_set_from_netplan (s_8021x,
+	                          netplan,
+	                          keys_netplan,
+	                          "IEEE_8021X_CA_CERT_PASSWORD",
+	                          NM_SETTING_802_1X_CA_CERT_PASSWORD);
+  
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_PEAP_VERSION", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_PEAP_VERSION", &value);
 	if (v) {
 		if (!strcmp (v, "0"))
 			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPVER, "0", NULL);
@@ -3186,16 +3188,16 @@ eap_peap_reader (const char *eap_method,
 		}
 	}
 
-	if (svGetValueBoolean (ifcfg, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", FALSE))
+	if (svGetValueBoolean (netplan, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", FALSE))
 		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1", NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_ANON_IDENTITY", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_ANON_IDENTITY", &value);
 	if (v)
 		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_INNER_AUTH_METHODS", &value);
 	if (!v) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
@@ -3209,13 +3211,13 @@ eap_peap_reader (const char *eap_method,
 		if (NM_IN_STRSET (*iter, "MSCHAPV2",
 		                         "MD5",
 		                         "GTC")) {
-			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
-				return FALSE;
-		} else if (nm_streq (*iter, "TLS")) {
-			if (!eap_tls_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
-				return FALSE;
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
+				return F  ALSE;
+		} else if (nm_stre  q (*iter, "TLS")) {
+			i  f (!eap_tls_re  ader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
+				return F  ALSE;
+		} else   {
+			g_set_error (erro  r, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
 			             *iter);
 			return FALSE;
@@ -3240,11 +3242,11 @@ eap_peap_reader (const char *eap_method,
 
 static gboolean
 eap_ttls_reader (const char *eap_method,
-                 shvarFile *ifcfg,
-                 shvarFile *keys_ifcfg,
-                 NMSetting8021x *s_8021x,
-                 gboolean phase2,
-                 GError **error)
+                 shvarFile *netplan,
+                   shvarFile *keys_netplan,
+                 NMS  etting8021x *s_8021x,
+                 gbo  olean phase2,
+                 GEr  ror **error)
 {
 	gs_free char *inner_auth = NULL;
 	gs_free char *value = NULL;
@@ -3252,26 +3254,26 @@ eap_ttls_reader (const char *eap_method,
 	gs_free const char **list = NULL;
 	const char *const *iter;
 
-	if (!_cert_set_from_ifcfg (s_8021x,
-	                           ifcfg,
-	                           "IEEE_8021X_CA_CERT",
-	                           NM_SETTING_802_1X_CA_CERT,
-	                           NULL,
-	                           error))
+	if (!_cert_set_from_netplan (s_8021x,
+	                             netplan,
+	                             "IEEE_8021X_CA_CERT",
+	                             NM_SETTING_802_1X_CA_CERT,
+	                             NULL,
+	                             error))
 		return FALSE;
-	_secret_set_from_ifcfg (s_8021x,
-	                        ifcfg,
-	                        keys_ifcfg,
-	                        "IEEE_8021X_CA_CERT_PASSWORD",
-	                        NM_SETTING_802_1X_CA_CERT_PASSWORD);
-
+	_secret_set_from_netplan (s_8021x,
+	                          netplan,
+	                          keys_netplan,
+	                          "IEEE_8021X_CA_CERT_PASSWORD",
+	                          NM_SETTING_802_1X_CA_CERT_PASSWORD);
+  
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_ANON_IDENTITY", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_ANON_IDENTITY", &value);
 	if (v)
 		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_INNER_AUTH_METHODS", &value);
 	if (!v) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
@@ -3288,20 +3290,20 @@ eap_ttls_reader (const char *eap_method,
 		                         "mschap",
 		                         "pap",
 		                         "chap")) {
-			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
-				return FALSE;
-			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, *iter, NULL);
-		} else if (nm_streq (*iter, "eap-tls")) {
-			if (!eap_tls_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
-				return FALSE;
-			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, "tls", NULL);
-		} else if (NM_IN_STRSET (*iter, "eap-mschapv2",
+			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
+				return F  ALSE;
+			g_object_set (s_8  021x, NM_SETTING_802_1X_PHASE2_AUTH, *iter, NULL);
+		} else if (nm_stre  q (*iter, "eap-tls")) {
+			i  f (!eap_tls_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
+				return F  ALSE;
+			g_object_set (s_8  021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, "tls", NULL);
+		} else if (NM_IN_S  TRSET (*iter, "eap-mschapv2",
 		                                "eap-md5",
 		                                "eap-gtc")) {
-			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
-				return FALSE;
-			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, (*iter + NM_STRLEN ("eap-")), NULL);
-		} else {
+			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
+				return F  ALSE;
+			g_object_set (s_8  021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, (*iter + NM_STRLEN ("eap-")), NULL);
+		} else   {
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
 			             *iter);
@@ -3314,11 +3316,11 @@ eap_ttls_reader (const char *eap_method,
 
 static gboolean
 eap_fast_reader (const char *eap_method,
-                 shvarFile *ifcfg,
-                 shvarFile *keys_ifcfg,
-                 NMSetting8021x *s_8021x,
-                 gboolean phase2,
-                 GError **error)
+                 shvarFile *netplan,
+                   shvarFile *keys_netplan,
+                 NMS  etting8021x *s_8021x,
+                 gbo  olean phase2,
+                 GEr  ror **error)
 {
 	char *anon_ident = NULL;
 	char *pac_file = NULL;
@@ -3332,13 +3334,13 @@ eap_fast_reader (const char *eap_method,
 	gboolean allow_unauth = FALSE, allow_auth = FALSE;
 	gboolean success = FALSE;
 
-	pac_file = svGetValueStr_cp (ifcfg, "IEEE_8021X_PAC_FILE");
+	pac_file = svGetValueStr_cp (netplan, "IEEE_8021X_PAC_FILE");
 	if (pac_file) {
-		real_pac_path = get_full_file_path (svFileGetName (ifcfg), pac_file);
+		real_pac_path = get_full_file_path (svFileGetName (netplan), pac_file);
 		g_object_set (s_8021x, NM_SETTING_802_1X_PAC_FILE, real_pac_path, NULL);
 	}
 
-	fast_provisioning = svGetValueStr_cp (ifcfg, "IEEE_8021X_FAST_PROVISIONING");
+	fast_provisioning = svGetValueStr_cp (netplan, "IEEE_8021X_FAST_PROVISIONING");
 	if (fast_provisioning) {
 		gs_free const char **list1 = NULL;
 
@@ -3364,11 +3366,11 @@ eap_fast_reader (const char *eap_method,
 		goto done;
 	}
 
-	anon_ident = svGetValueStr_cp (ifcfg, "IEEE_8021X_ANON_IDENTITY");
+	anon_ident = svGetValueStr_cp (netplan, "IEEE_8021X_ANON_IDENTITY");
 	if (anon_ident)
 		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, anon_ident, NULL);
 
-	inner_auth = svGetValueStr_cp (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS");
+	inner_auth = svGetValueStr_cp (netplan, "IEEE_8021X_INNER_AUTH_METHODS");
 	if (!inner_auth) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
@@ -3381,10 +3383,10 @@ eap_fast_reader (const char *eap_method,
 	if (iter) {
 		if (   !strcmp (*iter, "MSCHAPV2")
 		    || !strcmp (*iter, "GTC")) {
-			if (!eap_simple_reader (*iter, ifcfg, keys_ifcfg, s_8021x, TRUE, error))
-				goto done;
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
+				goto   done;
+		} else   {
+			g_set_error (erro  r, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
 			             *iter);
 			goto done;
@@ -3415,11 +3417,11 @@ done:
 typedef struct {
 	const char *method;
 	gboolean (*reader) (const char *eap_method,
-	                    shvarFile *ifcfg,
-	                    shvarFile *keys_ifcfg,
-	                    NMSetting8021x *s_8021x,
-	                    gboolean phase2,
-	                    GError **error);
+	                    shvarFile *netplan,
+	                      shvarFile *keys_netplan,
+	                      NMSetting8021x *s_8021x,
+	                      gboolean phase2,
+	                      GError **error);
 	gboolean wifi_phase2_only;
 } EAPReader;
 
@@ -3439,8 +3441,8 @@ static EAPReader eap_readers[] = {
 };
 
 static void
-read_8021x_list_value (shvarFile *ifcfg,
-                       const char *ifcfg_var_name,
+read_8021x_list_value (shvarFile *netplan,
+                       const char *netplan_var_name,
                        NMSetting8021x *setting,
                        const char *prop_name)
 {
@@ -3448,11 +3450,11 @@ read_8021x_list_value (shvarFile *ifcfg,
 	gs_free const char **strv = NULL;
 	const char *v;
 
-	g_return_if_fail (ifcfg != NULL);
-	g_return_if_fail (ifcfg_var_name != NULL);
+	g_return_if_fail (netplan != NULL);
+	g_return_if_fail (netplan_var_name != NULL);
 	g_return_if_fail (prop_name != NULL);
 
-	v = svGetValueStr (ifcfg, ifcfg_var_name, &value);
+	v = svGetValueStr (netplan, netplan_var_name, &value);
 	if (!v)
 		return;
 
@@ -3462,22 +3464,22 @@ read_8021x_list_value (shvarFile *ifcfg,
 }
 
 static NMSetting8021x *
-fill_8021x (shvarFile *ifcfg,
+fill_8021x (shvarFile *netplan,
             const char *file,
             const char *key_mgmt,
             gboolean wifi,
             GError **error)
 {
-	nm_auto_shvar_file_close shvarFile *keys_ifcfg = NULL;
-	gs_unref_object NMSetting8021x *s_8021x = NULL;
-	gs_free char *value = NULL;
-	const char *v;
+	nm_  auto_shvar_file_close shvarFile *keys_netplan = NULL;
+	gs_unref_object NMS  etting8021x *s_8021x = NULL;
+	gs_free char *value   = NULL;
+	const char *  v;
 	gs_free const char **list = NULL;
 	const char *const *iter;
 	gint64 timeout;
 	int i_val;
 
-	v = svGetValueStr (ifcfg, "IEEE_8021X_EAP_METHODS", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_EAP_METHODS", &value);
 	if (!v) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Missing IEEE_8021X_EAP_METHODS for key management '%s'",
@@ -3489,11 +3491,11 @@ fill_8021x (shvarFile *ifcfg,
 
 	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
 
-	/* Read in the lookaside keys_ifcfg file, if present */
-	keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
-
-	/* Validate and handle each EAP method */
-	for (iter = list; iter && *iter; iter++) {
+	/*   Read in the lookaside keys_netplan file, if present */
+	key  s_netplan = ut  ils_get_keys_netplan (file, FALSE);
+    
+	/* Validate and han    dle each EAP method */
+	for (iter = list; i  ter && *iter; iter++) {
 		EAPReader *eap = &eap_readers[0];
 		gboolean found = FALSE;
 		gs_free char *lower = NULL;
@@ -3514,10 +3516,10 @@ fill_8021x (shvarFile *ifcfg,
 			}
 
 			/* Parse EAP method specific options */
-			if (!(*eap->reader)(lower, ifcfg, keys_ifcfg, s_8021x, FALSE, error))
-				return NULL;
-
-			nm_setting_802_1x_add_eap_method (s_8021x, lower);
+			i  f (!(*eap->reader)(lower, netplan, keys_netplan, s_8021x, FALSE, error))
+				return   NULL;
+  
+			nm_setting_802_1x  _add_eap_method (s_8021x, lower);
 			found = TRUE;
 			break;
 
@@ -3536,41 +3538,41 @@ next:
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_SUBJECT_MATCH", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_SUBJECT_MATCH", &value);
 	g_object_set (s_8021x, NM_SETTING_802_1X_SUBJECT_MATCH, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_PHASE2_SUBJECT_MATCH", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_PHASE2_SUBJECT_MATCH", &value);
 	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH, v, NULL);
 
 	i_val = NM_SETTING_802_1X_AUTH_FLAGS_NONE;
-	if (!svGetValueEnum (ifcfg, "IEEE_8021X_PHASE1_AUTH_FLAGS",
+	if (!svGetValueEnum (netplan, "IEEE_8021X_PHASE1_AUTH_FLAGS",
 	                     nm_setting_802_1x_auth_flags_get_type (),
 	                     &i_val, error))
 		return NULL;
 	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_AUTH_FLAGS, (guint) i_val, NULL);
 
-	read_8021x_list_value (ifcfg, "IEEE_8021X_ALTSUBJECT_MATCHES",
+	read_8021x_list_value (netplan, "IEEE_8021X_ALTSUBJECT_MATCHES",
 	                       s_8021x, NM_SETTING_802_1X_ALTSUBJECT_MATCHES);
-	read_8021x_list_value (ifcfg, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES",
+	read_8021x_list_value (netplan, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES",
 	                       s_8021x, NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_DOMAIN_SUFFIX_MATCH", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_DOMAIN_SUFFIX_MATCH", &value);
 	g_object_set (s_8021x, NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH, v, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH", &value);
+	v = svGetValueStr (netplan, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH", &value);
 	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH, v, NULL);
 
-	timeout = svGetValueInt64 (ifcfg, "IEEE_8021X_AUTH_TIMEOUT", 10, 0, G_MAXINT32, 0);
+	timeout = svGetValueInt64 (netplan, "IEEE_8021X_AUTH_TIMEOUT", 10, 0, G_MAXINT32, 0);
 	g_object_set (s_8021x, NM_SETTING_802_1X_AUTH_TIMEOUT, (int) timeout, NULL);
 
 	return g_steal_pointer (&s_8021x);
 }
 
 static NMSetting *
-make_wpa_setting (shvarFile *ifcfg,
+make_wpa_setting (shvarFile *netplan,
                   const char *file,
                   GBytes *ssid,
                   gboolean adhoc,
@@ -3586,7 +3588,7 @@ make_wpa_setting (shvarFile *ifcfg,
 
 	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 
-	v = svGetValueStr (ifcfg, "KEY_MGMT", &value);
+	v = svGetValueStr (netplan, "KEY_MGMT", &value);
 	wpa_psk = nm_streq0 (v, "WPA-PSK");
 	wpa_sae = nm_streq0 (v, "SAE");
 	wpa_eap = nm_streq0 (v, "WPA-EAP");
@@ -3599,7 +3601,7 @@ make_wpa_setting (shvarFile *ifcfg,
 
 	/* WPS */
 	i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
-	if (!svGetValueEnum (ifcfg, "WPS_METHOD",
+	if (!svGetValueEnum (netplan, "WPS_METHOD",
 	                     nm_setting_wireless_security_wps_method_get_type (),
 	                     &i_val, error))
 		return NULL;
@@ -3609,8 +3611,8 @@ make_wpa_setting (shvarFile *ifcfg,
 
 	/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
 	if (wpa_psk || wpa_sae || wpa_eap) {
-		fill_wpa_ciphers (ifcfg, wsec, FALSE, adhoc);
-		fill_wpa_ciphers (ifcfg, wsec, TRUE, adhoc);
+		fill_wpa_ciphers (netplan, wsec, FALSE, adhoc);
+		fill_wpa_ciphers (netplan, wsec, TRUE, adhoc);
 	}
 
 	/* WPA and/or RSN */
@@ -3621,12 +3623,12 @@ make_wpa_setting (shvarFile *ifcfg,
 		gs_free char *value2 = NULL;
 		const char *v2;
 
-		v2 = svGetValueStr (ifcfg, "WPA_ALLOW_WPA", &value2);
+		v2 = svGetValueStr (netplan, "WPA_ALLOW_WPA", &value2);
 		if (v2 && svParseBoolean (v2, TRUE))
 			nm_setting_wireless_security_add_proto (wsec, "wpa");
 
 		nm_clear_g_free (&value2);
-		v2 = svGetValueStr (ifcfg, "WPA_ALLOW_WPA2", &value2);
+		v2 = svGetValueStr (netplan, "WPA_ALLOW_WPA2", &value2);
 		if (v2 && svParseBoolean (v2, TRUE))
 			nm_setting_wireless_security_add_proto (wsec, "rsn");
 	}
@@ -3634,14 +3636,14 @@ make_wpa_setting (shvarFile *ifcfg,
 	if (wpa_psk || wpa_sae) {
 		NMSettingSecretFlags psk_flags;
 
-		psk_flags = _secret_read_ifcfg_flags (ifcfg, "WPA_PSK_FLAGS");
+		psk_flags = _secret_read_netplan_flags (netplan, "WPA_PSK_FLAGS");
 		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS, psk_flags, NULL);
 
 		/* Read PSK if it's system-owned */
 		if (psk_flags == NM_SETTING_SECRET_FLAG_NONE) {
 			gs_free char *psk = NULL;
 
-			psk = parse_wpa_psk (ifcfg, file, ssid, &local);
+			psk = parse_wpa_psk (netplan, file, ssid, &local);
 			if (psk)
 				g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
 			else if (local) {
@@ -3666,7 +3668,7 @@ make_wpa_setting (shvarFile *ifcfg,
 			return NULL;
 		}
 
-		*s_8021x = fill_8021x (ifcfg, file, v, TRUE, error);
+		*s_8021x = fill_8021x (netplan, file, v, TRUE, error);
 		if (!*s_8021x)
 			return NULL;
 
@@ -3678,21 +3680,21 @@ make_wpa_setting (shvarFile *ifcfg,
 	}
 
 	i_val = NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT;
-	if (!svGetValueEnum (ifcfg, "PMF",
+	if (!svGetValueEnum (netplan, "PMF",
 	                     nm_setting_wireless_security_pmf_get_type (),
 	                     &i_val, error))
 		return NULL;
 	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PMF, i_val, NULL);
 
 	i_val = NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT;
-	if (!svGetValueEnum (ifcfg, "FILS",
+	if (!svGetValueEnum (netplan, "FILS",
 	                     nm_setting_wireless_security_fils_get_type (),
 	                     &i_val, error))
 		return NULL;
 	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_FILS, i_val, NULL);
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "SECURITYMODE", &value);
+	v = svGetValueStr (netplan, "SECURITYMODE", &value);
 	if (NM_IN_STRSET (v, NULL, "open"))
 		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, v, NULL);
 
@@ -3700,47 +3702,47 @@ make_wpa_setting (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_leap_setting (shvarFile *ifcfg,
+make_leap_setting (shvarFile *netplan,
                    const char *file,
                    GError **error)
 {
 	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
-	shvarFile *keys_ifcfg;
-	gs_free char *value = NULL;
-	NMSettingSecretFlags flags;
-
+  	shvarFile *keys_netplan;
+	gs_free char *value   = NULL;
+	NMSettingSecretFlag  s flags;
+  
 	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 
-	value = svGetValueStr_cp (ifcfg, "KEY_MGMT");
+	value = svGetValueStr_cp (netplan, "KEY_MGMT");
 	if (!value || strcmp (value, "IEEE8021X"))
 		return NULL;
 	nm_clear_g_free (&value);
 
-	value = svGetValueStr_cp (ifcfg, "SECURITYMODE");
+	value = svGetValueStr_cp (netplan, "SECURITYMODE");
 	if (!value || strcasecmp (value, "leap"))
 		return NULL; /* Not LEAP */
 	nm_clear_g_free (&value);
 
-	flags = _secret_read_ifcfg_flags (ifcfg, "IEEE_8021X_PASSWORD_FLAGS");
+	flags = _secret_read_netplan_flags (netplan, "IEEE_8021X_PASSWORD_FLAGS");
 	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags, NULL);
 
 	/* Read LEAP password if it's system-owned */
 	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
-		value = svGetValueStr_cp (ifcfg, "IEEE_8021X_PASSWORD");
+		value = svGetValueStr_cp (netplan, "IEEE_8021X_PASSWORD");
 		if (!value) {
 			/* Try to get keys from the "shadow" key file */
-			keys_ifcfg = utils_get_keys_ifcfg (file, FALSE);
-			if (keys_ifcfg) {
-				value = svGetValueStr_cp (keys_ifcfg, "IEEE_8021X_PASSWORD");
-				svCloseFile (keys_ifcfg);
-			}
-		}
-		if (value && strlen (value))
+			k  eys_netplan = utils_get_keys_netplan (file, FALSE);
+  			if (keys_netpl  an) {
+				  value = svGetV    alueStr_cp (keys_netplan, "IEEE_8021X_PASSWORD");
+  				svCloseFile (k      eys_netplan);
+  		    	}
+	    	}
+		if (value && strle  n (value))
 			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, value, NULL);
 		nm_clear_g_free (&value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "IEEE_8021X_IDENTITY");
+	value = svGetValueStr_cp (netplan, "IEEE_8021X_IDENTITY");
 	if (!value) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Missing LEAP identity");
@@ -3758,7 +3760,7 @@ make_leap_setting (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_wireless_security_setting (shvarFile *ifcfg,
+make_wireless_security_setting (shvarFile *netplan,
                                 const char *file,
                                 GBytes *ssid,
                                 gboolean adhoc,
@@ -3770,20 +3772,20 @@ make_wireless_security_setting (shvarFile *ifcfg,
 	g_return_val_if_fail (error && !*error, NULL);
 
 	if (!adhoc) {
-		wsec = make_leap_setting (ifcfg, file, error);
+		wsec = make_leap_setting (netplan, file, error);
 		if (wsec)
 			return wsec;
 		else if (*error)
 			return NULL;
 	}
 
-	wsec = make_wpa_setting (ifcfg, file, ssid, adhoc, s_8021x, error);
+	wsec = make_wpa_setting (netplan, file, ssid, adhoc, s_8021x, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
 		return NULL;
 
-	wsec = make_wep_setting (ifcfg, file, error);
+	wsec = make_wep_setting (netplan, file, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
@@ -3815,7 +3817,7 @@ transform_hwaddr_blacklist (const char *blacklist)
 }
 
 static NMSetting *
-make_wireless_setting (shvarFile *ifcfg,
+make_wireless_setting (shvarFile *netplan,
                        GError **error)
 {
 	NMSettingWireless *s_wireless;
@@ -3827,25 +3829,25 @@ make_wireless_setting (shvarFile *ifcfg,
 
 	s_wireless = NM_SETTING_WIRELESS (nm_setting_wireless_new ());
 
-	value = svGetValueStr_cp (ifcfg, "HWADDR");
+	value = svGetValueStr_cp (netplan, "HWADDR");
 	if (value) {
 		value = g_strstrip (value);
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "MACADDR");
+	value = svGetValueStr_cp (netplan, "MACADDR");
 	if (value) {
 		value = g_strstrip (value);
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS, value, NULL);
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "GENERATE_MAC_ADDRESS_MASK");
+	value = svGetValueStr_cp (netplan, "GENERATE_MAC_ADDRESS_MASK");
 	g_object_set (s_wireless, NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK, value, NULL);
 	g_free (value);
 
-	cvalue = svGetValueStr (ifcfg, "HWADDR_BLACKLIST", &value);
+	cvalue = svGetValueStr (netplan, "HWADDR_BLACKLIST", &value);
 	if (cvalue) {
 		gs_free const char **strv = NULL;
 
@@ -3854,7 +3856,7 @@ make_wireless_setting (shvarFile *ifcfg,
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "ESSID");
+	value = svGetValueStr_cp (netplan, "ESSID");
 	if (value) {
 		gs_unref_bytes GBytes *bytes = NULL;
 		gsize ssid_len = 0;
@@ -3883,7 +3885,7 @@ make_wireless_setting (shvarFile *ifcfg,
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "MODE");
+	value = svGetValueStr_cp (netplan, "MODE");
 	if (value) {
 		char *lcase;
 		const char *mode = NULL;
@@ -3909,14 +3911,14 @@ make_wireless_setting (shvarFile *ifcfg,
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, mode, NULL);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "BSSID");
+	value = svGetValueStr_cp (netplan, "BSSID");
 	if (value) {
 		value = g_strstrip (value);
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_BSSID, value, NULL);
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "CHANNEL");
+	value = svGetValueStr_cp (netplan, "CHANNEL");
 	if (value) {
 		chan = _nm_utils_ascii_str_to_int64 (value, 10, 1, 196, 0);
 		if (chan == 0) {
@@ -3929,7 +3931,7 @@ make_wireless_setting (shvarFile *ifcfg,
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "BAND");
+	value = svGetValueStr_cp (netplan, "BAND");
 	if (value) {
 		if (!strcmp (value, "a")) {
 			if (chan && chan <= 14) {
@@ -3960,7 +3962,7 @@ make_wireless_setting (shvarFile *ifcfg,
 			g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, "bg", NULL);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "MTU");
+	value = svGetValueStr_cp (netplan, "MTU");
 	if (value) {
 		int mtu;
 
@@ -3977,10 +3979,10 @@ make_wireless_setting (shvarFile *ifcfg,
 
 	g_object_set (s_wireless,
 	              NM_SETTING_WIRELESS_HIDDEN,
-	              svGetValueBoolean (ifcfg, "SSID_HIDDEN", FALSE),
+	              svGetValueBoolean (netplan, "SSID_HIDDEN", FALSE),
 	              NULL);
 
-	cvalue = svGetValue (ifcfg, "POWERSAVE", &value);
+	cvalue = svGetValue (netplan, "POWERSAVE", &value);
 	if (cvalue) {
 		if (!strcmp (cvalue, "default"))
 			powersave = NM_SETTING_WIRELESS_POWERSAVE_DEFAULT;
@@ -4004,7 +4006,7 @@ make_wireless_setting (shvarFile *ifcfg,
 	              powersave,
 	              NULL);
 
-	cvalue = svGetValue (ifcfg, "MAC_ADDRESS_RANDOMIZATION", &value);
+	cvalue = svGetValue (netplan, "MAC_ADDRESS_RANDOMIZATION", &value);
 	if (cvalue) {
 		if (strcmp (cvalue, "default") == 0)
 			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
@@ -4036,9 +4038,9 @@ error:
 }
 
 static NMConnection *
-wireless_connection_from_ifcfg (const char *file,
-                                shvarFile *ifcfg,
-                                GError **error)
+wireless_connection_from_netplan (const char *file,
+                                  shvarFile *netplan,
+                                  GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
@@ -4052,13 +4054,13 @@ wireless_connection_from_ifcfg (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 	g_return_val_if_fail (!error || !*error, NULL);
 
 	connection = nm_simple_connection_new ();
 
 	/* Wireless */
-	wireless_setting = make_wireless_setting (ifcfg, error);
+	wireless_setting = make_wireless_setting (netplan, error);
 	if (!wireless_setting) {
 		g_object_unref (connection);
 		return NULL;
@@ -4071,7 +4073,7 @@ wireless_connection_from_ifcfg (const char *file,
 		adhoc = TRUE;
 
 	/* Wireless security */
-	security_setting = make_wireless_security_setting (ifcfg, file, ssid, adhoc, &s_8021x, &local);
+	security_setting = make_wireless_security_setting (netplan, file, ssid, adhoc, &s_8021x, &local);
 	if (local) {
 		g_object_unref (connection);
 		g_propagate_error (error, local);
@@ -4088,7 +4090,7 @@ wireless_connection_from_ifcfg (const char *file,
 
 	/* Connection */
 	con_setting = make_connection_setting (file,
-	                                       ifcfg,
+	                                       netplan,
 	                                       NM_SETTING_WIRELESS_SETTING_NAME,
 	                                       nm_str_not_empty (ssid_utf8) ?: "unmanaged",
 	                                       NULL);
@@ -4142,7 +4144,7 @@ parse_ethtool_option (const char *value,
 				else if (nm_streq0 (opt_val, "off"))
 					onoff = NM_TERNARY_FALSE;
 
-				d = nms_ifcfg_rh_utils_get_ethtool_by_name (opt);
+				d = nms_netplan_utils_get_ethtool_by_name (opt);
 
 				if (!d) {
 					if (onoff != NM_TERNARY_DEFAULT) {
@@ -4286,14 +4288,14 @@ parse_ethtool_option (const char *value,
 }
 
 static GPtrArray *
-read_routing_rules_parse (shvarFile *ifcfg,
+read_routing_rules_parse (shvarFile *netplan,
                           gboolean routes_read)
 {
 	gs_unref_ptrarray GPtrArray *arr = NULL;
 	gs_free const char **keys = NULL;
 	guint i, len;
 
-	keys = svGetKeysSorted (ifcfg, SV_KEY_TYPE_ROUTING_RULE4 | SV_KEY_TYPE_ROUTING_RULE6, &len);
+	keys = svGetKeysSorted (netplan, SV_KEY_TYPE_ROUTING_RULE4 | SV_KEY_TYPE_ROUTING_RULE6, &len);
 	if (len == 0)
 		return NULL;
 
@@ -4315,7 +4317,7 @@ read_routing_rules_parse (shvarFile *ifcfg,
 		nm_assert (  key_is_ipv4  == NM_STR_HAS_PREFIX (key, "ROUTING_RULE_"));
 		nm_assert ((!key_is_ipv4) == NM_STR_HAS_PREFIX (key, "ROUTING_RULE6_"));
 
-		value = svGetValueStr (ifcfg, key, &value_to_free);
+		value = svGetValueStr (netplan, key, &value_to_free);
 		if (!value)
 			continue;
 
@@ -4341,7 +4343,7 @@ read_routing_rules_parse (shvarFile *ifcfg,
 }
 
 static void
-read_routing_rules (shvarFile *ifcfg,
+read_routing_rules (shvarFile *netplan,
                     gboolean routes_read,
                     NMSettingIPConfig *s_ip4,
                     NMSettingIPConfig *s_ip6)
@@ -4349,7 +4351,7 @@ read_routing_rules (shvarFile *ifcfg,
 	gs_unref_ptrarray GPtrArray *routing_rules = NULL;
 	guint i;
 
-	routing_rules = read_routing_rules_parse (ifcfg, routes_read);
+	routing_rules = read_routing_rules_parse (netplan, routes_read);
 	if (!routing_rules)
 		return;
 
@@ -4364,7 +4366,7 @@ read_routing_rules (shvarFile *ifcfg,
 }
 
 static void
-parse_ethtool_options (shvarFile *ifcfg, NMConnection *connection)
+parse_ethtool_options (shvarFile *netplan, NMConnection *connection)
 {
 	NMSettingWired *s_wired;
 	gs_unref_object NMSettingEthtool *s_ethtool = NULL;
@@ -4379,7 +4381,7 @@ parse_ethtool_options (shvarFile *ifcfg, NMConnection *connection)
 	const char *duplex = NULL;
 	gboolean wired_found = FALSE;
 
-	ethtool_opts = svGetValue (ifcfg, "ETHTOOL_OPTS", &ethtool_opts_free);
+	ethtool_opts = svGetValue (netplan, "ETHTOOL_OPTS", &ethtool_opts_free);
 	if (ethtool_opts) {
 		wired_found = TRUE;
 		/* WAKE_ON_LAN_IGNORE is inferred from a specified but empty ETHTOOL_OPTS */
@@ -4405,7 +4407,7 @@ parse_ethtool_options (shvarFile *ifcfg, NMConnection *connection)
 	}
 
 	/* ETHTOOL_WAKE_ON_LAN = ignore overrides WoL settings in ETHTOOL_OPTS */
-	tmp = svGetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN", &wol_value_free);
+	tmp = svGetValue (netplan, "ETHTOOL_WAKE_ON_LAN", &wol_value_free);
 	if (tmp)
 		wired_found = TRUE;
 	if (nm_streq0 (tmp, "ignore"))
@@ -4441,7 +4443,7 @@ parse_ethtool_options (shvarFile *ifcfg, NMConnection *connection)
 }
 
 static NMSetting *
-make_wired_setting (shvarFile *ifcfg,
+make_wired_setting (shvarFile *netplan,
                     const char *file,
                     NMSetting8021x **s_8021x,
                     GError **error)
@@ -4453,7 +4455,7 @@ make_wired_setting (shvarFile *ifcfg,
 
 	s_wired = NM_SETTING_WIRED (nm_setting_wired_new ());
 
-	cvalue = svGetValue (ifcfg, "MTU", &value);
+	cvalue = svGetValue (netplan, "MTU", &value);
 	if (cvalue) {
 		int mtu;
 
@@ -4466,7 +4468,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	value = svGetValue_cp (ifcfg, "HWADDR");
+	value = svGetValue_cp (netplan, "HWADDR");
 	if (value) {
 		if (value[0] != '\0') {
 			value = g_strstrip (value);
@@ -4476,7 +4478,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValue (ifcfg, "SUBCHANNELS", &value);
+	cvalue = svGetValue (netplan, "SUBCHANNELS", &value);
 	if (cvalue) {
 		if (cvalue[0] != '\0') {
 			const char *p = cvalue;
@@ -4509,7 +4511,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValue (ifcfg, "PORTNAME", &value);
+	cvalue = svGetValue (netplan, "PORTNAME", &value);
 	if (cvalue) {
 		if (cvalue[0] != '\0')
 			nm_setting_wired_add_s390_option (s_wired, "portname", cvalue);
@@ -4517,7 +4519,7 @@ make_wired_setting (shvarFile *ifcfg,
 		nm_clear_g_free (&value);
 	}
 
-	cvalue = svGetValue (ifcfg, "CTCPROT", &value);
+	cvalue = svGetValue (netplan, "CTCPROT", &value);
 	if (cvalue) {
 		if (cvalue[0] != '\0')
 			nm_setting_wired_add_s390_option (s_wired, "ctcprot", cvalue);
@@ -4525,7 +4527,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValue (ifcfg, "NETTYPE", &value);
+	cvalue = svGetValue (netplan, "NETTYPE", &value);
 	if (cvalue) {
 		if (NM_IN_STRSET (cvalue, "qeth", "lcs", "ctc"))
 			g_object_set (s_wired, NM_SETTING_WIRED_S390_NETTYPE, cvalue, NULL);
@@ -4535,7 +4537,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValue (ifcfg, "OPTIONS", &value);
+	cvalue = svGetValue (netplan, "OPTIONS", &value);
 	if (cvalue)
 		found = TRUE;
 	if (cvalue && cvalue[0]) {
@@ -4560,7 +4562,7 @@ make_wired_setting (shvarFile *ifcfg,
 	}
 	nm_clear_g_free (&value);
 
-	cvalue = svGetValueStr (ifcfg, "MACADDR", &value);
+	cvalue = svGetValueStr (netplan, "MACADDR", &value);
 	if (cvalue) {
 		if (cvalue[0] != '\0') {
 			g_object_set (s_wired,
@@ -4572,7 +4574,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK", &value);
+	cvalue = svGetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK", &value);
 	if (cvalue) {
 		if (cvalue[0] != '\0') {
 			g_object_set (s_wired,
@@ -4584,7 +4586,7 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValueStr (ifcfg, "HWADDR_BLACKLIST", &value);
+	cvalue = svGetValueStr (netplan, "HWADDR_BLACKLIST", &value);
 	if (cvalue) {
 		gs_free const char **strv = NULL;
 
@@ -4594,12 +4596,12 @@ make_wired_setting (shvarFile *ifcfg,
 		found = TRUE;
 	}
 
-	cvalue = svGetValue (ifcfg, "KEY_MGMT", &value);
+	cvalue = svGetValue (netplan, "KEY_MGMT", &value);
 	if (cvalue)
 		found = TRUE;
 	if (cvalue && cvalue[0] != '\0') {
 		if (!strcmp (cvalue, "IEEE8021X")) {
-			*s_8021x = fill_8021x (ifcfg, file, cvalue, FALSE, error);
+			*s_8021x = fill_8021x (netplan, file, cvalue, FALSE, error);
 			if (!*s_8021x)
 				return NULL;
 		} else {
@@ -4622,9 +4624,9 @@ make_wired_setting (shvarFile *ifcfg,
 }
 
 static NMConnection *
-wired_connection_from_ifcfg (const char *file,
-                             shvarFile *ifcfg,
-                             GError **error)
+wired_connection_from_netplan (const char *file,
+                               shvarFile *netplan,
+                               GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
@@ -4633,11 +4635,11 @@ wired_connection_from_ifcfg (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_WIRED_SETTING_NAME, NULL, NULL);
+	con_setting = make_connection_setting (file, netplan, NM_SETTING_WIRED_SETTING_NAME, NULL, NULL);
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -4646,7 +4648,7 @@ wired_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -4664,7 +4666,7 @@ wired_connection_from_ifcfg (const char *file,
 }
 
 static gboolean
-parse_infiniband_p_key (shvarFile *ifcfg,
+parse_infiniband_p_key (shvarFile *netplan,
                         int *out_p_key,
                         char **out_parent,
                         GError **error)
@@ -4674,19 +4676,19 @@ parse_infiniband_p_key (shvarFile *ifcfg,
 	int id;
 	gboolean ret = FALSE;
 
-	device = svGetValueStr_cp (ifcfg, "DEVICE");
+	device = svGetValueStr_cp (netplan, "DEVICE");
 	if (!device) {
 		PARSE_WARNING ("InfiniBand connection specified PKEY but not DEVICE");
 		goto done;
 	}
 
-	physdev = svGetValueStr_cp (ifcfg, "PHYSDEV");
+	physdev = svGetValueStr_cp (netplan, "PHYSDEV");
 	if (!physdev) {
 		PARSE_WARNING ("InfiniBand connection specified PKEY but not PHYSDEV");
 		goto done;
 	}
 
-	pkey_id = svGetValueStr_cp (ifcfg, "PKEY_ID");
+	pkey_id = svGetValueStr_cp (netplan, "PKEY_ID");
 	if (!pkey_id) {
 		PARSE_WARNING ("InfiniBand connection specified PKEY but not PKEY_ID");
 		goto done;
@@ -4724,7 +4726,7 @@ parse_infiniband_p_key (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_infiniband_setting (shvarFile *ifcfg,
+make_infiniband_setting (shvarFile *netplan,
                          const char *file,
                          GError **error)
 {
@@ -4733,7 +4735,7 @@ make_infiniband_setting (shvarFile *ifcfg,
 
 	s_infiniband = NM_SETTING_INFINIBAND (nm_setting_infiniband_new ());
 
-	value = svGetValueStr_cp (ifcfg, "MTU");
+	value = svGetValueStr_cp (netplan, "MTU");
 	if (value) {
 		int mtu;
 
@@ -4745,23 +4747,23 @@ make_infiniband_setting (shvarFile *ifcfg,
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (ifcfg, "HWADDR");
+	value = svGetValueStr_cp (netplan, "HWADDR");
 	if (value) {
 		value = g_strstrip (value);
 		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_MAC_ADDRESS, value, NULL);
 		g_free (value);
 	}
 
-	if (svGetValueBoolean (ifcfg, "CONNECTED_MODE", FALSE))
+	if (svGetValueBoolean (netplan, "CONNECTED_MODE", FALSE))
 		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "connected", NULL);
 	else
 		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram", NULL);
 
-	if (svGetValueBoolean (ifcfg, "PKEY", FALSE)) {
+	if (svGetValueBoolean (netplan, "PKEY", FALSE)) {
 		gs_free char *parent = NULL;
 		int p_key;
 
-		if (!parse_infiniband_p_key (ifcfg, &p_key, &parent, error)) {
+		if (!parse_infiniband_p_key (netplan, &p_key, &parent, error)) {
 			g_object_unref (s_infiniband);
 			return NULL;
 		}
@@ -4776,20 +4778,20 @@ make_infiniband_setting (shvarFile *ifcfg,
 }
 
 static NMConnection *
-infiniband_connection_from_ifcfg (const char *file,
-                                  shvarFile *ifcfg,
-                                  GError **error)
+infiniband_connection_from_netplan (const char *file,
+                                    shvarFile *netplan,
+                                    GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
 	NMSetting *infiniband_setting = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_INFINIBAND_SETTING_NAME, NULL, NULL);
+	con_setting = make_connection_setting (file, netplan, NM_SETTING_INFINIBAND_SETTING_NAME, NULL, NULL);
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -4798,7 +4800,7 @@ infiniband_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	infiniband_setting = make_infiniband_setting (ifcfg, file, error);
+	infiniband_setting = make_infiniband_setting (netplan, file, error);
 	if (!infiniband_setting) {
 		g_object_unref (connection);
 		return NULL;
@@ -4835,7 +4837,7 @@ handle_bond_option (NMSettingBond *s_bond,
 }
 
 static NMSetting *
-make_bond_setting (shvarFile *ifcfg,
+make_bond_setting (shvarFile *netplan,
                    const char *file,
                    GError **error)
 {
@@ -4843,7 +4845,7 @@ make_bond_setting (shvarFile *ifcfg,
 	gs_free char *value = NULL;
 	const char *v;
 
-	v = svGetValueStr (ifcfg, "DEVICE", &value);
+	v = svGetValueStr (netplan, "DEVICE", &value);
 	if (!v) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "mandatory DEVICE keyword missing");
@@ -4853,7 +4855,7 @@ make_bond_setting (shvarFile *ifcfg,
 	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "BONDING_OPTS", &value);
+	v = svGetValueStr (netplan, "BONDING_OPTS", &value);
 	if (v) {
 		gs_free const char **items = NULL;
 		const char *const *iter;
@@ -4877,9 +4879,9 @@ make_bond_setting (shvarFile *ifcfg,
 }
 
 static NMConnection *
-bond_connection_from_ifcfg (const char *file,
-                            shvarFile *ifcfg,
-                            GError **error)
+bond_connection_from_netplan (const char *file,
+                              shvarFile *netplan,
+                              GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
@@ -4889,11 +4891,11 @@ bond_connection_from_ifcfg (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_BOND_SETTING_NAME, NULL, _("Bond"));
+	con_setting = make_connection_setting (file, netplan, NM_SETTING_BOND_SETTING_NAME, NULL, _("Bond"));
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -4902,14 +4904,14 @@ bond_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	bond_setting = make_bond_setting (ifcfg, file, error);
+	bond_setting = make_bond_setting (netplan, file, error);
 	if (!bond_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
 	nm_connection_add_setting (connection, bond_setting);
 
-	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -4927,7 +4929,7 @@ bond_connection_from_ifcfg (const char *file,
 }
 
 static NMSetting *
-make_team_setting (shvarFile *ifcfg,
+make_team_setting (shvarFile *netplan,
                    const char *file,
                    GError **error)
 {
@@ -4935,7 +4937,7 @@ make_team_setting (shvarFile *ifcfg,
 	gs_free char *value_device = NULL;
 	gs_free char *value = NULL;
 
-	if (!svGetValueStr (ifcfg, "DEVICE", &value_device)) {
+	if (!svGetValueStr (netplan, "DEVICE", &value_device)) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "mandatory DEVICE keyword missing");
 		return NULL;
@@ -4944,15 +4946,15 @@ make_team_setting (shvarFile *ifcfg,
 	s_team = nm_setting_team_new ();
 	g_object_set (s_team,
 	              NM_SETTING_TEAM_CONFIG,
-	              svGetValue (ifcfg, "TEAM_CONFIG", &value),
+	              svGetValue (netplan, "TEAM_CONFIG", &value),
 	              NULL);
 	return s_team;
 }
 
 static NMConnection *
-team_connection_from_ifcfg (const char *file,
-                            shvarFile *ifcfg,
-                            GError **error)
+team_connection_from_netplan (const char *file,
+                              shvarFile *netplan,
+                              GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
@@ -4962,11 +4964,11 @@ team_connection_from_ifcfg (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_TEAM_SETTING_NAME, NULL, _("Team"));
+	con_setting = make_connection_setting (file, netplan, NM_SETTING_TEAM_SETTING_NAME, NULL, _("Team"));
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -4975,14 +4977,14 @@ team_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	team_setting = make_team_setting (ifcfg, file, error);
+	team_setting = make_team_setting (netplan, file, error);
 	if (!team_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
 	nm_connection_add_setting (connection, team_setting);
 
-	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -5129,7 +5131,7 @@ handle_bridging_opts (NMSetting *setting,
 }
 
 static void
-read_bridge_vlans (shvarFile *ifcfg,
+read_bridge_vlans (shvarFile *netplan,
                    const char *key,
                    NMSetting *setting,
                    const char *property)
@@ -5138,7 +5140,7 @@ read_bridge_vlans (shvarFile *ifcfg,
 	gs_free char *value_to_free = NULL;
 	const char *value;
 
-	value = svGetValueStr (ifcfg, key, &value_to_free);
+	value = svGetValueStr (netplan, key, &value_to_free);
 	if (value) {
 		gs_free const char **strv = NULL;
 		const char *const *iter;
@@ -5166,7 +5168,7 @@ read_bridge_vlans (shvarFile *ifcfg,
 }
 
 static NMSetting *
-make_bridge_setting (shvarFile *ifcfg,
+make_bridge_setting (shvarFile *netplan,
                      const char *file,
                      GError **error)
 {
@@ -5176,7 +5178,7 @@ make_bridge_setting (shvarFile *ifcfg,
 	gboolean stp = FALSE;
 	gboolean stp_set = FALSE;
 
-	value = svGetValueStr (ifcfg, "DEVICE", &value_to_free);
+	value = svGetValueStr (netplan, "DEVICE", &value_to_free);
 	if (!value) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "mandatory DEVICE keyword missing");
@@ -5186,13 +5188,13 @@ make_bridge_setting (shvarFile *ifcfg,
 
 	s_bridge = NM_SETTING_BRIDGE (nm_setting_bridge_new ());
 
-	value = svGetValueStr (ifcfg, "BRIDGE_MACADDR", &value_to_free);
+	value = svGetValueStr (netplan, "BRIDGE_MACADDR", &value_to_free);
 	if (value) {
 		g_object_set (s_bridge, NM_SETTING_BRIDGE_MAC_ADDRESS, value, NULL);
 		nm_clear_g_free (&value_to_free);
 	}
 
-	value = svGetValueStr (ifcfg, "STP", &value_to_free);
+	value = svGetValueStr (netplan, "STP", &value_to_free);
 	if (value) {
 		if (!strcasecmp (value, "on") || !strcasecmp (value, "yes")) {
 			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, TRUE, NULL);
@@ -5211,19 +5213,19 @@ make_bridge_setting (shvarFile *ifcfg,
 		g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, FALSE, NULL);
 	}
 
-	value = svGetValueStr (ifcfg, "DELAY", &value_to_free);
+	value = svGetValueStr (netplan, "DELAY", &value_to_free);
 	if (value) {
 		handle_bridge_option (NM_SETTING (s_bridge), stp, "DELAY", value, BRIDGE_OPT_TYPE_MAIN);
 		nm_clear_g_free (&value_to_free);
 	}
 
-	value = svGetValueStr (ifcfg, "BRIDGING_OPTS", &value_to_free);
+	value = svGetValueStr (netplan, "BRIDGING_OPTS", &value_to_free);
 	if (value) {
 		handle_bridging_opts (NM_SETTING (s_bridge), stp, value, handle_bridge_option, BRIDGE_OPT_TYPE_OPTION);
 		nm_clear_g_free (&value_to_free);
 	}
 
-	read_bridge_vlans (ifcfg,
+	read_bridge_vlans (netplan,
 	                   "BRIDGE_VLANS",
 	                   NM_SETTING (s_bridge),
 	                   NM_SETTING_BRIDGE_VLANS);
@@ -5232,9 +5234,9 @@ make_bridge_setting (shvarFile *ifcfg,
 }
 
 static NMConnection *
-bridge_connection_from_ifcfg (const char *file,
-                              shvarFile *ifcfg,
-                              GError **error)
+bridge_connection_from_netplan (const char *file,
+                                shvarFile *netplan,
+                                GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
@@ -5244,11 +5246,11 @@ bridge_connection_from_ifcfg (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_BRIDGE_SETTING_NAME, NULL, _("Bridge"));
+	con_setting = make_connection_setting (file, netplan, NM_SETTING_BRIDGE_SETTING_NAME, NULL, _("Bridge"));
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -5257,14 +5259,14 @@ bridge_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	bridge_setting = make_bridge_setting (ifcfg, file, error);
+	bridge_setting = make_bridge_setting (netplan, file, error);
 	if (!bridge_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
 	nm_connection_add_setting (connection, bridge_setting);
 
-	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -5282,28 +5284,28 @@ bridge_connection_from_ifcfg (const char *file,
 }
 
 static NMSetting *
-make_bridge_port_setting (shvarFile *ifcfg)
+make_bridge_port_setting (shvarFile *netplan)
 {
 	NMSetting *s_port = NULL;
 	gs_free char *value_to_free = NULL;
 	const char *value;
 
-	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (netplan != NULL, FALSE);
 
-	value = svGetValueStr (ifcfg, "BRIDGE_UUID", &value_to_free);
+	value = svGetValueStr (netplan, "BRIDGE_UUID", &value_to_free);
 	if (!value)
-		value = svGetValueStr (ifcfg, "BRIDGE", &value_to_free);
+		value = svGetValueStr (netplan, "BRIDGE", &value_to_free);
 	if (value) {
 		nm_clear_g_free (&value_to_free);
 
 		s_port = nm_setting_bridge_port_new ();
-		value = svGetValueStr (ifcfg, "BRIDGING_OPTS", &value_to_free);
+		value = svGetValueStr (netplan, "BRIDGING_OPTS", &value_to_free);
 		if (value) {
 			handle_bridging_opts (s_port, FALSE, value, handle_bridge_option, BRIDGE_OPT_TYPE_PORT_OPTION);
 			nm_clear_g_free (&value_to_free);
 		}
 
-		read_bridge_vlans (ifcfg,
+		read_bridge_vlans (netplan,
 		                   "BRIDGE_PORT_VLANS",
 		                   s_port,
 		                   NM_SETTING_BRIDGE_PORT_VLANS);
@@ -5313,12 +5315,12 @@ make_bridge_port_setting (shvarFile *ifcfg)
 }
 
 static NMSetting *
-make_team_port_setting (shvarFile *ifcfg)
+make_team_port_setting (shvarFile *netplan)
 {
 	NMSetting *s_port;
 	gs_free char *value = NULL;
 
-	value = svGetValueStr_cp (ifcfg, "TEAM_PORT_CONFIG");
+	value = svGetValueStr_cp (netplan, "TEAM_PORT_CONFIG");
 	if (!value)
 		return NULL;
 
@@ -5369,7 +5371,7 @@ is_wifi_device (const char *name, shvarFile *parsed)
 
 static void
 parse_prio_map_list (NMSettingVlan *s_vlan,
-                     shvarFile *ifcfg,
+                     shvarFile *netplan,
                      const char *key,
                      NMVlanPriorityMap map)
 {
@@ -5378,7 +5380,7 @@ parse_prio_map_list (NMSettingVlan *s_vlan,
 	const char *const *iter;
 	const char *v;
 
-	v = svGetValueStr (ifcfg, key, &value);
+	v = svGetValueStr (netplan, key, &value);
 	if (!v)
 		return;
 	list = nm_utils_strsplit_set (v, ",");
@@ -5392,7 +5394,7 @@ parse_prio_map_list (NMSettingVlan *s_vlan,
 }
 
 static NMSetting *
-make_vlan_setting (shvarFile *ifcfg,
+make_vlan_setting (shvarFile *netplan,
                    const char *file,
                    GError **error)
 {
@@ -5405,7 +5407,7 @@ make_vlan_setting (shvarFile *ifcfg,
 	guint32 vlan_flags = 0;
 	int gvrp, reorder_hdr;
 
-	v = svGetValueStr (ifcfg, "VLAN_ID", &value);
+	v = svGetValueStr (netplan, "VLAN_ID", &value);
 	if (v) {
 		vlan_id = _nm_utils_ascii_str_to_int64 (v, 10, 0, 4095, -1);
 		if (vlan_id == -1) {
@@ -5416,7 +5418,7 @@ make_vlan_setting (shvarFile *ifcfg,
 	}
 
 	/* Need DEVICE if we don't have a separate VLAN_ID property */
-	iface_name = svGetValueStr_cp (ifcfg, "DEVICE");
+	iface_name = svGetValueStr_cp (netplan, "DEVICE");
 	if (!iface_name && vlan_id < 0) {
 		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		                     "Missing DEVICE property; cannot determine VLAN ID.");
@@ -5426,7 +5428,7 @@ make_vlan_setting (shvarFile *ifcfg,
 	s_vlan = NM_SETTING_VLAN (nm_setting_vlan_new ());
 
 	/* Parent interface from PHYSDEV takes precedence if it exists */
-	parent = svGetValueStr_cp (ifcfg, "PHYSDEV");
+	parent = svGetValueStr_cp (netplan, "PHYSDEV");
 
 	if (iface_name) {
 		v = strchr (iface_name, '.');
@@ -5476,12 +5478,12 @@ make_vlan_setting (shvarFile *ifcfg,
 
 	vlan_flags |= NM_VLAN_FLAG_REORDER_HEADERS;
 
-	gvrp = svGetValueBoolean (ifcfg, "GVRP", -1);
+	gvrp = svGetValueBoolean (netplan, "GVRP", -1);
 	if (gvrp > 0)
 		vlan_flags |= NM_VLAN_FLAG_GVRP;
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "VLAN_FLAGS", &value);
+	v = svGetValueStr (netplan, "VLAN_FLAGS", &value);
 	if (v) {
 		gs_free const char **strv = NULL;
 		const char *const *ptr;
@@ -5497,26 +5499,26 @@ make_vlan_setting (shvarFile *ifcfg,
 		}
 	}
 
-	reorder_hdr = svGetValueBoolean (ifcfg, "REORDER_HDR", -1);
+	reorder_hdr = svGetValueBoolean (netplan, "REORDER_HDR", -1);
 	if (   reorder_hdr != -1
 	    && reorder_hdr != NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS))
 		PARSE_WARNING ("REORDER_HDR key is deprecated, use VLAN_FLAGS");
 
-	if (svGetValueBoolean (ifcfg, "MVRP", FALSE))
+	if (svGetValueBoolean (netplan, "MVRP", FALSE))
 		vlan_flags |= NM_VLAN_FLAG_MVRP;
 
 	g_object_set (s_vlan, NM_SETTING_VLAN_FLAGS, vlan_flags, NULL);
 
-	parse_prio_map_list (s_vlan, ifcfg, "VLAN_INGRESS_PRIORITY_MAP", NM_VLAN_INGRESS_MAP);
-	parse_prio_map_list (s_vlan, ifcfg, "VLAN_EGRESS_PRIORITY_MAP", NM_VLAN_EGRESS_MAP);
+	parse_prio_map_list (s_vlan, netplan, "VLAN_INGRESS_PRIORITY_MAP", NM_VLAN_INGRESS_MAP);
+	parse_prio_map_list (s_vlan, netplan, "VLAN_EGRESS_PRIORITY_MAP", NM_VLAN_EGRESS_MAP);
 
 	return NM_SETTING (g_steal_pointer (&s_vlan));
 }
 
 static NMConnection *
-vlan_connection_from_ifcfg (const char *file,
-                            shvarFile *ifcfg,
-                            GError **error)
+vlan_connection_from_netplan (const char *file,
+                              shvarFile *netplan,
+                              GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
@@ -5526,11 +5528,11 @@ vlan_connection_from_ifcfg (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (ifcfg != NULL, NULL);
+	g_return_val_if_fail (netplan != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_VLAN_SETTING_NAME, NULL, "Vlan");
+	con_setting = make_connection_setting (file, netplan, NM_SETTING_VLAN_SETTING_NAME, NULL, "Vlan");
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -5539,14 +5541,14 @@ vlan_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	vlan_setting = make_vlan_setting (ifcfg, file, error);
+	vlan_setting = make_vlan_setting (netplan, file, error);
 	if (!vlan_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
 	nm_connection_add_setting (connection, vlan_setting);
 
-	wired_setting = make_wired_setting (ifcfg, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -5564,7 +5566,7 @@ vlan_connection_from_ifcfg (const char *file,
 }
 
 static NMConnection *
-create_unhandled_connection (const char *filename, shvarFile *ifcfg,
+create_unhandled_connection (const char *filename, shvarFile *netplan,
                              const char *type, char **out_spec)
 {
 	NMConnection *connection;
@@ -5580,14 +5582,14 @@ create_unhandled_connection (const char *filename, shvarFile *ifcfg,
 	 * an empty type-specific setting as well, to make sure it passes
 	 * nm_connection_verify() later.
 	 */
-	s_con = make_connection_setting (filename, ifcfg, NM_SETTING_GENERIC_SETTING_NAME,
+	s_con = make_connection_setting (filename, netplan, NM_SETTING_GENERIC_SETTING_NAME,
 	                                 NULL, NULL);
 	nm_connection_add_setting (connection, s_con);
 
 	nm_connection_add_setting (connection, nm_setting_generic_new ());
 
 	/* Get a spec */
-	v = svGetValueStr (ifcfg, "HWADDR", &value);
+	v = svGetValueStr (netplan, "HWADDR", &value);
 	if (v) {
 		gs_free char *lower = g_ascii_strdown (v, -1);
 
@@ -5596,14 +5598,14 @@ create_unhandled_connection (const char *filename, shvarFile *ifcfg,
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "SUBCHANNELS", &value);
+	v = svGetValueStr (netplan, "SUBCHANNELS", &value);
 	if (v) {
 		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_S390_SUBCHANNELS_TAG"%s", type, v);
 		return connection;
 	}
 
 	nm_clear_g_free (&value);
-	v = svGetValueStr (ifcfg, "DEVICE", &value);
+	v = svGetValueStr (netplan, "DEVICE", &value);
 	if (v) {
 		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_INTERFACE_NAME_TAG"=%s", type, v);
 		return connection;
@@ -5614,7 +5616,7 @@ create_unhandled_connection (const char *filename, shvarFile *ifcfg,
 }
 
 static void
-check_dns_search_domains (shvarFile *ifcfg, NMSetting *s_ip4, NMSetting *s_ip6)
+check_dns_search_domains (shvarFile *netplan, NMSetting *s_ip4, NMSetting *s_ip6)
 {
 	if (!s_ip6)
 		return;
@@ -5628,7 +5630,7 @@ check_dns_search_domains (shvarFile *ifcfg, NMSetting *s_ip4, NMSetting *s_ip6)
 		gs_free char *value = NULL;
 		const char *v;
 
-		v = svGetValueStr (ifcfg, "DOMAIN", &value);
+		v = svGetValueStr (netplan, "DOMAIN", &value);
 		if (v) {
 			gs_free const char **searches = NULL;
 			const char *const *item;
@@ -5652,14 +5654,14 @@ connection_from_file_full (const char *filename,
                            GError **error,
                            gboolean *out_ignore_error)
 {
-	nm_auto_shvar_file_close shvarFile *main_ifcfg = NULL;
-	nm_auto_shvar_file_close shvarFile *network_ifcfg = NULL;
+	nm_auto_shvar_file_close shvarFile *main_netplan = NULL;
+	nm_auto_shvar_file_close shvarFile *network_netplan = NULL;
 	gs_unref_object NMConnection *connection = NULL;
 	gs_free char *type = NULL;
 	char *devtype, *bootproto;
 	NMSetting *s_ip4, *s_ip6, *s_tc, *s_proxy, *s_port, *s_dcb = NULL, *s_user;
 	NMSetting *s_sriov, *s_match;
-	const char *ifcfg_name = NULL;
+	const char *netplan_name = NULL;
 	gboolean has_ip4_defroute = FALSE;
 	gboolean has_complex_routes_v4;
 	gboolean has_complex_routes_v6;
@@ -5669,25 +5671,25 @@ connection_from_file_full (const char *filename,
 
 	NM_SET_OUT (out_ignore_error, FALSE);
 
-	/* Non-NULL only for unit tests; normally use /etc/sysconfig/network */
+	/* Non-NULL only for unit tests; normally use /etc/netplan */
 	if (!network_file)
-		network_file = SYSCONFDIR "/sysconfig/network";
+		network_file = SYSCONFDIR "/netplan";
 
-	ifcfg_name = utils_get_ifcfg_name (filename, TRUE);
-	if (!ifcfg_name) {
+	netplan_name = utils_get_netplan_name (filename, TRUE);
+	if (!netplan_name) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Ignoring connection '%s' because it's not an ifcfg file.", filename);
+		             "Ignoring connection '%s' because it's not an netplan file.", filename);
 		return NULL;
 	}
 
-	main_ifcfg = svOpenFile (filename, error);
-	if (!main_ifcfg)
+	main_netplan = svOpenFile (filename, error);
+	if (!main_netplan)
 		return NULL;
 
-	network_ifcfg = svOpenFile (network_file, NULL);
+	network_netplan = svOpenFile (network_file, NULL);
 
-	if (!svGetValueBoolean (main_ifcfg, "NM_CONTROLLED", TRUE)) {
-		connection = create_unhandled_connection (filename, main_ifcfg, "unmanaged", out_unhandled);
+	if (!svGetValueBoolean (main_netplan, "NM_CONTROLLED", TRUE)) {
+		connection = create_unhandled_connection (filename, main_netplan, "unmanaged", out_unhandled);
 		if (!connection) {
 			NM_SET_OUT (out_ignore_error, TRUE);
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
@@ -5697,7 +5699,7 @@ connection_from_file_full (const char *filename,
 	}
 
 	/* iBFT is handled by nm-initrd-generator during boot. */
-	bootproto = svGetValueStr_cp (main_ifcfg, "BOOTPROTO");
+	bootproto = svGetValueStr_cp (main_netplan, "BOOTPROTO");
 	if (bootproto && !g_ascii_strcasecmp (bootproto, "ibft")) {
 		NM_SET_OUT (out_ignore_error, TRUE);
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
@@ -5707,19 +5709,19 @@ connection_from_file_full (const char *filename,
 	}
 	g_free (bootproto);
 
-	devtype = svGetValueStr_cp (main_ifcfg, "DEVICETYPE");
+	devtype = svGetValueStr_cp (main_netplan, "DEVICETYPE");
 	if (devtype) {
 		if (!strcasecmp (devtype, TYPE_TEAM))
 			type = g_strdup (TYPE_TEAM);
 		else if (!strcasecmp (devtype, TYPE_TEAM_PORT)) {
 			gs_free char *device = NULL;
 
-			type = svGetValueStr_cp (main_ifcfg, "TYPE");
-			device = svGetValueStr_cp (main_ifcfg, "DEVICE");
+			type = svGetValueStr_cp (main_netplan, "TYPE");
+			device = svGetValueStr_cp (main_netplan, "DEVICE");
 
 			if (type) {
 				/* nothing to do */
-			} else if (device && is_vlan_device (device, main_ifcfg))
+			} else if (device && is_vlan_device (device, main_netplan))
 				type = g_strdup (TYPE_VLAN);
 			else
 				type = g_strdup (TYPE_ETHERNET);
@@ -5732,26 +5734,26 @@ connection_from_file_full (const char *filename,
 		/* Team and TeamPort types are also accepted by the mere
 		 * presence of TEAM_CONFIG/TEAM_MASTER. They don't require
 		 * DEVICETYPE. */
-		t = svGetValueStr_cp (main_ifcfg, "TEAM_CONFIG");
+		t = svGetValueStr_cp (main_netplan, "TEAM_CONFIG");
 		if (t)
 			type = g_strdup (TYPE_TEAM);
 	}
 
 	if (!type)
-		type = svGetValueStr_cp (main_ifcfg, "TYPE");
+		type = svGetValueStr_cp (main_netplan, "TYPE");
 
 	if (!type) {
 		gs_free char *tmp = NULL;
 		char *device;
 
-		if ((tmp = svGetValueStr_cp (main_ifcfg, "IPV6TUNNELIPV4"))) {
+		if ((tmp = svGetValueStr_cp (main_netplan, "IPV6TUNNELIPV4"))) {
 			NM_SET_OUT (out_ignore_error, TRUE);
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 			             "Ignoring unsupported connection due to IPV6TUNNELIPV4");
 			return NULL;
 		}
 
-		device = svGetValueStr_cp (main_ifcfg, "DEVICE");
+		device = svGetValueStr_cp (main_netplan, "DEVICE");
 		if (!device) {
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 			             "File '%s' had neither TYPE nor DEVICE keys.", filename);
@@ -5767,18 +5769,18 @@ connection_from_file_full (const char *filename,
 		}
 
 		if (!test_type) {
-			if (is_bond_device (device, main_ifcfg))
+			if (is_bond_device (device, main_netplan))
 				type = g_strdup (TYPE_BOND);
-			else if (is_vlan_device (device, main_ifcfg))
+			else if (is_vlan_device (device, main_netplan))
 				type = g_strdup (TYPE_VLAN);
-			else if (is_wifi_device (device, main_ifcfg))
+			else if (is_wifi_device (device, main_netplan))
 				type = g_strdup (TYPE_WIRELESS);
 			else {
 				gs_free char *p_path = NULL;
 				char *p_device;
 				gsize i;
 
-				/* network-functions detects DEVICETYPE based on the ifcfg-* name and the existence
+				/* network-functions detects DEVICETYPE based on the netplan-* name and the existence
 				 * of a ifup script:
 				 *    [ -z "$DEVICETYPE" ] && DEVICETYPE=$(echo ${DEVICE} | sed "s/[0-9]*$//")
 				 * later...
@@ -5837,14 +5839,14 @@ connection_from_file_full (const char *filename,
 	if (nm_streq0 (type, TYPE_ETHERNET)) {
 		gs_free char *bond_options = NULL;
 
-		if (svGetValueStr (main_ifcfg, "BONDING_OPTS", &bond_options)) {
+		if (svGetValueStr (main_netplan, "BONDING_OPTS", &bond_options)) {
 			/* initscripts consider these as bond masters */
 			g_free (type);
 			type = g_strdup (TYPE_BOND);
 		}
 	}
 
-	if (svGetValueBoolean (main_ifcfg, "BONDING_MASTER", FALSE) &&
+	if (svGetValueBoolean (main_netplan, "BONDING_MASTER", FALSE) &&
 	    strcasecmp (type, TYPE_BOND)) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "BONDING_MASTER=yes key only allowed in TYPE=bond connections");
@@ -5853,21 +5855,21 @@ connection_from_file_full (const char *filename,
 
 	/* Construct the connection */
 	if (!strcasecmp (type, TYPE_ETHERNET))
-		connection = wired_connection_from_ifcfg (filename, main_ifcfg, error);
+		connection = wired_connection_from_netplan (filename, main_netplan, error);
 	else if (!strcasecmp (type, TYPE_WIRELESS))
-		connection = wireless_connection_from_ifcfg (filename, main_ifcfg, error);
-	else if (!strcasecmp (type, TYPE_INFINIBAND))
-		connection = infiniband_connection_from_ifcfg (filename, main_ifcfg, error);
+		connection = wireless_connection_from_netplan (filename, main_netplan, error);
+	else if (!strcasecmp (type, TY  PE_INFINIBAND))
+		connection = infiniband_connection_from_netplan (filename, main_netplan, error);
 	else if (!strcasecmp (type, TYPE_BOND))
-		connection = bond_connection_from_ifcfg (filename, main_ifcfg, error);
+		connection = bond_connection_from_netplan (filename, main_netplan, error);
 	else if (!strcasecmp (type, TYPE_TEAM))
-		connection = team_connection_from_ifcfg (filename, main_ifcfg, error);
+		connection = team_connection_from_netplan (filename, main_netplan, error);
 	else if (!strcasecmp (type, TYPE_VLAN))
-		connection = vlan_connection_from_ifcfg (filename, main_ifcfg, error);
+		connection = vlan_connection_from_netplan (filename, main_netplan, error);
 	else if (!strcasecmp (type, TYPE_BRIDGE))
-		connection = bridge_connection_from_ifcfg (filename, main_ifcfg, error);
+		connection = bridge_connection_from_netplan (filename, main_netplan, error);
 	else {
-		connection = create_unhandled_connection (filename, main_ifcfg, "unrecognized", out_unhandled);
+		connection = create_unhandled_connection (filename, main_netplan, "unrecognized", out_unhandled);
 		if (!connection) {
 			PARSE_WARNING ("connection type was unrecognized but device was not uniquely identified; device may be managed");
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
@@ -5879,7 +5881,7 @@ connection_from_file_full (const char *filename,
 	if (!connection)
 		return NULL;
 
-	parse_ethtool_options (main_ifcfg, connection);
+	parse_ethtool_options (main_netplan, connection);
 
 	has_complex_routes_v4 = utils_has_complex_routes (filename, AF_INET);
 	has_complex_routes_v6 = utils_has_complex_routes (filename, AF_INET6);
@@ -5893,16 +5895,16 @@ connection_from_file_full (const char *filename,
 			PARSE_WARNING ("'rule-' and 'rule6-' files are present; you will need to use a dispatcher script to apply these routes");
 	}
 
-	s_ip6 = make_ip6_setting (main_ifcfg,
-	                          network_ifcfg,
+	s_ip6 = make_ip6_setting (main_netplan,
+	                          network_netplan,
 	                          !has_complex_routes_v4 && !has_complex_routes_v6,
 	                          error);
 	if (!s_ip6)
 		return NULL;
 	nm_connection_add_setting (connection, s_ip6);
 
-	s_ip4 = make_ip4_setting (main_ifcfg,
-	                          network_ifcfg,
+	s_ip4 = make_ip4_setting (main_netplan,
+	                          network_netplan,
 	                          !has_complex_routes_v4 && !has_complex_routes_v6,
 	                          &has_ip4_defroute,
 	                          error);
@@ -5913,16 +5915,16 @@ connection_from_file_full (const char *filename,
 	              filename);
 	nm_connection_add_setting (connection, s_ip4);
 
-	read_routing_rules (main_ifcfg,
+	read_routing_rules (main_netplan,
 	                    !has_complex_routes_v4 && !has_complex_routes_v6,
 	                    NM_SETTING_IP_CONFIG (s_ip4),
 	                    NM_SETTING_IP_CONFIG (s_ip6));
 
-	s_sriov = make_sriov_setting (main_ifcfg);
+	s_sriov = make_sriov_setting (main_netplan);
 	if (s_sriov)
 		nm_connection_add_setting (connection, s_sriov);
 
-	s_tc = make_tc_setting (main_ifcfg);
+	s_tc = make_tc_setting (main_netplan);
 	if (s_tc)
 		nm_connection_add_setting (connection, s_tc);
 
@@ -5930,29 +5932,29 @@ connection_from_file_full (const char *filename,
 	 * config fails for some reason, we read DOMAIN and put the
 	 * values into IPv6 config instead of IPv4.
 	 */
-	check_dns_search_domains (main_ifcfg, s_ip4, s_ip6);
+	check_dns_search_domains (main_netplan, s_ip4, s_ip6);
 
-	s_proxy = make_proxy_setting (main_ifcfg);
+	s_proxy = make_proxy_setting (main_netplan);
 	if (s_proxy)
 		nm_connection_add_setting (connection, s_proxy);
 
-	s_user = make_user_setting (main_ifcfg);
+	s_user = make_user_setting (main_netplan);
 	if (s_user)
 		nm_connection_add_setting (connection, s_user);
 
-	s_match = make_match_setting (main_ifcfg);
+	s_match = make_match_setting (main_netplan);
 	if (s_match)
 		nm_connection_add_setting (connection, s_match);
 
-	s_port = make_bridge_port_setting (main_ifcfg);
+	s_port = make_bridge_port_setting (main_netplan);
 	if (s_port)
 		nm_connection_add_setting (connection, s_port);
 
-	s_port = make_team_port_setting (main_ifcfg);
+	s_port = make_team_port_setting (main_netplan);
 	if (s_port)
 		nm_connection_add_setting (connection, s_port);
 
-	if (!make_dcb_setting (main_ifcfg, &s_dcb, error))
+	if (!make_dcb_setting (main_netplan, &s_dcb, error))
 		return NULL;
 	if (s_dcb)
 		nm_connection_add_setting (connection, s_dcb);
@@ -5962,6 +5964,7 @@ connection_from_file_full (const char *filename,
 
 	return g_steal_pointer (&connection);
 }
+#endif
 
 NMConnection *
 connection_from_file (const char *filename,
@@ -5969,10 +5972,13 @@ connection_from_file (const char *filename,
                       GError **error,
                       gboolean *out_ignore_error)
 {
+#if 0
 	return connection_from_file_full (filename, NULL, NULL,
 	                                  out_unhandled,
 	                                  error,
 	                                  out_ignore_error);
+#endif
+	return NULL;
 }
 
 NMConnection *
@@ -5982,10 +5988,15 @@ nmtst_connection_from_file (const char *filename,
                             char **out_unhandled,
                             GError **error)
 {
+#if 0
 	return connection_from_file_full (filename,
 	                                  network_file,
 	                                  test_type,
 	                                  out_unhandled,
 	                                  error,
 	                                  NULL);
+#endif
+	g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+	             "Not implemented yet");
+	return NULL;
 }
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.h b/src/settings/plugins/netplan/nms-netplan-reader.h
index 72e6b5144d0244323fe50d255f1fa7d64c671ccc..b26e2fe490a6c21e9dd19213d74b803bed93a148 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.h
+++ b/src/settings/plugins/netplan/nms-netplan-reader.h
@@ -1,11 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0+
 /* NetworkManager system settings service
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
  */
 
-#ifndef __NMS_IFCFG_RH_READER_H__
-#define __NMS_IFCFG_RH_READER_H__
+#ifndef __NMS_NETPLAN_READER_H__
+#define __NMS_NETPLAN_READER_H__
 
 #include "nm-connection.h"
 
@@ -20,4 +22,4 @@ NMConnection *nmtst_connection_from_file (const char *filename,
                                           char **out_unhandled,
                                           GError **error);
 
-#endif  /* __NMS_IFCFG_RH_READER_H__ */
+#endif  /* __NMS_NETPLAN_READER_H__ */
diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
new file mode 100644
index 0000000000000000000000000000000000000000..979c5803048dda8f286546784b1f7461f891665e
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -0,0 +1,263 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
+ */
+
+#include "nm-default.h"
+
+#include "nms-netplan-storage.h"
+
+#include "nm-utils.h"
+#include "nm-core-internal.h"
+#include "nms-netplan-plugin.h"
+
+/*****************************************************************************/
+
+struct _NMSNetplanStorageClass {
+	NMSettingsStorageClass parent;
+};
+
+G_DEFINE_TYPE (NMSNetplanStorage, nms_netplan_storage, NM_TYPE_SETTINGS_STORAGE)
+
+/*****************************************************************************/
+
+gboolean
+nms_netplan_storage_equal_type (const NMSNetplanStorage *self_a,
+                                const NMSNetplanStorage *self_b)
+{
+	return    (self_a == self_b)
+	       || (   self_a
+	           && self_b
+	           && nm_streq0 (nms_netplan_storage_get_uuid (self_a),
+	                         nms_netplan_storage_get_uuid (self_b))
+	           && nm_streq0 (self_a->unmanaged_spec,
+	                         self_b->unmanaged_spec)
+	           && nm_streq0 (self_a->unrecognized_spec,
+	                         self_b->unrecognized_spec));
+}
+
+void
+nms_netplan_storage_copy_content (NMSNetplanStorage *dst,
+                                  const NMSNetplanStorage *src)
+{
+	nm_assert (src != dst);
+	nm_assert (nm_streq (nms_netplan_storage_get_uuid (dst), nms_netplan_storage_get_uuid (src)));
+	nm_assert (   nms_netplan_storage_get_filename (dst)
+	           && nm_streq (nms_netplan_storage_get_filename (dst), nms_netplan_storage_get_filename (src)));
+	nm_assert (dst->storage_type == src->storage_type);
+	nm_assert (dst->is_meta_data == src->is_meta_data);
+
+	gs_unref_object NMConnection *connection_to_free = NULL;
+
+	connection_to_free = g_steal_pointer (&dst->u.conn_data.connection);
+	dst->u.conn_data = src->u.conn_data;
+	nm_g_object_ref (dst->u.conn_data.connection);
+}
+
+NMConnection *
+nms_netplan_storage_steal_connection (NMSNetplanStorage *self)
+{
+	nm_assert (NMS_IS_NETPLAN_STORAGE (self));
+	nm_assert (   self->is_meta_data
+	           || NM_IS_CONNECTION (self->u.conn_data.connection));
+
+	return   self->is_meta_data
+	       ? NULL
+	       : g_steal_pointer (&self->u.conn_data.connection);
+}
+
+/*****************************************************************************/
+
+static int
+cmp_fcn (const NMSNetplanStorage *a,
+         const NMSNetplanStorage *b)
+{
+	nm_assert (NMS_IS_NETPLAN_STORAGE (a));
+	nm_assert (NMS_IS_NETPLAN_STORAGE (b));
+	nm_assert (a != b);
+
+	/* sort by storage-type, which also has a numeric value according to their
+	 * (inverse) priority. */
+	NM_CMP_FIELD_UNSAFE (b, a, storage_type);
+
+	/* meta-data is more important. */
+	NM_CMP_FIELD_UNSAFE (a, b, is_meta_data);
+
+	if (a->is_meta_data) {
+		nm_assert (nm_streq (nms_netplan_storage_get_filename (a), nms_netplan_storage_get_filename (b)));
+		NM_CMP_FIELD_UNSAFE (a, b, u.meta_data.is_tombstone);
+	} else {
+		/* newer files are more important. */
+		NM_CMP_FIELD (a, b, u.conn_data.stat_mtime.tv_sec);
+		NM_CMP_FIELD (a, b, u.conn_data.stat_mtime.tv_nsec);
+
+		NM_CMP_DIRECT_STRCMP (nms_netplan_storage_get_filename (a), nms_netplan_storage_get_filename (b));
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+
+static void
+nms_netplan_storage_init (NMSNetplanStorage *self)
+{
+}
+
+static NMSNetplanStorage *
+_storage_new (NMSNetplanPlugin *plugin,
+              const char *uuid,
+              const char *filename,
+              gboolean is_meta_data,
+              NMSNetplanStorageType storage_type)
+
+{
+	NMSNetplanStorage *self;
+
+	nm_assert (NMS_IS_NETPLAN_PLUGIN (plugin));
+	nm_assert (nm_utils_is_uuid (uuid));
+	nm_assert (filename && filename[0] == '/');
+
+	self = g_object_new (NMS_TYPE_NETPLAN_STORAGE,
+	                     NM_SETTINGS_STORAGE_PLUGIN, plugin,
+	                     NM_SETTINGS_STORAGE_UUID, uuid,
+	                     NM_SETTINGS_STORAGE_FILENAME, filename,
+	                     NULL);
+
+	*((bool *) &self->is_meta_data) = is_meta_data;
+	*((NMSNetplanStorageType *) &self->storage_type) = storage_type;
+
+	return self;
+}
+
+NMSNetplanStorage *
+nms_netplan_storage_new_tombstone (NMSNetplanPlugin *plugin,
+                                   const char *uuid,
+                                   const char *filename,
+                                   NMSNetplanStorageType storage_type)
+{
+	NMSNetplanStorage *self;
+
+	nm_assert (nm_utils_is_uuid (uuid));
+	nm_assert (filename && filename[0] == '/');
+	nm_assert (NM_IN_SET (storage_type, NMS_NETPLAN_STORAGE_TYPE_ETC,
+	                                    NMS_NETPLAN_STORAGE_TYPE_RUN));
+
+	self = _storage_new (plugin, uuid, filename, TRUE, storage_type);
+	self->u.meta_data.is_tombstone = TRUE;
+	return self;
+}
+
+NMSNetplanStorage *
+nms_netplan_storage_new_unhandled (NMSNetplanPlugin *plugin,
+                                   const char *filename,
+                                   const char *unmanaged_spec,
+                                   const char *unrecognized_spec)
+{
+	NMSNetplanStorage *self;
+
+	nm_assert (unmanaged_spec || unrecognized_spec);
+
+	self = _storage_new (plugin,
+	                     NULL,
+	                     filename,
+			     FALSE,
+			     NMS_NETPLAN_STORAGE_TYPE_ETC);
+	self->unmanaged_spec = g_strdup (unmanaged_spec);
+	self->unrecognized_spec = g_strdup (unrecognized_spec);
+	return self;
+}
+
+NMSNetplanStorage *
+nms_netplan_storage_new_connection (NMSNetplanPlugin *plugin,
+                                    NMConnection *connection_take /* pass reference */,
+                                    const char *filename,
+                                    NMSNetplanStorageType storage_type)
+{
+	NMSNetplanStorage *self;
+
+	nm_assert (NMS_IS_NETPLAN_PLUGIN (plugin));
+	nm_assert (NM_IS_CONNECTION (connection_take));
+	nm_assert (_nm_connection_verify (connection_take, NULL) == NM_SETTING_VERIFY_SUCCESS);
+	nm_assert (filename && filename[0] == '/');
+	nm_assert (   storage_type >= NMS_NETPLAN_STORAGE_TYPE_RUN
+	           && storage_type <= _NMS_NETPLAN_STORAGE_TYPE_LIB_LAST);
+	nmtst_connection_assert_unchanging (connection_take);
+
+	self = _storage_new (plugin, nm_connection_get_uuid (connection_take), filename, FALSE, storage_type);
+
+	self->u.conn_data.connection = connection_take; /* take reference. */
+
+	return self;
+}
+
+static void
+_storage_clear (NMSNetplanStorage *self)
+{
+	c_list_unlink (&self->parent._storage_lst);
+	c_list_unlink (&self->parent._storage_by_uuid_lst);
+	g_clear_object (&self->u.conn_data.connection);
+}
+
+static void
+dispose (GObject *object)
+{
+	NMSNetplanStorage *self = NMS_NETPLAN_STORAGE (object);
+
+	_storage_clear (self);
+
+	G_OBJECT_CLASS (nms_netplan_storage_parent_class)->dispose (object);
+}
+
+void
+nms_netplan_storage_destroy (NMSNetplanStorage *self)
+{
+	_storage_clear (self);
+	g_object_unref (self);
+}
+
+static void
+nms_netplan_storage_class_init (NMSNetplanStorageClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	NMSettingsStorageClass *storage_class = NM_SETTINGS_STORAGE_CLASS (klass);
+
+	object_class->dispose = dispose;
+
+	storage_class->cmp_fcn = (int (*) (NMSettingsStorage *, NMSettingsStorage *)) cmp_fcn;
+}
+
+/*****************************************************************************/
+
+#include "settings/nm-settings-connection.h"
+
+void
+nm_settings_storage_load_sett_flags (NMSettingsStorage *self,
+                                     NMSettingsConnectionIntFlags *sett_flags,
+                                     NMSettingsConnectionIntFlags *sett_mask)
+{
+	NMSNetplanStorage *s;
+
+	*sett_flags = NM_SETTINGS_CONNECTION_INT_FLAGS_NONE;
+	*sett_mask =   NM_SETTINGS_CONNECTION_INT_FLAGS_NM_GENERATED
+	             | NM_SETTINGS_CONNECTION_INT_FLAGS_VOLATILE;
+
+	if (!NMS_IS_NETPLAN_STORAGE (self))
+		return;
+
+	s = NMS_NETPLAN_STORAGE (self);
+
+	if (s->is_meta_data)
+		return;
+	if (s->storage_type != NMS_NETPLAN_STORAGE_TYPE_RUN)
+		return;
+
+	if (s->u.conn_data.is_nm_generated)
+		*sett_flags |= NM_SETTINGS_CONNECTION_INT_FLAGS_NM_GENERATED;
+
+	if (s->u.conn_data.is_volatile)
+		*sett_flags |= NM_SETTINGS_CONNECTION_INT_FLAGS_VOLATILE;
+}
diff --git a/src/settings/plugins/netplan/nms-netplan-storage.h b/src/settings/plugins/netplan/nms-netplan-storage.h
new file mode 100644
index 0000000000000000000000000000000000000000..8585501c76143f96bec469945f2d70c2c42bc048
--- /dev/null
+++ b/src/settings/plugins/netplan/nms-netplan-storage.h
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager system settings service
+ *
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
+ */
+
+#ifndef __NMS_NETPLAN_STORAGE_H__
+#define __NMS_NETPLAN_STORAGE_H__
+
+#include "c-list/src/c-list.h"
+#include "settings/nm-settings-storage.h"
+#include "nms-netplan-utils.h"
+
+/*****************************************************************************/
+
+#define NMS_TYPE_NETPLAN_STORAGE            (nms_netplan_storage_get_type ())
+#define NMS_NETPLAN_STORAGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NMS_TYPE_NETPLAN_STORAGE, NMSNetplanStorage))
+#define NMS_NETPLAN_STORAGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NMS_TYPE_NETPLAN_STORAGE, NMSNetplanStorageClass))
+#define NMS_IS_NETPLAN_STORAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NMS_TYPE_NETPLAN_STORAGE))
+#define NMS_IS_NETPLAN_STORAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NMS_TYPE_NETPLAN_STORAGE))
+#define NMS_NETPLAN_STORAGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NMS_TYPE_NETPLAN_STORAGE, NMSNetplanStorageClass))
+
+typedef struct {
+	/* whether this is a tombstone to hide a UUID (via symlink to /dev/null). */
+	bool is_tombstone:1;
+} NMSettingsMetaData;
+
+typedef struct {
+	NMSettingsStorage parent;
+
+	NMConnection *connection;
+
+	/* The connection. Note that there are tombstones (loaded-uuid files to /dev/null)
+	 * that don't have a connection.
+	 *
+	 * Also, we don't actually remember the loaded connection after returning it
+	 * to NMSettings. So, also for regular storages (non-tombstones) this field
+	 * is often cleared. */
+	union {
+		struct {
+			NMConnection *connection;
+
+			/* the timestamp (stat's mtime) of the keyfile. For meta-data this
+			 * is irrelevant. The purpose is that if the same storage type (directory) has
+			 * multiple files with the same UUID, then the newer file gets preferred. */
+			struct timespec stat_mtime;
+
+			/* these flags are only relevant for storages with %NMS_NETPLAN_STORAGE_TYPE_RUN
+			 * (and non-metadata). This is to persist and reload these settings flags to
+			 * /run.
+			 *
+			 * Note that these flags are not stored in as meta-data. The reason is that meta-data
+			 * is per UUID. But these flags are only relevant for a particular keyfile on disk.
+			 * That is, it must be tied to the actual keyfile, and not to the UUID. */
+			bool is_nm_generated:1;
+			bool is_volatile:1;
+
+		} conn_data;
+
+		/* the content from the .nmmeta file. Note that the nmmeta file has the UUID
+		 * in the filename, that means there can be only two variants of this file:
+		 * in /etc and in /run. As such, this is really meta-data about the entire profile
+		 * (the UUID), and not about the individual keyfile. */
+		NMSettingsMetaData meta_data;
+
+	} u;
+
+	char *unmanaged_spec;
+	char *unrecognized_spec;
+
+	/* The storage type. This is directly related to the filename. Since
+	 * the filename cannot change, this value is unchanging. */
+	const NMSNetplanStorageType storage_type;
+
+	/* whether union "u" has meta_data or conn_data. Since the type of the storage
+	 * depends on the (immutable) filename, this is also const. */
+	const bool is_meta_data;
+
+	/* this flag is only used during reload to mark and prune old entries. */
+	bool is_dirty:1;
+
+} NMSNetplanStorage;
+
+typedef struct _NMSNetplanStorageClass NMSNetplanStorageClass;
+
+GType nms_netplan_storage_get_type (void);
+
+struct _NMSNetplanPlugin;
+
+NMSNetplanStorage *nms_netplan_storage_new_tombstone (struct _NMSNetplanPlugin *self,
+                                                      const char *uuid,
+                                                      const char *filename,
+                                                      NMSNetplanStorageType storage_type);
+
+NMSNetplanStorage *nms_netplan_storage_new_connection (struct _NMSNetplanPlugin *self,
+                                                       NMConnection *connection_take /* pass reference */,
+                                                       const char *filename,
+                                                       NMSNetplanStorageType storage_type);
+
+NMSNetplanStorage *nms_netplan_storage_new_unhandled (struct _NMSNetplanPlugin *plugin,
+                                                      const char *filename,
+                                                      const char *unmanaged_spec,
+                                                      const char *unrecognized_spec);
+
+void nms_netplan_storage_destroy (NMSNetplanStorage *storage);
+
+/*****************************************************************************/
+
+gboolean nms_netplan_storage_equal_type (const NMSNetplanStorage *self_a,
+                                         const NMSNetplanStorage *self_b);
+
+void nms_netplan_storage_copy_content (NMSNetplanStorage *dst,
+                                       const NMSNetplanStorage *src);
+
+NMConnection *nms_netplan_storage_steal_connection (NMSNetplanStorage *storage);
+
+/*****************************************************************************/
+
+static inline const char *
+nms_netplan_storage_get_uuid (const NMSNetplanStorage *self)
+{
+	return nm_settings_storage_get_uuid ((const NMSettingsStorage *) self);
+}
+
+static inline const char *
+nms_netplan_storage_get_filename (const NMSNetplanStorage *self)
+{
+	return nm_settings_storage_get_filename ((const NMSettingsStorage *) self);
+}
+
+/*****************************************************************************/
+
+static inline gboolean
+nm_settings_storage_is_netplan_run (const NMSettingsStorage *self)
+{
+	return    NMS_IS_NETPLAN_STORAGE (self)
+	       && (((NMSNetplanStorage *) self)->storage_type == NMS_NETPLAN_STORAGE_TYPE_RUN);
+}
+
+static inline gboolean
+nm_settings_storage_is_netplan_lib (const NMSettingsStorage *self)
+{
+	return    NMS_IS_NETPLAN_STORAGE (self)
+	       && (((NMSNetplanStorage *) self)->storage_type >= NMS_NETPLAN_STORAGE_TYPE_LIB_BASE);
+}
+
+static inline const NMSettingsMetaData *
+nm_settings_storage_is_meta_data (const NMSettingsStorage *storage)
+{
+	const NMSNetplanStorage *self;
+
+	if (!NMS_IS_NETPLAN_STORAGE (storage))
+		return NULL;
+
+	self = (NMSNetplanStorage *) storage;
+
+	if (!self->is_meta_data)
+		return NULL;
+
+	return &self->u.meta_data;
+}
+
+static inline const NMSettingsMetaData *
+nm_settings_storage_is_meta_data_alive (const NMSettingsStorage *storage)
+{
+	const NMSettingsMetaData *meta_data;
+
+	meta_data = nm_settings_storage_is_meta_data (storage);
+
+	if (!meta_data)
+		return NULL;
+
+	/* Regular (all other) storages are alive as long as they report a NMConnection, and
+	 * they will be dropped, once they have no more connection.
+	 *
+	 * Meta-data storages are special: they never report a NMConnection.
+	 * So, a meta-data storage is alive as long as it is tracked by the
+	 * settings plugin.
+	 *
+	 * This function is used to ckeck for that. */
+
+	if (c_list_is_empty (&storage->_storage_lst))
+		return NULL;
+
+	return meta_data;
+}
+
+/*****************************************************************************/
+
+enum _NMSettingsConnectionIntFlags;
+
+void nm_settings_storage_load_sett_flags (NMSettingsStorage *self,
+                                          enum _NMSettingsConnectionIntFlags *sett_flags,
+                                          enum _NMSettingsConnectionIntFlags *sett_mask);
+
+#endif /* __NMS_NETPLAN_STORAGE_H__ */
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.c b/src/settings/plugins/netplan/nms-netplan-utils.c
index f5dfdc7507398553604b0c86d2ac18530d28adc1..e745846f42c789ac8a0d8b4f48ed6f31a3bbc148 100644
--- a/src/settings/plugins/netplan/nms-netplan-utils.c
+++ b/src/settings/plugins/netplan/nms-netplan-utils.c
@@ -1,24 +1,24 @@
 // SPDX-License-Identifier: GPL-2.0+
 /* NetworkManager system settings service
  *
- * (C) Copyright 2008 - 2017 Red Hat, Inc.
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
  */
 
 #include "nm-default.h"
 
-#include "nms-ifcfg-rh-utils.h"
+#include "nms-netplan-utils.h"
 
 #include <stdlib.h>
 
 #include "nm-core-internal.h"
 #include "NetworkManagerUtils.h"
 
-#include "nms-ifcfg-rh-common.h"
-
 /*****************************************************************************/
 
 gboolean
-nms_ifcfg_rh_util_parse_unhandled_spec (const char *unhandled_spec,
+nms_netplan_util_parse_unhandled_spec (const char *unhandled_spec,
                                         const char **out_unmanaged_spec,
                                         const char **out_unrecognized_spec)
 {
@@ -79,7 +79,7 @@ check_suffix (const char *base, const char *tag)
 }
 
 gboolean
-utils_should_ignore_file (const char *filename, gboolean only_ifcfg)
+utils_should_ignore_file (const char *filename, gboolean only_netplan)
 {
 	gs_free char *base = NULL;
 
@@ -87,26 +87,7 @@ utils_should_ignore_file (const char *filename, gboolean only_ifcfg)
 
 	base = g_path_get_basename (filename);
 
-	/* Only handle ifcfg, keys, and routes files */
-	if (strncmp (base, IFCFG_TAG, strlen (IFCFG_TAG)) != 0) {
-		if (only_ifcfg)
-			return TRUE;
-		else if (   strncmp (base, KEYS_TAG, strlen (KEYS_TAG)) != 0
-		         && strncmp (base, ROUTE_TAG, strlen (ROUTE_TAG)) != 0
-		         && strncmp (base, ROUTE6_TAG, strlen (ROUTE6_TAG)) != 0)
-			return TRUE;
-	}
-
-	/* But not those that have certain suffixes */
-	if (   check_suffix (base, BAK_TAG)
-	    || check_suffix (base, TILDE_TAG)
-	    || check_suffix (base, ORIG_TAG)
-	    || check_suffix (base, REJ_TAG)
-	    || check_suffix (base, RPMNEW_TAG)
-	    || check_suffix (base, AUGNEW_TAG)
-	    || check_suffix (base, AUGTMP_TAG)
-	    || check_rpm_temp_suffix (base))
-		return TRUE;
+	// TODO: Implement any file ignore logic necessary?
 
 	return FALSE;
 }
@@ -121,7 +102,7 @@ utils_cert_path (const char *parent, const char *suffix, const char *extension)
 	g_return_val_if_fail (suffix, NULL);
 	g_return_val_if_fail (extension, NULL);
 
-	name = utils_get_ifcfg_name (parent, FALSE);
+	name = utils_get_netplan_name (parent, FALSE);
 	g_return_val_if_fail (name, NULL);
 
 	dir = g_path_get_dirname (parent);
@@ -129,7 +110,7 @@ utils_cert_path (const char *parent, const char *suffix, const char *extension)
 }
 
 const char *
-utils_get_ifcfg_name (const char *file, gboolean only_ifcfg)
+utils_get_netplan_name (const char *file, gboolean only_netplan)
 {
 	const char *name;
 
@@ -143,34 +124,10 @@ utils_get_ifcfg_name (const char *file, gboolean only_ifcfg)
 	if (!*name)
 		return NULL;
 
-#define MATCH_TAG_AND_RETURN(name, TAG) \
-	G_STMT_START { \
-		if (strncmp (name, TAG, NM_STRLEN (TAG)) == 0) { \
-			name += NM_STRLEN (TAG); \
-			if (name[0] == '\0') \
-				return NULL; \
-			else \
-				return name; \
-		} \
-	} G_STMT_END
-
-	/* Do not detect alias files and return 'eth0:0' instead of 'eth0'.
-	 * Unfortunately, we cannot be sure that our files don't contain colons,
-	 * so we cannot reject files with colons.
-	 *
-	 * Instead, you must not call utils_get_ifcfg_name() with an alias file
-	 * or files that are ignored. */
-	MATCH_TAG_AND_RETURN (name, IFCFG_TAG);
-	if (!only_ifcfg) {
-		MATCH_TAG_AND_RETURN (name, KEYS_TAG);
-		MATCH_TAG_AND_RETURN (name, ROUTE_TAG);
-		MATCH_TAG_AND_RETURN (name, ROUTE6_TAG);
-	}
-
-	return NULL;
+	return name;
 }
 
-/* Used to get any ifcfg/extra file path from any other ifcfg/extra path
+/* Used to get any netplan/extra file path from any other netplan/extra path
  * in the form <tag><name>.
  */
 static char *
@@ -186,7 +143,7 @@ utils_get_extra_path (const char *parent, const char *tag)
 	if (!dirname)
 		g_return_val_if_reached (NULL);
 
-	name = utils_get_ifcfg_name (parent, FALSE);
+	name = utils_get_netplan_name (parent, FALSE);
 	if (name) {
 		if (!strcmp (dirname, "."))
 			item_path = g_strdup_printf ("%s%s", tag, name);
@@ -198,34 +155,12 @@ utils_get_extra_path (const char *parent, const char *tag)
 	return item_path;
 }
 
-char *
-utils_get_ifcfg_path (const char *parent)
-{
-	return utils_get_extra_path (parent, IFCFG_TAG);
-}
-
-char *
-utils_get_keys_path (const char *parent)
-{
-	return utils_get_extra_path (parent, KEYS_TAG);
-}
-
-char *
-utils_get_route_path (const char *parent)
-{
-	return utils_get_extra_path (parent, ROUTE_TAG);
-}
-
-char *
-utils_get_route6_path (const char *parent)
-{
-	return utils_get_extra_path (parent, ROUTE6_TAG);
-}
 
+#if 0 // TODO: Figure out if we need to be picking these; probably not (single file for netplan)
 shvarFile *
-utils_get_extra_ifcfg (const char *parent, const char *tag, gboolean should_create)
+utils_get_extra_netplan (const char *parent, const char *tag, gboolean should_create)
 {
-	shvarFile *ifcfg = NULL;
+	shvarFile *netplan = NULL;
 	char *path;
 
 	path = utils_get_extra_path (parent, tag);
@@ -233,26 +168,27 @@ utils_get_extra_ifcfg (const char *parent, const char *tag, gboolean should_crea
 		return NULL;
 
 	if (should_create && !g_file_test (path, G_FILE_TEST_EXISTS))
-		ifcfg = svCreateFile (path);
+		netplan = svCreateFile (path);
 
-	if (!ifcfg)
-		ifcfg = svOpenFile (path, NULL);
+	if (!netplan)
+		netplan = svOpenFile (path, NULL);
 
 	g_free (path);
-	return ifcfg;
+	return netplan;
 }
 
 shvarFile *
-utils_get_keys_ifcfg (const char *parent, gboolean should_create)
+utils_get_keys_netplan (const char *parent, gboolean should_create)
 {
-	return utils_get_extra_ifcfg (parent, KEYS_TAG, should_create);
+	return utils_get_extra_netplan (parent, KEYS_TAG, should_create);
 }
 
 shvarFile *
-utils_get_route_ifcfg (const char *parent, gboolean should_create)
+utils_get_route_netplan (const char *parent, gboolean should_create)
 {
-	return utils_get_extra_ifcfg (parent, ROUTE_TAG, should_create);
+	return utils_get_extra_netplan (parent, ROUTE_TAG, should_create);
 }
+#endif
 
 /* Finds out if route file has new or older format
  * Returns TRUE  - new syntax (ADDRESS<n>=a.b.c.d ...), error opening file or empty
@@ -289,51 +225,37 @@ utils_has_complex_routes (const char *filename, int addr_family)
 {
 	g_return_val_if_fail (filename, TRUE);
 
-	if (NM_IN_SET (addr_family, AF_UNSPEC, AF_INET)) {
-		gs_free char *rules = utils_get_extra_path (filename, RULE_TAG);
-
-		if (g_file_test (rules, G_FILE_TEST_EXISTS))
-			return TRUE;
-	}
-
-	if (NM_IN_SET (addr_family, AF_UNSPEC, AF_INET6)) {
-		gs_free char *rules = utils_get_extra_path (filename, RULE6_TAG);
-		if (g_file_test (rules, G_FILE_TEST_EXISTS))
-			return TRUE;
-	}
+	// TODO: Do we need to handle complex routes specially??
 
 	return FALSE;
 }
 
-/* Find out if the 'alias' file name might be an alias file for 'ifcfg' file name,
- * or any alias when 'ifcfg' is NULL. Does not check that it's actually a valid
+/* Find out if the 'alias' file name might be an alias file for 'netplan' file name,
+ * or any alias when 'netplan' is NULL. Does not check that it's actually a valid
  * alias name; that happens in reader.c
  */
 gboolean
-utils_is_ifcfg_alias_file (const char *alias, const char *ifcfg)
+utils_is_netplan_alias_file (const char *alias, const char *netplan)
 {
 	g_return_val_if_fail (alias != NULL, FALSE);
 
-	if (strncmp (alias, IFCFG_TAG, strlen (IFCFG_TAG)))
-		return FALSE;
-
-	if (ifcfg) {
-		size_t len = strlen (ifcfg);
+	if (netplan) {
+		size_t len = strlen (netplan);
 
-		return (strncmp (alias, ifcfg, len) == 0 && alias[len] == ':');
+		return (strncmp (alias, netplan, len) == 0 && alias[len] == ':');
 	} else {
 		return (strchr (alias, ':') != NULL);
 	}
 }
 
 char *
-utils_detect_ifcfg_path (const char *path, gboolean only_ifcfg)
+utils_detect_netplan_path (const char *path, gboolean only_netplan)
 {
 	const char *base;
 
 	g_return_val_if_fail (path != NULL, NULL);
 
-	if (utils_should_ignore_file (path, only_ifcfg))
+	if (utils_should_ignore_file (path, only_netplan))
 		return NULL;
 
 	base = strrchr (path, '/');
@@ -342,39 +264,15 @@ utils_detect_ifcfg_path (const char *path, gboolean only_ifcfg)
 	else
 		base += 1;
 
-	if (NM_STR_HAS_PREFIX (base, IFCFG_TAG)) {
-		if (base[NM_STRLEN (IFCFG_TAG)] == '\0')
-			return NULL;
-		if (utils_is_ifcfg_alias_file (base, NULL)) {
-			gs_free char *ifcfg = NULL;
-			char *ptr;
-
-			ifcfg = g_strdup (path);
-			ptr = strrchr (ifcfg, ':');
-			if (   ptr
-			    && ptr > ifcfg
-			    && !strchr (ptr, '/')) {
-				*ptr = '\0';
-				if (g_file_test (ifcfg, G_FILE_TEST_EXISTS)) {
-					/* the file has a colon, so it is probably an alias.
-					 * To be ~more~ certain that this is an alias file,
-					 * check whether a corresponding base file exists. */
-					if (only_ifcfg)
-						return NULL;
-					return g_steal_pointer (&ifcfg);
-				}
-			}
-		}
-		return g_strdup (path);
-	}
-
-	if (only_ifcfg)
+	if (only_netplan)
 		return NULL;
-	return utils_get_ifcfg_path (path);
+
+	// TODO: utils_get_netplan_path (path) ???
+	return NULL;
 }
 
 void
-nms_ifcfg_rh_utils_user_key_encode (const char *key, GString *str_buffer)
+nms_netplan_utils_user_key_encode (const char *key, GString *str_buffer)
 {
 	gsize i;
 
@@ -410,7 +308,7 @@ nms_ifcfg_rh_utils_user_key_encode (const char *key, GString *str_buffer)
 }
 
 gboolean
-nms_ifcfg_rh_utils_user_key_decode (const char *name, GString *str_buffer)
+nms_netplan_utils_user_key_decode (const char *name, GString *str_buffer)
 {
 	gsize i;
 
@@ -489,7 +387,7 @@ nms_ifcfg_rh_utils_user_key_decode (const char *name, GString *str_buffer)
 
 /*****************************************************************************/
 
-const char *const _nm_ethtool_ifcfg_names[] = {
+const char *const _nm_ethtool_netplan_names[] = {
 #define ETHT_NAME(eid, ename) \
 [eid - _NM_ETHTOOL_ID_FEATURE_FIRST] = ""ename""
 	/* indexed by NMEthtoolID - _NM_ETHTOOL_ID_FEATURE_FIRST */
@@ -548,7 +446,7 @@ const char *const _nm_ethtool_ifcfg_names[] = {
 };
 
 const NMEthtoolData *
-nms_ifcfg_rh_utils_get_ethtool_by_name (const char *name)
+nms_netplan_utils_get_ethtool_by_name (const char *name)
 {
 	static const struct {
 		NMEthtoolID ethtool_id;
@@ -565,8 +463,8 @@ nms_ifcfg_rh_utils_get_ethtool_by_name (const char *name)
 	};
 	guint i;
 
-	for (i = 0; i < G_N_ELEMENTS (_nm_ethtool_ifcfg_names); i++) {
-		if (nm_streq (name, _nm_ethtool_ifcfg_names[i]))
+	for (i = 0; i < G_N_ELEMENTS (_nm_ethtool_netplan_names); i++) {
+		if (nm_streq (name, _nm_ethtool_netplan_names[i]))
 			return nm_ethtool_data[i];
 	}
 
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.h b/src/settings/plugins/netplan/nms-netplan-utils.h
index e0308178cf8ebc123d7a80672ac9fdb42c986685..bcd3ce8a212fe7a61cc49e2adcb92e82ceb12186 100644
--- a/src/settings/plugins/netplan/nms-netplan-utils.h
+++ b/src/settings/plugins/netplan/nms-netplan-utils.h
@@ -1,7 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0+
 /* NetworkManager system settings service
  *
- * (C) Copyright 2008 - 2017 Red Hat, Inc.
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
  */
 
 #ifndef _UTILS_H_
@@ -10,81 +12,67 @@
 #include "nm-connection.h"
 #include "nm-libnm-core-intern/nm-ethtool-utils.h"
 
-#include "shvar.h"
+typedef enum {
+	NMS_NETPLAN_STORAGE_TYPE_RUN       = 1, /* read-write, runtime only, e.g. /run */
+	NMS_NETPLAN_STORAGE_TYPE_ETC       = 2, /* read-write, persistent,   e.g. /etc     */
+	NMS_NETPLAN_STORAGE_TYPE_LIB_BASE  = 3, /* read-only,                e.g. /usr/lib */
 
-gboolean nms_ifcfg_rh_util_parse_unhandled_spec (const char *unhandled_spec,
-                                                 const char **out_unmanaged_spec,
-                                                 const char **out_unrecognized_spec);
+	_NMS_NETPLAN_STORAGE_TYPE_LIB_LAST = 1000,
+} NMSNetplanStorageType;
 
-#define NM_IFCFG_CONNECTION_LOG_PATH(path)  ((path) ?: "in-memory")
-#define NM_IFCFG_CONNECTION_LOG_FMT         "%s (%s,\"%s\")"
-#define NM_IFCFG_CONNECTION_LOG_ARG(con)    NM_IFCFG_CONNECTION_LOG_PATH (nm_settings_connection_get_filename ((NMSettingsConnection *) (con))), nm_settings_connection_get_uuid ((NMSettingsConnection *) (con)), nm_settings_connection_get_id ((NMSettingsConnection *) (con))
-#define NM_IFCFG_CONNECTION_LOG_FMTD        "%s (%s,\"%s\",%p)"
-#define NM_IFCFG_CONNECTION_LOG_ARGD(con)   NM_IFCFG_CONNECTION_LOG_PATH (nm_settings_connection_get_filename ((NMSettingsConnection *) (con))), nm_settings_connection_get_uuid ((NMSettingsConnection *) (con)), nm_settings_connection_get_id ((NMSettingsConnection *) (con)), (con)
+static inline NMSNetplanStorageType
+NMS_NETPLAN_STORAGE_TYPE_LIB (guint run_idx)
+{
+	nm_assert (run_idx <= (_NMS_NETPLAN_STORAGE_TYPE_LIB_LAST - NMS_NETPLAN_STORAGE_TYPE_LIB_BASE));
+	return NMS_NETPLAN_STORAGE_TYPE_LIB_BASE + run_idx;
+}
 
-char *utils_cert_path (const char *parent, const char *suffix, const char *extension);
+gboolean nms_netplan_util_parse_unhandled_spec (const char *unhandled_spec,
+                                                const char **out_unmanaged_spec,
+                                                const char **out_unrecognized_spec);
+
+#define NM_NETPLAN_CONNECTION_LOG_PATH(path)  ((path) ?: "in-memory")
+#define NM_NETPLAN_CONNECTION_LOG_FMT         "%s (%s,\"%s\")"
+#define NM_NETPLAN_CONNECTION_LOG_ARG(con)    NM_NETPLAN_CONNECTION_LOG_PATH (nm_settings_connection_get_filename ((NMSettingsConnection *) (con))), nm_settings_connection_get_uuid ((NMSettingsConnection *) (con)), nm_settings_connection_get_id ((NMSettingsConnection *) (con))
+#define NM_NETPLAN_CONNECTION_LOG_FMTD        "%s (%s,\"%s\",%p)"
+#define NM_NETPLAN_CONNECTION_LOG_ARGD(con)   NM_NETPLAN_CONNECTION_LOG_PATH (nm_settings_connection_get_filename ((NMSettingsConnection *) (con))), nm_settings_connection_get_uuid ((NMSettingsConnection *) (con)), nm_settings_connection_get_id ((NMSettingsConnection *) (con)), (con)
 
-const char *utils_get_ifcfg_name (const char *file, gboolean only_ifcfg);
+char *utils_cert_path (const char *parent, const char *suffix, const char *extension);
 
-gboolean utils_should_ignore_file (const char *filename, gboolean only_ifcfg);
+const char *utils_get_netplan_name (const char *file, gboolean only_netplan);
 
-char *utils_get_ifcfg_path (const char *parent);
-char *utils_get_keys_path (const char *parent);
-char *utils_get_route_path (const char *parent);
-char *utils_get_route6_path (const char *parent);
+gboolean utils_should_ignore_file (const char *filename, gboolean only_netplan);
 
-shvarFile *utils_get_extra_ifcfg (const char *parent, const char *tag, gboolean should_create);
-shvarFile *utils_get_keys_ifcfg (const char *parent, gboolean should_create);
-shvarFile *utils_get_route_ifcfg (const char *parent, gboolean should_create);
+#if 0 // See C file...
+shvarFile *utils_get_extra_netplan (const char *parent, const char *tag, gboolean should_create);
+shvarFile *utils_get_keys_netplan (const char *parent, gboolean should_create);
+shvarFile *utils_get_route_netplan (const char *parent, gboolean should_create);
+#endif
 
 gboolean utils_has_route_file_new_syntax (const char *filename);
 gboolean utils_has_complex_routes (const char *filename, int addr_family);
 
-gboolean utils_is_ifcfg_alias_file (const char *alias, const char *ifcfg);
-
-char *utils_detect_ifcfg_path (const char *path, gboolean only_ifcfg);
+gboolean utils_is_netplan_alias_file (const char *alias, const char *netplan);
 
-void nms_ifcfg_rh_utils_user_key_encode (const char *key, GString *str_buffer);
-gboolean nms_ifcfg_rh_utils_user_key_decode (const char *name, GString *str_buffer);
+char *utils_detect_netplan_path (const char *path, gboolean only_netplan);
 
-static inline const char *
-_nms_ifcfg_rh_utils_numbered_tag (char *buf, gsize buf_len, const char *tag_name, int which)
-{
-	gsize l;
-
-	l = g_strlcpy (buf, tag_name, buf_len);
-	nm_assert (l < buf_len);
-	if (which != -1) {
-		buf_len -= l;
-		l = g_snprintf (&buf[l], buf_len, "%d", which);
-		nm_assert (l < buf_len);
-	}
-	return buf;
-}
-#define numbered_tag(buf, tag_name, which) \
-	({ \
-		_nm_unused char *const _buf = (buf); \
-		\
-		/* some static assert trying to ensure that the buffer is statically allocated.
-		 * It disallows a buffer size of sizeof(gpointer) to catch that. */ \
-		G_STATIC_ASSERT (G_N_ELEMENTS (buf) == sizeof (buf) && sizeof (buf) != sizeof (char *) && sizeof (buf) < G_MAXINT); \
-		_nms_ifcfg_rh_utils_numbered_tag (buf, sizeof (buf), ""tag_name"", (which)); \
-	})
+void nms_netplan_utils_user_key_encode (const char *key, GString *str_buffer);
+gboolean nms_netplan_utils_user_key_decode (const char *name, GString *str_buffer);
 
 /*****************************************************************************/
 
-extern const char *const _nm_ethtool_ifcfg_names[_NM_ETHTOOL_ID_FEATURE_NUM];
+extern const char *const _nm_ethtool_netplan_names[_NM_ETHTOOL_ID_FEATURE_NUM];
 
 static inline const char *
-nms_ifcfg_rh_utils_get_ethtool_name (NMEthtoolID ethtool_id)
+nms_netplan_utils_get_ethtool_name (NMEthtoolID ethtool_id)
 {
 	nm_assert (ethtool_id >= _NM_ETHTOOL_ID_FEATURE_FIRST && ethtool_id <= _NM_ETHTOOL_ID_FEATURE_LAST);
-	nm_assert ((ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST) < G_N_ELEMENTS (_nm_ethtool_ifcfg_names));
-	nm_assert (_nm_ethtool_ifcfg_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST]);
+	nm_assert ((ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST) < G_N_ELEMENTS (_nm_ethtool_netplan_names));
+	nm_assert (_nm_ethtool_netplan_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST]);
 
-	return _nm_ethtool_ifcfg_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST];
+	return _nm_ethtool_netplan_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST];
 }
 
-const NMEthtoolData *nms_ifcfg_rh_utils_get_ethtool_by_name (const char *name);
+const NMEthtoolData *nms_netplan_utils_get_ethtool_by_name (const char *name);
 
 #endif  /* _UTILS_H_ */
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 7dc054fb823e21fa0aa7396c0910bc0e208cb62a..feb4c48fd1d414ad9743213959e3cf7ef79194cb 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1,12 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0+
-/* NetworkManager system settings service - keyfile plugin
+/* NetworkManager system settings service
  *
- * Copyright 2009 - 2015 Red Hat, Inc.
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
  */
 
 #include "nm-default.h"
 
-#include "nms-ifcfg-rh-writer.h"
+#include "nms-netplan-writer.h"
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -16,6 +18,8 @@
 #include <unistd.h>
 #include <stdio.h>
 
+#include <gio/gio.h>
+
 #include "nm-glib-aux/nm-enum-utils.h"
 #include "nm-glib-aux/nm-io-utils.h"
 #include "nm-manager.h"
@@ -38,15 +42,13 @@
 #include "nm-meta-setting.h"
 #include "nm-libnm-core-intern/nm-ethtool-utils.h"
 
-#include "nms-ifcfg-rh-common.h"
-#include "nms-ifcfg-rh-reader.h"
-#include "nms-ifcfg-rh-utils.h"
-#include "shvar.h"
+#include "nms-netplan-reader.h"
+#include "nms-netplan-utils.h"
 
 /*****************************************************************************/
 
 #define _NMLOG_DOMAIN      LOGD_SETTINGS
-#define _NMLOG_PREFIX_NAME "ifcfg-rh"
+#define _NMLOG_PREFIX_NAME "netplan"
 #define _NMLOG(level, ...) \
     G_STMT_START { \
         nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
@@ -58,17 +60,18 @@
 /*****************************************************************************/
 
 static void
-save_secret_flags (shvarFile *ifcfg,
+save_secret_flags (GOutputStream *netplan,
                    const char *key,
                    NMSettingSecretFlags flags)
 {
+#if 0 // TODO: we don't do secret_flags yet.
 	GString *str;
 
-	g_return_if_fail (ifcfg != NULL);
+	g_return_if_fail (netplan != NULL);
 	g_return_if_fail (key != NULL);
 
 	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
-		svUnsetValue (ifcfg, key);
+		svUnsetValue (netplan, key);
 		return;
 	}
 
@@ -89,46 +92,51 @@ save_secret_flags (shvarFile *ifcfg,
 		g_string_append (str, SECRET_FLAG_NOT_REQUIRED);
 	}
 
-	svSetValueStr (ifcfg, key, str->len ? str->str : NULL);
+	svSetValueStr (netplan, key, str->len ? str->str : NULL);
 	g_string_free (str, TRUE);
+#endif
 }
 
 static void
-set_secret (shvarFile *ifcfg,
+set_secret (GOutputStream *netplan,
             GHashTable *secrets,
             const char *key,
             const char *value,
             const char *flags_key,
             NMSettingSecretFlags flags)
 {
-	/* Clear the secret from the ifcfg and the associated "keys" file */
-	svUnsetValue (ifcfg, key);
+	// TODO: check how to handle secret flags -- toggles for special behavior of secrets.
+#if 0 // TODO: set_secret(): we write secrets directly to the main YAML file for netplan
+	/* Clear the secret from the netplan and the associated "keys" file */
+	svUnsetValue (netplan, key);
 
 	/* Save secret flags */
-	save_secret_flags (ifcfg, flags_key, flags);
+	save_secret_flags (netplan, flags_key, flags);
 
 	/* Only write the secret if it's system owned and supposed to be saved */
 	if (flags != NM_SETTING_SECRET_FLAG_NONE)
 		value = NULL;
 
 	g_hash_table_replace (secrets, g_strdup (key), g_strdup (value));
+#endif
 }
 
 static gboolean
-write_secrets (shvarFile *ifcfg,
+write_secrets (GOutputStream *netplan,
                GHashTable *secrets,
                GError **error)
 {
+#if 0  // TODO: write_secrets(): we don't write secrets to a separate file for netplan...
 	nm_auto_shvar_file_close shvarFile *keyfile = NULL;
 	gs_free const char **secrets_keys = NULL;
 	guint i, secrets_keys_n;
 	GError *local = NULL;
 	gboolean any_secrets = FALSE;
 
-	keyfile = utils_get_keys_ifcfg (svFileGetName (ifcfg), TRUE);
+	keyfile = utils_get_keys_netplan (svFileGetName (netplan), TRUE);
 	if (!keyfile) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Failure to create secrets file for '%s'", svFileGetName (ifcfg));
+		             "Failure to create secrets file for '%s'", svFileGetName (netplan));
 		return FALSE;
 	}
 
@@ -153,33 +161,34 @@ write_secrets (shvarFile *ifcfg,
 		             "Failure to write secrets to '%s': %s", svFileGetName (keyfile), local->message);
 		return FALSE;
 	}
-
+#endif
 	return TRUE;
 }
 
 typedef struct {
 	const NMSetting8021xSchemeVtable *vtable;
-	const char *ifcfg_rh_key;
+	const char *netplan_key;
 } Setting8021xSchemeVtable;
 
+// TODO: implement Phase2 auth blobs for 802.1x...
 static const Setting8021xSchemeVtable setting_8021x_scheme_vtable[] = {
-#define _D(_scheme_type, _ifcfg_rh_key) \
+#define _D(_scheme_type, _netplan_key) \
 	[(_scheme_type)] = { \
 		.vtable       = &nm_setting_8021x_scheme_vtable[(_scheme_type)], \
-		.ifcfg_rh_key = ""_ifcfg_rh_key"", \
-	}
-	_D (NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT,            "IEEE_8021X_CA_CERT"),
-	_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT,     "IEEE_8021X_INNER_CA_CERT"),
-	_D (NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT,        "IEEE_8021X_CLIENT_CERT"),
-	_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT, "IEEE_8021X_INNER_CLIENT_CERT"),
-	_D (NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY,        "IEEE_8021X_PRIVATE_KEY"),
-	_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_PRIVATE_KEY, "IEEE_8021X_INNER_PRIVATE_KEY"),
+		.netplan_key = ""_netplan_key"", \
+	}
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT,            "ca-certificate"),
+	//_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT,     "inner-ca-certificate"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT,        "client-certificate"),
+	//_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT, "inner-client-certificate"),
+	_D (NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY,        "client-key"),
+	//_D (NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_PRIVATE_KEY, "IEEE_8021X_INNER_PRIVATE_KEY"),
 #undef _D
 };
 
 static gboolean
 write_object (NMSetting8021x *s_8021x,
-              shvarFile *ifcfg,
+              GOutputStream *netplan,
               GHashTable *secrets,
               GHashTable *blobs,
               const Setting8021xSchemeVtable *objtype,
@@ -196,7 +205,7 @@ write_object (NMSetting8021x *s_8021x,
 	const char *extension;
 	char *standard_file;
 
-	g_return_val_if_fail (ifcfg != NULL, FALSE);
+	g_return_val_if_fail (netplan != NULL, FALSE);
 	g_return_val_if_fail (objtype != NULL, FALSE);
 
 	scheme = (*(objtype->vtable->scheme_func))(s_8021x);
@@ -219,34 +228,40 @@ write_object (NMSetting8021x *s_8021x,
 	}
 
 	/* Set the password for certificate/private key. */
-	nm_sprintf_buf (secret_name, "%s_PASSWORD", objtype->ifcfg_rh_key);
-	nm_sprintf_buf (secret_flags, "%s_PASSWORD_FLAGS", objtype->ifcfg_rh_key);
+	//nm_sprintf_buf (secret_flags, "%s_PASSWORD_FLAGS", objtype->netplan_key);
+	//flags = (*(objtype->vtable->pwflag_func))(s_8021x);
+	//set_secret (netplan, secrets, secret_name, password, secret_flags, flags);
 	password = (*(objtype->vtable->passwd_func))(s_8021x);
-	flags = (*(objtype->vtable->pwflag_func))(s_8021x);
-	set_secret (ifcfg, secrets, secret_name, password, secret_flags, flags);
-
-	if (!objtype->vtable->format_func)
-		extension = "der";
-	else if (objtype->vtable->format_func (s_8021x) == NM_SETTING_802_1X_CK_FORMAT_PKCS12)
-		extension = "p12";
-	else
-		extension = "pem";
+	if (password)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "          %s-password: \"%s\"\n",
+			                objtype->netplan_key, password);
 
 	/* If the object path was specified, prefer that over any raw cert data that
 	 * may have been sent.
 	 */
 	if (value) {
-		svSetValueStr (ifcfg, objtype->ifcfg_rh_key, value);
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "          %s: %s\n",
+				        objtype->netplan_key, value);
 		return TRUE;
 	}
 
+#if 0 // TODO: netplan does not yet support saving binary certs instead of paths
+	if (!objtype->vtable->format_func)
+		extension = "der";
+	else if (objtype->vtable->format_func (s_8021x) == NM_SETTING_802_1X_CK_FORMAT_PKCS12)
+		extension = "p12";
+	else
+		extension = "pem";
+
 	/* If it's raw certificate data, write the data out to the standard file */
 	if (blob) {
 		char *new_file;
 
-		new_file = utils_cert_path (svFileGetName (ifcfg), objtype->vtable->file_suffix, extension);
+		new_file = utils_cert_path (svFileGetName (netplan), objtype->vtable->file_suffix, extension);
 		g_hash_table_replace (blobs, new_file, g_bytes_ref (blob));
-		svSetValueStr (ifcfg, objtype->ifcfg_rh_key, new_file);
+		svSetValueStr (netplan, objtype->netplan_key, new_file);
 		return TRUE;
 	}
 
@@ -259,10 +274,11 @@ write_object (NMSetting8021x *s_8021x,
 	 * /etc/sysconfig/network-scripts/ca-cert-Test_Write_Wifi_WPA_EAP-TLS.der
 	 * will be deleted, but /etc/pki/tls/cert.pem will not.
 	 */
-	standard_file = utils_cert_path (svFileGetName (ifcfg), objtype->vtable->file_suffix, extension);
+	standard_file = utils_cert_path (svFileGetName (netplan), objtype->vtable->file_suffix, extension);
 	g_hash_table_replace (blobs, standard_file, NULL);
-	svSetValue (ifcfg, objtype->ifcfg_rh_key, force_write ? "" : NULL);
-	return TRUE;
+	svSetValue (netplan, objtype->netplan_key, force_write ? "" : NULL);
+#endif
+	return FALSE;
 }
 
 static gboolean
@@ -272,6 +288,7 @@ write_blobs (GHashTable *blobs, GError **error)
 	const char *filename;
 	GBytes *blob;
 
+#if 0 // TODO: netplan does not yet support saving binary blobs in yaml (802.1x certs)
 	if (!blobs)
 		return TRUE;
 
@@ -301,6 +318,7 @@ write_blobs (GHashTable *blobs, GError **error)
 			return FALSE;
 		}
 	}
+#endif
 
 	return TRUE;
 }
@@ -310,14 +328,14 @@ write_8021x_certs (NMSetting8021x *s_8021x,
                    GHashTable *secrets,
                    GHashTable *blobs,
                    gboolean phase2,
-                   shvarFile *ifcfg,
+                   GOutputStream *netplan,
                    GError **error)
 {
 	const Setting8021xSchemeVtable *pk_otype = NULL;
 	gs_free char *value_to_free = NULL;
 
 	/* CA certificate */
-	if (!write_object (s_8021x, ifcfg, secrets, blobs,
+	if (!write_object (s_8021x, netplan, secrets, blobs,
 	                   phase2
 	                       ? &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT]
 	                       : &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT],
@@ -332,7 +350,7 @@ write_8021x_certs (NMSetting8021x *s_8021x,
 		pk_otype = &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY];
 
 	/* Save the private key */
-	if (!write_object (s_8021x, ifcfg, secrets, blobs, pk_otype, FALSE, error))
+	if (!write_object (s_8021x, netplan, secrets, blobs, pk_otype, FALSE, error))
 		return FALSE;
 
 	/* Save the client certificate.
@@ -341,11 +359,11 @@ write_8021x_certs (NMSetting8021x *s_8021x,
 	 * doesn't have to read the private key file to determine if it
 	 * is a PKCS #12 one which serves also as client certificate.
 	 */
-	if (!write_object (s_8021x, ifcfg, secrets, blobs,
+	if (!write_object (s_8021x, netplan, secrets, blobs,
 	                   phase2
 	                       ? &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT]
 	                       : &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT],
-	                   !!svGetValue (ifcfg, pk_otype->ifcfg_rh_key, &value_to_free),
+	                   FALSE, // XXX: may need adjustment; ifcfg-rh uses a conditional here.
 	                   error))
 		return FALSE;
 
@@ -354,7 +372,7 @@ write_8021x_certs (NMSetting8021x *s_8021x,
 
 static gboolean
 write_8021x_setting (NMConnection *connection,
-                     shvarFile *ifcfg,
+                     GOutputStream *netplan,
                      GHashTable *secrets,
                      GHashTable *blobs,
                      gboolean wired,
@@ -365,7 +383,6 @@ write_8021x_setting (NMConnection *connection,
 	const char *value, *match;
 	gconstpointer ptr;
 	GBytes* bytes;
-	char *tmp = NULL;
 	GString *phase2_auth;
 	GString *str;
 	guint32 i, num;
@@ -373,46 +390,58 @@ write_8021x_setting (NMConnection *connection,
 	int vint;
 
 	s_8021x = nm_connection_get_setting_802_1x (connection);
-	if (!s_8021x) {
-		/* If wired, clear KEY_MGMT */
-		if (wired)
-			svUnsetValue (ifcfg, "KEY_MGMT");
+	if (!s_8021x)
 		return TRUE;
-	}
 
 	/* If wired, write KEY_MGMT */
 	if (wired)
-		svSetValueStr (ifcfg, "KEY_MGMT", "IEEE8021X");
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "        key-management: %s\n", "802.1x");
 
 	/* EAP method */
 	if (nm_setting_802_1x_get_num_eap_methods (s_8021x)) {
 		value = nm_setting_802_1x_get_eap_method (s_8021x, 0);
-		if (value)
-			tmp = g_ascii_strup (value, -1);
+		// TODO: For 802.1x: NetworkManager has a bunch of extra "EAP" methods that we should support.
+		// See eap_methods_table  in libnm-core/nm-setting-8021x.c
+		if (!g_strcmp0(value, "peap") || !g_strcmp0(value, "tls") || !g_strcmp0(value, "ttls")) {
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+					        "        method: %s\n", value);
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Unsupported '%s' method in netplan", value);
+		}
+		return FALSE;
 	}
-	svSetValueStr (ifcfg, "IEEE_8021X_EAP_METHODS", tmp);
-	g_free (tmp);
 
-	svSetValueStr (ifcfg, "IEEE_8021X_IDENTITY",
-	               nm_setting_802_1x_get_identity (s_8021x));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        identity: %s\n",
+	                        nm_setting_802_1x_get_identity (s_8021x));
 
-	svSetValueStr (ifcfg, "IEEE_8021X_ANON_IDENTITY",
-	               nm_setting_802_1x_get_anonymous_identity (s_8021x));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        anonymous-identity: %s\n",
+	                        nm_setting_802_1x_get_anonymous_identity (s_8021x));
 
-	set_secret (ifcfg,
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        password: %s\n",
+			        nm_setting_802_1x_get_password(s_8021x));
+
+#if 0 // TODO: 802.1x use set_secret instead of g_output_stream_printf()...
+	set_secret (netplan,
 	            secrets,
 	            "IEEE_8021X_PASSWORD",
 	            nm_setting_802_1x_get_password (s_8021x),
 	            "IEEE_8021X_PASSWORD_FLAGS",
 	            nm_setting_802_1x_get_password_flags (s_8021x));
+#endif
 
+#if 0 // TODO: 802.1x complex EAP / PEAP and other auth settings
 	tmp = NULL;
 	bytes = nm_setting_802_1x_get_password_raw (s_8021x);
 	if (bytes) {
 		ptr = g_bytes_get_data (bytes, &size);
 		tmp = nm_utils_bin2hexstr (ptr, size, -1);
 	}
-	set_secret (ifcfg,
+	set_secret (netplan,
 	            secrets,
 	            "IEEE_8021X_PASSWORD_RAW",
 	            tmp,
@@ -422,36 +451,36 @@ write_8021x_setting (NMConnection *connection,
 
 	/* PEAP version */
 	value = nm_setting_802_1x_get_phase1_peapver (s_8021x);
-	svUnsetValue (ifcfg, "IEEE_8021X_PEAP_VERSION");
+	svUnsetValue (netplan, "IEEE_8021X_PEAP_VERSION");
 	if (value && (!strcmp (value, "0") || !strcmp (value, "1")))
-		svSetValueStr (ifcfg, "IEEE_8021X_PEAP_VERSION", value);
+		svSetValueStr (netplan, "IEEE_8021X_PEAP_VERSION", value);
 
 	/* Force new PEAP label */
 	value = nm_setting_802_1x_get_phase1_peaplabel (s_8021x);
-	svUnsetValue (ifcfg, "IEEE_8021X_PEAP_FORCE_NEW_LABEL");
+	svUnsetValue (netplan, "IEEE_8021X_PEAP_FORCE_NEW_LABEL");
 	if (value && !strcmp (value, "1"))
-		svSetValueStr (ifcfg, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", "yes");
+		svSetValueStr (netplan, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", "yes");
 
 	/* PAC file */
 	value = nm_setting_802_1x_get_pac_file (s_8021x);
-	svUnsetValue (ifcfg, "IEEE_8021X_PAC_FILE");
+	svUnsetValue (netplan, "IEEE_8021X_PAC_FILE");
 	if (value)
-		svSetValueStr (ifcfg, "IEEE_8021X_PAC_FILE", value);
+		svSetValueStr (netplan, "IEEE_8021X_PAC_FILE", value);
 
 	/* FAST PAC provisioning */
 	value = nm_setting_802_1x_get_phase1_fast_provisioning (s_8021x);
-	svUnsetValue (ifcfg, "IEEE_8021X_FAST_PROVISIONING");
+	svUnsetValue (netplan, "IEEE_8021X_FAST_PROVISIONING");
 	if (value) {
 		if (strcmp (value, "1") == 0)
-			svSetValueStr (ifcfg, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth");
+			svSetValueStr (netplan, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth");
 		else if (strcmp (value, "2") == 0)
-			svSetValueStr (ifcfg, "IEEE_8021X_FAST_PROVISIONING", "allow-auth");
+			svSetValueStr (netplan, "IEEE_8021X_FAST_PROVISIONING", "allow-auth");
 		else if (strcmp (value, "3") == 0)
-			svSetValueStr (ifcfg, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth allow-auth");
+			svSetValueStr (netplan, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth allow-auth");
 	}
 
 	/* Phase2 auth methods */
-	svUnsetValue (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS");
+	svUnsetValue (netplan, "IEEE_8021X_INNER_AUTH_METHODS");
 	phase2_auth = g_string_new (NULL);
 
 	value = nm_setting_802_1x_get_phase2_auth (s_8021x);
@@ -473,25 +502,25 @@ write_8021x_setting (NMConnection *connection,
 
 	auth_flags = nm_setting_802_1x_get_phase1_auth_flags (s_8021x);
 	if (auth_flags == NM_SETTING_802_1X_AUTH_FLAGS_NONE) {
-		svUnsetValue (ifcfg, "IEEE_8021X_PHASE1_AUTH_FLAGS");
+		svUnsetValue (netplan, "IEEE_8021X_PHASE1_AUTH_FLAGS");
 	} else {
-		svSetValueEnum (ifcfg, "IEEE_8021X_PHASE1_AUTH_FLAGS",
+		svSetValueEnum (netplan, "IEEE_8021X_PHASE1_AUTH_FLAGS",
 		                nm_setting_802_1x_auth_flags_get_type(),
 		                auth_flags);
 	}
 
-	svSetValueStr (ifcfg, "IEEE_8021X_INNER_AUTH_METHODS",
+	svSetValueStr (netplan, "IEEE_8021X_INNER_AUTH_METHODS",
 	               phase2_auth->len ? phase2_auth->str : NULL);
 
 	g_string_free (phase2_auth, TRUE);
 
-	svSetValueStr (ifcfg, "IEEE_8021X_SUBJECT_MATCH",
+	svSetValueStr (netplan, "IEEE_8021X_SUBJECT_MATCH",
 	               nm_setting_802_1x_get_subject_match (s_8021x));
 
-	svSetValueStr (ifcfg, "IEEE_8021X_PHASE2_SUBJECT_MATCH",
+	svSetValueStr (netplan, "IEEE_8021X_PHASE2_SUBJECT_MATCH",
 	               nm_setting_802_1x_get_phase2_subject_match (s_8021x));
 
-	svUnsetValue (ifcfg, "IEEE_8021X_ALTSUBJECT_MATCHES");
+	svUnsetValue (netplan, "IEEE_8021X_ALTSUBJECT_MATCHES");
 	str = g_string_new (NULL);
 	num = nm_setting_802_1x_get_num_altsubject_matches (s_8021x);
 	for (i = 0; i < num; i++) {
@@ -501,10 +530,10 @@ write_8021x_setting (NMConnection *connection,
 		g_string_append (str, match);
 	}
 	if (str->len > 0)
-		svSetValueStr (ifcfg, "IEEE_8021X_ALTSUBJECT_MATCHES", str->str);
+		svSetValueStr (netplan, "IEEE_8021X_ALTSUBJECT_MATCHES", str->str);
 	g_string_free (str, TRUE);
 
-	svUnsetValue (ifcfg, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES");
+	svUnsetValue (netplan, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES");
 	str = g_string_new (NULL);
 	num = nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x);
 	for (i = 0; i < num; i++) {
@@ -514,33 +543,35 @@ write_8021x_setting (NMConnection *connection,
 		g_string_append (str, match);
 	}
 	if (str->len > 0)
-		svSetValueStr (ifcfg, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES", str->str);
+		svSetValueStr (netplan, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES", str->str);
 	g_string_free (str, TRUE);
 
-	svSetValueStr (ifcfg, "IEEE_8021X_DOMAIN_SUFFIX_MATCH",
+	svSetValueStr (netplan, "IEEE_8021X_DOMAIN_SUFFIX_MATCH",
 	               nm_setting_802_1x_get_domain_suffix_match (s_8021x));
-	svSetValueStr (ifcfg, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH",
+	svSetValueStr (netplan, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH",
 	               nm_setting_802_1x_get_phase2_domain_suffix_match (s_8021x));
 
 	vint = nm_setting_802_1x_get_auth_timeout (s_8021x);
-	svSetValueInt64_cond (ifcfg, "IEEE_8021X_AUTH_TIMEOUT", vint > 0, vint);
+	svSetValueInt64_cond (netplan, "IEEE_8021X_AUTH_TIMEOUT", vint > 0, vint);
+#endif
 
-	if (!write_8021x_certs (s_8021x, secrets, blobs, FALSE, ifcfg, error))
+#if 0 // TODO: 802.1x certs in binary / path
+	if (!write_8021x_certs (s_8021x, secrets, blobs, FALSE, netplan, error))
 		return FALSE;
 
 	/* phase2/inner certs */
-	if (!write_8021x_certs (s_8021x, secrets, blobs, TRUE, ifcfg, error))
+	if (!write_8021x_certs (s_8021x, secrets, blobs, TRUE, netplan, error))
 		return FALSE;
+#endif
 
 	return TRUE;
 }
 
 static gboolean
 write_wireless_security_setting (NMConnection *connection,
-                                 shvarFile *ifcfg,
+                                 GOutputStream *netplan,
                                  GHashTable *secrets,
                                  gboolean adhoc,
-                                 gboolean *no_8021x,
                                  GError **error)
 {
 	NMSettingWirelessSecurity *s_wsec;
@@ -548,7 +579,6 @@ write_wireless_security_setting (NMConnection *connection,
 	const char *psk = NULL;
 	gboolean wep = FALSE, wpa = FALSE, dynamic_wep = FALSE;
 	NMSettingWirelessSecurityWpsMethod wps_method;
-	char *tmp;
 	guint32 i, num;
 	GString *str;
 
@@ -564,79 +594,68 @@ write_wireless_security_setting (NMConnection *connection,
 
 	auth_alg = nm_setting_wireless_security_get_auth_alg (s_wsec);
 
-	svUnsetValue (ifcfg, "DEFAULTKEY");
+	g_output_stream_printf (netplan, 0, NULL, NULL, "          auth:\n");
 
 	if (!strcmp (key_mgmt, "none")) {
-		svUnsetValue (ifcfg, "KEY_MGMT");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: none\n");
 		wep = TRUE;
-		*no_8021x = TRUE;
 	} else if (!strcmp (key_mgmt, "wpa-psk")) {
-		svSetValueStr (ifcfg, "KEY_MGMT", "WPA-PSK");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: psk\n");
 		wpa = TRUE;
-		*no_8021x = TRUE;
 	} else if (!strcmp (key_mgmt, "sae")) {
-		svSetValueStr (ifcfg, "KEY_MGMT", "SAE");
+		// TODO: Implement wireless auth SAE mode in netplan
+		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: sae\n");
 		wpa = TRUE;
-		*no_8021x = TRUE;
 	} else if (!strcmp (key_mgmt, "ieee8021x")) {
-		svSetValueStr (ifcfg, "KEY_MGMT", "IEEE8021X");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: 802.1x\n");
 		dynamic_wep = TRUE;
 	} else if (!strcmp (key_mgmt, "wpa-eap")) {
-		svSetValueStr (ifcfg, "KEY_MGMT", "WPA-EAP");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: eap\n");
 		wpa = TRUE;
 	}
 
-	svUnsetValue (ifcfg, "SECURITYMODE");
+#if 0 // TODO: Unravel this SECURITYMODE story: restricted | open | leap ???
+	svUnsetValue (netplan, "SECURITYMODE");
 	if (auth_alg) {
 		if (!strcmp (auth_alg, "shared"))
-			svSetValueStr (ifcfg, "SECURITYMODE", "restricted");
+			svSetValueStr (netplan, "SECURITYMODE", "restricted");
 		else if (!strcmp (auth_alg, "open"))
-			svSetValueStr (ifcfg, "SECURITYMODE", "open");
+			svSetValueStr (netplan, "SECURITYMODE", "open");
 		else if (!strcmp (auth_alg, "leap")) {
-			svSetValueStr (ifcfg, "SECURITYMODE", "leap");
-			svSetValueStr (ifcfg, "IEEE_8021X_IDENTITY",
+			svSetValueStr (netplan, "SECURITYMODE", "leap");
+			svSetValueStr (netplan, "IEEE_8021X_IDENTITY",
 			               nm_setting_wireless_security_get_leap_username (s_wsec));
-			set_secret (ifcfg,
+			set_secret (netplan,
 			            secrets,
 			            "IEEE_8021X_PASSWORD",
 			            nm_setting_wireless_security_get_leap_password (s_wsec),
 			            "IEEE_8021X_PASSWORD_FLAGS",
 			            nm_setting_wireless_security_get_leap_password_flags (s_wsec));
-			*no_8021x = TRUE;
 		}
 	}
+#endif
 
+#if 0 // TODO: support enabling WPS in netplan.
 	/* WPS */
 	wps_method = nm_setting_wireless_security_get_wps_method (s_wsec);
 	if (wps_method == NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT)
-		svUnsetValue (ifcfg, "WPS_METHOD");
+		svUnsetValue (netplan, "WPS_METHOD");
 	else
-		svSetValueEnum (ifcfg, "WPS_METHOD", nm_setting_wireless_security_wps_method_get_type (), wps_method);
+		svSetValueEnum (netplan, "WPS_METHOD", nm_setting_wireless_security_wps_method_get_type (), wps_method);
+#endif
 
 	/* WEP keys */
 
-	/* Clear any default key */
-	set_secret (ifcfg, secrets, "KEY", NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-
-	/* Clear existing keys */
-	for (i = 0; i < 4; i++) {
-		char tag[64];
-
-		numbered_tag (tag, "KEY_PASSPHRASE", i + 1);
-		set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-
-		numbered_tag (tag, "KEY", i + 1);
-		set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-	}
-
 	/* And write the new ones out */
 	if (wep) {
 		NMWepKeyType key_type;
 		const char *key_type_str = NULL;
 
 		/* Default WEP TX key index */
-		svSetValueInt64 (ifcfg, "DEFAULTKEY", nm_setting_wireless_security_get_wep_tx_keyidx(s_wsec) + 1);
+		// TODO: Fix defaultkey / TX key ID for WEP.
+		//svSetValueInt64 (netplan, "DEFAULTKEY", nm_setting_wireless_security_get_wep_tx_keyidx(s_wsec) + 1);
 
+#if 0 // TODO: differentiate hex key vs. passphrase in netplan for WEP (see below)
 		key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
 		switch (key_type) {
 		case NM_WEP_KEY_TYPE_KEY:
@@ -648,7 +667,8 @@ write_wireless_security_setting (NMConnection *connection,
 		case NM_WEP_KEY_TYPE_UNKNOWN:
 			break;
 		}
-		svSetValue (ifcfg, "KEY_TYPE", key_type_str);
+		svSetValue (netplan, "KEY_TYPE", key_type_str);
+#endif
 
 		for (i = 0; i < 4; i++) {
 			key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
@@ -657,7 +677,7 @@ write_wireless_security_setting (NMConnection *connection,
 				char tag[64];
 				gboolean key_valid = TRUE;
 
-				/* Passphrase needs a different ifcfg key since with WEP, there
+				/* Passphrase needs a different netplan key since with WEP, there
 				 * are some passphrases that are indistinguishable from WEP hex
 				 * keys.
 				 */
@@ -668,47 +688,28 @@ write_wireless_security_setting (NMConnection *connection,
 						key_type = NM_WEP_KEY_TYPE_PASSPHRASE;
 				}
 
-				if (key_type == NM_WEP_KEY_TYPE_PASSPHRASE)
-					numbered_tag (tag, "KEY_PASSPHRASE", i + 1);
-				else if (key_type == NM_WEP_KEY_TYPE_KEY) {
-					numbered_tag (tag, "KEY", i + 1);
-
+				if (key_type == NM_WEP_KEY_TYPE_KEY) {
 					/* Add 's:' prefix for ASCII keys */
 					if (strlen (key) == 5 || strlen (key) == 13) {
 						ascii_key = g_strdup_printf ("s:%s", key);
 						key = ascii_key;
 					}
-				} else {
+				} else if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
 					g_warn_if_reached ();
 					key_valid = FALSE;
 				}
 
+				// FIXME: use set_secret??
 				if (key_valid) {
-					set_secret (ifcfg,
-					            secrets,
-					            tag,
-					            key,
-					            "WEP_KEY_FLAGS",
-					            nm_setting_wireless_security_get_wep_key_flags (s_wsec));
+					g_output_stream_printf(netplan, 0, NULL, NULL,
+							       "          password: %s\n", key);
 				}
 			}
 		}
 	}
 
-	/* WPA protos */
-	svUnsetValue (ifcfg, "WPA_ALLOW_WPA");
-	svUnsetValue (ifcfg, "WPA_ALLOW_WPA2");
-	num = nm_setting_wireless_security_get_num_protos (s_wsec);
-	for (i = 0; i < num; i++) {
-		proto = nm_setting_wireless_security_get_proto (s_wsec, i);
-		if (proto && !strcmp (proto, "wpa"))
-			svSetValueStr (ifcfg, "WPA_ALLOW_WPA", "yes");
-		else if (proto && !strcmp (proto, "rsn"))
-			svSetValueStr (ifcfg, "WPA_ALLOW_WPA2", "yes");
-	}
-
+#if 0 // TODO: implement WPA ciphers
 	/* WPA Pairwise ciphers */
-	svUnsetValue (ifcfg, "CIPHER_PAIRWISE");
 	str = g_string_new (NULL);
 	num = nm_setting_wireless_security_get_num_pairwise (s_wsec);
 	for (i = 0; i < num; i++) {
@@ -726,11 +727,11 @@ write_wireless_security_setting (NMConnection *connection,
 		}
 	}
 	if (strlen (str->str) && (dynamic_wep == FALSE))
-		svSetValueStr (ifcfg, "CIPHER_PAIRWISE", str->str);
+		svSetValueStr (netplan, "CIPHER_PAIRWISE", str->str);
 	g_string_free (str, TRUE);
 
 	/* WPA Group ciphers */
-	svUnsetValue (ifcfg, "CIPHER_GROUP");
+	svUnsetValue (netplan, "CIPHER_GROUP");
 	str = g_string_new (NULL);
 	num = nm_setting_wireless_security_get_num_groups (s_wsec);
 	for (i = 0; i < num; i++) {
@@ -742,41 +743,39 @@ write_wireless_security_setting (NMConnection *connection,
 		g_free (tmp);
 	}
 	if (strlen (str->str) && (dynamic_wep == FALSE))
-		svSetValueStr (ifcfg, "CIPHER_GROUP", str->str);
+		svSetValueStr (netplan, "CIPHER_GROUP", str->str);
 	g_string_free (str, TRUE);
+#endif
 
 	if (wpa)
 		psk = nm_setting_wireless_security_get_psk (s_wsec);
 
-	set_secret (ifcfg,
-	            secrets,
-	            "WPA_PSK",
-	            psk,
-	            "WPA_PSK_FLAGS",
-	            wpa ? nm_setting_wireless_security_get_psk_flags (s_wsec) : NM_SETTING_SECRET_FLAG_NONE);
+	// XXX: Should be using set_secret() here?
+	g_output_stream_printf(netplan, 0, NULL, NULL,
+			       "          password: %s\n", psk);
 
+#if 0 // TODO: wireless security: implement PMF and FILS support
 	if (nm_setting_wireless_security_get_pmf (s_wsec) == NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT)
-		svUnsetValue (ifcfg, "PMF");
+		svUnsetValue (netplan, "PMF");
 	else {
-		svSetValueEnum (ifcfg, "PMF", nm_setting_wireless_security_pmf_get_type (),
+		svSetValueEnum (netplan, "PMF", nm_setting_wireless_security_pmf_get_type (),
 		                nm_setting_wireless_security_get_pmf (s_wsec));
 	}
 
 	if (nm_setting_wireless_security_get_fils (s_wsec) == NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT)
-		svUnsetValue (ifcfg, "FILS");
+		svUnsetValue (netplan, "FILS");
 	else {
-		svSetValueEnum (ifcfg, "FILS", nm_setting_wireless_security_fils_get_type (),
+		svSetValueEnum (netplan, "FILS", nm_setting_wireless_security_fils_get_type (),
 		                nm_setting_wireless_security_get_fils (s_wsec));
 	}
+#endif
 
 	return TRUE;
 }
 
 static gboolean
 write_wireless_setting (NMConnection *connection,
-                        shvarFile *ifcfg,
-                        GHashTable *secrets,
-                        gboolean *no_8021x,
+                        GOutputStream *netplan,
                         GError **error)
 {
 	NMSettingWireless *s_wireless;
@@ -789,6 +788,9 @@ write_wireless_setting (NMConnection *connection,
 	gboolean adhoc = FALSE, hex_ssid = FALSE;
 	const char *const*macaddr_blacklist;
 
+	// TODO: move type selection to a place that makes sense (wireless)
+	//svSetValueStr (netplan, "TYPE", TYPE_WIRELESS);
+
 	s_wireless = nm_connection_get_setting_wireless (connection);
 	if (!s_wireless) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
@@ -796,27 +798,34 @@ write_wireless_setting (NMConnection *connection,
 		return FALSE;
 	}
 
+	// TODO: wireless: fix matching / blacklist / MAC setting
 	device_mac = nm_setting_wireless_get_mac_address (s_wireless);
-	svSetValueStr (ifcfg, "HWADDR", device_mac);
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      match: { mac-address: %s }\n", device_mac);
 
 	cloned_mac = nm_setting_wireless_get_cloned_mac_address (s_wireless);
-	svSetValueStr (ifcfg, "MACADDR", cloned_mac);
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      mac-address: %s\n", cloned_mac);
 
-	svSetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK",
+#if 0	// TODO: fix MAC setting, blacklist for wireless.
+	svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
 	               nm_setting_wireless_get_generate_mac_address_mask (s_wireless));
 
-	svUnsetValue (ifcfg, "HWADDR_BLACKLIST");
+	svUnsetValue (netplan, "HWADDR_BLACKLIST");
 	macaddr_blacklist = nm_setting_wireless_get_mac_address_blacklist (s_wireless);
 	if (macaddr_blacklist[0]) {
 		char *blacklist_str;
 
 		blacklist_str = g_strjoinv (" ", (char **) macaddr_blacklist);
-		svSetValueStr (ifcfg, "HWADDR_BLACKLIST", blacklist_str);
+		svSetValueStr (netplan, "HWADDR_BLACKLIST", blacklist_str);
 		g_free (blacklist_str);
 	}
+#endif
 
 	mtu = nm_setting_wireless_get_mtu (s_wireless);
-	svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+	if (mtu != 0)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      mtu: %d\n", mtu);
 
 	ssid = nm_setting_wireless_get_ssid (s_wireless);
 	if (!ssid) {
@@ -834,6 +843,7 @@ write_wireless_setting (NMConnection *connection,
 	/* If the SSID contains any non-printable characters, we need to use the
 	 * hex notation of the SSID instead.
 	 */
+	// XXX (cyphermox): Is this true for netplan? Do we support this correctly?
 	if (   ssid_len > 2
 	    && ssid_data[0] == '0'
 	    && ssid_data[1] == 'x') {
@@ -854,131 +864,107 @@ write_wireless_setting (NMConnection *connection,
 		}
 	}
 
+	GString *essid;
+	essid = g_string_sized_new (ssid_len * 2 + 3);
 	if (hex_ssid) {
-		GString *str;
 
 		/* Hex SSIDs don't get quoted */
-		str = g_string_sized_new (ssid_len * 2 + 3);
-		g_string_append (str, "0x");
+		g_string_append (essid, "0x");
 		for (i = 0; i < ssid_len; i++)
-			g_string_append_printf (str, "%02X", ssid_data[i]);
-		svSetValueStr (ifcfg, "ESSID", str->str);
-		g_string_free (str, TRUE);
+			g_string_append_printf (essid, "%02X", ssid_data[i]);
 	} else {
-		char buf[33];
-
 		nm_assert (ssid_len <= 32);
-		memcpy (buf, ssid_data, ssid_len);
-		buf[ssid_len] = '\0';
-		svSetValueStr (ifcfg, "ESSID", buf);
+		for (i = 0; i < ssid_len; i++)
+			g_string_append_printf (essid, "%c", ssid_data[i]);
+		g_string_append_printf (essid, "%c", '\0');
 	}
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      access-points:\n");
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        %s:\n", essid->str);
+	g_string_free(essid, TRUE);
 
 	mode = nm_setting_wireless_get_mode (s_wireless);
-	if (!mode)
-		svUnsetValue(ifcfg, "MODE");
-	else if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_INFRA))
-		svSetValueStr (ifcfg, "MODE", "Managed");
+	if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_INFRA))
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "          mode: %s\n", "infrastructure");
 	else if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_ADHOC)) {
-		svSetValueStr (ifcfg, "MODE", "Ad-Hoc");
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "          mode: %s\n", "adhoc");
 		adhoc = TRUE;
 	} else if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_AP))
-		svSetValueStr (ifcfg, "MODE", "Ap");
-	else {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "          mode: %s\n", "ap");
+	else if (mode != NULL) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
 		             "Invalid mode '%s' in '%s' setting",
 		             mode, NM_SETTING_WIRELESS_SETTING_NAME);
 		return FALSE;
 	}
 
-	svUnsetValue (ifcfg, "CHANNEL");
-	svUnsetValue (ifcfg, "BAND");
+#if 0 // TODO: implement channel, band, bssid selection in netplan
+	svUnsetValue (netplan, "CHANNEL");
+	svUnsetValue (netplan, "BAND");
 	chan = nm_setting_wireless_get_channel (s_wireless);
 	if (chan) {
-		svSetValueInt64 (ifcfg, "CHANNEL", chan);
+		svSetValueInt64 (netplan, "CHANNEL", chan);
 	} else {
 		/* Band only set if channel is not, since channel implies band */
-		svSetValueStr (ifcfg, "BAND", nm_setting_wireless_get_band (s_wireless));
+		svSetValueStr (netplan, "BAND", nm_setting_wireless_get_band (s_wireless));
 	}
 
 	bssid = nm_setting_wireless_get_bssid (s_wireless);
-	svSetValueStr (ifcfg, "BSSID", bssid);
-
-	/* Ensure DEFAULTKEY and SECURITYMODE are cleared unless there's security;
-	 * otherwise there's no way to detect WEP vs. open when WEP keys aren't
-	 * saved.
-	 */
-	svUnsetValue (ifcfg, "DEFAULTKEY");
-	svUnsetValue (ifcfg, "SECURITYMODE");
+	svSetValueStr (netplan, "BSSID", bssid);
+#endif
 
 	if (nm_connection_get_setting_wireless_security (connection)) {
-		if (!write_wireless_security_setting (connection, ifcfg, secrets, adhoc, no_8021x, error))
+		if (!write_wireless_security_setting (connection, netplan, NULL, adhoc, error))
 			return FALSE;
-	} else {
-		/* Clear out wifi security keys */
-		svUnsetValue (ifcfg, "KEY_MGMT");
-		svUnsetValue (ifcfg, "IEEE_8021X_IDENTITY");
-		set_secret (ifcfg, secrets, "IEEE_8021X_PASSWORD", NULL, "IEEE_8021X_PASSWORD_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-		svUnsetValue (ifcfg, "SECURITYMODE");
-
-		/* Clear existing keys */
-		set_secret (ifcfg, secrets, "KEY", NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-		for (i = 0; i < 4; i++) {
-			char tag[64];
-
-			numbered_tag (tag, "KEY_PASSPHRASE", i + 1);
-			set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-
-			numbered_tag (tag, "KEY", i + 1);
-			set_secret (ifcfg, secrets, tag, NULL, "WEP_KEY_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
-		}
-
-		svUnsetValue (ifcfg, "DEFAULTKEY");
-		svUnsetValue (ifcfg, "WPA_ALLOW_WPA");
-		svUnsetValue (ifcfg, "WPA_ALLOW_WPA2");
-		svUnsetValue (ifcfg, "CIPHER_PAIRWISE");
-		svUnsetValue (ifcfg, "CIPHER_GROUP");
-		set_secret (ifcfg, secrets, "WPA_PSK", NULL, "WPA_PSK_FLAGS", NM_SETTING_SECRET_FLAG_NONE);
 	}
 
-	svSetValueStr (ifcfg, "SSID_HIDDEN", nm_setting_wireless_get_hidden (s_wireless) ? "yes" : NULL);
+	// TODO: add support for non-broadcast (hidden) SSID.
+	//svSetValueStr (netplan, "SSID_HIDDEN", nm_setting_wireless_get_hidden (s_wireless) ? "yes" : NULL);
 
+#if 0 // TODO: implement wifi powersave mode selection.
 	switch (nm_setting_wireless_get_powersave (s_wireless)) {
 	case NM_SETTING_WIRELESS_POWERSAVE_IGNORE:
-		svSetValueStr (ifcfg, "POWERSAVE", "ignore");
+		svSetValueStr (netplan, "POWERSAVE", "ignore");
 		break;
 	case NM_SETTING_WIRELESS_POWERSAVE_DISABLE:
-		svSetValueStr (ifcfg, "POWERSAVE", "disable");
+		svSetValueStr (netplan, "POWERSAVE", "disable");
 		break;
 	case NM_SETTING_WIRELESS_POWERSAVE_ENABLE:
-		svSetValueStr (ifcfg, "POWERSAVE", "enable");
+		svSetValueStr (netplan, "POWERSAVE", "enable");
 		break;
 	default:
 	case NM_SETTING_WIRELESS_POWERSAVE_DEFAULT:
-		svUnsetValue (ifcfg, "POWERSAVE");
+		svUnsetValue (netplan, "POWERSAVE");
 		break;
 	}
+#endif
 
+#if 0 // TODO: implement wifi MAC address randomization in netplan
 	switch (nm_setting_wireless_get_mac_address_randomization (s_wireless)) {
 	case NM_SETTING_MAC_RANDOMIZATION_NEVER:
-		svSetValueStr (ifcfg, "MAC_ADDRESS_RANDOMIZATION", "never");
+		svSetValueStr (netplan, "MAC_ADDRESS_RANDOMIZATION", "never");
 		break;
 	case NM_SETTING_MAC_RANDOMIZATION_ALWAYS:
-		svSetValueStr (ifcfg, "MAC_ADDRESS_RANDOMIZATION", "always");
+		svSetValueStr (netplan, "MAC_ADDRESS_RANDOMIZATION", "always");
 		break;
 	case NM_SETTING_MAC_RANDOMIZATION_DEFAULT:
 	default:
-		svSetValueStr (ifcfg, "MAC_ADDRESS_RANDOMIZATION", "default");
+		svSetValueStr (netplan, "MAC_ADDRESS_RANDOMIZATION", "default");
 		break;
 	}
-
-	svSetValueStr (ifcfg, "TYPE", TYPE_WIRELESS);
+#endif
 
 	return TRUE;
 }
 
 static gboolean
-write_infiniband_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_infiniband_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0 // TODO: implement infiniband!
 	NMSettingInfiniband *s_infiniband;
 	const char *mac, *transport_mode, *parent;
 	guint32 mtu;
@@ -992,37 +978,41 @@ write_infiniband_setting (NMConnection *connection, shvarFile *ifcfg, GError **e
 	}
 
 	mac = nm_setting_infiniband_get_mac_address (s_infiniband);
-	svSetValueStr (ifcfg, "HWADDR", mac);
+	svSetValueStr (netplan, "HWADDR", mac);
 
 	mtu = nm_setting_infiniband_get_mtu (s_infiniband);
-	svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+	svSetValueInt64_cond (netplan, "MTU", mtu != 0, mtu);
 
 	transport_mode = nm_setting_infiniband_get_transport_mode (s_infiniband);
-	svSetValueBoolean (ifcfg, "CONNECTED_MODE", nm_streq (transport_mode, "connected"));
+	svSetValueBoolean (netplan, "CONNECTED_MODE", nm_streq (transport_mode, "connected"));
 
 	p_key = nm_setting_infiniband_get_p_key (s_infiniband);
 	if (p_key != -1) {
-		svSetValueStr (ifcfg, "PKEY", "yes");
-		svSetValueInt64 (ifcfg, "PKEY_ID", p_key);
+		svSetValueStr (netplan, "PKEY", "yes");
+		svSetValueInt64 (netplan, "PKEY_ID", p_key);
 
 		parent = nm_setting_infiniband_get_parent (s_infiniband);
 		if (parent)
-			svSetValueStr (ifcfg, "PHYSDEV", parent);
+			svSetValueStr (netplan, "PHYSDEV", parent);
 	}
 
-	svSetValueStr (ifcfg, "TYPE", TYPE_INFINIBAND);
+	svSetValueStr (netplan, "TYPE", TYPE_INFINIBAND);
+#endif
 
 	return TRUE;
 }
 
 static gboolean
-write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingWired *s_wired;
 	const char *const*s390_subchannels;
 	guint32 mtu, num_opts, i;
 	const char *const*macaddr_blacklist;
 
+	// TODO: move type setting for ethernet devices
+	//svSetValueStr (netplan, "TYPE", TYPE_ETHERNET);
+
 	s_wired = nm_connection_get_setting_wired (connection);
 	if (!s_wired) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
@@ -1030,27 +1020,35 @@ write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		return FALSE;
 	}
 
-	svSetValueStr (ifcfg, "HWADDR",
-	               nm_setting_wired_get_mac_address (s_wired));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      match: { mac-address: %s }\n",
+	                        nm_setting_wired_get_mac_address (s_wired));
 
-	svSetValueStr (ifcfg, "MACADDR",
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      mac-address: %s\n",
 	               nm_setting_wired_get_cloned_mac_address (s_wired));
 
-	svSetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK",
-	               nm_setting_wired_get_generate_mac_address_mask (s_wired));
+	// TODO: dedup fields for mac-address to do MAC setting cleanly.
+	//svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
+	//               nm_setting_wired_get_generate_mac_address_mask (s_wired));
 
+#if 0  // TODO: No MAC match blacklist in netplan. Do we need one?
 	macaddr_blacklist = nm_setting_wired_get_mac_address_blacklist (s_wired);
 	if (macaddr_blacklist[0]) {
 		gs_free char *blacklist_str = NULL;
 
 		blacklist_str = g_strjoinv (" ", (char **) macaddr_blacklist);
-		svSetValueStr (ifcfg, "HWADDR_BLACKLIST", blacklist_str);
+		svSetValueStr (netplan, "HWADDR_BLACKLIST", blacklist_str);
 	} else
-		svUnsetValue (ifcfg, "HWADDR_BLACKLIST");
+		svUnsetValue (netplan, "HWADDR_BLACKLIST");
+#endif
 
 	mtu = nm_setting_wired_get_mtu (s_wired);
-	svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+	if (mtu != 0)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      mtu: %d\n", mtu);
 
+#if 0 // TODO: implement s390 subchannels 
 	s390_subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
 
 	{
@@ -1068,19 +1066,19 @@ write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 			                       s390_subchannels[2]);
 		}
 
-		svSetValueStr (ifcfg, "SUBCHANNELS", tmp);
+		svSetValueStr (netplan, "SUBCHANNELS", tmp);
 	}
 
-	svSetValueStr (ifcfg, "NETTYPE",
+	svSetValueStr (netplan, "NETTYPE",
 	               nm_setting_wired_get_s390_nettype (s_wired));
 
-	svSetValueStr (ifcfg, "PORTNAME",
+	svSetValueStr (netplan, "PORTNAME",
 	               nm_setting_wired_get_s390_option_by_key (s_wired, "portname"));
 
-	svSetValueStr (ifcfg, "CTCPROT",
+	svSetValueStr (netplan, "CTCPROT",
 	               nm_setting_wired_get_s390_option_by_key (s_wired, "ctcprot"));
 
-	svUnsetValue (ifcfg, "OPTIONS");
+	svUnsetValue (netplan, "OPTIONS");
 	num_opts = nm_setting_wired_get_num_s390_options (s_wired);
 	if (s390_subchannels && num_opts) {
 		nm_auto_free_gstring GString *tmp = NULL;
@@ -1109,17 +1107,17 @@ write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 			nm_utils_escaped_tokens_escape_gstr (s390_val, NM_ASCII_SPACES, tmp);
 		}
 		if (tmp)
-			svSetValueStr (ifcfg, "OPTIONS", tmp->str);
+			svSetValueStr (netplan, "OPTIONS", tmp->str);
 	}
-
-	svSetValueStr (ifcfg, "TYPE", TYPE_ETHERNET);
+#endif
 
 	return TRUE;
 }
 
 static gboolean
-write_ethtool_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_ethtool_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0 // TODO (cyphermox): add support for ethtool settings in netplan
 	NMSettingWired *s_wired;
 	NMSettingEthtool *s_ethtool;
 	const char *duplex;
@@ -1133,8 +1131,8 @@ write_ethtool_setting (NMConnection *connection, shvarFile *ifcfg, GError **erro
 	s_ethtool = NM_SETTING_ETHTOOL (nm_connection_get_setting (connection, NM_TYPE_SETTING_ETHTOOL));
 
 	if (!s_wired && !s_ethtool) {
-		svUnsetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN");
-		svUnsetValue (ifcfg, "ETHTOOL_OPTS");
+		svUnsetValue (netplan, "ETHTOOL_WAKE_ON_LAN");
+		svUnsetValue (netplan, "ETHTOOL_OPTS");
 		return TRUE;
 	}
 
@@ -1163,7 +1161,7 @@ write_ethtool_setting (NMConnection *connection, shvarFile *ifcfg, GError **erro
 		wol = nm_setting_wired_get_wake_on_lan (s_wired);
 		wol_password = nm_setting_wired_get_wake_on_lan_password (s_wired);
 
-		svSetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN",
+		svSetValue (netplan, "ETHTOOL_WAKE_ON_LAN",
 		              wol == NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE
 		            ? "ignore"
 		            : NULL);
@@ -1196,7 +1194,7 @@ write_ethtool_setting (NMConnection *connection, shvarFile *ifcfg, GError **erro
 				g_string_append_printf (str, "s sopass %s", wol_password);
 		}
 	} else
-		svUnsetValue (ifcfg, "ETHTOOL_WAKE_ON_LAN");
+		svUnsetValue (netplan, "ETHTOOL_WAKE_ON_LAN");
 
 	if (s_ethtool) {
 		NMEthtoolID ethtool_id;
@@ -1226,25 +1224,26 @@ write_ethtool_setting (NMConnection *connection, shvarFile *ifcfg, GError **erro
 			const NMEthtoolData *ed = nm_ethtool_data[ethtool_id];
 			NMTernary val;
 
-			nm_assert (nms_ifcfg_rh_utils_get_ethtool_name (ethtool_id));
+			nm_assert (nms_netplan_utils_get_ethtool_name (ethtool_id));
 
 			val = nm_setting_ethtool_get_feature (s_ethtool, ed->optname);
 			if (val == NM_TERNARY_DEFAULT)
 				continue;
 
 			g_string_append_c (str, ' ');
-			g_string_append (str, nms_ifcfg_rh_utils_get_ethtool_name (ethtool_id));
+			g_string_append (str, nms_netplan_utils_get_ethtool_name (ethtool_id));
 			g_string_append (str, val == NM_TERNARY_TRUE ? " on" : " off");
 		}
 	}
 
 	if (str) {
-		svSetValueStr (ifcfg, "ETHTOOL_OPTS", str->str);
+		svSetValueStr (netplan, "ETHTOOL_OPTS", str->str);
 		g_string_free (str, TRUE);
 	} else
-		svUnsetValue (ifcfg, "ETHTOOL_OPTS");
+		svUnsetValue (netplan, "ETHTOOL_OPTS");
 
 	return TRUE;
+#endif
 }
 
 static char *
@@ -1270,7 +1269,7 @@ vlan_priority_maplist_to_stringlist (NMSettingVlan *s_vlan, NMVlanPriorityMap ma
 }
 
 static gboolean
-write_wired_for_virtual (NMConnection *connection, shvarFile *ifcfg)
+write_wired_for_virtual (NMConnection *connection, GOutputStream *netplan)
 {
 	NMSettingWired *s_wired;
 	gboolean has_wired = FALSE;
@@ -1283,22 +1282,28 @@ write_wired_for_virtual (NMConnection *connection, shvarFile *ifcfg)
 		has_wired = TRUE;
 
 		device_mac = nm_setting_wired_get_mac_address (s_wired);
-		svSetValue (ifcfg, "HWADDR", device_mac ?: "");
+		if (device_mac)
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+					        "      match: { mac-address: %s }\n", device_mac);
 
 		cloned_mac = nm_setting_wired_get_cloned_mac_address (s_wired);
-		svSetValueStr (ifcfg, "MACADDR", cloned_mac);
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      mac-address: %s\n", cloned_mac);
 
-		svSetValueStr (ifcfg, "GENERATE_MAC_ADDRESS_MASK",
-		               nm_setting_wired_get_generate_mac_address_mask (s_wired));
+		// TODO: (cyphermox) suport generate_mac_address_mask 
+		//svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
+		//               nm_setting_wired_get_generate_mac_address_mask (s_wired));
 
 		mtu = nm_setting_wired_get_mtu (s_wired);
-		svSetValueInt64_cond (ifcfg, "MTU", mtu != 0, mtu);
+		if (mtu != 0)
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+					        "      mtu: %d\n", mtu);
 	}
 	return has_wired;
 }
 
 static gboolean
-write_vlan_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+write_vlan_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingVlan *s_vlan;
 	char *tmp;
@@ -1313,14 +1318,15 @@ write_vlan_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired,
 		return FALSE;
 	}
 
-	svSetValueStr (ifcfg, "VLAN", "yes");
-	svSetValueStr (ifcfg, "TYPE", TYPE_VLAN);
-	svSetValueStr (ifcfg, "PHYSDEV", nm_setting_vlan_get_parent (s_vlan));
-	svSetValueInt64 (ifcfg, "VLAN_ID", nm_setting_vlan_get_id (s_vlan));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      id: %d\n", nm_setting_vlan_get_id (s_vlan));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      link: %s\n", nm_setting_vlan_get_parent (s_vlan));
 
+#if 0  /* TODO: (cyphermox) add support for vlan flags / advanced settings */
 	vlan_flags = nm_setting_vlan_get_flags (s_vlan);
-	svSetValueBoolean (ifcfg, "REORDER_HDR", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS));
-	svSetValueBoolean (ifcfg, "GVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_GVRP));
+	svSetValueBoolean (netplan, "REORDER_HDR", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS));
+	svSetValueBoolean (netplan, "GVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_GVRP));
 
 	nm_utils_strbuf_init (s_buf, &s_buf_ptr, &s_buf_len);
 
@@ -1329,29 +1335,24 @@ write_vlan_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired,
 	if (!NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS))
 		nm_utils_strbuf_append (&s_buf_ptr, &s_buf_len, "%sNO_REORDER_HDR", s_buf[0] ? "," : "");
 
-	svSetValueStr (ifcfg, "VLAN_FLAGS", s_buf);
+	svSetValueStr (netplan, "VLAN_FLAGS", s_buf);
 
-	svSetValueBoolean (ifcfg, "MVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_MVRP));
+	svSetValueBoolean (netplan, "MVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_MVRP));
 
 	tmp = vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_INGRESS_MAP);
-	svSetValueStr (ifcfg, "VLAN_INGRESS_PRIORITY_MAP", tmp);
+	svSetValueStr (netplan, "VLAN_INGRESS_PRIORITY_MAP", tmp);
 	g_free (tmp);
 
 	tmp = vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_EGRESS_MAP);
-	svSetValueStr (ifcfg, "VLAN_EGRESS_PRIORITY_MAP", tmp);
+	svSetValueStr (netplan, "VLAN_EGRESS_PRIORITY_MAP", tmp);
 	g_free (tmp);
-
-	svUnsetValue (ifcfg, "HWADDR");
-	svUnsetValue (ifcfg, "MACADDR");
-	svUnsetValue (ifcfg, "MTU");
-
-	*wired = write_wired_for_virtual (connection, ifcfg);
+#endif
 
 	return TRUE;
 }
 
 static gboolean
-write_bond_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+write_bond_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingBond *s_bond;
 	guint32 i, num_opts;
@@ -1363,8 +1364,6 @@ write_bond_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired,
 		return FALSE;
 	}
 
-	svUnsetValue (ifcfg, "BONDING_OPTS");
-
 	num_opts = nm_setting_bond_get_num_options (s_bond);
 	if (num_opts) {
 		nm_auto_free_gstring GString *str = NULL;
@@ -1372,26 +1371,21 @@ write_bond_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired,
 
 		str = g_string_sized_new (64);
 		for (i = 0; i < num_opts; i++) {
-			if (str->len)
-				g_string_append_c (str, ' ');
 			nm_setting_bond_get_option (s_bond, i, &name, &value);
-			g_string_append_printf (str, "%s=%s", name, value);
+			g_string_append_printf (str, "        %s: %s\n", name, value);
 		}
 
-		svSetValueStr (ifcfg, "BONDING_OPTS", str->str);
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      parameters:\n%s", str->str);
 	}
 
-	svSetValueStr (ifcfg, "TYPE", TYPE_BOND);
-	svSetValueStr (ifcfg, "BONDING_MASTER", "yes");
-
-	*wired = write_wired_for_virtual (connection, ifcfg);
-
 	return TRUE;
 }
 
 static gboolean
-write_team_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+write_team_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0 // TODO (cyphermox): implement team devices in netplan
 	NMSettingTeam *s_team;
 	const char *config;
 
@@ -1403,11 +1397,12 @@ write_team_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired,
 	}
 
 	config = nm_setting_team_get_config (s_team);
-	svSetValueStr (ifcfg, "TEAM_CONFIG", config);
+	svSetValueStr (netplan, "TEAM_CONFIG", config);
 
-	*wired = write_wired_for_virtual (connection, ifcfg);
+	*wired = write_wired_for_virtual (connection, netplan);
 
 	return TRUE;
+#endif
 }
 
 static guint32
@@ -1447,10 +1442,11 @@ get_setting_default_boolean (NMSetting *setting, const char *prop)
 static gboolean
 write_bridge_vlans (NMSetting *setting,
                     const char *property_name,
-                    shvarFile *ifcfg,
+                    GOutputStream *netplan,
                     const char *key,
                     GError **error)
 {
+#if 0 // TODO (cyphermox): Implement brdige VLANs printif settings.
 	gs_unref_ptrarray GPtrArray *vlans = NULL;
 	NMBridgeVlan *vlan;
 	GString *string;
@@ -1459,7 +1455,7 @@ write_bridge_vlans (NMSetting *setting,
 	g_object_get (setting, property_name, &vlans, NULL);
 
 	if (!vlans || !vlans->len) {
-		svUnsetValue (ifcfg, key);
+		svUnsetValue (netplan, key);
 		return TRUE;
 	}
 
@@ -1476,13 +1472,15 @@ write_bridge_vlans (NMSetting *setting,
 		nm_utils_escaped_tokens_escape_gstr_assert (vlan_str, ",", string);
 	}
 
-	svSetValueStr (ifcfg, key, string->str);
+	svSetValueStr (netplan, key, string->str);
 	g_string_free (string, TRUE);
+#endif
+
 	return TRUE;
 }
 
 static gboolean
-write_bridge_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
+write_bridge_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingBridge *s_bridge;
 	guint32 i;
@@ -1497,61 +1495,55 @@ write_bridge_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wire
 		return FALSE;
 	}
 
-	svUnsetValue (ifcfg, "BRIDGING_OPTS");
-	svSetValueBoolean (ifcfg, "STP", FALSE);
-	svUnsetValue (ifcfg, "DELAY");
-
 	mac = nm_setting_bridge_get_mac_address (s_bridge);
-	svSetValueStr (ifcfg, "BRIDGE_MACADDR", mac);
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "      mac-address: %s\n", mac);
 
 	/* Bridge options */
 	opts = g_string_sized_new (32);
 
 	if (nm_setting_bridge_get_stp (s_bridge)) {
-		svSetValueStr (ifcfg, "STP", "yes");
+		g_string_append_printf (opts, "        stp: %s\n", "yes");
 
 		i = nm_setting_bridge_get_forward_delay (s_bridge);
 		if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_FORWARD_DELAY))
-			svSetValueInt64 (ifcfg, "DELAY", i);
+			g_string_append_printf (opts, "        forward-delay: %u\n", i);
 
-		g_string_append_printf (opts, "priority=%u", nm_setting_bridge_get_priority (s_bridge));
+		g_string_append_printf (opts, "        priority: %u\n", nm_setting_bridge_get_priority (s_bridge));
 
 		i = nm_setting_bridge_get_hello_time (s_bridge);
 		if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_HELLO_TIME)) {
-			if (opts->len)
-				g_string_append_c (opts, ' ');
-			g_string_append_printf (opts, "hello_time=%u", i);
+			g_string_append_printf (opts, "        hello-time: %u\n", i);
 		}
 
 		i = nm_setting_bridge_get_max_age (s_bridge);
 		if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_MAX_AGE)) {
-			if (opts->len)
-				g_string_append_c (opts, ' ');
-			g_string_append_printf (opts, "max_age=%u", i);
+			g_string_append_printf (opts, "        max-age: %u\n", i);
 		}
 	}
 
 	i = nm_setting_bridge_get_ageing_time (s_bridge);
 	if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_AGEING_TIME)) {
-		if (opts->len)
-			g_string_append_c (opts, ' ');
-		g_string_append_printf (opts, "ageing_time=%u", i);
+		g_string_append_printf (opts, "        ageing-time: %u\n", i);
 	}
 
+#if 0  // TODO: group_fw_mask for bridges.
 	i = nm_setting_bridge_get_group_forward_mask (s_bridge);
 	if (i != get_setting_default_uint (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_GROUP_FORWARD_MASK)) {
-		if (opts->len)
-			g_string_append_c (opts, ' ');
-		g_string_append_printf (opts, "group_fwd_mask=%u", i);
+		g_string_append_printf (opts, "        group_fwd_mask: %u", i);
 	}
+#endif
 
+#if 0 // TODO: implement multicast snooping seting for bridges.
 	b = nm_setting_bridge_get_multicast_snooping (s_bridge);
 	if (b != get_setting_default_boolean (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_MULTICAST_SNOOPING)) {
 		if (opts->len)
 			g_string_append_c (opts, ' ');
 		g_string_append_printf (opts, "multicast_snooping=%u", (guint32) b);
 	}
+#endif
 
+#if 0 // TODO: implement bridge vlan filtering
 	b = nm_setting_bridge_get_vlan_filtering (s_bridge);
 	if (b != get_setting_default_boolean (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_VLAN_FILTERING)) {
 		if (opts->len)
@@ -1565,28 +1557,32 @@ write_bridge_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wire
 			g_string_append_c (opts, ' ');
 		g_string_append_printf (opts, "default_pvid=%u", i);
 	}
+#endif
 
 	if (opts->len)
-		svSetValueStr (ifcfg, "BRIDGING_OPTS", opts->str);
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      parameters:\n%s", opts->str);
 	g_string_free (opts, TRUE);
 
+#if 0 // TODO: Bridge VLANS magic???
 	if (!write_bridge_vlans ((NMSetting *) s_bridge,
 	                         NM_SETTING_BRIDGE_VLANS,
-	                         ifcfg,
+	                         netplan,
 	                         "BRIDGE_VLANS",
 	                         error))
 		return FALSE;
+#endif
 
-	svSetValueStr (ifcfg, "TYPE", TYPE_BRIDGE);
-
-	*wired = write_wired_for_virtual (connection, ifcfg);
+	// TODO: org for output the right type of device.
+	//svSetValueStr (netplan, "TYPE", TYPE_BRIDGE);
 
 	return TRUE;
 }
 
 static gboolean
-write_bridge_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+	// TODO: Probably needs reorg in netplan to support in member device bond/bridge params.
 	NMSettingBridgePort *s_port;
 	guint32 i;
 	GString *string;
@@ -1595,35 +1591,36 @@ write_bridge_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **
 	if (!s_port)
 		return TRUE;
 
-	svUnsetValue (ifcfg, "BRIDGING_OPTS");
-
 	/* Bridge options */
 	string = g_string_sized_new (32);
 
 	i = nm_setting_bridge_port_get_priority (s_port);
 	if (i != get_setting_default_uint (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PRIORITY))
-		g_string_append_printf (string, "priority=%u", i);
+		g_string_append_printf (string, "        priority: %u", i);
 
 	i = nm_setting_bridge_port_get_path_cost (s_port);
 	if (i != get_setting_default_uint (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PATH_COST)) {
 		if (string->len)
 			g_string_append_c (string, ' ');
-		g_string_append_printf (string, "path_cost=%u", i);
+		g_string_append_printf (string, "        path-cost: %u", i);
 	}
 
+#if 0 // TODO (cyphermox): hairpin mode support in networkd/netplan
 	if (nm_setting_bridge_port_get_hairpin_mode (s_port)) {
 		if (string->len)
 			g_string_append_c (string, ' ');
 		g_string_append_printf (string, "hairpin_mode=1");
 	}
+#endif
 
 	if (string->len)
-		svSetValueStr (ifcfg, "BRIDGING_OPTS", string->str);
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      parameters:\n%s", string->str);
 	g_string_free (string, TRUE);
 
 	if (!write_bridge_vlans ((NMSetting *) s_port,
 	                         NM_SETTING_BRIDGE_PORT_VLANS,
-	                         ifcfg,
+	                         netplan,
 	                         "BRIDGE_PORT_VLANS",
 	                         error))
 		return FALSE;
@@ -1632,8 +1629,9 @@ write_bridge_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **
 }
 
 static gboolean
-write_team_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_team_port_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0 // TODO (cyphermox): TEAM port settings.
 	NMSettingTeamPort *s_port;
 	const char *config;
 
@@ -1642,80 +1640,88 @@ write_team_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **er
 		return TRUE;
 
 	config = nm_setting_team_port_get_config (s_port);
-	svSetValueStr (ifcfg, "TEAM_PORT_CONFIG", config);
+	svSetValueStr (netplan, "TEAM_PORT_CONFIG", config);
 
 	return TRUE;
+#endif
 }
 
 static void
-write_dcb_flags (shvarFile *ifcfg, const char *tag, NMSettingDcbFlags flags)
+write_dcb_flags (GOutputStream *netplan, const char *tag, NMSettingDcbFlags flags)
 {
+#if 0
 	char prop[NM_STRLEN ("DCB_xxxxxxxxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyyyy")];
 
 	nm_sprintf_buf (prop, "DCB_%s_ENABLE", tag);
-	svSetValueStr (ifcfg, prop, (flags & NM_SETTING_DCB_FLAG_ENABLE) ? "yes" : NULL);
+	svSetValueStr (netplan, prop, (flags & NM_SETTING_DCB_FLAG_ENABLE) ? "yes" : NULL);
 
 	nm_sprintf_buf (prop, "DCB_%s_ADVERTISE", tag);
-	svSetValueStr (ifcfg, prop, (flags & NM_SETTING_DCB_FLAG_ADVERTISE) ? "yes" : NULL);
+	svSetValueStr (netplan, prop, (flags & NM_SETTING_DCB_FLAG_ADVERTISE) ? "yes" : NULL);
 
 	nm_sprintf_buf (prop, "DCB_%s_WILLING", tag);
-	svSetValueStr (ifcfg, prop, (flags & NM_SETTING_DCB_FLAG_WILLING) ? "yes" : NULL);
+	svSetValueStr (netplan, prop, (flags & NM_SETTING_DCB_FLAG_WILLING) ? "yes" : NULL);
+#endif
 }
 
 static void
-write_dcb_app (shvarFile *ifcfg,
+write_dcb_app (GOutputStream *netplan,
                const char *tag,
                NMSettingDcbFlags flags,
                int priority)
 {
+#if 0
 	char prop[NM_STRLEN ("DCB_xxxxxxxxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyyyy")];
 
-	write_dcb_flags (ifcfg, tag, flags);
+	write_dcb_flags (netplan, tag, flags);
 
 	nm_sprintf_buf (prop, "DCB_%s_PRIORITY", tag);
 	if ((flags & NM_SETTING_DCB_FLAG_ENABLE) && (priority >= 0))
-		svSetValueInt64 (ifcfg, prop, priority);
+		svSetValueInt64 (netplan, prop, priority);
 	else
-		svUnsetValue (ifcfg, prop);
+		svUnsetValue (netplan, prop);
+#endif
 }
 
 typedef gboolean (*DcbGetBoolFunc) (NMSettingDcb *, guint);
 
 static void
-write_dcb_bool_array (shvarFile *ifcfg,
+write_dcb_bool_array (GOutputStream *netplan,
                       const char *key,
                       NMSettingDcb *s_dcb,
                       NMSettingDcbFlags flags,
                       DcbGetBoolFunc get_func)
 {
+#if 0
 	char str[9];
 	guint i;
 
 	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		svUnsetValue (ifcfg, key);
+		svUnsetValue (netplan, key);
 		return;
 	}
 
 	str[8] = 0;
 	for (i = 0; i < 8; i++)
 		str[i] = get_func (s_dcb, i) ? '1' : '0';
-	svSetValueStr (ifcfg, key, str);
+	svSetValueStr (netplan, key, str);
+#endif
 }
 
 typedef guint (*DcbGetUintFunc) (NMSettingDcb *, guint);
 
 static void
-write_dcb_uint_array (shvarFile *ifcfg,
+write_dcb_uint_array (GOutputStream *netplan,
                       const char *key,
                       NMSettingDcb *s_dcb,
                       NMSettingDcbFlags flags,
                       DcbGetUintFunc get_func)
 {
+#if 0
 	char str[9];
 	guint i, num;
 
 	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		svUnsetValue (ifcfg, key);
+		svUnsetValue (netplan, key);
 		return;
 	}
 
@@ -1729,21 +1735,23 @@ write_dcb_uint_array (shvarFile *ifcfg,
 		else
 			g_assert_not_reached ();
 	}
-	svSetValueStr (ifcfg, key, str);
+	svSetValueStr (netplan, key, str);
+#endif
 }
 
 static void
-write_dcb_percent_array (shvarFile *ifcfg,
+write_dcb_percent_array (GOutputStream *netplan,
                          const char *key,
                          NMSettingDcb *s_dcb,
                          NMSettingDcbFlags flags,
                          DcbGetUintFunc get_func)
 {
+#if 0
 	GString *str;
 	guint i;
 
 	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		svUnsetValue (ifcfg, key);
+		svUnsetValue (netplan, key);
 		return;
 	}
 
@@ -1753,13 +1761,15 @@ write_dcb_percent_array (shvarFile *ifcfg,
 			g_string_append_c (str, ',');
 		g_string_append_printf (str, "%d", get_func (s_dcb, i));
 	}
-	svSetValueStr (ifcfg, key, str->str);
+	svSetValueStr (netplan, key, str->str);
 	g_string_free (str, TRUE);
+#endif
 }
 
 static gboolean
-write_dcb_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_dcb_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0 // TODO (cyphermox): Implement DCB.
 	NMSettingDcb *s_dcb;
 	NMSettingDcbFlags flags;
 
@@ -1793,87 +1803,98 @@ write_dcb_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		const char **iter;
 
 		for (iter = clear_keys; *iter; iter++)
-			svUnsetValue (ifcfg, *iter);
+			svUnsetValue (netplan, *iter);
 		return TRUE;
 	}
 
-	svSetValueStr (ifcfg, "DCB", "yes");
+	svSetValueStr (netplan, "DCB", "yes");
 
-	write_dcb_app (ifcfg, "APP_FCOE",
+	write_dcb_app (netplan, "APP_FCOE",
 	               nm_setting_dcb_get_app_fcoe_flags (s_dcb),
 	               nm_setting_dcb_get_app_fcoe_priority (s_dcb));
 	if (nm_setting_dcb_get_app_fcoe_flags (s_dcb) & NM_SETTING_DCB_FLAG_ENABLE)
-		svSetValueStr (ifcfg, KEY_DCB_APP_FCOE_MODE, nm_setting_dcb_get_app_fcoe_mode (s_dcb));
+		svSetValueStr (netplan, KEY_DCB_APP_FCOE_MODE, nm_setting_dcb_get_app_fcoe_mode (s_dcb));
 	else
-		svUnsetValue (ifcfg, KEY_DCB_APP_FCOE_MODE);
+		svUnsetValue (netplan, KEY_DCB_APP_FCOE_MODE);
 
-	write_dcb_app (ifcfg, "APP_ISCSI",
+	write_dcb_app (netplan, "APP_ISCSI",
 	               nm_setting_dcb_get_app_iscsi_flags (s_dcb),
 	               nm_setting_dcb_get_app_iscsi_priority (s_dcb));
-	write_dcb_app (ifcfg, "APP_FIP",
+	write_dcb_app (netplan, "APP_FIP",
 	               nm_setting_dcb_get_app_fip_flags (s_dcb),
 	               nm_setting_dcb_get_app_fip_priority (s_dcb));
 
-	write_dcb_flags (ifcfg, "PFC", nm_setting_dcb_get_priority_flow_control_flags (s_dcb));
-	write_dcb_bool_array (ifcfg, KEY_DCB_PFC_UP, s_dcb,
+	write_dcb_flags (netplan, "PFC", nm_setting_dcb_get_priority_flow_control_flags (s_dcb));
+	write_dcb_bool_array (netplan, KEY_DCB_PFC_UP, s_dcb,
 	                      nm_setting_dcb_get_priority_flow_control_flags (s_dcb),
 	                      nm_setting_dcb_get_priority_flow_control);
 
 	flags = nm_setting_dcb_get_priority_group_flags (s_dcb);
-	write_dcb_flags (ifcfg, "PG", flags);
-	write_dcb_uint_array (ifcfg, KEY_DCB_PG_ID, s_dcb, flags, nm_setting_dcb_get_priority_group_id);
-	write_dcb_percent_array (ifcfg, KEY_DCB_PG_PCT, s_dcb, flags, nm_setting_dcb_get_priority_group_bandwidth);
-	write_dcb_percent_array (ifcfg, KEY_DCB_PG_UPPCT, s_dcb, flags, nm_setting_dcb_get_priority_bandwidth);
-	write_dcb_bool_array (ifcfg, KEY_DCB_PG_STRICT, s_dcb, flags, nm_setting_dcb_get_priority_strict_bandwidth);
-	write_dcb_uint_array (ifcfg, KEY_DCB_PG_UP2TC, s_dcb, flags, nm_setting_dcb_get_priority_traffic_class);
+	write_dcb_flags (netplan, "PG", flags);
+	write_dcb_uint_array (netplan, KEY_DCB_PG_ID, s_dcb, flags, nm_setting_dcb_get_priority_group_id);
+	write_dcb_percent_array (netplan, KEY_DCB_PG_PCT, s_dcb, flags, nm_setting_dcb_get_priority_group_bandwidth);
+	write_dcb_percent_array (netplan, KEY_DCB_PG_UPPCT, s_dcb, flags, nm_setting_dcb_get_priority_bandwidth);
+	write_dcb_bool_array (netplan, KEY_DCB_PG_STRICT, s_dcb, flags, nm_setting_dcb_get_priority_strict_bandwidth);
+	write_dcb_uint_array (netplan, KEY_DCB_PG_UP2TC, s_dcb, flags, nm_setting_dcb_get_priority_traffic_class);
+#endif
 
 	return TRUE;
 }
 
 static void
-write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
+write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 {
-	guint32 n, i;
-	GString *str;
-	const char *master, *master_iface = NULL, *type;
-	int vint;
-	gint32 vint32;
-	NMSettingConnectionMdns mdns;
-	NMSettingConnectionLlmnr llmnr;
-	guint32 vuint32;
-	const char *tmp;
-
-	svSetValueStr (ifcfg, "NAME", nm_setting_connection_get_id (s_con));
-	svSetValueStr (ifcfg, "UUID", nm_setting_connection_get_uuid (s_con));
-	svSetValueStr (ifcfg, "STABLE_ID", nm_setting_connection_get_stable_id (s_con));
-	svSetValueStr (ifcfg, "DEVICE", nm_setting_connection_get_interface_name (s_con));
-	svSetValueBoolean (ifcfg, "ONBOOT", nm_setting_connection_get_autoconnect (s_con));
-
+	//guint32 n, i;
+	//GString *str;
+	//const char *master, *master_iface = NULL, *type;
+	//int vint;
+	//gint32 vint32;
+	//NMSettingConnectionMdns mdns;
+	//NMSettingConnectionLlmnr llmnr;
+	//guint32 vuint32;
+	//const char *tmp;
+
+	g_output_stream_printf (netplan, 0, NULL, NULL, "      networkmanager:\n");
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        name: %s\n", nm_setting_connection_get_id(s_con));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        uuid: %s\n", nm_setting_connection_get_uuid (s_con));
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        stable-id: %s\n", nm_setting_connection_get_stable_id (s_con));
+	
+	
+	// TODO: MOVE to header to identify the device / connection it is under
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "        device: %s\n", nm_setting_connection_get_interface_name (s_con));
+
+	// TODO: hook up autoconnect ???
+	//g_output_stream_printf (netplan, "ONBOOT", nm_setting_connection_get_autoconnect (s_con));
+
+#if 0
 	vint = nm_setting_connection_get_autoconnect_priority (s_con);
-	svSetValueInt64_cond (ifcfg, "AUTOCONNECT_PRIORITY",
-	                      vint != NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT,
-	                      vint);
+	g_hash_table_insert (netplan, "AUTOCONNECT_PRIORITY",
+	                      vint != NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT ?
+	                      vint : NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT);
 
 	vint = nm_setting_connection_get_autoconnect_retries (s_con);
-	svSetValueInt64_cond (ifcfg, "AUTOCONNECT_RETRIES",
-	                      vint != -1,
-	                      vint);
+	g_hash_table_insert (netplan, "AUTOCONNECT_RETRIES",
+	                      vint != -1 ?
+	                      vint: -1);
 
 	vint = nm_setting_connection_get_multi_connect (s_con);
-	svSetValueInt64_cond (ifcfg, "MULTI_CONNECT",
-	                      vint != NM_CONNECTION_MULTI_CONNECT_DEFAULT,
-	                      vint);
+	g_hash_table_insert (netplan, "MULTI_CONNECT",
+	                      vint != NM_CONNECTION_MULTI_CONNECT_DEFAULT ?
+	                      vint: NM_CONNECTION_MULTI_CONNECT_DEFAULT);
 
 	/* Only save the value for master connections */
 	type = nm_setting_connection_get_connection_type (s_con);
 	if (_nm_connection_type_is_master (type)) {
 		NMSettingConnectionAutoconnectSlaves autoconnect_slaves;
 		autoconnect_slaves = nm_setting_connection_get_autoconnect_slaves (s_con);
-		svSetValueStr (ifcfg, "AUTOCONNECT_SLAVES",
+		g_hash_table_insert (netplan, "AUTOCONNECT_SLAVES",
 		               autoconnect_slaves == NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES ? "yes" :
 		               autoconnect_slaves == NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO ? "no" : NULL);
-	} else
-		svUnsetValue (ifcfg, "AUTOCONNECT_SLAVES");
+	}
 
 	switch (nm_setting_connection_get_lldp (s_con)) {
 	case NM_SETTING_CONNECTION_LLDP_ENABLE_RX:
@@ -1885,10 +1906,12 @@ write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 	default:
 		tmp = NULL;
 	}
-	svSetValueStr (ifcfg, "LLDP", tmp);
+	g_hash_table_insert (netplan, "LLDP", tmp);
+#endif
 
+#if 0 // TODO (cyphermox): handle user permissions for connections
 	/* Permissions */
-	svUnsetValue (ifcfg, "USERS");
+	g_hash_table_insert (netplan, "USERS");
 	n = nm_setting_connection_get_num_permissions (s_con);
 	if (n > 0) {
 		str = g_string_sized_new (n * 20);
@@ -1905,20 +1928,14 @@ write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 			if (nm_setting_connection_get_permission (s_con, i, NULL, &puser, NULL))
 				g_string_append (str, puser);
 		}
-		svSetValueStr (ifcfg, "USERS", str->str);
+		g_hash_table_insert (netplan, "USERS", str->str);
 		g_string_free (str, TRUE);
 	}
 
-	svSetValueStr (ifcfg, "ZONE", nm_setting_connection_get_zone (s_con));
-
-	svSetValueStr (ifcfg, "MASTER_UUID", NULL);
-	svSetValueStr (ifcfg, "MASTER", NULL);
-	svSetValueStr (ifcfg, "SLAVE", NULL);
-	svSetValueStr (ifcfg, "BRIDGE_UUID", NULL);
-	svSetValueStr (ifcfg, "BRIDGE", NULL);
-	svSetValueStr (ifcfg, "TEAM_MASTER_UUID", NULL);
-	svSetValueStr (ifcfg, "TEAM_MASTER", NULL);
+	g_hash_table_insert (netplan, "ZONE", nm_setting_connection_get_zone (s_con));
+#endif
 
+#if 0
 	master = nm_setting_connection_get_master (s_con);
 	if (master) {
 		/* The reader prefers the *_UUID variants, however we still try to resolve
@@ -1934,37 +1951,34 @@ write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 		}
 
 		if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME)) {
-			svSetValueStr (ifcfg, "MASTER_UUID", master);
-			svSetValueStr (ifcfg, "MASTER", master_iface);
-			svSetValueStr (ifcfg, "SLAVE", "yes");
+			g_hash_table_insert (netplan, "MASTER_UUID", master);
+			g_hash_table_insert (netplan, "MASTER", master_iface);
+			g_hash_table_insert (netplan, "SLAVE", "yes");
 		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BRIDGE_SETTING_NAME)) {
-			svSetValueStr (ifcfg, "BRIDGE_UUID", master);
-			svSetValueStr (ifcfg, "BRIDGE", master_iface);
+			g_hash_table_insert (netplan, "BRIDGE_UUID", master);
+			g_hash_table_insert (netplan, "BRIDGE", master_iface);
 		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME)) {
-			svSetValueStr (ifcfg, "TEAM_MASTER_UUID", master);
-			svSetValueStr (ifcfg, "TEAM_MASTER", master_iface);
-			if (NM_IN_STRSET (type,
-			                  NM_SETTING_WIRED_SETTING_NAME,
-			                  NM_SETTING_VLAN_SETTING_NAME))
-				svUnsetValue (ifcfg, "TYPE");
+			g_hash_table_insert (netplan, "TEAM_MASTER_UUID", master);
+			g_hash_table_insert (netplan, "TEAM_MASTER", master_iface);
 		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_OVS_PORT_SETTING_NAME)) {
-			svSetValueStr (ifcfg, "OVS_PORT_UUID", master);
-			svSetValueStr (ifcfg, "OVS_PORT", master_iface);
+			g_hash_table_insert (netplan, "OVS_PORT_UUID", master);
+			g_hash_table_insert (netplan, "OVS_PORT", master_iface);
 		} else {
 			_LOGW ("don't know how to set master for a %s slave",
 			       nm_setting_connection_get_slave_type (s_con));
 		}
 	}
+#endif
 
+#if 0 // TODO (cyphermox): use devicetype code for bridgeport detection
 	if (nm_streq0 (type, NM_SETTING_TEAM_SETTING_NAME))
-		svSetValueStr (ifcfg, "DEVICETYPE", TYPE_TEAM);
+		g_hash_table_insert (netplan, "DEVICETYPE", TYPE_TEAM);
 	else if (master_iface && nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME))
-		svSetValueStr (ifcfg, "DEVICETYPE", TYPE_TEAM_PORT);
-	else
-		svUnsetValue (ifcfg, "DEVICETYPE");
+		g_hash_table_insert (netplan, "DEVICETYPE", TYPE_TEAM_PORT);
+#endif
 
+#if 0
 	/* secondary connection UUIDs */
-	svUnsetValue (ifcfg, "SECONDARY_UUIDS");
 	n = nm_setting_connection_get_num_secondaries (s_con);
 	if (n > 0) {
 		str = g_string_sized_new (n * 37);
@@ -1981,55 +1995,56 @@ write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 			if ((uuid = nm_setting_connection_get_secondary (s_con, i)) != NULL)
 				g_string_append (str, uuid);
 		}
-		svSetValueStr (ifcfg, "SECONDARY_UUIDS", str->str);
+		g_hash_table_insert (netplan, "SECONDARY_UUIDS", str->str);
 		g_string_free (str, TRUE);
 	}
 
 	vuint32 = nm_setting_connection_get_gateway_ping_timeout (s_con);
-	svSetValueInt64_cond (ifcfg, "GATEWAY_PING_TIMEOUT",
-	                      vuint32 != 0,
-	                      vuint32);
+	if (vuint32 != 0)
+		g_hash_table_insert (netplan, "GATEWAY_PING_TIMEOUT", vuint32);
 
 	switch (nm_setting_connection_get_metered (s_con)) {
 	case NM_METERED_YES:
-		svSetValueStr (ifcfg, "CONNECTION_METERED", "yes");
+		g_hash_table_insert (netplan, "CONNECTION_METERED", "yes");
 		break;
 	case NM_METERED_NO:
-		svSetValueStr (ifcfg, "CONNECTION_METERED", "no");
+		g_hash_table_insert (netplan, "CONNECTION_METERED", "no");
 		break;
 	default:
-		svUnsetValue (ifcfg, "CONNECTION_METERED");
+		break;
 	}
 
 	vint = nm_setting_connection_get_auth_retries (s_con);
-	svSetValueInt64_cond (ifcfg, "AUTH_RETRIES", vint >= 0, vint);
+	if (vint >= 0)
+		g_hash_table_insert (netplan, "AUTH_RETRIES", vint);
 
 	vint32 = nm_setting_connection_get_wait_device_timeout (s_con);
 	if (vint32 == -1)
-		svUnsetValue (ifcfg, "DEVTIMEOUT");
+		// Do nothing
 	else if ((vint32 % 1000) == 0)
-		svSetValueInt64 (ifcfg, "DEVTIMEOUT", vint32 / 1000);
+		g_hash_table_insert (netplan, "DEVTIMEOUT", vint32 / 1000);
 	else {
 		char b[100];
 
-		svSetValueStr (ifcfg,
-		               "DEVTIMEOUT",
-		               nm_sprintf_buf (b, "%.3f", ((double) vint) / 1000.0));
+		g_hash_table_insert (netplan,
+		                     "DEVTIMEOUT",
+		                     nm_sprintf_buf (b, "%.3f", ((double) vint) / 1000.0));
 	}
+#endif
 
+#if 0
 	mdns = nm_setting_connection_get_mdns (s_con);
 	if (mdns != NM_SETTING_CONNECTION_MDNS_DEFAULT) {
-		svSetValueEnum (ifcfg, "MDNS", nm_setting_connection_mdns_get_type (),
-		                mdns);
-	} else
-		svUnsetValue (ifcfg, "MDNS");
+		g_hash_table_insert (netplan, "MDNS", //nm_setting_connection_mdns_get_type (),
+		                     mdns);
+	}
 
 	llmnr = nm_setting_connection_get_llmnr (s_con);
 	if (llmnr != NM_SETTING_CONNECTION_LLMNR_DEFAULT) {
-		svSetValueEnum (ifcfg, "LLMNR", nm_setting_connection_llmnr_get_type (),
-		                llmnr);
-	} else
-		svUnsetValue (ifcfg, "LLMNR");
+		g_output_stream_printf (netplan, "LLMNR", //nm_setting_connection_llmnr_get_type (),
+		                        llmnr);
+	}
+#endif
 }
 
 static char *
@@ -2102,63 +2117,8 @@ get_route_attributes_string (NMIPRoute *route, int family)
 	return g_string_free (str, FALSE);
 }
 
-static shvarFile *
-write_route_file_svformat (const char *filename, NMSettingIPConfig *s_ip4)
-{
-	shvarFile *routefile;
-	guint i, num;
-
-	routefile = utils_get_route_ifcfg (filename, TRUE);
-
-	svUnsetAll (routefile, SV_KEY_TYPE_ROUTE_SVFORMAT);
-
-	num = nm_setting_ip_config_get_num_routes (s_ip4);
-	for (i = 0; i < num; i++) {
-		char buf[INET_ADDRSTRLEN];
-		NMIPRoute *route;
-		guint32 netmask;
-		gint64 metric;
-		char addr_key[64];
-		char gw_key[64];
-		char netmask_key[64];
-		char metric_key[64];
-		char options_key[64];
-		gs_free char *options = NULL;
-
-		numbered_tag (addr_key, "ADDRESS", i);
-		numbered_tag (netmask_key, "NETMASK", i);
-		numbered_tag (gw_key, "GATEWAY", i);
-
-		route = nm_setting_ip_config_get_route (s_ip4, i);
-
-		svSetValueStr (routefile, addr_key, nm_ip_route_get_dest (route));
-
-		netmask = _nm_utils_ip4_prefix_to_netmask (nm_ip_route_get_prefix (route));
-		svSetValueStr (routefile, netmask_key,
-		               nm_utils_inet4_ntop (netmask, buf));
-
-		svSetValueStr (routefile, gw_key, nm_ip_route_get_next_hop (route));
-
-		metric = nm_ip_route_get_metric (route);
-		if (metric != -1) {
-			svSetValueInt64 (routefile,
-			                 numbered_tag (metric_key, "METRIC", i),
-			                 metric);
-		}
-
-		options = get_route_attributes_string (route, AF_INET);
-		if (options) {
-			svSetValueStr (routefile,
-			               numbered_tag (options_key, "OPTIONS", i),
-			               options);
-		}
-	}
-
-	return routefile;
-}
-
 static GString *
-write_route_file (NMSettingIPConfig *s_ip)
+write_route_settings (NMSettingIPConfig *s_ip)
 {
 	GString *contents;
 	NMIPRoute *route;
@@ -2183,27 +2143,28 @@ write_route_file (NMSettingIPConfig *s_ip)
 		metric = nm_ip_route_get_metric (route);
 		options = get_route_attributes_string (route, addr_family);
 
-		g_string_append_printf (contents, "%s/%u",
+		g_string_append_printf (contents, "      - to: %s/%u\n",
 		                        nm_ip_route_get_dest (route),
 		                        nm_ip_route_get_prefix (route));
 		if (next_hop)
-			g_string_append_printf (contents, " via %s", next_hop);
+			g_string_append_printf (contents, "        via: %s\n", next_hop);
 		if (metric >= 0)
-			g_string_append_printf (contents, " metric %u", (guint) metric);
+			g_string_append_printf (contents, "        metric: %u\n", (guint) metric);
+#if 0  // TODO: implementing route options
 		if (options) {
 			g_string_append_c (contents, ' ');
 			g_string_append (contents, options);
 		}
-
-		g_string_append_c (contents, '\n');
+#endif
 	}
 
 	return contents;
 }
 
 static gboolean
-write_proxy_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_proxy_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0  // TODO: implement proxy support.
 	NMSettingProxy *s_proxy;
 	NMSettingProxyMethod method;
 	const char *pac_url, *pac_script;
@@ -2212,44 +2173,45 @@ write_proxy_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 	if (!s_proxy)
 		return TRUE;
 
-	svUnsetValue (ifcfg, "BROWSER_ONLY");
-	svUnsetValue (ifcfg, "PAC_URL");
-	svUnsetValue (ifcfg, "PAC_SCRIPT");
+	svUnsetValue (netplan, "BROWSER_ONLY");
+	svUnsetValue (netplan, "PAC_URL");
+	svUnsetValue (netplan, "PAC_SCRIPT");
 
 	method = nm_setting_proxy_get_method (s_proxy);
 	switch (method) {
 	case NM_SETTING_PROXY_METHOD_AUTO:
-		svSetValueStr (ifcfg, "PROXY_METHOD", "auto");
+		svSetValueStr (netplan, "PROXY_METHOD", "auto");
 
 		pac_url = nm_setting_proxy_get_pac_url (s_proxy);
 		if (pac_url)
-			svSetValueStr (ifcfg, "PAC_URL", pac_url);
+			svSetValueStr (netplan, "PAC_URL", pac_url);
 
 		pac_script = nm_setting_proxy_get_pac_script (s_proxy);
 		if (pac_script)
-			svSetValueStr (ifcfg, "PAC_SCRIPT", pac_script);
+			svSetValueStr (netplan, "PAC_SCRIPT", pac_script);
 
 		break;
 	case NM_SETTING_PROXY_METHOD_NONE:
-		svSetValueStr (ifcfg, "PROXY_METHOD", "none");
+		svSetValueStr (netplan, "PROXY_METHOD", "none");
 		break;
 	}
 
-	svSetValueBoolean (ifcfg, "BROWSER_ONLY", nm_setting_proxy_get_browser_only (s_proxy));
-
+	svSetValueBoolean (netplan, "BROWSER_ONLY", nm_setting_proxy_get_browser_only (s_proxy));
+#endif
 	return TRUE;
 }
 
 static gboolean
-write_user_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_user_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
+#if 0  // TODO: (cyphermox)  implement user permission settings stat.
 	NMSettingUser *s_user;
 	guint i, len;
 	const char *const*keys;
 
 	s_user = NM_SETTING_USER (nm_connection_get_setting (connection, NM_TYPE_SETTING_USER));
 
-	svUnsetAll (ifcfg, SV_KEY_TYPE_USER);
+	svUnsetAll (netplan, SV_KEY_TYPE_USER);
 
 	if (!s_user)
 		return TRUE;
@@ -2263,19 +2225,20 @@ write_user_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 
 			g_string_set_size (str, 0);
 			g_string_append (str, "NM_USER_");
-			nms_ifcfg_rh_utils_user_key_encode (key, str);
-			svSetValue (ifcfg,
+			nms_netplan_utils_user_key_encode (key, str);
+			svSetValue (netplan,
 			            str->str,
 			            nm_setting_user_get_data (s_user, key));
 		}
 	}
-
+#endif
 	return TRUE;
 }
 
 static void
-write_sriov_setting (NMConnection *connection, shvarFile *ifcfg)
+write_sriov_setting (NMConnection *connection, GHashTable *netplan)
 {
+#if 0  // TODO: implement SR-IOV settings
 	NMSettingSriov *s_sriov;
 	guint i, num = 0;
 	NMTernary b;
@@ -2283,42 +2246,38 @@ write_sriov_setting (NMConnection *connection, shvarFile *ifcfg)
 	char key[32];
 	char *str;
 
-	svUnsetAll (ifcfg, SV_KEY_TYPE_SRIOV_VF);
+	svUnsetAll (netplan, SV_KEY_TYPE_SRIOV_VF);
 
 	s_sriov = NM_SETTING_SRIOV (nm_connection_get_setting (connection,
 	                                                       NM_TYPE_SETTING_SRIOV));
-	if (!s_sriov) {
-		svUnsetValue (ifcfg, "SRIOV_TOTAL_VFS");
-		svUnsetValue (ifcfg, "SRIOV_AUTOPROBE_DRIVERS");
-		return;
-	}
-
-	svSetValueInt64 (ifcfg, "SRIOV_TOTAL_VFS", nm_setting_sriov_get_total_vfs (s_sriov));
+	svSetValueInt64 (netplan, "SRIOV_TOTAL_VFS", nm_setting_sriov_get_total_vfs (s_sriov));
 
 	b = nm_setting_sriov_get_autoprobe_drivers (s_sriov);
 	if (b != NM_TERNARY_DEFAULT)
-		svSetValueInt64 (ifcfg, "SRIOV_AUTOPROBE_DRIVERS", b);
+		svSetValueInt64 (netplan, "SRIOV_AUTOPROBE_DRIVERS", b);
 	else
-		svUnsetValue (ifcfg, "SRIOV_AUTOPROBE_DRIVERS");
+		svUnsetValue (netplan, "SRIOV_AUTOPROBE_DRIVERS");
 
 	num = nm_setting_sriov_get_num_vfs (s_sriov);
 	for (i = 0; i < num; i++) {
 		vf = nm_setting_sriov_get_vf (s_sriov, i);
 		nm_sprintf_buf (key, "SRIOV_VF%u", nm_sriov_vf_get_index (vf));
 		str = nm_utils_sriov_vf_to_str (vf, TRUE, NULL);
-		svSetValueStr (ifcfg, key, str);
+		svSetValueStr (netplan, key, str);
 		g_free (str);
 	}
+#endif
 }
 
 static gboolean
-write_tc_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_tc_setting (NMConnection *connection, GHashTable *netplan, GError **error)
 {
+#if 0 // TODO: implement TC settings for netplan
 	NMSettingTCConfig *s_tc;
 	guint i, num, n;
 	char tag[64];
 
-	svUnsetAll (ifcfg, SV_KEY_TYPE_TC);
+	svUnsetAll (netplan, SV_KEY_TYPE_TC);
 
 	s_tc = nm_connection_get_setting_tc_config (connection);
 	if (!s_tc)
@@ -2334,7 +2293,7 @@ write_tc_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		if (!str)
 			return FALSE;
 
-		svSetValueStr (ifcfg, numbered_tag (tag, "QDISC", n), str);
+		svSetValueStr (netplan, numbered_tag (tag, "QDISC", n), str);
 		n++;
 	}
 
@@ -2348,22 +2307,20 @@ write_tc_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		if (!str)
 			return FALSE;
 
-		svSetValueStr (ifcfg, numbered_tag (tag, "FILTER", n), str);
+		svSetValueStr (netplan, numbered_tag (tag, "FILTER", n), str);
 		n++;
 	}
-
+#endif
 	return TRUE;
 }
 
 static gboolean
-write_match_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_match_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingMatch *s_match;
 	nm_auto_free_gstring GString *str = NULL;
 	guint i, num;
 
-	svUnsetValue (ifcfg, "MATCH_INTERFACE_NAME");
-
 	s_match = (NMSettingMatch *) nm_connection_get_setting (connection, NM_TYPE_SETTING_MATCH);
 	if (!s_match)
 		return TRUE;
@@ -2383,23 +2340,23 @@ write_match_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		nm_utils_escaped_tokens_escape_gstr (name, NM_ASCII_SPACES, str);
 	}
 
-	if (str)
-		svSetValueStr (ifcfg, "MATCH_INTERFACE_NAME", str->str);
+	if (str) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "      match:\n");
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "        name: %s\n", str->str);
+	}
 
 	return TRUE;
 }
 
 static void
-write_res_options (shvarFile *ifcfg, NMSettingIPConfig *s_ip, const char *var)
+write_res_options (GHashTable *netplan, NMSettingIPConfig *s_ip, const char *var)
 {
+#if 0  // TODO: implement DNS options (edns0, etc.)
 	nm_auto_free_gstring GString *value = NULL;
 	guint i, num_options;
 
-	if (!nm_setting_ip_config_has_dns_options (s_ip)) {
-		svUnsetValue (ifcfg, var);
-		return;
-	}
-
 	value = g_string_new (NULL);
 	num_options = nm_setting_ip_config_get_num_dns_options (s_ip);
 	for (i = 0; i < num_options; i++) {
@@ -2408,14 +2365,16 @@ write_res_options (shvarFile *ifcfg, NMSettingIPConfig *s_ip, const char *var)
 		g_string_append (value, nm_setting_ip_config_get_dns_option (s_ip, i));
 	}
 
-	svSetValue (ifcfg, var, value->str);
+	svSetValue (netplan, var, value->str);
+#endif
 }
 
 static gboolean
 write_ip4_setting (NMConnection *connection,
-                   shvarFile *ifcfg,
-                   shvarFile **out_route_content_svformat,
-                   GString **out_route_content,
+                   GOutputStream *netplan,
+		   GArray *addresses,
+		   GArray *nameservers,
+		   GArray *searches,
                    GError **error)
 {
 	NMSettingIPConfig *s_ip4;
@@ -2428,66 +2387,39 @@ write_ip4_setting (NMConnection *connection,
 	NMIPRouteTableSyncMode route_table;
 	int priority;
 	int timeout;
-	GString *searches;
 	const char *method = NULL;
 	gboolean has_netmask;
 
-	NM_SET_OUT (out_route_content_svformat, NULL);
-	NM_SET_OUT (out_route_content, NULL);
-
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	if (!s_ip4) {
-		/* slave-type: clear IPv4 settings.
-		 *
-		 * Some IPv4 setting related options are not cleared,
-		 * for no strong reason. */
-		svUnsetValue (ifcfg, "BOOTPROTO");
-		svUnsetValue (ifcfg, "RES_OPTIONS");
-		svUnsetAll (ifcfg, SV_KEY_TYPE_IP4_ADDRESS);
-		return TRUE;
-	}
-
 	method = nm_setting_ip_config_get_method (s_ip4);
 
 	/* Missing IP4 setting is assumed to be DHCP */
 	if (!method)
 		method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
 
-	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED)) {
-		/* IPv4 disabled, clear IPv4 related parameters */
-		svUnsetValue (ifcfg, "BOOTPROTO");
-		for (j = -1; j < 256; j++) {
-			svUnsetValue (ifcfg, numbered_tag (tag, "IPADDR", j));
-			svUnsetValue (ifcfg, numbered_tag (tag, "PREFIX", j));
-			svUnsetValue (ifcfg, numbered_tag (tag, "NETMASK", j));
-			svUnsetValue (ifcfg, numbered_tag (tag, "GATEWAY", j));
-		}
-		return TRUE;
-	}
-
 	num = nm_setting_ip_config_get_num_addresses (s_ip4);
 
 	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO))
-		svSetValueStr (ifcfg, "BOOTPROTO", "dhcp");
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "      dhcp4: yes\n");
+#if 0
 	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)) {
-		/* Preserve the archaic form of "static" if there actually
-		 * is static configuration. */
-		if (g_strcmp0 (svGetValue (ifcfg, "BOOTPROTO", &tmp), "static") || !num)
-			svSetValueStr (ifcfg, "BOOTPROTO", "none");
-		g_free (tmp);
+		// Static addresses addressed below.
 	} else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
-		svSetValueStr (ifcfg, "BOOTPROTO", "autoip");
+		link_local &= 0x2;
 	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED))
-		svSetValueStr (ifcfg, "BOOTPROTO", "shared");
-
-	has_netmask = !!svFindFirstKeyWithPrefix (ifcfg, "NETMASK");
+		// FIXME: (cyphermox) implement connection sharing.
+#endif
 
 	/* Write out IPADDR<n>, PREFIX<n>, GATEWAY<n> for current IP addresses
 	 * without labels. Unset obsolete NETMASK<n>.
 	 */
+
 	for (i = n = 0; i < num; i++) {
 		NMIPAddress *addr;
-		guint prefix;
+		GString *address;
+
+		address = g_string_sized_new(50);
 
 		addr = nm_setting_ip_config_get_address (s_ip4, i);
 
@@ -2498,260 +2430,174 @@ write_ip4_setting (NMConnection *connection,
 			if (label)
 				continue;
 		}
-
-		if (n == 0) {
-			/* Instead of index 0 use un-numbered variables.
-			 * It's needed for compatibility with ifup that only recognizes 'GATEAWAY'
-			 * See https://bugzilla.redhat.com/show_bug.cgi?id=771673
-			 * and https://bugzilla.redhat.com/show_bug.cgi?id=1105770
-			 */
-			j = -1;
-		} else
-			j = n;
-
-		svSetValueStr (ifcfg,
-		               numbered_tag (tag, "IPADDR", j),
-		               nm_ip_address_get_address (addr));
-
-		prefix = nm_ip_address_get_prefix (addr);
-		svSetValueInt64 (ifcfg, numbered_tag (tag, "PREFIX", j), prefix);
-
-		/* If the legacy "NETMASK" is present, keep it. */
-		numbered_tag (tag, "NETMASK", j);
-		if (has_netmask) {
-			char buf[INET_ADDRSTRLEN];
-
-			svSetValueStr (ifcfg, tag,
-			               nm_utils_inet4_ntop (_nm_utils_ip4_prefix_to_netmask (prefix), buf));
-		} else
-			svUnsetValue (ifcfg, tag);
-
-		n++;
-	}
-
-	svUnsetValue (ifcfg, numbered_tag (tag, "IPADDR", 0));
-	svUnsetValue (ifcfg, numbered_tag (tag, "PREFIX", 0));
-	svUnsetValue (ifcfg, numbered_tag (tag, "NETMASK", 0));
-	if (n == 0) {
-		svUnsetValue (ifcfg, "IPADDR");
-		svUnsetValue (ifcfg, "PREFIX");
-		svUnsetValue (ifcfg, "NETMASK");
-	}
-	for (j = n; j < 256; j++) {
-		svUnsetValue (ifcfg, numbered_tag (tag, "IPADDR", j));
-		svUnsetValue (ifcfg, numbered_tag (tag, "PREFIX", j));
-		svUnsetValue (ifcfg, numbered_tag (tag, "NETMASK", j));
-	}
-
-	for (j = -1; j < 256; j++) {
-		if (j != 0)
-			svUnsetValue (ifcfg, numbered_tag (tag, "GATEWAY", j));
-	}
-	svSetValueStr (ifcfg, "GATEWAY", nm_setting_ip_config_get_gateway (s_ip4));
+		g_string_printf(address, "%s/%d",
+		                nm_ip_address_get_address (addr),
+		                nm_ip_address_get_prefix (addr));
+		value = g_string_free(address, FALSE);
+		g_array_append_val (addresses, value);
+	}
+
+#if 0
+		routes = g_array_new(...)
+	    // (cyphermox) Routes -> split up into routes section
+	    // routes = g_array_new (...)
+	    // ...
+	    // g_hash_table_insert (netplan, "routes", <routes>)
+	    // 
+		g_hash_table_insert (route,
+		                     "to",
+		                     nm_ip_address_get_address (addr));
+#endif
+
+	g_output_stream_printf(netplan, 0, NULL, NULL,
+	                       "      gateway4: %s\n", nm_setting_ip_config_get_gateway (s_ip4));
 
 	num = nm_setting_ip_config_get_num_dns (s_ip4);
-	for (i = 0; i < 254; i++) {
+	for (i = 0; i < num; i++) {
 		const char *dns;
 
-		numbered_tag (tag, "DNS", i + 1);
-		if (i >= num)
-			svUnsetValue (ifcfg, tag);
-		else {
-			dns = nm_setting_ip_config_get_dns (s_ip4, i);
-			svSetValueStr (ifcfg, tag, dns);
-		}
+		dns = nm_setting_ip_config_get_dns (s_ip4, i);
+		g_array_append_val(nameservers, dns);
 	}
 
 	num = nm_setting_ip_config_get_num_dns_searches (s_ip4);
 	if (num > 0) {
-		searches = g_string_new (NULL);
 		for (i = 0; i < num; i++) {
-			if (i > 0)
-				g_string_append_c (searches, ' ');
-			g_string_append (searches, nm_setting_ip_config_get_dns_search (s_ip4, i));
+			const char *search;
+
+			search = nm_setting_ip_config_get_dns_search (s_ip4, i);
+			g_array_append_val (searches, search);
 		}
-		svSetValueStr (ifcfg, "DOMAIN", searches->str);
-		g_string_free (searches, TRUE);
-	} else
-		svUnsetValue (ifcfg, "DOMAIN");
+	}
 
+	// TODO: (cyphermox) dhcp overrides in part here...
+#if 0  // TODO: (cyphermox) def-route toggles and peer, dhcp settings.
 	/* DEFROUTE; remember that it has the opposite meaning from never-default */
-	svSetValueBoolean (ifcfg, "DEFROUTE", !nm_setting_ip_config_get_never_default (s_ip4));
+	svSetValueBoolean (netplan, "DEFROUTE", !nm_setting_ip_config_get_never_default (s_ip4));
 
 	/* Missing PEERDNS means TRUE, so write it only when is FALSE */
-	svSetValueStr (ifcfg, "PEERDNS",
+	svSetValueStr (netplan, "PEERDNS",
 	               nm_setting_ip_config_get_ignore_auto_dns (s_ip4) ? "no" : NULL);
 	/* Missing PEERROUTES means TRUE, so write it only when is FALSE */
-	svSetValueStr (ifcfg, "PEERROUTES",
+	svSetValueStr (netplan, "PEERROUTES",
 	               nm_setting_ip_config_get_ignore_auto_routes (s_ip4) ? "no" : NULL);
 
 	value = nm_setting_ip_config_get_dhcp_hostname (s_ip4);
-	svSetValueStr (ifcfg, "DHCP_HOSTNAME", value);
+	svSetValueStr (netplan, "DHCP_HOSTNAME", value);
 
 	value = nm_setting_ip4_config_get_dhcp_fqdn (NM_SETTING_IP4_CONFIG (s_ip4));
-	svSetValueStr (ifcfg, "DHCP_FQDN", value);
+	svSetValueStr (netplan, "DHCP_FQDN", value);
 
 	/* Missing DHCP_SEND_HOSTNAME means TRUE, and we prefer not write it explicitly
 	 * in that case, because it is NM-specific variable
 	 */
-	svSetValueStr (ifcfg, "DHCP_SEND_HOSTNAME",
+	svSetValueStr (netplan, "DHCP_SEND_HOSTNAME",
 	               nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) ? NULL : "no");
 
 	value = nm_setting_ip4_config_get_dhcp_client_id (NM_SETTING_IP4_CONFIG (s_ip4));
-	svSetValueStr (ifcfg, "DHCP_CLIENT_ID", value);
+	svSetValueStr (netplan, "DHCP_CLIENT_ID", value);
 
 	timeout = nm_setting_ip_config_get_dhcp_timeout (s_ip4);
-	svSetValueInt64_cond (ifcfg,
+	svSetValueInt64_cond (netplan,
 	                      "IPV4_DHCP_TIMEOUT",
 	                      timeout != 0,
 	                      timeout);
+#endif
 
-	svSetValueBoolean (ifcfg, "IPV4_FAILURE_FATAL", !nm_setting_ip_config_get_may_fail (s_ip4));
+#if 0  // TODO: Implement route settings here for ipv4
+	svSetValueBoolean (netplan, "IPV4_FAILURE_FATAL", !nm_setting_ip_config_get_may_fail (s_ip4));
 
 	route_metric = nm_setting_ip_config_get_route_metric (s_ip4);
-	svSetValueInt64_cond (ifcfg,
+	svSetValueInt64_cond (netplan,
 	                      "IPV4_ROUTE_METRIC",
 	                      route_metric != -1,
 	                      route_metric);
 
 	route_table = nm_setting_ip_config_get_route_table (s_ip4);
-	svSetValueInt64_cond (ifcfg,
+	svSetValueInt64_cond (netplan,
 	                      "IPV4_ROUTE_TABLE",
 	                      route_table != 0,
 	                      route_table);
 
-	NM_SET_OUT (out_route_content_svformat, write_route_file_svformat (svFileGetName (ifcfg), s_ip4));
-	NM_SET_OUT (out_route_content, write_route_file (s_ip4));
+	//NM_SET_OUT (out_route_content_svformat, write_route_file_svformat (svFileGetName (netplan), s_ip4));
+	NM_SET_OUT (out_route_content, write_route_settings (s_ip4));
 
 	timeout = nm_setting_ip_config_get_dad_timeout (s_ip4);
 	if (timeout < 0) {
-		svUnsetValue (ifcfg, "ACD_TIMEOUT");
-		svUnsetValue (ifcfg, "ARPING_WAIT");
+		svUnsetValue (netplan, "ACD_TIMEOUT");
+		svUnsetValue (netplan, "ARPING_WAIT");
 	} else if (timeout == 0) {
-		svSetValueStr (ifcfg, "ACD_TIMEOUT", "0");
-		svSetValueStr (ifcfg, "ARPING_WAIT", "0");
+		svSetValueStr (netplan, "ACD_TIMEOUT", "0");
+		svSetValueStr (netplan, "ARPING_WAIT", "0");
 	} else {
-		svSetValueInt64 (ifcfg, "ACD_TIMEOUT", timeout);
+		svSetValueInt64 (netplan, "ACD_TIMEOUT", timeout);
 		/* Round the value up to next integer for initscripts */
-		svSetValueInt64 (ifcfg, "ARPING_WAIT", (timeout - 1) / 1000 + 1);
+		svSetValueInt64 (netplan, "ARPING_WAIT", (timeout - 1) / 1000 + 1);
 	}
 
 	priority = nm_setting_ip_config_get_dns_priority (s_ip4);
 	if (priority)
-		svSetValueInt64 (ifcfg, "IPV4_DNS_PRIORITY", priority);
+		svSetValueInt64 (netplan, "IPV4_DNS_PRIORITY", priority);
 	else
-		svUnsetValue (ifcfg, "IPV4_DNS_PRIORITY");
+		svUnsetValue (netplan, "IPV4_DNS_PRIORITY");
 
-	write_res_options (ifcfg, s_ip4, "RES_OPTIONS");
+	write_res_options (netplan, s_ip4, "RES_OPTIONS");
+#endif
 
 	return TRUE;
 }
 
 static void
-write_ip4_aliases (NMConnection *connection, const char *base_ifcfg_path)
+write_ip4_aliases (NMConnection *connection, GArray *addresses, const char *base_netplan_path)
 {
 	NMSettingIPConfig *s_ip4;
-	gs_free char *base_ifcfg_dir = NULL, *base_ifcfg_name = NULL;
+	gs_free char *base_netplan_dir = NULL, *base_netplan_name = NULL;
 	const char *base_name;
-	int i, num, base_ifcfg_name_len, base_name_len;
+	int i, num, base_netplan_name_len, base_name_len;
 	GDir *dir;
 
-	base_ifcfg_dir = g_path_get_dirname (base_ifcfg_path);
-	base_ifcfg_name = g_path_get_basename (base_ifcfg_path);
-	base_ifcfg_name_len = strlen (base_ifcfg_name);
-	if (!g_str_has_prefix (base_ifcfg_name, IFCFG_TAG))
-		g_return_if_reached ();
-	base_name = base_ifcfg_name + strlen (IFCFG_TAG);
-	base_name_len = strlen (base_name);
-
-	/* Remove all existing aliases for this file first */
-	dir = g_dir_open (base_ifcfg_dir, 0, NULL);
-	if (dir) {
-		const char *item;
-
-		while ((item = g_dir_read_name (dir))) {
-			char *full_path;
-
-			if (   strncmp (item, base_ifcfg_name, base_ifcfg_name_len) != 0
-			    || item[base_ifcfg_name_len] != ':')
-				continue;
-
-			full_path = g_build_filename (base_ifcfg_dir, item, NULL);
-			unlink (full_path);
-			g_free (full_path);
-		}
-
-		g_dir_close (dir);
-	}
-
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	if (!s_ip4) {
-		/* slave-type: no alias files */
+	if (!s_ip4)
 		return;
-	}
 
 	num = nm_setting_ip_config_get_num_addresses (s_ip4);
 	for (i = 0; i < num; i++) {
-		GVariant *label_var;
-		const char *label, *p;
-		char *path;
 		NMIPAddress *addr;
-		shvarFile *ifcfg;
+		GString *ip_addr;
+		const char *address;
 
 		addr = nm_setting_ip_config_get_address (s_ip4, i);
 
-		label_var = nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL);
-		if (!label_var)
-			continue;
-		label = g_variant_get_string (label_var, NULL);
-		if (   strncmp (label, base_name, base_name_len) != 0
-		    || label[base_name_len] != ':')
-			continue;
-
-		for (p = label; *p; p++) {
-			if (!g_ascii_isalnum (*p) && *p != '_' && *p != ':')
-				break;
-		}
-		if (*p)
-			continue;
-
-		path = g_strdup_printf ("%s%s", base_ifcfg_path, label + base_name_len);
-		ifcfg = svCreateFile (path);
-		g_free (path);
+		ip_addr = g_string_sized_new(50);
+		g_string_printf (ip_addr, "%s/%d",
+		                 nm_ip_address_get_address (addr),
+		                 nm_ip_address_get_prefix (addr));
 
-		svSetValueStr (ifcfg, "DEVICE", label);
-
-		addr = nm_setting_ip_config_get_address (s_ip4, i);
-		svSetValueStr (ifcfg, "IPADDR", nm_ip_address_get_address (addr));
-
-		svSetValueInt64 (ifcfg, "PREFIX", nm_ip_address_get_prefix(addr));
-
-		svWriteFile (ifcfg, 0644, NULL);
-		svCloseFile (ifcfg);
+		address = g_string_free(ip_addr, FALSE);
+		g_array_append_val(addresses, address);
 	}
 }
 
 static void
-write_ip6_setting_dhcp_hostname (NMSettingIPConfig *s_ip6, shvarFile *ifcfg)
+write_ip6_setting_dhcp_hostname (NMSettingIPConfig *s_ip6,
+				 GHashTable *dhcp_overrides)
 {
 	const char *hostname;
 
 	hostname = nm_setting_ip_config_get_dhcp_hostname (s_ip6);
-	svSetValueStr (ifcfg, "DHCPV6_HOSTNAME", hostname);
+	g_hash_table_insert (dhcp_overrides, "use-hostname", g_strdup(hostname));
 
-	/* Missing DHCPV6_SEND_HOSTNAME means TRUE, and we prefer not write it
-	 * explicitly in that case, because it is NM-specific variable
-	 */
-	if (nm_setting_ip_config_get_dhcp_send_hostname (s_ip6))
-		svUnsetValue (ifcfg, "DHCPV6_SEND_HOSTNAME");
-	else
-		svSetValueStr (ifcfg, "DHCPV6_SEND_HOSTNAME", "no");
+	if (!nm_setting_ip_config_get_dhcp_send_hostname (s_ip6))
+		g_hash_table_insert (dhcp_overrides, "send-hostname", g_strdup("no"));
 }
 
 static gboolean
 write_ip6_setting (NMConnection *connection,
-                   shvarFile *ifcfg,
-                   GString **out_route6_content,
+                   GOutputStream *netplan,
+		   GArray *addresses,
+		   GArray *nameservers,
+		   GArray *searches,
+		   GHashTable *dhcp_overrides,
                    GError **error)
 {
 	NMSettingIPConfig *s_ip6;
@@ -2763,215 +2609,148 @@ write_ip6_setting (NMConnection *connection,
 	const char *dns;
 	gint64 route_metric;
 	NMIPRouteTableSyncMode route_table;
-	GString *ip_str1, *ip_str2, *ip_ptr;
+	GString *ip_str;
 	NMSettingIP6ConfigAddrGenMode addr_gen_mode;
 
-	NM_SET_OUT (out_route6_content, NULL);
-
 	s_ip6 = nm_connection_get_setting_ip6_config (connection);
 	if (!s_ip6) {
-		/* slave-type: clear IPv6 settings
-		 *
-		 * Some IPv6 setting related options are not cleared,
-		 * for no strong reason. */
-		svUnsetValue (ifcfg, "IPV6INIT");
-		svUnsetValue (ifcfg, "IPV6_AUTOCONF");
-		svUnsetValue (ifcfg, "DHCPV6C");
-		svUnsetValue (ifcfg, "DHCPv6_DUID");
-		svUnsetValue (ifcfg, "DHCPV6_HOSTNAME");
-		svUnsetValue (ifcfg, "DHCPV6_SEND_HOSTNAME");
-		svUnsetValue (ifcfg, "IPV6_DEFROUTE");
-		svUnsetValue (ifcfg, "IPV6_PEERDNS");
-		svUnsetValue (ifcfg, "IPV6_PEERROUTES");
-		svUnsetValue (ifcfg, "IPV6_FAILURE_FATAL");
-		svUnsetValue (ifcfg, "IPV6_ROUTE_METRIC");
-		svUnsetValue (ifcfg, "IPV6_ADDR_GEN_MODE");
-		svUnsetValue (ifcfg, "IPV6_RES_OPTIONS");
 		return TRUE;
 	}
 
 	value = nm_setting_ip_config_get_method (s_ip6);
 	g_assert (value);
-	svUnsetValue (ifcfg, "IPV6_DISABLED");
 	if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
-		svSetValueStr (ifcfg, "IPV6INIT", "no");
-		svUnsetValue (ifcfg, "DHCPV6C");
 		return TRUE;
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DISABLED)) {
-		svSetValueStr (ifcfg, "IPV6_DISABLED", "yes");
-		svSetValueStr (ifcfg, "IPV6INIT", "no");
-		svUnsetValue (ifcfg, "DHCPV6C");
-		svUnsetValue (ifcfg, "IPV6_AUTOCONF");
+		// TODO: (cyphermox) set optional
 		return TRUE;
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
-		svSetValueStr (ifcfg, "IPV6INIT", "yes");
-		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "yes");
-		svUnsetValue (ifcfg, "DHCPV6C");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp6: yes\n");
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
-		svSetValueStr (ifcfg, "IPV6INIT", "yes");
-		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "no");
-		svSetValueStr (ifcfg, "DHCPV6C", "yes");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp6: yes\n");
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_MANUAL)) {
-		svSetValueStr (ifcfg, "IPV6INIT", "yes");
-		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "no");
-		svUnsetValue (ifcfg, "DHCPV6C");
+		// TODO: (cyphermox) implement addresses: [] separately; below
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)) {
-		svSetValueStr (ifcfg, "IPV6INIT", "yes");
-		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "no");
-		svUnsetValue (ifcfg, "DHCPV6C");
+		// TODO: (cyphermox) set optional
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
-		svSetValueStr (ifcfg, "IPV6INIT", "yes");
-		svSetValueStr (ifcfg, "IPV6_AUTOCONF", "shared");
-		svUnsetValue (ifcfg, "DHCPV6C");
+		// TODO: (cyphermox) implement sharing
 	}
 
-	svSetValueStr (ifcfg, "DHCPV6_DUID",
-	               nm_setting_ip6_config_get_dhcp_duid (NM_SETTING_IP6_CONFIG (s_ip6)));
+	// TODO: (cyphermox) not in netplan yet (DUID)
+	//svSetValueStr (netplan, "DHCPV6_DUID",
+	//               nm_setting_ip6_config_get_dhcp_duid (NM_SETTING_IP6_CONFIG (s_ip6)));
 
-	write_ip6_setting_dhcp_hostname (s_ip6, ifcfg);
+	write_ip6_setting_dhcp_hostname (s_ip6, dhcp_overrides);
+	// TODO: (cyphermox) write out dhcp_overrides to GOutputStream
 
 	/* Write out IP addresses */
 	num = nm_setting_ip_config_get_num_addresses (s_ip6);
-	ip_str1 = g_string_new (NULL);
-	ip_str2 = g_string_new (NULL);
 	for (i = 0; i < num; i++) {
-		if (i == 0)
-			ip_ptr = ip_str1;
-		else
-			ip_ptr = ip_str2;
+		ip_str = g_string_new (NULL);
 
 		addr = nm_setting_ip_config_get_address (s_ip6, i);
 
-		if (i > 1)
-			g_string_append_c (ip_ptr, ' ');  /* separate addresses in IPV6ADDR_SECONDARIES */
-		g_string_append_printf (ip_ptr, "%s/%u",
-		                        nm_ip_address_get_address (addr),
-		                        nm_ip_address_get_prefix (addr));
+		g_string_printf (ip_str, "%s/%u",
+		                 nm_ip_address_get_address (addr),
+		                 nm_ip_address_get_prefix (addr));
+
+		value = g_string_free(ip_str, FALSE);
+		g_array_append_val(addresses, value);
 	}
-	svSetValueStr (ifcfg, "IPV6ADDR", ip_str1->str);
-	svSetValueStr (ifcfg, "IPV6ADDR_SECONDARIES", ip_str2->str);
-	svSetValueStr (ifcfg, "IPV6_DEFAULTGW", nm_setting_ip_config_get_gateway (s_ip6));
-	g_string_free (ip_str1, TRUE);
-	g_string_free (ip_str2, TRUE);
 
 	/* Write out DNS - 'DNS' key is used both for IPv4 and IPv6 */
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	num4 = s_ip4 ? nm_setting_ip_config_get_num_dns (s_ip4) : 0; /* from where to start with IPv6 entries */
 	num = nm_setting_ip_config_get_num_dns (s_ip6);
-	for (i = 0; i < 254; i++) {
-		char tag[64];
-
-		numbered_tag (tag, "DNS", i + num4 + 1);
-
-		if (i >= num)
-			svUnsetValue (ifcfg, tag);
-		else {
-			dns = nm_setting_ip_config_get_dns (s_ip6, i);
-			svSetValueStr (ifcfg, tag, dns);
-		}
+	for (i = 0; i < num; i++) {
+		dns = nm_setting_ip_config_get_dns (s_ip6, i);
+		g_array_append_val(nameservers, dns);
 	}
 
 	/* Write out DNS domains */
 	num = nm_setting_ip_config_get_num_dns_searches (s_ip6);
 	if (num > 0) {
-		nm_auto_free_gstring GString *searches = NULL;
-
-		searches = g_string_new (NULL);
 		for (i = 0; i < num; i++) {
-			if (searches->len > 0)
-				g_string_append_c (searches, ' ');
-			g_string_append (searches, nm_setting_ip_config_get_dns_search (s_ip6, i));
+			value = nm_setting_ip_config_get_dns_search (s_ip6, i);
+			g_array_append_val (searches, value);
 		}
-		svSetValueStr (ifcfg, "IPV6_DOMAIN", searches->str);
-	} else
-		svUnsetValue (ifcfg, "IPV6_DOMAIN");
+	}
 
 	/* handle IPV6_DEFROUTE */
 	/* IPV6_DEFROUTE has the opposite meaning from 'never-default' */
-	if (nm_setting_ip_config_get_never_default (s_ip6))
-		svSetValueStr (ifcfg, "IPV6_DEFROUTE", "no");
-	else
-		svSetValueStr (ifcfg, "IPV6_DEFROUTE", "yes");
-
-	svSetValueStr (ifcfg, "IPV6_PEERDNS",
-	               nm_setting_ip_config_get_ignore_auto_dns (s_ip6) ? "no" : NULL);
-
-	svSetValueStr (ifcfg, "IPV6_PEERROUTES",
-	               nm_setting_ip_config_get_ignore_auto_routes (s_ip6) ? "no" : NULL);
+	if (nm_setting_ip_config_get_never_default (s_ip6)) {
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp6-overrides:\n");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        use-routes: no\n");
+	}
 
-	svSetValueStr (ifcfg, "IPV6_FAILURE_FATAL",
-	               nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes");
+	// TODO: (cyphermox)  more about "optional" (see above)
+	//svSetValueStr (netplan, "IPV6_FAILURE_FATAL",
+	//               nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes");
 
 	route_metric = nm_setting_ip_config_get_route_metric (s_ip6);
-	svSetValueInt64_cond (ifcfg,
-	                      "IPV6_ROUTE_METRIC",
-	                      route_metric != -1,
-	                      route_metric);
+	if (route_metric != -1)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "      metric: %ld\n", route_metric);
+
+#if 0
+    // TODO: (cyphermox)  Currently can't set what route table in netplan.
+    // Implement RouteTable= (networkd)  for DHCP.
 
 	route_table = nm_setting_ip_config_get_route_table (s_ip6);
-	svSetValueInt64_cond (ifcfg,
+	svSetValueInt64_cond (netplan,
 	                      "IPV6_ROUTE_TABLE",
 	                      route_table != 0,
 	                      route_table);
+#endif
 
 	/* IPv6 Privacy Extensions */
-	svUnsetValue (ifcfg, "IPV6_PRIVACY");
-	svUnsetValue (ifcfg, "IPV6_PRIVACY_PREFER_PUBLIC_IP");
 	switch (nm_setting_ip6_config_get_ip6_privacy (NM_SETTING_IP6_CONFIG (s_ip6))) {
-	case NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED:
-		svSetValueStr (ifcfg, "IPV6_PRIVACY", "no");
-	break;
 	case NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR:
-		svSetValueStr (ifcfg, "IPV6_PRIVACY", "rfc3041");
-		svSetValueStr (ifcfg, "IPV6_PRIVACY_PREFER_PUBLIC_IP", "yes");
-	break;
+		// FIXME: not implemented; use the temporary always.
 	case NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR:
-		svSetValueStr (ifcfg, "IPV6_PRIVACY", "rfc3041");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      ipv6-privacy: yes\n");
 	break;
 	default:
 	break;
 	}
 
+#if 0
+    // TODO: (cyphermox) Address generation and interface identified. (not in netplan yet)
 	/* IPv6 Address generation mode */
 	addr_gen_mode = nm_setting_ip6_config_get_addr_gen_mode (NM_SETTING_IP6_CONFIG (s_ip6));
 	if (addr_gen_mode != NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64) {
-		svSetValueEnum (ifcfg, "IPV6_ADDR_GEN_MODE", nm_setting_ip6_config_addr_gen_mode_get_type (),
+		svSetValueEnum (netplan, "IPV6_ADDR_GEN_MODE", nm_setting_ip6_config_addr_gen_mode_get_type (),
 		                addr_gen_mode);
 	} else {
-		svUnsetValue (ifcfg, "IPV6_ADDR_GEN_MODE");
+		svUnsetValue (netplan, "IPV6_ADDR_GEN_MODE");
 	}
 
 	/* IPv6 tokenized interface identifier */
 	value = nm_setting_ip6_config_get_token (NM_SETTING_IP6_CONFIG (s_ip6));
-	svSetValueStr (ifcfg, "IPV6_TOKEN", value);
+	svSetValueStr (netplan, "IPV6_TOKEN", value);
+#endif
 
+    // TODO: (cyphermox) Implement priority for connections
+#if 0
 	priority = nm_setting_ip_config_get_dns_priority (s_ip6);
 	if (priority)
-		svSetValueInt64 (ifcfg, "IPV6_DNS_PRIORITY", priority);
+		svSetValueInt64 (netplan, "IPV6_DNS_PRIORITY", priority);
 	else
-		svUnsetValue (ifcfg, "IPV6_DNS_PRIORITY");
+		svUnsetValue (netplan, "IPV6_DNS_PRIORITY");
 
-	write_res_options (ifcfg, s_ip6, "IPV6_RES_OPTIONS");
-
-	NM_SET_OUT (out_route6_content, write_route_file (s_ip6));
+	write_res_options (netplan, s_ip6, "IPV6_RES_OPTIONS");
+#endif
 
 	return TRUE;
 }
 
 static void
 write_ip_routing_rules (NMConnection *connection,
-                        shvarFile *ifcfg,
-                        gboolean route_ignore)
+                        GOutputStream *netplan)
 {
-	gsize idx;
+	gsize idx = 0;
 	int is_ipv4;
 
-	svUnsetAll (ifcfg, SV_KEY_TYPE_ROUTING_RULE4 | SV_KEY_TYPE_ROUTING_RULE6);
-
-	if (route_ignore)
-		return;
-
-	idx = 0;
+	g_output_stream_printf(netplan, 0, NULL, NULL, "      routing-policy:\n");
 
 	for (is_ipv4 = 1; is_ipv4 >= 0; is_ipv4--) {
 		const int addr_family = is_ipv4 ? AF_INET : AF_INET6;
@@ -2988,137 +2767,42 @@ write_ip_routing_rules (NMConnection *connection,
 			gs_free const char *s = NULL;
 			char key[64];
 
-			s = nm_ip_routing_rule_to_string (rule,
-			                                  NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE,
-			                                  NULL,
-			                                  NULL);
-			if (!s)
-				continue;
-
-			if (is_ipv4)
-				numbered_tag (key, "ROUTING_RULE_", ++idx);
-			else
-				numbered_tag (key, "ROUTING_RULE6_", ++idx);
-			svSetValueStr (ifcfg, key, s);
+			g_output_stream_printf(netplan, 0, NULL, NULL, "        - to: %s\n",
+			                       nm_ip_routing_rule_get_to(rule));
+			g_output_stream_printf(netplan, 0, NULL, NULL, "          from: %s\n",
+			                       nm_ip_routing_rule_get_from(rule));
+			g_output_stream_printf(netplan, 0, NULL, NULL, "          table: %d\n",
+			                       nm_ip_routing_rule_get_table(rule));
+			g_output_stream_printf(netplan, 0, NULL, NULL, "          mark: %d\n",
+			                       nm_ip_routing_rule_get_fwmark(rule));
+			g_output_stream_printf(netplan, 0, NULL, NULL, "          type-of-service: %d\n",
+			                       nm_ip_routing_rule_get_tos(rule));
+			g_output_stream_printf(netplan, 0, NULL, NULL, "          priority: %ld\n",
+			                       nm_ip_routing_rule_get_priority(rule));
 		}
 	}
 }
 
-static char *
-escape_id (const char *id)
-{
-	char *escaped = g_strdup (id);
-	char *p = escaped;
-
-	/* Escape random stuff */
-	while (*p) {
-		if (*p == ' ')
-			*p = '_';
-		else if (strchr ("\\][|/=()!:", *p))
-			*p = '-';
-		p++;
-	}
-
-	return escaped;
-}
-
 static gboolean
 do_write_construct (NMConnection *connection,
-                    const char *ifcfg_dir,
-                    const char *filename,
-                    NMSIfcfgRHWriterAllowFilenameCb allow_filename_cb,
-                    gpointer allow_filename_user_data,
-                    shvarFile **out_ifcfg,
-                    GHashTable **out_blobs,
-                    GHashTable **out_secrets,
-                    gboolean *out_route_ignore,
-                    shvarFile **out_route_content_svformat,
-                    GString **out_route_content,
-                    GString **out_route6_content,
+                    GOutputStream *netplan,
                     GError **error)
 {
 	NMSettingConnection *s_con;
-	nm_auto_shvar_file_close shvarFile *ifcfg = NULL;
-	gs_free char *ifcfg_name = NULL;
-	gs_free char *route_path = NULL;
-	gs_free char *route6_path = NULL;
-	const char *type;
-	gs_unref_hashtable GHashTable *blobs = NULL;
-	gs_unref_hashtable GHashTable *secrets = NULL;
-	gboolean wired;
-	gboolean no_8021x;
-	gboolean route_path_is_svformat;
-	gboolean has_complex_routes_v4;
-	gboolean has_complex_routes_v6;
-	gboolean route_ignore;
-	nm_auto_shvar_file_close shvarFile *route_content_svformat = NULL;
-	nm_auto_free_gstring GString *route_content = NULL;
-	nm_auto_free_gstring GString *route6_content = NULL;
+	NMSettingIPConfig *s_ip6;
+	NMSettingIPConfig *s_ip4;
+	const gchar *type = NULL;
+	GArray *addresses, *nameservers, *searches;
+	GHashTable *dhcp_overrides;
 
 	nm_assert (NM_IS_CONNECTION (connection));
 	nm_assert (_nm_connection_verify (connection, NULL) == NM_SETTING_VERIFY_SUCCESS);
 
-	if (!nms_ifcfg_rh_writer_can_write_connection (connection, error))
+	if (!nms_netplan_writer_can_write_connection (connection, error))
 		return FALSE;
 
 	s_con = nm_connection_get_setting_connection (connection);
 
-	if (filename) {
-		/* For existing connections, 'filename' should be full path to ifcfg file */
-		ifcfg = svOpenFile (filename, error);
-		if (!ifcfg)
-			return FALSE;
-
-		ifcfg_name = g_strdup (filename);
-	} else if (ifcfg_dir) {
-		gs_free char *escaped = NULL;
-		int i_path;
-
-		escaped = escape_id (nm_setting_connection_get_id (s_con));
-
-		for (i_path = 0; i_path < 10000; i_path++) {
-			gs_free char *path_candidate = NULL;
-
-			if (i_path == 0)
-				path_candidate = g_strdup_printf ("%s/ifcfg-%s", ifcfg_dir, escaped);
-			else
-				path_candidate = g_strdup_printf ("%s/ifcfg-%s-%d", ifcfg_dir, escaped, i_path);
-
-			if (   allow_filename_cb
-			    && !allow_filename_cb (path_candidate, allow_filename_user_data))
-				continue;
-
-			if (g_file_test (path_candidate, G_FILE_TEST_EXISTS))
-				continue;
-
-			ifcfg_name = g_steal_pointer (&path_candidate);
-			break;
-		}
-
-		if (!ifcfg_name) {
-			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			                     "Failed to find usable ifcfg file name");
-			return FALSE;
-		}
-
-		ifcfg = svCreateFile (ifcfg_name);
-	} else
-		ifcfg = svCreateFile ("/tmp/ifcfg-dummy");
-
-	route_path = utils_get_route_path (svFileGetName (ifcfg));
-	if (!route_path) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Could not get route file path for '%s'", svFileGetName (ifcfg));
-		return FALSE;
-	}
-
-	route6_path = utils_get_route6_path (svFileGetName (ifcfg));
-	if (!route6_path) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Could not get route6 file path for '%s'", svFileGetName (ifcfg));
-		return FALSE;
-	}
-
 	type = nm_setting_connection_get_connection_type (s_con);
 	if (!type) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
@@ -3126,10 +2810,6 @@ do_write_construct (NMConnection *connection,
 		return FALSE;
 	}
 
-	secrets = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, g_free);
-
-	wired = FALSE;
-	no_8021x = FALSE;
 	if (!strcmp (type, NM_SETTING_WIRED_SETTING_NAME)) {
 		// FIXME: can't write PPPoE at this time
 		if (nm_connection_get_setting_pppoe (connection)) {
@@ -3139,26 +2819,25 @@ do_write_construct (NMConnection *connection,
 			return FALSE;
 		}
 
-		if (!write_wired_setting (connection, ifcfg, error))
+		if (!write_wired_setting (connection, netplan, error))
 			return FALSE;
-		wired = TRUE;
 	} else if (!strcmp (type, NM_SETTING_VLAN_SETTING_NAME)) {
-		if (!write_vlan_setting (connection, ifcfg, &wired, error))
+		if (!write_vlan_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
-		if (!write_wireless_setting (connection, ifcfg, secrets, &no_8021x, error))
+		if (!write_wireless_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_INFINIBAND_SETTING_NAME)) {
-		if (!write_infiniband_setting (connection, ifcfg, error))
+		if (!write_infiniband_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_BOND_SETTING_NAME)) {
-		if (!write_bond_setting (connection, ifcfg, &wired, error))
+		if (!write_bond_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_TEAM_SETTING_NAME)) {
-		if (!write_team_setting (connection, ifcfg, &wired, error))
+		if (!write_team_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_BRIDGE_SETTING_NAME)) {
-		if (!write_bridge_setting (connection, ifcfg, &wired, error))
+		if (!write_bridge_setting (connection, netplan, error))
 			return FALSE;
 	} else {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
@@ -3166,223 +2845,130 @@ do_write_construct (NMConnection *connection,
 		return FALSE;
 	}
 
-	if (!no_8021x) {
-		blobs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, (GDestroyNotify) g_bytes_unref);
-		if (!write_8021x_setting (connection, ifcfg, secrets, blobs, wired, error))
-			return FALSE;
-	}
-
-	if (!write_bridge_port_setting (connection, ifcfg, error))
-		return FALSE;
-
-	if (!write_team_port_setting (connection, ifcfg, error))
+	if (!write_bridge_port_setting (connection, netplan, error))
 		return FALSE;
 
-	if (!write_dcb_setting (connection, ifcfg, error))
-		return FALSE;
+	//if (!write_team_port_setting (connection, netplan, error))
+	//	return FALSE;
 
-	if (!write_proxy_setting (connection, ifcfg, error))
-		return FALSE;
+	//if (!write_dcb_setting (connection, netplan, error))
+	//	return FALSE;
 
-	if (!write_ethtool_setting (connection, ifcfg, error))
-		return FALSE;
+	//if (!write_proxy_setting (connection, netplan, error))
+	//	return FALSE;
 
-	if (!write_user_setting (connection, ifcfg, error))
-		return FALSE;
+	//if (!write_ethtool_setting (connection, netplan, error))
+	//	return FALSE;
 
-	if (!write_match_setting (connection, ifcfg, error))
+	if (!write_user_setting (connection, netplan, error))
 		return FALSE;
 
-	write_sriov_setting (connection, ifcfg);
-
-	if (!write_tc_setting (connection, ifcfg, error))
+	if (!write_match_setting (connection, netplan, error))
 		return FALSE;
 
-	svUnsetValue (ifcfg, "DHCP_HOSTNAME");
-	svUnsetValue (ifcfg, "DHCP_FQDN");
-
-	route_path_is_svformat = utils_has_route_file_new_syntax (route_path);
+	//write_sriov_setting (connection, netplan);
 
-	has_complex_routes_v4 = utils_has_complex_routes (ifcfg_name, AF_INET);
-	has_complex_routes_v6 = utils_has_complex_routes (ifcfg_name, AF_INET6);
+	//if (!write_tc_setting (connection, netplan, error))
+	//	return FALSE;
 
-	if (has_complex_routes_v4 || has_complex_routes_v6) {
-		NMSettingIPConfig *s_ip4, *s_ip6;
-
-		s_ip4 = nm_connection_get_setting_ip4_config (connection);
-		s_ip6 = nm_connection_get_setting_ip6_config (connection);
-		if (   (   s_ip4
-		        && nm_setting_ip_config_get_num_routes (s_ip4) > 0)
-		    || (   s_ip6
-		        && nm_setting_ip_config_get_num_routes (s_ip6) > 0)) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			             "Cannot configure static routes on a connection that has an associated 'rule%s-' file",
-			             has_complex_routes_v4 ? "" : "6");
-			return FALSE;
-		}
-		if (   (   s_ip4
-		        && nm_setting_ip_config_get_route_table (s_ip4) != 0)
-		    || (   s_ip6
-		        && nm_setting_ip_config_get_route_table (s_ip6) != 0)) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			             "Cannot configure a route table for policy routing on a connection that has an associated 'rule%s-' file",
-			             has_complex_routes_v4 ? "" : "6");
-			return FALSE;
-		}
-		if (   (   s_ip4
-		        && nm_setting_ip_config_get_num_routing_rules (s_ip4) > 0)
-		    || (   s_ip6
-		        && nm_setting_ip_config_get_num_routing_rules (s_ip6) > 0)) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			             "Cannot configure routing rules on a connection that has an associated 'rule%s-' file",
-			             has_complex_routes_v4 ? "" : "6");
-			return FALSE;
-		}
-		route_ignore = TRUE;
-	} else
-		route_ignore = FALSE;
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
 
 	if (!write_ip4_setting (connection,
-	                        ifcfg,
-	                        !route_ignore && route_path_is_svformat ? &route_content_svformat : NULL,
-	                        !route_ignore && route_path_is_svformat ? NULL                      :&route_content,
+	                        netplan,
+				addresses,
+				nameservers,
+				searches,
 	                        error))
 		return FALSE;
 
 	if (!write_ip6_setting (connection,
-	                        ifcfg,
-	                        !route_ignore ? &route6_content : NULL,
+	                        netplan,
+				addresses,
+				nameservers,
+				searches,
+				dhcp_overrides,
 	                        error))
 		return FALSE;
 
 	write_ip_routing_rules (connection,
-	                        ifcfg,
-	                        route_ignore);
-
-	write_connection_setting (s_con, ifcfg);
-
-	NM_SET_OUT (out_ifcfg, g_steal_pointer (&ifcfg));
-	NM_SET_OUT (out_blobs, g_steal_pointer (&blobs));
-	NM_SET_OUT (out_secrets, g_steal_pointer (&secrets));
-	NM_SET_OUT (out_route_ignore, route_ignore);
-	NM_SET_OUT (out_route_content_svformat, g_steal_pointer (&route_content_svformat));
-	NM_SET_OUT (out_route_content, g_steal_pointer (&route_content));
-	NM_SET_OUT (out_route6_content, g_steal_pointer (&route6_content));
+	                        netplan);
+
+	write_connection_setting (s_con, netplan);
+
+	//NM_SET_OUT (out_netplan, g_steal_pointer (&netplan));
 	return TRUE;
 }
 
 static gboolean
 do_write_to_disk (NMConnection *connection,
-                  shvarFile *ifcfg,
+                  GOutputStream *netplan,
                   GHashTable *blobs,
                   GHashTable *secrets,
                   gboolean route_ignore,
-                  shvarFile *route_content_svformat,
+                  GOutputStream *route_content_svformat,
                   GString *route_content,
                   GString *route6_content,
                   GError **error)
 {
 	/* From here on, we persist data to disk. Before, it was all in-memory
-	 * only. But we loaded the ifcfg files from disk, and managled our
+	 * only. But we loaded the netplan files from disk, and managled our
 	 * new settings (in-memory). */
 
-	if (!svWriteFile (ifcfg, 0644, error))
+#if 0  // TODO: (cyphermox) Do actually write everything together to disk...
+	if (!svWriteFile (netplan, 0644, error))
 		return FALSE;
 
-	write_ip4_aliases (connection, svFileGetName (ifcfg));
-
 	if (!write_blobs (blobs, error))
 		return FALSE;
 
-	if (!write_secrets (ifcfg, secrets, error))
+	if (!write_secrets (netplan, secrets, error))
 		return FALSE;
 
-	if (!route_ignore) {
-		gs_free char *route_path = utils_get_route_path (svFileGetName (ifcfg));
-
-		if (!route_content && !route_content_svformat)
-			(void) unlink (route_path);
-		else {
-			nm_assert (route_content_svformat || route_content);
-			if (route_content_svformat) {
-				if (!svWriteFile (route_content_svformat, 0644, error))
-					return FALSE;
-			} else {
-				if (!g_file_set_contents (route_path, route_content->str, route_content->len, NULL)) {
-					g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-					             "Writing route file '%s' failed", route_path);
-					return FALSE;
-				}
-			}
-		}
-	}
-
-	if (!route_ignore) {
-		gs_free char *route6_path = utils_get_route6_path (svFileGetName (ifcfg));
-
-		if (!route6_content)
-			(void) unlink (route6_path);
-		else {
-			if (!g_file_set_contents (route6_path, route6_content->str, route6_content->len, NULL)) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-				             "Writing route6 file '%s' failed", route6_path);
-				return FALSE;
-			}
-		}
+	if (route_ignore) {
+		// TODO: write out ignore routes settings
 	}
+#endif
 
 	return TRUE;
 }
 
 gboolean
-nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
-                                      const char *ifcfg_dir,
-                                      const char *filename,
-                                      NMSIfcfgRHWriterAllowFilenameCb allow_filename_cb,
-                                      gpointer allow_filename_user_data,
-                                      char **out_filename,
-                                      NMConnection **out_reread,
-                                      gboolean *out_reread_same,
-                                      GError **error)
+nms_netplan_writer_write_connection (NMConnection *connection,
+                                     const char *netplan_dir,
+                                     const char *filename,
+                                     NMSNetplanWriterAllowFilenameCb allow_filename_cb,
+                                     gpointer allow_filename_user_data,
+                                     char **out_filename,
+                                     NMConnection **out_reread,
+                                     gboolean *out_reread_same,
+                                     GError **error)
 {
-	nm_auto_shvar_file_close shvarFile *ifcfg = NULL;
+	GOutputStream *netplan;
+	gboolean ret = TRUE;
 	nm_auto_free_gstring GString *route_content = NULL;
 	gboolean route_ignore = FALSE;
-	nm_auto_shvar_file_close shvarFile *route_content_svformat = NULL;
-	nm_auto_free_gstring GString *route6_content = NULL;
 	gs_unref_hashtable GHashTable *secrets = NULL;
 	gs_unref_hashtable GHashTable *blobs = NULL;
 
 	nm_assert (!out_reread || !*out_reread);
 
 	if (!do_write_construct (connection,
-	                         ifcfg_dir,
-	                         filename,
-	                         allow_filename_cb,
-	                         allow_filename_user_data,
-	                         &ifcfg,
-	                         &blobs,
-	                         &secrets,
-	                         &route_ignore,
-	                         &route_content_svformat,
-	                         &route_content,
-	                         &route6_content,
+	                         netplan,
 	                         error))
 		return FALSE;
 
 	_LOGT ("write: write connection %s (%s) to file \"%s\"",
 	       nm_connection_get_id (connection),
 	       nm_connection_get_uuid (connection),
-	       svFileGetName (ifcfg));
+	       filename);
 
 	if (!do_write_to_disk (connection,
-	                       ifcfg,
+	                       netplan,
 	                       blobs,
 	                       secrets,
 	                       route_ignore,
-	                       route_content_svformat,
-	                       route_content,
-	                       route6_content,
+			       NULL, NULL, NULL,
 	                       error))
 		return FALSE;
 
@@ -3401,7 +2987,7 @@ nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
 		gs_free_error GError *local = NULL;
 		gs_free char *unhandled = NULL;
 
-		reread = connection_from_file (svFileGetName (ifcfg),
+		reread = connection_from_file (filename,
 		                               &unhandled,
 		                               &local,
 		                               NULL);
@@ -3409,11 +2995,11 @@ nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
 
 		if (!reread) {
 			_LOGW ("write: failure to re-read connection \"%s\": %s",
-			       svFileGetName (ifcfg), local->message);
+			       filename, local->message);
 		} else if (unhandled) {
 			g_clear_object (&reread);
 			_LOGW ("write: failure to re-read connection \"%s\": %s",
-			       svFileGetName (ifcfg), "connection is unhandled");
+			       filename, "connection is unhandled");
 		} else {
 			if (out_reread_same) {
 				reread_same = nm_connection_compare (reread, connection, NM_SETTING_COMPARE_FLAG_EXACT);
@@ -3421,7 +3007,7 @@ nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
 					_LOGD ("write: connection %s (%s) was modified by persisting it to \"%s\" ",
 					       nm_connection_get_id (connection),
 					       nm_connection_get_uuid (connection),
-					       svFileGetName (ifcfg));
+					       filename);
 				}
 			}
 		}
@@ -3430,34 +3016,31 @@ nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
 		NM_SET_OUT (out_reread_same, reread_same);
 	}
 
-	/* Only return the filename if this was a newly written ifcfg */
+	/* Only return the filename if this was a newly written netplan */
 	if (out_filename && !filename)
-		*out_filename = g_strdup (svFileGetName (ifcfg));
+		*out_filename = g_strdup (filename);
 
 	return TRUE;
 }
 
 gboolean
-nms_ifcfg_rh_writer_can_write_connection (NMConnection *connection, GError **error)
+nms_netplan_writer_can_write_connection (NMConnection *connection, GError **error)
 {
 	const char *type, *id;
 
 	type = nm_connection_get_connection_type (connection);
+	_LOGW ("MATT: writing \"%s\"", type);
 	if (NM_IN_STRSET (type,
 	                  NM_SETTING_VLAN_SETTING_NAME,
 	                  NM_SETTING_WIRELESS_SETTING_NAME,
-	                  NM_SETTING_INFINIBAND_SETTING_NAME,
 	                  NM_SETTING_BOND_SETTING_NAME,
 	                  NM_SETTING_TEAM_SETTING_NAME,
 	                  NM_SETTING_BRIDGE_SETTING_NAME))
 		return TRUE;
-	if (   nm_streq0 (type, NM_SETTING_WIRED_SETTING_NAME)
-	    && !nm_connection_get_setting_pppoe (connection))
-		return TRUE;
 
 	id = nm_connection_get_id (connection);
 	g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-	             "The ifcfg-rh plugin cannot write the connection %s%s%s (type %s%s%s)",
+	             "The netplan plugin cannot write the connection %s%s%s (type %s%s%s)",
 	             NM_PRINT_FMT_QUOTE_STRING (id),
 	             NM_PRINT_FMT_QUOTE_STRING (type));
 	return FALSE;
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.h b/src/settings/plugins/netplan/nms-netplan-writer.h
index fec844748bc356081946eb832fbb4ee8c213d82a..5f0eddcdaa3f6cd2945903af9b6233e6cadeb10a 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.h
+++ b/src/settings/plugins/netplan/nms-netplan-writer.h
@@ -1,29 +1,31 @@
 // SPDX-License-Identifier: GPL-2.0+
-/* NetworkManager system settings service - keyfile plugin
+/* NetworkManager system settings service
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ *
+ * Copyright (C) 2019 Canonical Ltd..
  */
 
-#ifndef __NMS_IFCFG_RH_WRITER_H__
-#define __NMS_IFCFG_RH_WRITER_H__
+#ifndef __NMS_NETPLAN_WRITER_H__
+#define __NMS_NETPLAN_WRITER_H__
 
 #include "nm-connection.h"
 
 
-typedef gboolean (*NMSIfcfgRHWriterAllowFilenameCb) (const char *check_filename,
+typedef gboolean (*NMSNetplanWriterAllowFilenameCb) (const char *check_filename,
                                                      gpointer allow_filename_user_data);
 
-gboolean nms_ifcfg_rh_writer_can_write_connection (NMConnection *connection,
-                                                   GError **error);
+gboolean nms_netplan_writer_can_write_connection (NMConnection *connection,
+                                                  GError **error);
 
-gboolean nms_ifcfg_rh_writer_write_connection (NMConnection *connection,
-                                               const char *ifcfg_dir,
-                                               const char *filename,
-                                               NMSIfcfgRHWriterAllowFilenameCb allow_filename_cb,
-                                               gpointer allow_filename_user_data,
-                                               char **out_filename,
-                                               NMConnection **out_reread,
-                                               gboolean *out_reread_same,
-                                               GError **error);
+gboolean nms_netplan_writer_write_connection (NMConnection *connection,
+                                              const char *netplan_dir,
+                                              const char *filename,
+                                              NMSNetplanWriterAllowFilenameCb allow_filename_cb,
+                                              gpointer allow_filename_user_data,
+                                              char **out_filename,
+                                              NMConnection **out_reread,
+                                              gboolean *out_reread_same,
+                                              GError **error);
 
-#endif /* __NMS_IFCFG_RH_WRITER_H__ */
+#endif /* __NMS_NETPLAN_WRITER_H__ */
diff --git a/src/settings/plugins/netplan/tests/meson.build b/src/settings/plugins/netplan/tests/meson.build
deleted file mode 100644
index dcc18d8b68c2eecf3257bb83ccf3cba201a36e53..0000000000000000000000000000000000000000
--- a/src/settings/plugins/netplan/tests/meson.build
+++ /dev/null
@@ -1,17 +0,0 @@
-test_unit = 'test-netplan'
-
-test_netplan_dir = meson.current_source_dir()
-
-exe = executable(
-  test_unit,
-  test_unit + '.c',
-  dependencies: test_nm_dep,
-  link_with: libnms_netplan_core,
-)
-
-test(
-  'netplan/' + test_unit,
-  test_script,
-  timeout: 90,
-  args: test_args + [exe.full_path()],
-)
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
deleted file mode 100644
index 3cd571dfcf8e9e66090ef45485ba0193705036f2..0000000000000000000000000000000000000000
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ /dev/null
@@ -1,10485 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/* NetworkManager system settings service - keyfile plugin
- *
- * Copyright (C) 2008 - 2011 Red Hat, Inc.
- */
-
-#include "nm-default.h"
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <unistd.h>
-#include <linux/pkt_sched.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include "nm-utils.h"
-#include "nm-setting-connection.h"
-#include "nm-setting-wired.h"
-#include "nm-setting-user.h"
-#include "nm-setting-wireless.h"
-#include "nm-setting-wireless-security.h"
-#include "nm-setting-ip4-config.h"
-#include "nm-setting-ip6-config.h"
-#include "nm-setting-8021x.h"
-#include "nm-setting-pppoe.h"
-#include "nm-setting-ppp.h"
-#include "nm-setting-vpn.h"
-#include "nm-setting-ethtool.h"
-#include "nm-setting-gsm.h"
-#include "nm-setting-cdma.h"
-#include "nm-setting-serial.h"
-#include "nm-setting-vlan.h"
-#include "nm-setting-dcb.h"
-#include "nm-core-internal.h"
-#include "nm-libnm-core-intern/nm-ethtool-utils.h"
-
-#include "NetworkManagerUtils.h"
-
-#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-common.h"
-#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-reader.h"
-#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-writer.h"
-#include "settings/plugins/ifcfg-rh/nms-ifcfg-rh-utils.h"
-
-#include "nm-test-utils-core.h"
-
-#define TEST_IFCFG_DIR          NM_BUILD_SRCDIR"/src/settings/plugins/ifcfg-rh/tests/network-scripts"
-#define TEST_SCRATCH_DIR        NM_BUILD_BUILDDIR"/src/settings/plugins/ifcfg-rh/tests/network-scripts"
-#define TEST_SCRATCH_DIR_TMP    TEST_SCRATCH_DIR"/tmp"
-
-#define TEST_SCRATCH_ALIAS_BASE TEST_SCRATCH_DIR"/ifcfg-alias0"
-
-/*****************************************************************************/
-
-#define _svOpenFile(testfile) \
-	({ \
-		shvarFile *_f; \
-		GError *_error = NULL; \
-		const char *_testfile = (testfile); \
-		\
-		g_assert (_testfile); \
-		_f = svOpenFile (_testfile, &_error); \
-		nmtst_assert_success (_f, _error); \
-		_f; \
-	})
-
-#define _svGetValue_check(f, key, expected_value) \
-	G_STMT_START { \
-		const char *_val; \
-		gs_free char *_to_free = NULL; \
-		gs_free char *_val_string = NULL; \
-		shvarFile *const _f = (f); \
-		const char *const _key = (key); \
-		\
-		_val_string = svGetValueStr_cp (_f, _key); \
-		_val = svGetValue (_f, _key, &_to_free); \
-		g_assert_cmpstr (_val, ==, (expected_value)); \
-		g_assert (   (!_val_string && (!_val || !_val[0])) \
-		          || ( _val_string && nm_streq0 (_val, _val_string))); \
-	} G_STMT_END
-
-static void
-_assert_reread_same (NMConnection *connection, NMConnection *reread)
-{
-	nmtst_assert_connection_verifies_without_normalization (reread);
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-_assert_reread_same_FIXME (NMConnection *connection, NMConnection *reread)
-{
-	gs_unref_object NMConnection *connection_normalized = NULL;
-	gs_unref_hashtable GHashTable *settings = NULL;
-
-	/* FIXME: these assertion failures should not happen as we expect
-	 * that re-reading a connection after write yields the same result.
-	 *
-	 * Needs investation and fixing. */
-	nmtst_assert_connection_verifies_without_normalization (reread);
-
-	connection_normalized = nmtst_connection_duplicate_and_normalize (connection);
-
-	g_assert (!nm_connection_compare (connection_normalized, reread, NM_SETTING_COMPARE_FLAG_EXACT));
-	g_assert (!nm_connection_diff (connection_normalized, reread, NM_SETTING_COMPARE_FLAG_EXACT, &settings));
-}
-
-/* dummy path for an "expected" file, meaning: don't check for expected
- * written ifcfg file. */
-static const char NO_EXPECTED[1];
-
-static void
-_assert_expected_content (NMConnection *connection, const char *filename, const char *expected)
-{
-	gs_free char *content_expectd = NULL;
-	gs_free char *content_written = NULL;
-	GError *error = NULL;
-	gsize len_expectd = 0;
-	gsize len_written = 0;
-	gboolean success;
-	const char *uuid = NULL;
-
-	g_assert (NM_IS_CONNECTION (connection));
-	g_assert (filename);
-	g_assert (g_file_test (filename, G_FILE_TEST_EXISTS));
-
-	g_assert (expected);
-	if (expected == NO_EXPECTED)
-		return;
-
-	success = g_file_get_contents (filename, &content_written, &len_written, &error);
-	nmtst_assert_success (success, error);
-
-	success = g_file_get_contents (expected, &content_expectd, &len_expectd, &error);
-	nmtst_assert_success (success, error);
-
-	{
-		gsize i, j;
-
-		for (i = 0; i < len_expectd; ) {
-			if (content_expectd[i] != '$') {
-				i++;
-				continue;
-			}
-			if (g_str_has_prefix (&content_expectd[i], "${UUID}")) {
-				GString *str;
-
-				if (!uuid) {
-					uuid = nm_connection_get_uuid (connection);
-					g_assert (uuid);
-				}
-
-				j = strlen (uuid);
-
-				str = g_string_new_len (content_expectd, len_expectd);
-				g_string_erase (str, i, NM_STRLEN ("${UUID}"));
-				g_string_insert_len (str, i, uuid, j);
-
-				g_free (content_expectd);
-				len_expectd = str->len;
-				content_expectd = g_string_free (str, FALSE);
-				i += j;
-				continue;
-			}
-
-			/* other '$' is not supported. If need be, support escaping of
-			 * '$' via '$$'. */
-			g_assert_not_reached ();
-		}
-	}
-
-	if (   len_expectd != len_written
-	    || memcmp (content_expectd, content_written, len_expectd) != 0) {
-		if (   g_getenv ("NMTST_IFCFG_RH_UPDATE_EXPECTED")
-		    || nm_streq0 (g_getenv ("NM_TEST_REGENERATE"), "1")) {
-			if (uuid) {
-				gs_free char *search = g_strdup_printf ("UUID=%s\n", uuid);
-				const char *s;
-				gsize i;
-				GString *str;
-
-				s = content_written;
-				while (TRUE) {
-					s = strstr (s, search);
-					g_assert (s);
-					if (   s == content_written
-					    || s[-1] == '\n')
-						break;
-					s += strlen (search);
-				}
-
-				i = s - content_written;
-
-				str = g_string_new_len (content_written, len_written);
-				g_string_erase (str, i, strlen (search));
-				g_string_insert (str, i, "UUID=${UUID}\n");
-
-				len_written = str->len;
-				content_written = g_string_free (str, FALSE);
-			}
-			success = g_file_set_contents (expected, content_written, len_written, &error);
-			nmtst_assert_success (success, error);
-		} else {
-			g_error ("The content of \"%s\" (%zu) differs from \"%s\" (%zu). Set NMTST_IFCFG_RH_UPDATE_EXPECTED=yes to update the files inplace\n\n>>>%s<<<\n\n>>>%s<<<\n",
-			         filename, len_written,
-			         expected, len_expectd,
-			         content_written,
-			         content_expectd);
-		}
-	}
-}
-
-#define _writer_update_connection_reread(connection, ifcfg_dir, filename, expected, out_reread, out_reread_same) \
-	G_STMT_START { \
-		gs_unref_object NMConnection *_connection = nmtst_connection_duplicate_and_normalize (connection); \
-		NMConnection **_out_reread = (out_reread); \
-		gboolean *_out_reread_same = (out_reread_same); \
-		const char *_ifcfg_dir = (ifcfg_dir); \
-		const char *_filename = (filename); \
-		const char *_expected = (expected); \
-		GError *_error = NULL; \
-		gboolean _success; \
-		\
-		g_assert (_ifcfg_dir && _ifcfg_dir[0]); \
-		g_assert (_filename && _filename[0]); \
-		\
-		_success = nms_ifcfg_rh_writer_write_connection (_connection, _ifcfg_dir, _filename, NULL, NULL, NULL, _out_reread, _out_reread_same, &_error); \
-		nmtst_assert_success (_success, _error); \
-		_assert_expected_content (_connection, _filename, _expected); \
-	} G_STMT_END
-
-#define _writer_update_connection(connection, ifcfg_dir, filename, expected) \
-	G_STMT_START { \
-		gs_unref_object NMConnection *_reread = NULL; \
-		NMConnection *_c = (connection); \
-		gboolean _reread_same = FALSE; \
-		\
-		_writer_update_connection_reread (_c, ifcfg_dir, filename, expected, &_reread, &_reread_same); \
-		_assert_reread_same (_c, _reread); \
-		g_assert (_reread_same); \
-	} G_STMT_END
-
-static NMConnection *
-_connection_from_file (const char *filename,
-                       const char *network_file,
-                       const char *test_type,
-                       char **out_unhandled)
-{
-	NMConnection *connection;
-	GError *error = NULL;
-	char *unhandled_fallback = NULL;
-
-	g_assert (!out_unhandled || !*out_unhandled);
-
-	connection = nmtst_connection_from_file (filename, network_file, test_type,
-	                                         out_unhandled ?: &unhandled_fallback, &error);
-	g_assert_no_error (error);
-	g_assert (!unhandled_fallback);
-
-	if (out_unhandled && *out_unhandled)
-		nmtst_assert_connection_verifies (connection);
-	else
-		nmtst_assert_connection_verifies_without_normalization (connection);
-	return connection;
-}
-
-static void
-_connection_from_file_fail (const char *filename,
-                            const char *network_file,
-                            const char *test_type,
-                            GError **error)
-{
-	NMConnection *connection;
-	GError *local = NULL;
-	char *unhandled = NULL;
-
-	connection = nmtst_connection_from_file (filename, network_file, test_type, &unhandled, &local);
-
-	g_assert (!connection);
-	g_assert (local);
-	g_assert (!unhandled);
-	g_propagate_error (error, local);
-}
-
-static void
-_writer_new_connection_reread (NMConnection *connection,
-                               const char *ifcfg_dir,
-                               char **out_filename,
-                               const char *expected,
-                               NMConnection **out_reread,
-                               gboolean *out_reread_same)
-{
-	gboolean success;
-	GError *error = NULL;
-	char *filename = NULL;
-	gs_unref_object NMConnection *con_verified = NULL;
-	gs_unref_object NMConnection *reread_copy = NULL;
-	NMConnection **reread = out_reread ?: ((nmtst_get_rand_uint32 () % 2) ? &reread_copy : NULL);
-
-	g_assert (NM_IS_CONNECTION (connection));
-	g_assert (ifcfg_dir);
-
-	con_verified = nmtst_connection_duplicate_and_normalize (connection);
-
-	success = nms_ifcfg_rh_writer_write_connection (con_verified,
-	                                                ifcfg_dir,
-	                                                NULL,
-	                                                NULL,
-	                                                NULL,
-	                                                &filename,
-	                                                reread,
-	                                                out_reread_same,
-	                                                &error);
-	nmtst_assert_success (success, error);
-	g_assert (filename && filename[0]);
-
-	if (reread)
-		nmtst_assert_connection_verifies_without_normalization (*reread);
-
-	_assert_expected_content (con_verified, filename, expected);
-
-	if (out_filename)
-		*out_filename = filename;
-	else
-		g_free (filename);
-
-}
-
-static void
-_writer_new_connec_exp (NMConnection *connection,
-                        const char *ifcfg_dir,
-                        const char *expected,
-                        char **out_filename)
-{
-	gs_unref_object NMConnection *reread = NULL;
-	gboolean reread_same = FALSE;
-
-	_writer_new_connection_reread (connection, ifcfg_dir, out_filename, expected, &reread, &reread_same);
-	_assert_reread_same (connection, reread);
-	g_assert (reread_same);
-}
-
-static void
-_writer_new_connection (NMConnection *connection,
-                        const char *ifcfg_dir,
-                        char **out_filename)
-{
-	_writer_new_connec_exp (connection, ifcfg_dir, NO_EXPECTED, out_filename);
-}
-
-static void
-_writer_new_connection_FIXME (NMConnection *connection,
-                              const char *ifcfg_dir,
-                              char **out_filename)
-{
-	gs_unref_object NMConnection *reread = NULL;
-	gboolean reread_same = FALSE;
-
-	/* FIXME: this should not happen. Fix it to use _writer_new_connection() instead. */
-
-	_writer_new_connection_reread (connection, ifcfg_dir, out_filename, NO_EXPECTED, &reread, &reread_same);
-	_assert_reread_same_FIXME (connection, reread);
-	g_assert (!reread_same);
-}
-
-static void
-_writer_new_connection_fail (NMConnection *connection,
-                             const char *ifcfg_dir,
-                             GError **error)
-{
-	gs_unref_object NMConnection *connection_normalized = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	gboolean success;
-	GError *local = NULL;
-	char *filename = NULL;
-
-	g_assert (NM_IS_CONNECTION (connection));
-	g_assert (ifcfg_dir);
-
-	connection_normalized = nmtst_connection_duplicate_and_normalize (connection);
-
-	success = nms_ifcfg_rh_writer_write_connection (connection_normalized,
-	                                                ifcfg_dir,
-	                                                NULL,
-	                                                NULL,
-	                                                NULL,
-	                                                &filename,
-	                                                &reread,
-	                                                NULL,
-	                                                &local);
-	nmtst_assert_no_success (success, local);
-	g_assert (!filename);
-	g_assert (!reread);
-
-	g_propagate_error (error, local);
-}
-
-/*****************************************************************************/
-
-static void
-test_read_netmask_1 (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_free char *content = NULL;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMIPAddress *ip4_addr;
-	const char *FILENAME = TEST_IFCFG_DIR"/ifcfg-netmask-1";
-
-	connection = _connection_from_file (FILENAME, NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System netmask-1");
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpuint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 1);
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "102.0.2.2");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 15);
-
-	nmtst_assert_connection_verifies_without_normalization (connection);
-
-	content = nmtst_file_get_contents (FILENAME);
-
-	testfile = g_strdup (TEST_SCRATCH_DIR"/ifcfg-netmask-1.copy");
-
-	nmtst_file_set_contents (testfile, content);
-
-	_writer_update_connection (connection,
-	                           TEST_SCRATCH_DIR,
-	                           testfile,
-	                           TEST_IFCFG_DIR"/ifcfg-netmask-1.cexpected");
-}
-
-/*****************************************************************************/
-
-static gboolean
-verify_cert_or_key (NMSetting8021x *s_compare,
-                    const char *file,
-                    const char *privkey_password,
-                    const char *property)
-{
-	NMSetting8021x *s_8021x;
-	GError *error = NULL;
-	gboolean success = FALSE;
-	const char *expected = NULL, *setting = NULL;
-	gboolean phase2 = FALSE;
-	NMSetting8021xCKScheme scheme = NM_SETTING_802_1X_CK_SCHEME_UNKNOWN;
-
-	if (strstr (property, "phase2"))
-		phase2 = TRUE;
-
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-
-	/* Load the certificate into an empty setting */
-	if (strstr (property, "ca-cert")) {
-		if (phase2)
-			success = nm_setting_802_1x_set_phase2_ca_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
-		else
-			success = nm_setting_802_1x_set_ca_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
-	} else if (strstr (property, "client-cert")) {
-		if (phase2)
-			success = nm_setting_802_1x_set_phase2_client_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
-		else
-			success = nm_setting_802_1x_set_client_cert (s_8021x, file, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
-	} else if (strstr (property, "private-key")) {
-		if (phase2)
-			success = nm_setting_802_1x_set_phase2_private_key (s_8021x, file, privkey_password, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
-		else
-			success = nm_setting_802_1x_set_private_key (s_8021x, file, privkey_password, NM_SETTING_802_1X_CK_SCHEME_PATH, NULL, &error);
-	}
-	g_assert_no_error (error);
-	g_assert_cmpint (success, ==, TRUE);
-
-	/* Ensure it was loaded using the PATH scheme */
-	if (strstr (property, "ca-cert")) {
-		if (phase2)
-			scheme = nm_setting_802_1x_get_phase2_ca_cert_scheme (s_8021x);
-		else
-			scheme = nm_setting_802_1x_get_ca_cert_scheme (s_8021x);
-	} else if (strstr (property, "client-cert")) {
-		if (phase2)
-			scheme = nm_setting_802_1x_get_phase2_client_cert_scheme (s_8021x);
-		else
-			scheme = nm_setting_802_1x_get_client_cert_scheme (s_8021x);
-	} else if (strstr (property, "private-key")) {
-		if (phase2)
-			scheme = nm_setting_802_1x_get_phase2_private_key_scheme (s_8021x);
-		else
-			scheme = nm_setting_802_1x_get_private_key_scheme (s_8021x);
-	}
-	g_assert_cmpint (scheme, ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
-
-	/* Grab the path back out */
-	if (strstr (property, "ca-cert")) {
-		if (phase2)
-			expected = nm_setting_802_1x_get_phase2_ca_cert_path (s_8021x);
-		else
-			expected = nm_setting_802_1x_get_ca_cert_path (s_8021x);
-	} else if (strstr (property, "client-cert")) {
-		if (phase2)
-			expected = nm_setting_802_1x_get_phase2_client_cert_path (s_8021x);
-		else
-			expected = nm_setting_802_1x_get_client_cert_path (s_8021x);
-	} else if (strstr (property, "private-key")) {
-		if (phase2)
-			expected = nm_setting_802_1x_get_phase2_private_key_path (s_8021x);
-		else
-			expected = nm_setting_802_1x_get_private_key_path (s_8021x);
-	}
-	g_assert_cmpstr (expected, ==, file);
-
-	/* Compare the path with the expected path from the real setting */
-	if (strstr (property, "ca-cert")) {
-		if (phase2)
-			setting = nm_setting_802_1x_get_phase2_ca_cert_path (s_compare);
-		else
-			setting = nm_setting_802_1x_get_ca_cert_path (s_compare);
-	} else if (strstr (property, "client-cert")) {
-		if (phase2)
-			setting = nm_setting_802_1x_get_phase2_client_cert_path (s_compare);
-		else
-			setting = nm_setting_802_1x_get_client_cert_path (s_compare);
-	} else if (strstr (property, "private-key")) {
-		if (phase2)
-			setting = nm_setting_802_1x_get_phase2_private_key_path (s_compare);
-		else
-			setting = nm_setting_802_1x_get_private_key_path (s_compare);
-	}
-	g_assert_cmpstr (setting, ==, expected);
-
-	g_object_unref (s_8021x);
-	return TRUE;
-}
-
-static void
-test_read_basic (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-minimal",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-minimal");
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
-
-	/* MAC address */
-	mac = nm_setting_wired_get_mac_address (s_wired);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
-
-	/* ===== IPv6 SETTING ===== */
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_miscellaneous_variables (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	char *expected_mac_blacklist[3] = { "00:16:41:11:22:88", "00:16:41:11:22:99", "6a:5d:5a:fa:dd:f0" };
-	int mac_blacklist_num, i;
-	guint64 expected_timestamp = 0;
-
-	NMTST_EXPECT_NM_WARN ("*invalid MAC in HWADDR_BLACKLIST 'XX:aa:invalid'*");
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-misc-variables",
-	                                    NULL, TYPE_ETHERNET, NULL);
-	g_test_assert_expected_messages ();
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, 100);
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
-
-	/* MAC blacklist */
-	mac_blacklist_num = nm_setting_wired_get_num_mac_blacklist_items (s_wired);
-	g_assert_cmpint (mac_blacklist_num, ==, 3);
-	for (i = 0; i < mac_blacklist_num; i++)
-		g_assert (nm_utils_hwaddr_matches (nm_setting_wired_get_mac_blacklist_item (s_wired, i), -1, expected_mac_blacklist[i], -1));
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_variables_corner_cases (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-variables-corner-cases-1",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-variables-corner-cases-1");
-	g_assert_cmpstr (nm_setting_connection_get_zone (s_con), ==, NULL);
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
-
-	/* MAC address */
-	mac = nm_setting_wired_get_mac_address (s_wired);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_unmanaged (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	char *unhandled_spec = NULL;
-	guint64 expected_timestamp = 0;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-nm-controlled",
-	                                    NULL, TYPE_ETHERNET,
-	                                    &unhandled_spec);
-	g_assert_cmpstr (unhandled_spec, ==, "unmanaged:mac:00:11:22:33:f8:9f");
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-nm-controlled");
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	g_free (unhandled_spec);
-	g_object_unref (connection);
-}
-
-static void
-test_read_unmanaged_unrecognized (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	gs_free char *unhandled_spec = NULL;
-	guint64 expected_timestamp = 0;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-nm-controlled-unrecognized",
-	                                    NULL, NULL,
-	                                    &unhandled_spec);
-	g_assert_cmpstr (unhandled_spec, ==, "unmanaged:interface-name:=ipoac0");
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "PigeonNet");
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_unrecognized (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	gs_free char *unhandled_spec = NULL;
-	guint64 expected_timestamp = 0;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-unrecognized",
-	                                    NULL, NULL,
-	                                    &unhandled_spec);
-	g_assert_cmpstr (unhandled_spec, ==, "unrecognized:mac:00:11:22:33");
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-unrecognized");
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, expected_timestamp);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_static (gconstpointer test_data)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char *unmanaged = NULL;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0xee };
-	NMIPAddress *ip4_addr;
-	NMIPAddress *ip6_addr;
-	const char *file, *expected_id;
-	gpointer expect_ip6_p;
-
-	nmtst_test_data_unpack (test_data, &file, &expected_id, &expect_ip6_p);
-
-	g_assert (expected_id);
-
-	connection = _connection_from_file (file, NULL, TYPE_ETHERNET,
-	                                    &unmanaged);
-	g_assert_cmpstr (unmanaged, ==, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 1492);
-
-	/* MAC address */
-	mac = nm_setting_wired_get_mac_address (s_wired);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-	g_assert (nm_setting_ip_config_get_may_fail (s_ip4));
-
-	g_assert (nm_setting_ip_config_has_dns_options (s_ip4));
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns_options (s_ip4), ==, 0);
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "192.168.1.5");
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.1");
-
-	/* ===== IPv6 SETTING ===== */
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	if (GPOINTER_TO_INT (expect_ip6_p)) {
-		g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_MANUAL);
-		g_assert (nm_setting_ip_config_get_may_fail (s_ip6));
-
-		g_assert (nm_setting_ip_config_has_dns_options (s_ip6));
-		g_assert_cmpint (nm_setting_ip_config_get_num_dns_options (s_ip6), ==, 0);
-
-		/* DNS Addresses */
-		g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 2);
-		g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
-		g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 1), ==, "1:2:3:4::b");
-
-		/* IP addresses */
-		g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 2);
-
-		ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
-		g_assert (ip6_addr);
-		g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 64);
-		g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "dead:beaf::1");
-
-		ip6_addr = nm_setting_ip_config_get_address (s_ip6, 1);
-		g_assert (ip6_addr);
-		g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
-		g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "dead:beaf::2");
-	} else {
-		g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);
-		g_assert (!nm_setting_ip_config_has_dns_options (s_ip6));
-	}
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_static_no_prefix (gconstpointer user_data)
-{
-	guint32 expected_prefix = GPOINTER_TO_UINT (user_data);
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMIPAddress *ip4_addr;
-	char *file, *expected_id;
-
-	file = g_strdup_printf (TEST_IFCFG_DIR"/ifcfg-test-wired-static-no-prefix-%u", expected_prefix);
-	expected_id = g_strdup_printf ("System test-wired-static-no-prefix-%u", expected_prefix);
-
-	NMTST_EXPECT_NM_WARN ("*missing PREFIX, assuming*");
-	connection = _connection_from_file (file, NULL, TYPE_ETHERNET, NULL);
-	g_test_assert_expected_messages ();
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	g_assert (!nm_setting_ip_config_has_dns_options (s_ip4));
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns_options (s_ip4), ==, 0);
-
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, expected_prefix);
-
-	g_free (file);
-	g_free (expected_id);
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_dhcp (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	char *unmanaged = NULL;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0xee };
-	const char *mac;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp",
-	                                    NULL, TYPE_ETHERNET,
-	                                    &unmanaged);
-	g_assert (unmanaged == NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-dhcp");
-	g_assert_cmpuint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* MAC address */
-	mac = nm_setting_wired_get_mac_address (s_wired);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, "foobar");
-	g_assert (nm_setting_ip_config_get_ignore_auto_dns (s_ip4));
-	g_assert_cmpuint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_dhcp_plus_ip (void)
-{
-	NMConnection *connection;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMIPAddress *ip4_addr;
-	NMIPAddress *ip6_addr;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp-plus-ip",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_may_fail (s_ip4));
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 2);
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "1.2.3.4");
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
-
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 1);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 16);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "9.8.7.6");
-
-	/* ===== IPv6 SETTING ===== */
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_may_fail (s_ip6));
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 2);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 1), ==, "1:2:3:4::b");
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 3);
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
-	g_assert (ip6_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "1001:abba::1234");
-
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 1);
-	g_assert (ip6_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 64);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "2001:abba::2234");
-
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 2);
-	g_assert (ip6_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 96);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "3001:abba::3234");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_shared_plus_ip (void)
-{
-	NMConnection *connection;
-	NMSettingIPConfig *s_ip4;
-	NMIPAddress *ip4_addr;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-shared-plus-ip",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_SHARED);
-	g_assert (nm_setting_ip_config_get_may_fail (s_ip4));
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "10.20.30.5");
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_global_gateway (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMIPAddress *ip4_addr;
-	char *unmanaged = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-global-gateway",
-	                                    TEST_IFCFG_DIR"/network-test-wired-global-gateway",
-	                                    TYPE_ETHERNET, &unmanaged);
-	g_assert (unmanaged == NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-global-gateway");
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	/* Address #1 */
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "192.168.1.5");
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.2");
-
-	g_object_unref (connection);
-}
-
-/* Ignore GATEWAY from /etc/sysconfig/network for automatic connections */
-static void
-test_read_wired_global_gateway_ignore (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	char *unmanaged = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*ignoring GATEWAY (/etc/sysconfig/network) for * because the connection has no static addresses");
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-global-gateway-ignore",
-	                                    TEST_IFCFG_DIR"/network-test-wired-global-gateway-ignore",
-	                                    TYPE_ETHERNET, &unmanaged);
-	g_test_assert_expected_messages ();
-	g_assert (unmanaged == NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-global-gateway-ignore");
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	/* Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 0);
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, NULL);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_obsolete_gateway_n (void)
-{
-	NMConnection *connection;
-	NMSettingIPConfig *s_ip4;
-	NMIPAddress *ip4_addr;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-obsolete-gateway-n",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr);
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "1.2.3.4");
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
-
-	g_object_unref (connection);
-}
-
-static void
-test_user_1 (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingUser *s_user;
-
-	connection = nmtst_create_minimal_connection ("Test User 1", NULL, NM_SETTING_WIRED_SETTING_NAME, NULL);
-	s_user = NM_SETTING_USER (nm_setting_user_new ());
-
-#define _USER_SET_DATA(s_user, key, val) \
-	G_STMT_START { \
-		GError *_error = NULL; \
-		gboolean _success; \
-		\
-		_success = nm_setting_user_set_data ((s_user), (key), (val), &_error); \
-		nmtst_assert_success (_success, _error); \
-	} G_STMT_END
-
-#define _USER_SET_DATA_X(s_user, key) \
-	_USER_SET_DATA (s_user, key, "val="key"")
-
-	_USER_SET_DATA (s_user, "my.val1", "");
-	_USER_SET_DATA_X (s_user, "my.val2");
-	_USER_SET_DATA_X (s_user, "my.v__al3");
-	_USER_SET_DATA_X (s_user, "my._v");
-	_USER_SET_DATA_X (s_user, "my.v+");
-	_USER_SET_DATA_X (s_user, "my.Av");
-	_USER_SET_DATA_X (s_user, "MY.AV");
-	_USER_SET_DATA_X (s_user, "MY.8V");
-	_USER_SET_DATA_X (s_user, "MY.8-V");
-	_USER_SET_DATA_X (s_user, "MY.8_V");
-	_USER_SET_DATA_X (s_user, "MY.8+V");
-	_USER_SET_DATA_X (s_user, "MY.8/V");
-	_USER_SET_DATA_X (s_user, "MY.8=V");
-	_USER_SET_DATA_X (s_user, "MY.-");
-	_USER_SET_DATA_X (s_user, "MY._");
-	_USER_SET_DATA_X (s_user, "MY.+");
-	_USER_SET_DATA_X (s_user, "MY./");
-	_USER_SET_DATA_X (s_user, "MY.=");
-	_USER_SET_DATA_X (s_user, "my.keys.1");
-	_USER_SET_DATA_X (s_user, "my.other.KEY.42");
-
-	nm_connection_add_setting (connection, NM_SETTING (s_user));
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_User_1.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_wired_never_default (void)
-{
-	NMConnection *connection;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-never-default",
-	                                    TEST_IFCFG_DIR"/network-test-wired-never-default",
-	                                    TYPE_ETHERNET, NULL);
-
-	/* ===== WIRED SETTING ===== */
-	g_assert (nm_connection_get_setting_wired (connection));
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4));
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 0);
-
-	/* ===== IPv6 SETTING ===== */
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip6));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_defroute_no (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char *unmanaged = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-defroute-no",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (unmanaged == NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-defroute-no");
-
-	g_assert (nm_connection_get_setting_wired (connection));
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4));
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip6));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_defroute_no_gatewaydev_yes (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char *unmanaged = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-defroute-no-gatewaydev-yes",
-	                                    TEST_IFCFG_DIR"/network-test-wired-defroute-no-gatewaydev-yes",
-	                                    TYPE_ETHERNET,
-	                                    &unmanaged);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-defroute-no-gatewaydev-yes");
-
-	g_assert (nm_connection_get_setting_wired (connection));
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_static_routes (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMIPRoute *ip4_route;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-static-routes",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-static-routes");
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	/* Routes */
-	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 3);
-
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 0);
-	g_assert (ip4_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "11.22.33.0");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 24);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "192.168.1.5");
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, -1);
-
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 1);
-	g_assert (ip4_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "44.55.66.77");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "192.168.1.7");
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 3);
-	nmtst_assert_route_attribute_byte (ip4_route, NM_IP_ROUTE_ATTRIBUTE_TOS, 0x28);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, 30000);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 12);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITCWND, 13);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITRWND, 14);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 9000);
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND, TRUE);
-	nmtst_assert_route_attribute_string (ip4_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "1.1.1.1");
-
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 2);
-	g_assert (ip4_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "44.55.66.78");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "192.168.1.8");
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 3);
-	nmtst_assert_route_attribute_byte (ip4_route, NM_IP_ROUTE_ATTRIBUTE_TOS, 0x28);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, 30000);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 12);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITCWND, 13);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITRWND, 14);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 9000);
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND, TRUE);
-	nmtst_assert_route_attribute_string (ip4_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "1.1.1.1");
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, TRUE);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_static_routes_legacy (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	char *unmanaged = NULL;
-	NMIPRoute *ip4_route;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-static-routes-legacy",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-static-routes-legacy");
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	/* Routes */
-	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 4);
-
-	/* Route #1 */
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 0);
-	g_assert (ip4_route != NULL);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "21.31.41.0");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 24);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "9.9.9.9");
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 1);
-
-	/* Route #2 */
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 1);
-	g_assert (ip4_route != NULL);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "32.42.52.62");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "8.8.8.8");
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, -1);
-
-	/* Route #3 */
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 2);
-	g_assert (ip4_route != NULL);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "43.53.0.0");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 16);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, "7.7.7.7");
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 3);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, 10000);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 14);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITCWND, 42);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_INITRWND, 20);
-	nmtst_assert_route_attribute_uint32 (ip4_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 9000);
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW, TRUE);
-	nmtst_assert_route_attribute_boolean (ip4_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
-	nmtst_assert_route_attribute_string (ip4_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "1.2.3.4");
-
-	ip4_route = nm_setting_ip_config_get_route (s_ip4, 3);
-	g_assert (ip4_route != NULL);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip4_route), ==, "7.7.7.8");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip4_route), ==, 32);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip4_route), ==, NULL);
-	g_assert_cmpint (nm_ip_route_get_metric (ip4_route), ==, 18);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_ipv4_manual (gconstpointer data)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	char *unmanaged = NULL;
-	NMIPAddress *ip4_addr;
-	const char *file, *expected_id;
-
-	nmtst_test_data_unpack (data, &file, &expected_id);
-
-	g_assert (expected_id);
-
-	connection = _connection_from_file (file,
-	                                    NULL,
-	                                    TYPE_ETHERNET,
-	                                    &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-	g_assert_cmpint (nm_setting_ip_config_get_dad_timeout (s_ip4), ==, 2000);
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 3);
-
-	/* Address #1 */
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "1.2.3.4");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-
-	/* Address #2 */
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 1);
-	g_assert (ip4_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "9.8.7.6");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 16);
-
-	/* Address #3 */
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 2);
-	g_assert (ip4_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "3.3.3.3");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 8);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_ipv6_manual (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char *unmanaged = NULL;
-	NMIPAddress *ip6_addr;
-	NMIPRoute *ip6_route;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-ipv6-manual",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-ipv6-manual");
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
-
-	/* DNS search domains */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns_searches (s_ip4), ==, 3);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip4, 0), ==, "lorem.com");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip4, 1), ==, "ipsum.org");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip4, 2), ==, "dolor.edu");
-
-	/* ===== IPv6 SETTING ===== */
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_MANUAL);
-	g_assert (!nm_setting_ip_config_get_never_default (s_ip6));
-	g_assert (nm_setting_ip_config_get_may_fail (s_ip6));
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 3);
-
-	/* Address #1 */
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
-	g_assert (ip6_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "1001:abba::1234");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
-
-	/* Address #2 */
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 1);
-	g_assert (ip6_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "2001:abba::2234");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 64);
-
-	/* Address #3 */
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 2);
-	g_assert (ip6_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "3001:abba::3234");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 96);
-
-	/* Routes */
-	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip6), ==, 4);
-	/* Route #1 */
-	ip6_route = nm_setting_ip_config_get_route (s_ip6, 0);
-	g_assert (ip6_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "9876::1234");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 96);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, "9876::7777");
-	g_assert_cmpint (nm_ip_route_get_metric (ip6_route), ==, 2);
-	/* Route #2 */
-	ip6_route = nm_setting_ip_config_get_route (s_ip6, 1);
-	g_assert (ip6_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "::");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 0);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, "dead::beaf");
-	g_assert_cmpint (nm_ip_route_get_metric (ip6_route), ==, -1);
-	/* Route #3 */
-	ip6_route = nm_setting_ip_config_get_route (s_ip6, 2);
-	g_assert (ip6_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "abbe::cafe");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 64);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, NULL);
-	g_assert_cmpint (nm_ip_route_get_metric (ip6_route), ==, 777);
-	/* Route #4 */
-	ip6_route = nm_setting_ip_config_get_route (s_ip6, 3);
-	g_assert (ip6_route);
-	g_assert_cmpstr (nm_ip_route_get_dest (ip6_route), ==, "aaaa::cccc");
-	g_assert_cmpint (nm_ip_route_get_prefix (ip6_route), ==, 64);
-	g_assert_cmpstr (nm_ip_route_get_next_hop (ip6_route), ==, "3333::4444");
-	nmtst_assert_route_attribute_uint32 (ip6_route, NM_IP_ROUTE_ATTRIBUTE_CWND, 13);
-	nmtst_assert_route_attribute_uint32 (ip6_route, NM_IP_ROUTE_ATTRIBUTE_MTU, 1450);
-	nmtst_assert_route_attribute_boolean (ip6_route, NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU, TRUE);
-	nmtst_assert_route_attribute_string (ip6_route, NM_IP_ROUTE_ATTRIBUTE_FROM, "1111::2222/48");
-	nmtst_assert_route_attribute_string (ip6_route, NM_IP_ROUTE_ATTRIBUTE_SRC, "5555::6666");
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 2);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 1), ==, "1:2:3:4::b");
-
-	/* DNS domains - none as domains are stuffed to 'ipv4' setting */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns_searches (s_ip6), ==, 0);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_ipv6_only (gconstpointer test_data)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char *unmanaged = NULL;
-	NMIPAddress *ip6_addr;
-	const char *method;
-	const char *file, *expected_id;
-
-	nmtst_test_data_unpack (test_data, &file, &expected_id);
-
-	g_assert (expected_id);
-
-	connection = _connection_from_file (file, NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-
-	method = nm_setting_ip_config_get_method (s_ip4);
-	g_assert_cmpstr (method, ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
-
-	/* ===== IPv6 SETTING ===== */
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_MANUAL);
-
-	/* IP addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip6), ==, 1);
-
-	/* Address #1 */
-	ip6_addr = nm_setting_ip_config_get_address (s_ip6, 0);
-	g_assert (ip6_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip6_addr), ==, "1001:abba::1234");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip6_addr), ==, 56);
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip6), ==, 1);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip6, 0), ==, "1:2:3:4::a");
-
-	/* DNS domains should be in IPv6, because IPv4 is disabled */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns_searches (s_ip6), ==, 3);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip6, 0), ==, "lorem.com");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip6, 1), ==, "ipsum.org");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns_search (s_ip6, 2), ==, "dolor.edu");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_dhcp6_only (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char *unmanaged = NULL;
-	const char *method;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp6-only", NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-dhcp6-only");
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-
-	method = nm_setting_ip_config_get_method (s_ip4);
-	g_assert_cmpstr (method, ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
-
-	/* ===== IPv6 SETTING ===== */
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_DHCP);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_autoip (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingIPConfig *s_ip4;
-	char *unmanaged = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-autoip",
-	                                    NULL, TYPE_ETHERNET,
-	                                    &unmanaged);
-	g_assert (unmanaged == NULL);
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL);
-	g_assert (!nm_setting_ip_config_get_may_fail (s_ip4));
-	g_assert (nm_setting_ip_config_get_ignore_auto_dns (s_ip4));
-}
-
-static void
-test_read_onboot_no (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	char *unmanaged = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-onboot-no", NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	g_assert (!nm_setting_connection_get_autoconnect (s_con));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_noip (void)
-{
-	NMConnection *connection;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-noip", NULL, TYPE_ETHERNET, NULL);
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);
-	g_assert (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
-
-	g_object_unref (connection);
-}
-
-#define TEST_IFCFG_WIRED_8021x_PEAP_MSCHAPV2_CA_CERT TEST_IFCFG_DIR"/test_ca_cert.pem"
-
-static void
-test_read_wired_8021x_peap_mschapv2 (void)
-{
-	NMConnection *connection;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSetting8021x *s_8021x;
-	NMSetting8021x *tmp_8021x;
-	char *unmanaged = NULL;
-	GError *error = NULL;
-	gboolean success = FALSE;
-	const char *expected_ca_cert_path;
-	const char *read_ca_cert_path;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-peap-mschapv2",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "peap");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "David Smith");
-	g_assert_cmpstr (nm_setting_802_1x_get_anonymous_identity (s_8021x), ==, "somebody");
-	g_assert_cmpstr (nm_setting_802_1x_get_password (s_8021x), ==, "foobar baz");
-	g_assert_cmpstr (nm_setting_802_1x_get_phase1_peapver (s_8021x), ==, "1");
-	g_assert_cmpstr (nm_setting_802_1x_get_phase1_peaplabel (s_8021x), ==, "1");
-
-	/* CA Cert */
-	tmp_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-
-	success = nm_setting_802_1x_set_ca_cert (tmp_8021x,
-	                                         TEST_IFCFG_WIRED_8021x_PEAP_MSCHAPV2_CA_CERT,
-	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                         NULL,
-	                                         &error);
-	g_assert_no_error (error);
-	g_assert (success == TRUE);
-
-	expected_ca_cert_path = nm_setting_802_1x_get_ca_cert_path (tmp_8021x);
-	g_assert (expected_ca_cert_path);
-
-	read_ca_cert_path = nm_setting_802_1x_get_ca_cert_path (s_8021x);
-	g_assert (read_ca_cert_path);
-
-	g_assert_cmpstr (read_ca_cert_path, ==, expected_ca_cert_path);
-
-	g_object_unref (tmp_8021x);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_8021x_tls_secret_flags (gconstpointer test_data)
-{
-	NMConnection *connection;
-	NMSettingWired *s_wired;
-	NMSetting8021x *s_8021x;
-	char *dirname, *tmp;
-	const char *ifcfg;
-	gpointer expected_flags_p;
-
-	nmtst_test_data_unpack (test_data, &ifcfg, &expected_flags_p);
-
-	connection = _connection_from_file (ifcfg, NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "tls");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "David Smith");
-	g_assert_cmpint (nm_setting_802_1x_get_private_key_password_flags (s_8021x), ==, GPOINTER_TO_INT (expected_flags_p));
-
-	dirname = g_path_get_dirname (ifcfg);
-	tmp = g_build_path ("/", dirname, "test_ca_cert.pem", NULL);
-	g_assert_cmpstr (nm_setting_802_1x_get_ca_cert_path (s_8021x), ==, tmp);
-	g_free (tmp);
-
-	tmp = g_build_path ("/", dirname, "test1_key_and_cert.pem", NULL);
-	g_assert_cmpstr (nm_setting_802_1x_get_client_cert_path (s_8021x), ==, tmp);
-	g_assert_cmpstr (nm_setting_802_1x_get_private_key_path (s_8021x), ==, tmp);
-	g_free (tmp);
-
-	g_free (dirname);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_write_802_1X_subj_matches (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSetting8021x *s_8021x;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-802-1X-subj-matches",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "peap");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Jara Cimrman");
-	g_assert_cmpstr (nm_setting_802_1x_get_subject_match (s_8021x), ==, "server1.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_subject_match (s_8021x), ==, "server2.yourdomain.tld");
-	g_assert_cmpint (nm_setting_802_1x_get_num_altsubject_matches (s_8021x), ==, 3);
-	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 0), ==, "a.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 1), ==, "b.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 2), ==, "c.yourdomain.tld");
-	g_assert_cmpint (nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x), ==, 2);
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 0), ==, "x.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 1), ==, "y.yourdomain.tld");
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-System_test-wired-802-1X-subj-matches.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	/* Check 802.1X stuff of the re-read connection. */
-	s_8021x = nm_connection_get_setting_802_1x (reread);
-	g_assert (s_8021x);
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "peap");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Jara Cimrman");
-	g_assert_cmpstr (nm_setting_802_1x_get_subject_match (s_8021x), ==, "server1.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_subject_match (s_8021x), ==, "server2.yourdomain.tld");
-	g_assert_cmpint (nm_setting_802_1x_get_num_altsubject_matches (s_8021x), ==, 3);
-	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 0), ==, "a.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 1), ==, "b.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_altsubject_match (s_8021x, 2), ==, "c.yourdomain.tld");
-	g_assert_cmpint (nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x), ==, 2);
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 0), ==, "x.yourdomain.tld");
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, 1), ==, "y.yourdomain.tld");
-}
-
-static void
-test_read_802_1x_ttls_eapgtc (void)
-{
-	NMConnection *connection;
-	NMSetting8021x *s_8021x;
-
-	/* Test that EAP-* inner methods are correctly read into the
-	 * NMSetting8021x::autheap property.
-	 */
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-802-1x-ttls-eapgtc",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-
-	/* EAP methods */
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "ttls");
-
-	/* Auth methods */
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_auth (s_8021x), ==, NULL);
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_autheap (s_8021x), ==, "gtc");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_802_1x_tls_p12_no_client_cert (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSetting8021x *s_8021x;
-	const char *path;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-tls-p12-no-client-cert",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-
-	g_assert_cmpint (nm_setting_802_1x_get_private_key_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
-	path = nm_setting_802_1x_get_private_key_path (s_8021x);
-	g_assert (path);
-
-	g_assert_cmpint (nm_setting_802_1x_get_client_cert_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
-	g_assert_cmpstr (path, ==, nm_setting_802_1x_get_client_cert_path (s_8021x));
-}
-
-static void
-test_read_write_802_1x_password_raw (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSetting8021x *s_8021x;
-	GBytes *bytes;
-	gconstpointer data;
-	gsize size;
-
-	/* Test that the 802-1x.password-raw is correctly read and written. */
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-802-1x-password-raw",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-
-	bytes = nm_setting_802_1x_get_password_raw (s_8021x);
-	g_assert (bytes);
-	data = g_bytes_get_data (bytes, &size);
-	g_assert_cmpmem (data, size, "\x04\x08\x15\x16\x23\x42\x00\x01", 8);
-
-	g_assert_cmpint (nm_setting_802_1x_get_password_raw_flags (s_8021x),
-	                 ==,
-	                 NM_SETTING_SECRET_FLAG_NONE);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	keyfile = utils_get_keys_path (testfile);
-	g_assert (g_file_test (keyfile, G_FILE_TEST_EXISTS));
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_wired_aliases_good (gconstpointer test_data)
-{
-	const int N = GPOINTER_TO_INT (test_data);
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	int expected_num_addresses;
-	const char *expected_address_0[] = { "192.168.1.5", "192.168.1.6", "192.168.1.9", "192.168.1.99", NULL };
-	const char *expected_address_3[] = { "192.168.1.5", "192.168.1.6", NULL };
-	const char *expected_label_0[] = { NULL, "aliasem0:1", "aliasem0:2", "aliasem0:99", NULL, };
-	const char *expected_label_3[] = { NULL, "aliasem3:1", NULL, };
-	const char **expected_address;
-	const char **expected_label;
-	int i, j;
-	char path[256];
-
-	expected_address = N == 0 ? expected_address_0 : expected_address_3;
-	expected_label   = N == 0 ? expected_label_0   : expected_label_3;
-	expected_num_addresses = g_strv_length ((char **) expected_address);
-
-	nm_sprintf_buf (path, TEST_IFCFG_DIR"/ifcfg-aliasem%d", N);
-
-	connection = _connection_from_file (path, NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	if (N == 0)
-		g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System aliasem0");
-	else
-		g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System aliasem3");
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, expected_num_addresses);
-
-	/* Addresses */
-	for (i = 0; i < expected_num_addresses; i++) {
-		NMIPAddress *ip4_addr;
-		const char *addr;
-		GVariant *label;
-
-		ip4_addr = nm_setting_ip_config_get_address (s_ip4, i);
-		g_assert (ip4_addr != NULL);
-
-		addr = nm_ip_address_get_address (ip4_addr);
-		g_assert (nm_utils_ipaddr_valid (AF_INET, addr));
-
-		for (j = 0; j < expected_num_addresses; j++) {
-			if (!g_strcmp0 (addr, expected_address[j]))
-				break;
-		}
-		g_assert (j < expected_num_addresses);
-
-		g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-		label = nm_ip_address_get_attribute (ip4_addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL);
-		if (expected_label[j])
-			g_assert_cmpstr (g_variant_get_string (label, NULL), ==, expected_label[j]);
-		else
-			g_assert (label == NULL);
-
-		expected_address[j] = NULL;
-		expected_label[j] = NULL;
-	}
-
-	/* Gateway */
-	g_assert (!nm_setting_ip_config_get_never_default (s_ip4));
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.1");
-
-	for (i = 0; i < expected_num_addresses; i++)
-		g_assert (!expected_address[i]);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_aliases_bad (const char *base, const char *expected_id)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMIPAddress *ip4_addr;
-
-	g_assert (expected_id);
-
-	connection = _connection_from_file (base, NULL, TYPE_ETHERNET, NULL);
-	g_test_assert_expected_messages ();
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	g_assert_cmpint (nm_setting_ip_config_get_num_addresses (s_ip4), ==, 1);
-
-	/* Addresses */
-	ip4_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-	g_assert (ip4_addr != NULL);
-	g_assert_cmpstr (nm_ip_address_get_address (ip4_addr), ==, "192.168.1.5");
-	g_assert_cmpint (nm_ip_address_get_prefix (ip4_addr), ==, 24);
-	g_assert (nm_ip_address_get_attribute (ip4_addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL) == NULL);
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "192.168.1.1");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_aliases_bad_1 (void)
-{
-	NMTST_EXPECT_NM_WARN ("*aliasem1:1*has no DEVICE*");
-	test_read_wired_aliases_bad (TEST_IFCFG_DIR"/ifcfg-aliasem1", "System aliasem1");
-}
-
-static void
-test_read_wired_aliases_bad_2 (void)
-{
-	NMTST_EXPECT_NM_WARN ("*aliasem2:1*has invalid DEVICE*");
-	test_read_wired_aliases_bad (TEST_IFCFG_DIR"/ifcfg-aliasem2", "System aliasem2");
-}
-
-static void
-test_read_dns_options (void)
-{
-	NMConnection *connection;
-	NMSettingIPConfig *s_ip4, *s_ip6;
-	char *unmanaged = NULL;
-	const char *option;
-	const char *options4[] = { "ndots:3", "single-request-reopen" };
-	const char *options6[] = { "inet6" };
-	guint32 i, num;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-dns-options",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert_cmpstr (unmanaged, ==, NULL);
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-
-	num = nm_setting_ip_config_get_num_dns_options (s_ip4);
-	g_assert_cmpint (num, ==, G_N_ELEMENTS (options4));
-
-	for (i = 0; i < num; i++) {
-		option = nm_setting_ip_config_get_dns_option (s_ip4, i);
-		g_assert_cmpstr (options4[i], ==, option);
-	}
-
-	num = nm_setting_ip_config_get_num_dns_options (s_ip6);
-	g_assert_cmpint (num, ==, G_N_ELEMENTS (options6));
-
-	for (i = 0; i < num; i++) {
-		option = nm_setting_ip_config_get_dns_option (s_ip6, i);
-		g_assert_cmpstr (options6[i], ==, option);
-	}
-
-	g_object_unref (connection);
-}
-
-static void
-test_clear_master (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_free char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	char *unmanaged = NULL;
-	shvarFile *f;
-
-	/* 1. load the bridge slave connection from disk */
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-component",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert_cmpstr (unmanaged, ==, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "br0");
-	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, "bridge");
-
-	/* 2. write the connection to a new file */
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-System_test-bridge-component-a.cexpected",
-	                        &testfile);
-
-	/* 3. clear master and slave-type */
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_MASTER, NULL,
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NULL,
-	              NULL);
-
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, NULL);
-	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NULL);
-
-	nmtst_assert_connection_verifies_after_normalization (connection, 0, 0);
-
-	/* 4. update the connection on disk */
-	_writer_update_connection (connection,
-	                           TEST_SCRATCH_DIR,
-	                           testfile,
-	                           TEST_IFCFG_DIR"/ifcfg-System_test-bridge-component-b.cexpected");
-	keyfile = utils_get_keys_path (testfile);
-	g_assert (!g_file_test (keyfile, G_FILE_TEST_EXISTS));
-
-	/* 5. check that BRIDGE variable has been removed */
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "BRIDGE", NULL);
-	svCloseFile (f);
-}
-
-static void
-test_write_dns_options (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	static const char *mac = "31:33:33:37:be:cd";
-	guint32 mtu = 1492;
-	NMIPAddress *addr;
-	NMIPAddress *addr6;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test DNS options",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
-	              NM_SETTING_WIRED_MTU, mtu,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	nm_setting_ip_config_add_dns_option (s_ip4, "debug");
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 206,
-	              NULL);
-
-	/* Add addresses */
-	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	nm_setting_ip_config_add_dns_option (s_ip6, "timeout:3");
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_wifi_open (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4, *s_ip6;
-	GBytes *ssid;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
-	const char *expected_ssid = "blahblah";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-open)");
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-	g_assert_cmpint (nm_setting_connection_get_autoconnect_priority (s_con), ==, -1);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* MAC address */
-	mac = nm_setting_wireless_get_mac_address (s_wireless);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
-
-	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
-	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 1);
-
-	/* ===== Wi-Fi SECURITY SETTING ===== */
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec == NULL);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpint (nm_setting_ip_config_get_route_metric (s_ip4), ==, 104);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert( s_ip6);
-	g_assert_cmpint (nm_setting_ip_config_get_route_metric (s_ip6), ==, 106);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_open_auto (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-auto",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-open-auto)");
-
-	/* ===== WIRELESS SETTING ===== */
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_open_ssid_hex (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	GBytes *ssid;
-	const char *expected_ssid = "blahblah";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-hex",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-open-ssid-hex)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_open_ssid_hex_bad (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	GBytes *ssid;
-	const char *expected_ssid = "0x626cxx";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-bad-hex",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System 0x626cxx (test-wifi-open-ssid-bad-hex)");
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-}
-
-static void
-test_read_wifi_open_ssid_bad (gconstpointer data)
-{
-	_connection_from_file_fail ((const char *) data, NULL, TYPE_WIRELESS, NULL);
-}
-
-static void
-test_read_wifi_open_ssid_quoted (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	GBytes *ssid;
-	const char *expected_ssid = "foo\"bar\\";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-quoted",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System foo\"bar\\ (test-wifi-open-ssid-quoted)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	GBytes *ssid;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
-	const char *expected_ssid = "blahblah";
-	NMWepKeyType key_type;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wep)");
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* MAC address */
-	mac = nm_setting_wireless_get_mac_address (s_wireless);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
-
-	/* MTU */
-	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
-	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 1);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
-	g_assert_cmpstr (nm_setting_wireless_security_get_auth_alg (s_wsec), ==, "shared");
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
-
-	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
-	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
-
-	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "0123456789abcdef0123456789");
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_adhoc (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	GBytes *ssid;
-	const char *expected_ssid = "blahblah";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-adhoc",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wep-adhoc)");
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	g_assert (!nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "adhoc");
-	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 11);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
-	g_assert (!nm_setting_wireless_security_get_auth_alg (s_wsec));
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
-
-	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "0123456789abcdef0123456789");
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	/* Ignore auto DNS */
-	g_assert (nm_setting_ip_config_get_ignore_auto_dns (s_ip4));
-
-	/* DNS Addresses */
-	g_assert_cmpint (nm_setting_ip_config_get_num_dns (s_ip4), ==, 2);
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 0), ==, "4.2.2.1");
-	g_assert_cmpstr (nm_setting_ip_config_get_dns (s_ip4, 1), ==, "4.2.2.2");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_passphrase (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-passphrase",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_key_type (s_wsec), ==, NM_WEP_KEY_TYPE_UNKNOWN);
-	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "foobar222blahblah");
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_40_ascii (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMWepKeyType key_type;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-40-ascii",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
-
-	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
-	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
-
-	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "Lorem");
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_104_ascii (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMWepKeyType key_type;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-104-ascii",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
-
-	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
-	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
-
-	g_assert_cmpstr (nm_setting_wireless_security_get_wep_key (s_wsec, 0), ==, "LoremIpsumSit");
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 1));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 2));
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 3));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_leap (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-leap",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-leap)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "ieee8021x");
-	g_assert_cmpstr (nm_setting_wireless_security_get_auth_alg (s_wsec), ==, "leap");
-	g_assert_cmpstr (nm_setting_wireless_security_get_leap_username (s_wsec), ==, "Bill Smith");
-	g_assert_cmpstr (nm_setting_wireless_security_get_leap_password (s_wsec), ==, "foobarblah");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_leap_secret_flags (gconstpointer test_data)
-{
-	NMConnection *connection;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	const char *file;
-	gpointer expected_flags_p;
-
-	nmtst_test_data_unpack (test_data, &file, &expected_flags_p);
-
-	connection = _connection_from_file (file, NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== WIRELESS SETTING ===== */
-	s_wifi = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wifi);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-
-	g_assert (g_strcmp0 (nm_setting_wireless_security_get_key_mgmt (s_wsec), "ieee8021x") == 0);
-	g_assert (g_strcmp0 (nm_setting_wireless_security_get_auth_alg (s_wsec), "leap") == 0);
-	g_assert (g_strcmp0 (nm_setting_wireless_security_get_leap_username (s_wsec), "Bill Smith") == 0);
-	/* password blank as it's not system-owned */
-	g_assert (nm_setting_wireless_security_get_leap_password_flags (s_wsec) == GPOINTER_TO_INT (expected_flags_p));
-	g_assert (nm_setting_wireless_security_get_leap_password (s_wsec) == NULL);
-
-	g_object_unref (connection);
-}
-
-static void
-test_ifcfg_no_trailing_newline (void)
-{
-	shvarFile *sv;
-
-	sv = _svOpenFile (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk");
-	_svGetValue_check (sv, "LAST_ENTRY", "no-newline");
-	svCloseFile (sv);
-}
-
-static void
-test_read_wifi_wpa_psk (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	GBytes *ssid;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
-	const char *expected_ssid = "blahblah";
-	guint32 n, i;
-	gboolean found_pair_tkip = FALSE;
-	gboolean found_pair_ccmp = FALSE;
-	gboolean found_group_tkip = FALSE;
-	gboolean found_group_ccmp = FALSE;
-	gboolean found_group_wep40 = FALSE;
-	gboolean found_group_wep104 = FALSE;
-	gboolean found_proto_wpa = FALSE;
-	gboolean found_proto_rsn = FALSE;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk)");
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	mac = nm_setting_wireless_get_mac_address (s_wireless);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
-
-	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
-	g_assert_cmpint (nm_setting_wireless_get_channel (s_wireless), ==, 1);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "wpa-psk");
-	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "I wonder what the king is doing tonight?");
-	g_assert (!nm_setting_wireless_security_get_auth_alg (s_wsec));
-
-	/* Pairwise ciphers */
-	n = nm_setting_wireless_security_get_num_pairwise (s_wsec);
-	g_assert_cmpint (n, ==, 2);
-	for (i = 0; i < n; i++) {
-		const char * tmp = nm_setting_wireless_security_get_pairwise (s_wsec, i);
-		g_assert (tmp);
-		if (strcmp (tmp, "tkip") == 0)
-			found_pair_tkip = TRUE;
-		else if (strcmp (tmp, "ccmp") == 0)
-			found_pair_ccmp = TRUE;
-	}
-	g_assert (found_pair_tkip);
-	g_assert (found_pair_ccmp);
-
-	/* Group ciphers */
-	n = nm_setting_wireless_security_get_num_groups (s_wsec);
-	g_assert_cmpint (n, ==, 4);
-	for (i = 0; i < n; i++) {
-		const char *tmp = nm_setting_wireless_security_get_group (s_wsec, i);
-		g_assert (tmp);
-		if (strcmp (tmp, "tkip") == 0)
-			found_group_tkip = TRUE;
-		else if (strcmp (tmp, "ccmp") == 0)
-			found_group_ccmp = TRUE;
-		else if (strcmp (tmp, "wep40") == 0)
-			found_group_wep40 = TRUE;
-		else if (strcmp (tmp, "wep104") == 0)
-			found_group_wep104 = TRUE;
-	}
-	g_assert (found_group_tkip);
-	g_assert (found_group_ccmp);
-	g_assert (found_group_wep40);
-	g_assert (found_group_wep104);
-
-	/* Protocols */
-	n = nm_setting_wireless_security_get_num_protos (s_wsec);
-	g_assert_cmpint (n, ==, 2);
-	for (i = 0; i < n; i++) {
-		const char *tmp = nm_setting_wireless_security_get_proto (s_wsec, i);
-		g_assert (tmp);
-		if (strcmp (tmp, "wpa") == 0)
-			found_proto_wpa = TRUE;
-		else if (strcmp (tmp, "rsn") == 0)
-			found_proto_rsn = TRUE;
-	}
-	g_assert (found_proto_wpa);
-	g_assert (found_proto_rsn);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_sae (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	GBytes *ssid;
-	const char *expected_ssid = "blahblah";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-sae",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-sae)");
-
-	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	g_assert_cmpint (nm_setting_wireless_get_mtu (s_wireless), ==, 0);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert_cmpmem (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid), expected_ssid, strlen (expected_ssid));
-
-	g_assert (!nm_setting_wireless_get_bssid (s_wireless));
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "infrastructure");
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "sae");
-	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "The king is dead.");
-	g_assert (!nm_setting_wireless_security_get_auth_alg (s_wsec));
-}
-
-static void
-test_read_wifi_wpa_psk_2 (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-2",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System ipsum (test-wifi-wpa-psk-2)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "They're really saying I love you. >>`<< '");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wpa_psk_unquoted (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-unquoted",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk-unquoted)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "54336845e2f3f321c4c7");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wpa_psk_unquoted2 (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-unquoted2",
-	                                    NULL, TYPE_WIRELESS, NULL);
-}
-
-static void
-test_read_wifi_wpa_psk_adhoc (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-
-	connection = _connection_from_file(TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-adhoc",
-	                                   NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk-adhoc)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	g_assert_cmpstr (nm_setting_wireless_get_mode (s_wireless), ==, "adhoc");
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "wpa-psk");
-	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "I wonder what the king is doing tonight?");
-
-	g_assert_cmpint (nm_setting_wireless_security_get_num_pairwise (s_wsec), ==, 1);
-	g_assert_cmpstr (nm_setting_wireless_security_get_pairwise (s_wsec, 0), ==, "ccmp");
-
-	g_assert_cmpint (nm_setting_wireless_security_get_num_groups (s_wsec), ==, 1);
-	g_assert_cmpstr (nm_setting_wireless_security_get_group (s_wsec, 0), ==, "ccmp");
-
-	g_assert_cmpint (nm_setting_wireless_security_get_num_protos (s_wsec), ==, 1);
-	g_assert_cmpstr (nm_setting_wireless_security_get_proto (s_wsec, 0), ==, "rsn");
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wpa_psk_hex (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	GBytes *ssid;
-	const char *expected_ssid = "blahblah";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-psk-hex",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System blahblah (test-wifi-wpa-psk-hex)");
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_assert (ssid);
-	g_assert (nm_utils_gbytes_equal_mem (ssid, expected_ssid, strlen (expected_ssid)));
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "wpa-psk");
-	g_assert_cmpstr (nm_setting_wireless_security_get_psk (s_wsec), ==, "1da190379817bc360dda52e85c388c439a21ea5c7bf819c64e9da051807deae6");
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	g_object_unref (connection);
-}
-
-#define TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT TEST_IFCFG_DIR"/test_ca_cert.pem"
-#define TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT TEST_IFCFG_DIR"/test1_key_and_cert.pem"
-#define TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY TEST_IFCFG_DIR"/test1_key_and_cert.pem"
-
-static void
-test_read_wifi_wpa_eap_tls (void)
-{
-	NMConnection *connection;
-	NMSettingWireless *s_wireless;
-	NMSettingIPConfig *s_ip4;
-	NMSetting8021x *s_8021x;
-	char *unmanaged = NULL;
-	const char *expected_privkey_password = "test1";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-eap-tls",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "tls");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Bill Smith");
-
-	/* CA Cert */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
-	                    NULL,
-	                    NM_SETTING_802_1X_CA_CERT);
-
-	/* Client Cert */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
-	                    NULL,
-	                    NM_SETTING_802_1X_CLIENT_CERT);
-
-	/* Private Key Password */
-	g_assert_cmpstr (nm_setting_802_1x_get_private_key_password (s_8021x), ==, expected_privkey_password);
-
-	/* Private key */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
-	                    expected_privkey_password,
-	                    NM_SETTING_802_1X_PRIVATE_KEY);
-
-	g_object_unref (connection);
-}
-
-/* Also use TLS defines from the previous test */
-
-static void
-test_read_wifi_wpa_eap_ttls_tls (void)
-{
-	NMConnection *connection;
-	NMSettingWireless *s_wireless;
-	NMSettingIPConfig *s_ip4;
-	NMSetting8021x *s_8021x;
-	char *unmanaged = NULL;
-	const char *expected_privkey_password = "test1";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wpa-eap-ttls-tls",
-	                                    NULL, TYPE_WIRELESS, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "ttls");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "Chuck Shumer");
-
-	/* CA Cert */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_DIR"/test_ca_cert.pem",
-	                    NULL,
-	                    NM_SETTING_802_1X_CA_CERT);
-
-	/* Inner auth method */
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_autheap (s_8021x), ==, "tls");
-
-	/* Inner CA Cert */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
-	                    NULL,
-	                    NM_SETTING_802_1X_PHASE2_CA_CERT);
-
-	/* Inner Client Cert */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
-	                    NULL,
-	                    NM_SETTING_802_1X_PHASE2_CLIENT_CERT);
-
-	/* Inner Private Key Password */
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_private_key_password (s_8021x), ==, expected_privkey_password);
-
-	/* Inner private key */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
-	                    expected_privkey_password,
-	                    NM_SETTING_802_1X_PHASE2_PRIVATE_KEY);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_dynamic_wep_leap (void)
-{
-	NMConnection *connection;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSetting8021x *s_8021x;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-dynamic-wep-leap",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wifi = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wifi);
-
-	/* ===== Wi-Fi SECURITY SETTING ===== */
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-
-	/* Key management */
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "ieee8021x");
-
-	/* Auth alg should be NULL (open) for dynamic WEP with LEAP as the EAP method;
-	 * only "old-school" LEAP uses 'leap' for the auth alg.
-	 */
-	g_assert_cmpstr (nm_setting_wireless_security_get_auth_alg (s_wsec), ==, NULL);
-
-	/* Expect no old-school LEAP username/password, that'll be in the 802.1x setting */
-	g_assert_cmpstr (nm_setting_wireless_security_get_leap_username (s_wsec), ==, NULL);
-	g_assert_cmpstr (nm_setting_wireless_security_get_leap_password (s_wsec), ==, NULL);
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-
-	/* EAP method should be "leap" */
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "leap");
-
-	/* username & password */
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "bill smith");
-	g_assert_cmpstr (nm_setting_802_1x_get_password (s_8021x), ==, "foobar baz");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_eap_ttls_chap (void)
-{
-	NMConnection *connection;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSetting8021x *s_8021x;
-	char *unmanaged = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-eap-ttls-chap",
-	                                    NULL, TYPE_WIRELESS, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	/* ===== 802.1x SETTING ===== */
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "ieee8021x");
-
-	/* ===== 802.1x SETTING ===== */
-	s_8021x = nm_connection_get_setting_802_1x (connection);
-	g_assert (s_8021x);
-
-	/* EAP methods */
-	g_assert_cmpint (nm_setting_802_1x_get_num_eap_methods (s_8021x), ==, 1);
-	g_assert_cmpstr (nm_setting_802_1x_get_eap_method (s_8021x, 0), ==, "ttls");
-
-	/* CA Cert */
-	verify_cert_or_key (s_8021x,
-	                    TEST_IFCFG_DIR"/test_ca_cert.pem",
-	                    NULL,
-	                    NM_SETTING_802_1X_CA_CERT);
-
-	g_assert_cmpstr (nm_setting_802_1x_get_phase2_auth (s_8021x), ==, "chap");
-	g_assert_cmpstr (nm_setting_802_1x_get_identity (s_8021x), ==, "David Smith");
-	g_assert_cmpstr (nm_setting_802_1x_get_password (s_8021x), ==, "foobar baz");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_wake_on_lan (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-wake-on-lan",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-	g_assert_cmpint (nm_setting_wired_get_wake_on_lan (s_wired),
-	                 ==,
-	                 NM_SETTING_WIRED_WAKE_ON_LAN_ARP |
-	                 NM_SETTING_WIRED_WAKE_ON_LAN_PHY |
-	                 NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC);
-
-	g_assert_cmpstr (nm_setting_wired_get_wake_on_lan_password (s_wired),
-	                 ==,
-	                 "00:11:22:33:44:55");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_auto_negotiate_off (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-wake-on-lan",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	g_assert (!nm_setting_wired_get_auto_negotiate (s_wired));
-	g_assert_cmpint (nm_setting_wired_get_speed (s_wired), ==, 100);
-	g_assert_cmpstr (nm_setting_wired_get_duplex (s_wired), ==, "full");
-}
-
-static void
-test_read_wired_auto_negotiate_on (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-auto-negotiate-on",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	g_assert (nm_setting_wired_get_auto_negotiate (s_wired));
-	g_assert_cmpint (nm_setting_wired_get_speed (s_wired), ==, 0);
-	g_assert_cmpstr (nm_setting_wired_get_duplex (s_wired), ==, NULL);
-}
-
-static void
-test_read_wired_unknown_ethtool_opt (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-unknown-ethtool-opt",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	g_assert (!nm_setting_wired_get_auto_negotiate (s_wired));
-	g_assert (!nm_setting_wired_get_speed (s_wired));
-	g_assert (!nm_setting_wired_get_duplex (s_wired));
-
-	g_assert_cmpint (nm_setting_wired_get_wake_on_lan (s_wired),
-	                 ==,
-	                 NM_SETTING_WIRED_WAKE_ON_LAN_ARP |
-	                 NM_SETTING_WIRED_WAKE_ON_LAN_PHY |
-	                 NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC);
-	g_assert_cmpstr (nm_setting_wired_get_wake_on_lan_password (s_wired),
-	                 ==,
-	                 "00:11:22:33:44:55");
-}
-
-static void
-test_read_wifi_hidden (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-hidden",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRELESS_SETTING_NAME);
-
-	s_wifi = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wifi);
-	g_assert (nm_setting_wireless_get_hidden (s_wifi) == TRUE);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_wifi_hidden (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	shvarFile *f;
-	GBytes *ssid;
-	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Hidden",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_HIDDEN, TRUE,
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_WiFi_Hidden.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "SSID_HIDDEN", "yes");
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_wifi_mac_random (gconstpointer user_data)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	gs_free char *path = NULL;
-	NMSettingWireless *s_wifi;
-	const char *name;
-	gpointer value_p;
-	NMSettingMacRandomization value;
-
-	nmtst_test_data_unpack (user_data, &name, &value_p);
-	value = GPOINTER_TO_INT (value_p);
-
-	path = g_strdup_printf (TEST_IFCFG_DIR"/ifcfg-test-wifi-mac-random-%s", name);
-	connection = _connection_from_file (path, NULL, TYPE_WIRELESS, NULL);
-
-	s_wifi = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wifi);
-	g_assert_cmpint (nm_setting_wireless_get_mac_address_randomization (s_wifi), ==, value);
-}
-
-static void
-test_write_wifi_mac_random (gconstpointer user_data)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	char *val;
-	shvarFile *f;
-	GBytes *ssid;
-	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
-	const char *name, *write_expected;
-	gpointer value_p;
-	NMSettingMacRandomization value;
-	char cexpected[NM_STRLEN (TEST_IFCFG_DIR) + 100];
-
-	nmtst_test_data_unpack (user_data, &name, &value_p, &write_expected);
-	value = GPOINTER_TO_INT (value_p);
-
-	g_assert (write_expected);
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	val = g_strdup_printf ("Test Write Wi-Fi MAC %s", name);
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, val,
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-	g_free (val);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, value,
-	              NULL);
-	g_bytes_unref (ssid);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        nm_sprintf_buf (cexpected, TEST_IFCFG_DIR"/ifcfg-Test_Write_WiFi_MAC_%s.cexpected", name),
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "MAC_ADDRESS_RANDOMIZATION", write_expected);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_wake_on_lan (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingWiredWakeOnLan wol;
-	char *val;
-	shvarFile *f;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired Wake-on-LAN",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	wol = NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST |
-	      NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST |
-	      NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC;
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_WAKE_ON_LAN, wol,
-	              NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD, "00:00:00:11:22:33",
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Wake-on-LAN.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	val = svGetValueStr_cp (f, "ETHTOOL_OPTS");
-	g_assert (val);
-	g_assert (strstr (val, "wol"));
-	g_assert (strstr (val, "sopass 00:00:00:11:22:33"));
-	g_free (val);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_auto_negotiate_off (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingWired *s_wired;
-	char *val;
-	shvarFile *f;
-
-	connection = nmtst_create_minimal_connection ("Test Write Wired Auto-Negotiate", NULL, NM_SETTING_WIRED_SETTING_NAME, NULL);
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_AUTO_NEGOTIATE, FALSE,
-	              NM_SETTING_WIRED_DUPLEX, "half",
-	              NM_SETTING_WIRED_SPEED, 10,
-	              NULL);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Auto-Negotiate.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	val = svGetValueStr_cp (f, "ETHTOOL_OPTS");
-	g_assert (val);
-	g_assert (strstr (val, "autoneg off"));
-	g_assert (strstr (val, "speed 10"));
-	g_assert (strstr (val, "duplex half"));
-	g_free (val);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_auto_negotiate_on (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingWired *s_wired;
-	NMSettingEthtool *s_ethtool;
-	char *val;
-	shvarFile *f;
-
-	connection = nmtst_create_minimal_connection ("Test Write Wired Auto-Negotiate", NULL, NM_SETTING_WIRED_SETTING_NAME, NULL);
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_AUTO_NEGOTIATE, TRUE,
-	              NULL);
-
-	s_ethtool = NM_SETTING_ETHTOOL (nm_setting_ethtool_new ());
-	nm_setting_ethtool_set_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_TX, NM_TERNARY_TRUE);
-	nm_setting_ethtool_set_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN, NM_TERNARY_FALSE);
-	nm_connection_add_setting (connection, NM_SETTING (s_ethtool));
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-test_write_wired_auto_negotiate_on.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	val = svGetValueStr_cp (f, "ETHTOOL_OPTS");
-	g_assert (val);
-	g_assert (strstr (val, "autoneg on"));
-	g_assert (!strstr (val, "speed"));
-	g_assert (!strstr (val, "duplex"));
-	g_free (val);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_verifies_without_normalization (reread);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	s_ethtool = NM_SETTING_ETHTOOL (nm_connection_get_setting (reread, NM_TYPE_SETTING_ETHTOOL));
-	g_assert (s_ethtool);
-	g_assert_cmpint (nm_setting_ethtool_get_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_TX), ==, NM_TERNARY_TRUE);
-	g_assert_cmpint (nm_setting_ethtool_get_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN), ==, NM_TERNARY_FALSE);
-	g_assert_cmpint (nm_setting_ethtool_get_feature (s_ethtool, NM_ETHTOOL_OPTNAME_FEATURE_TXVLAN), ==, NM_TERNARY_DEFAULT);
-}
-
-static void
-test_read_wifi_band_a (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-band-a",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRELESS_SETTING_NAME);
-
-	s_wifi = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wifi);
-	g_assert_cmpstr (nm_setting_wireless_get_band (s_wifi), ==, "a");
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_wifi_band_a (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	shvarFile *f;
-	GBytes *ssid;
-	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Band A",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NM_SETTING_WIRELESS_BAND, "a",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_WiFi_Band_A.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "BAND", "a");
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_wifi_band_a_channel_mismatch (void)
-{
-	gs_free_error GError *error = NULL;
-
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-wifi-band-a-channel-mismatch",
-	                            NULL, TYPE_WIRELESS, &error);
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-}
-
-static void
-test_read_wifi_band_bg_channel_mismatch (void)
-{
-	gs_free_error GError *error = NULL;
-
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-wifi-band-bg-channel-mismatch",
-	                            NULL, TYPE_WIRELESS, &error);
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-}
-
-static void
-test_read_wired_qeth_static (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	char *unmanaged = NULL;
-	const char * const *subchannels;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-qeth-static",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-qeth-static");
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	g_assert (!nm_setting_wired_get_mac_address (s_wired));
-
-	/* Subchannels */
-	subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
-	g_assert (subchannels);
-	g_assert (subchannels[0] && subchannels[1] && subchannels[2] && !subchannels[3]);
-
-	g_assert_cmpstr (subchannels[0], ==, "0.0.0600");
-	g_assert_cmpstr (subchannels[1], ==, "0.0.0601");
-	g_assert_cmpstr (subchannels[2], ==, "0.0.0602");
-
-	g_assert_cmpstr (nm_setting_wired_get_s390_nettype (s_wired), ==, "qeth");
-	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "portname"), ==, "OSAPORT");
-	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "portno"), ==, "0");
-	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "layer2"), ==, "1");
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wired_ctc_static (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	char *unmanaged = NULL;
-	const char * const *subchannels;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-ctc-static",
-	                                    NULL, TYPE_ETHERNET, &unmanaged);
-	g_assert (unmanaged == NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con != NULL);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System test-wired-ctc-static");
-
-	/* ===== WIRED SETTING ===== */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired != NULL);
-
-	g_assert (nm_setting_wired_get_mac_address (s_wired) == NULL);
-
-	/* Subchannels */
-	subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
-	g_assert (subchannels != NULL);
-	g_assert (subchannels[0] && subchannels[1] && !subchannels[2]);
-
-	g_assert_cmpstr (subchannels[0], ==, "0.0.1b00");
-	g_assert_cmpstr (subchannels[1], ==, "0.0.1b01");
-
-	g_assert_cmpstr (nm_setting_wired_get_s390_nettype (s_wired), ==, "ctc");
-	g_assert_cmpstr (nm_setting_wired_get_s390_option_by_key (s_wired, "ctcprot"), ==, "0");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_no_keys (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
-	NMWepKeyType key_type;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-no-keys",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System foobar (test-wifi-wep-no-keys)");
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	/* ===== WIRELESS SETTING ===== */
-
-	s_wireless = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wireless);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-
-	/* Key management */
-	g_assert_cmpstr (nm_setting_wireless_security_get_key_mgmt (s_wsec), ==, "none");
-
-	/* WEP key index */
-	g_assert_cmpint (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec), ==, 0);
-
-	/* WEP key type */
-	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
-	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
-
-	/* WEP key index 0; we don't expect it to be filled */
-	g_assert (!nm_setting_wireless_security_get_wep_key (s_wsec, 0));
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_permissions (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	gboolean success;
-	guint32 num;
-	const char *tmp;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-permissions",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	num = nm_setting_connection_get_num_permissions (s_con);
-	g_assert_cmpint (num, ==, 3);
-
-	/* verify each permission */
-	tmp = NULL;
-	success = nm_setting_connection_get_permission (s_con, 0, NULL, &tmp, NULL);
-	g_assert (success);
-	g_assert_cmpstr (tmp, ==, "dcbw");
-
-	tmp = NULL;
-	success = nm_setting_connection_get_permission (s_con, 1, NULL, &tmp, NULL);
-	g_assert (success);
-	g_assert_cmpstr (tmp, ==, "ssmith");
-
-	tmp = NULL;
-	success = nm_setting_connection_get_permission (s_con, 2, NULL, &tmp, NULL);
-	g_assert (success);
-	g_assert_cmpstr (tmp, ==, "johnny5");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_wifi_wep_agent_keys (void)
-{
-	NMConnection *connection;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMWepKeyType key_type;
-	NMSettingSecretFlags flags;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wifi-wep-agent-keys",
-	                                    NULL, TYPE_WIRELESS, NULL);
-
-	/* Ensure the connection is still marked for wifi security even though
-	 * we don't have any WEP keys because they are agent owned.
-	 */
-
-	/* ===== WIRELESS SETTING ===== */
-	s_wifi = nm_connection_get_setting_wireless (connection);
-	g_assert (s_wifi);
-
-	/* ===== WIRELESS SECURITY SETTING ===== */
-	s_wsec = nm_connection_get_setting_wireless_security (connection);
-	g_assert (s_wsec);
-
-	g_assert (strcmp (nm_setting_wireless_security_get_key_mgmt (s_wsec), "none") == 0);
-	g_assert (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec) == 0);
-
-	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
-	g_assert (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY);
-
-	/* We don't expect WEP key0 to be filled */
-	g_assert (nm_setting_wireless_security_get_wep_key (s_wsec, 0) == NULL);
-
-	flags = nm_setting_wireless_security_get_wep_key_flags (s_wsec);
-	g_assert (flags & NM_SETTING_SECRET_FLAG_AGENT_OWNED);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_wired_static (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *route6file = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4, *reread_s_ip4;
-	NMSettingIPConfig *s_ip6, *reread_s_ip6;
-	NMIPAddress *addr;
-	NMIPAddress *addr6;
-	NMIPRoute *route6;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES, 1,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
-	              NM_SETTING_WIRED_MTU, (guint32) 1492,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
-
-	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
-	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 206,
-	              NULL);
-
-	/* Add addresses */
-	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	addr6 = nm_ip_address_new (AF_INET6, "2003:1234:abcd::2", 22, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	addr6 = nm_ip_address_new (AF_INET6, "3003:1234:abcd::3", 33, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	/* Add routes */
-	route6 = nm_ip_route_new (AF_INET6,
-	                          "2222:aaaa:bbbb:cccc::", 64,
-	                          "2222:aaaa:bbbb:cccc:dddd:eeee:5555:6666", 99, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_route (s_ip6, route6);
-	nm_ip_route_unref (route6);
-
-	route6 = nm_ip_route_new (AF_INET6, "::", 128, "2222:aaaa::9999", 1, &error);
-	g_assert_no_error (error);
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_CWND, g_variant_new_uint32 (100));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_MTU, g_variant_new_uint32 (1280));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND, g_variant_new_boolean (TRUE));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_FROM, g_variant_new_string ("2222::bbbb/32"));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_SRC, g_variant_new_string ("::42"));
-	nm_setting_ip_config_add_route (s_ip6, route6);
-	nm_ip_route_unref (route6);
-
-	/* DNS servers */
-	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
-	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
-
-	/* DNS domains */
-	nm_setting_ip_config_add_dns_search (s_ip6, "foobar6.com");
-	nm_setting_ip_config_add_dns_search (s_ip6, "lab6.foobar.com");
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-	route6file = utils_get_route6_path (testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	reread_s_ip4 = nm_connection_get_setting_ip4_config (reread);
-	reread_s_ip6 = nm_connection_get_setting_ip6_config (reread);
-
-	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip4), ==, 204);
-	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip6), ==, 206);
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
-}
-
-static void
-test_write_wired_static_with_generic (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *route6file = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4, *reread_s_ip4;
-	NMSettingIPConfig *s_ip6, *reread_s_ip6;
-	NMIPAddress *addr;
-	NMIPAddress *addr6;
-	NMIPRoute *route6;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES, 1,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
-	              NM_SETTING_WIRED_MTU, (guint32) 1492,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
-
-	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
-	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 206,
-	              NULL);
-
-	/* Add addresses */
-	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	addr6 = nm_ip_address_new (AF_INET6, "2003:1234:abcd::2", 22, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	addr6 = nm_ip_address_new (AF_INET6, "3003:1234:abcd::3", 33, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	/* Add routes */
-	route6 = nm_ip_route_new (AF_INET6,
-	                          "2222:aaaa:bbbb:cccc::", 64,
-	                          "2222:aaaa:bbbb:cccc:dddd:eeee:5555:6666", 99, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_route (s_ip6, route6);
-	nm_ip_route_unref (route6);
-
-	route6 = nm_ip_route_new (AF_INET6, "::", 128, "2222:aaaa::9999", 1, &error);
-	g_assert_no_error (error);
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_CWND, g_variant_new_uint32 (100));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_MTU, g_variant_new_uint32 (1280));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND, g_variant_new_boolean (TRUE));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_FROM, g_variant_new_string ("2222::bbbb/32"));
-	nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_SRC, g_variant_new_string ("::42"));
-	nm_setting_ip_config_add_route (s_ip6, route6);
-	nm_ip_route_unref (route6);
-
-	/* DNS servers */
-	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
-	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
-
-	/* DNS domains */
-	nm_setting_ip_config_add_dns_search (s_ip6, "foobar6.com");
-	nm_setting_ip_config_add_dns_search (s_ip6, "lab6.foobar.com");
-
-	nm_connection_add_setting (connection, nm_setting_generic_new ());
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_FIXME (connection,
-	                              TEST_SCRATCH_DIR,
-	                              &testfile);
-	route6file = utils_get_route6_path (testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	reread_s_ip4 = nm_connection_get_setting_ip4_config (reread);
-	reread_s_ip6 = nm_connection_get_setting_ip6_config (reread);
-
-	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip4), ==, 204);
-	g_assert_cmpint (nm_setting_ip_config_get_route_metric (reread_s_ip6), ==, 206);
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	{
-		gs_unref_hashtable GHashTable *diffs = NULL;
-
-		g_assert (!nm_connection_diff (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT, &diffs));
-		g_assert (diffs);
-		g_assert (g_hash_table_size (diffs) == 1);
-		g_assert (g_hash_table_lookup (diffs, "generic"));
-		g_assert (!nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
-	}
-	g_assert (!nm_connection_get_setting (reread, NM_TYPE_SETTING_GENERIC));
-	nm_connection_add_setting (reread, nm_setting_generic_new ());
-	{
-		gs_unref_hashtable GHashTable *diffs = NULL;
-
-		g_assert (nm_connection_diff (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT, &diffs));
-		g_assert (!diffs);
-		g_assert (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
-	}
-}
-
-static void
-test_write_wired_dhcp (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired DHCP",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, "random-client-id-00:22:33",
-	              NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, "awesome-hostname",
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, TRUE,
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static NMIPRoutingRule *
-_ip_routing_rule_new (int addr_family,
-                      const char *str)
-{
-	NMIPRoutingRuleAsStringFlags flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE;
-	gs_free_error GError *local = NULL;
-	NMIPRoutingRule *rule;
-
-	if (addr_family != AF_UNSPEC) {
-		if (addr_family == AF_INET)
-			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET;
-		else {
-			g_assert (addr_family == AF_INET6);
-			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6;
-		}
-	}
-
-	rule = nm_ip_routing_rule_from_string (str,
-	                                         NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
-	                                       | flags,
-	                                       NULL,
-	                                       nmtst_get_rand_bool () ? &local : NULL);
-	nmtst_assert_success (rule, local);
-
-	if (addr_family != AF_UNSPEC)
-		g_assert_cmpint (nm_ip_routing_rule_get_addr_family (rule), ==, addr_family);
-	return rule;
-}
-
-static void
-_ip_routing_rule_add_to_setting (NMSettingIPConfig *s_ip,
-                                 const char *str)
-{
-	nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
-
-	rule = _ip_routing_rule_new (nm_setting_ip_config_get_addr_family (s_ip), str);
-	nm_setting_ip_config_add_routing_rule (s_ip, rule);
-}
-
-static void
-test_write_routing_rules (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = nm_simple_connection_new ();
-
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Routing Rules",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	_ip_routing_rule_add_to_setting (s_ip4, "pref 10 from 0.0.0.0/0 table 1");
-	_ip_routing_rule_add_to_setting (s_ip4, "priority 10 to 192.167.8.0/24 table 2");
-	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 table 10");
-	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 to 1:2:3::5/24 table 22");
-	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 to 1:3:3::5/128 table 55");
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Routing_Rules.cexpected",
-	                        &testfile);
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_match (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingMatch *s_match;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired with Match setting",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
-
-	/* Match setting */
-	s_match = (NMSettingMatch *) nm_setting_match_new ();
-	nm_setting_match_add_interface_name (s_match, "ens*");
-	nm_setting_match_add_interface_name (s_match, "eth 1?");
-	nm_setting_match_add_interface_name (s_match, "!veth*");
-	nm_connection_add_setting (connection, NM_SETTING (s_match));
-
-	nmtst_assert_connection_verifies (connection);
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_match.cexpected",
-	                        &testfile);
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_dhcp_plus_ip (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp-plus-ip",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_write_wired_dhcp_send_hostname (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	const char * dhcp_hostname = "kamil-patka";
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcp-send-hostname",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* Check dhcp-hostname and dhcp-send-hostname */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip4);
-	g_assert (s_ip6);
-	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) == TRUE);
-	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, "svata-pulec");
-	g_assert (!nm_setting_ip_config_get_dhcp_hostname (s_ip6));
-
-	/* Set dhcp-send-hostname=false dhcp-hostname="kamil-patka" and write the connection. */
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, dhcp_hostname, NULL);
-	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, dhcp_hostname, NULL);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	/* Check dhcp-hostname and dhcp-send-hostname from the re-read connection. */
-	s_ip4 = nm_connection_get_setting_ip4_config (reread);
-	s_ip6 = nm_connection_get_setting_ip6_config (reread);
-	g_assert (s_ip4);
-	g_assert (s_ip6);
-	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) == FALSE);
-	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, dhcp_hostname);
-	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
-}
-
-static void
-test_read_wired_dhcpv6_hostname_fallback (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingIPConfig *s_ip6;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-wired-dhcpv6-hostname-fallback",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	g_assert (s_ip6);
-	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip6) == TRUE);
-	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, "fully.qualified.domain");
-}
-
-static void
-test_write_wired_static_ip6_only (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMIPAddress *addr6;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static IP6 Only",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd", NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_DISABLED,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
-	              NULL);
-
-	/* Add addresses */
-	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	/* DNS server */
-	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_ip6_disabled (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = nmtst_create_minimal_connection ("Test Write Wired Disabled IP6",
-	                                              NULL,
-	                                              NM_SETTING_WIRED_SETTING_NAME,
-	                                              &s_con);
-
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_DISABLED,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR_TMP,
-	                        TEST_IFCFG_DIR"/ifcfg-test-ip6-disabled.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-/* Test writing an IPv6 config with varying gateway address.
- * For missing gateway (::), we expect no IPV6_DEFAULTGW to be written
- * to ifcfg-rh.
- *
- * As user_data pass the IPv6 address of the gateway as string. NULL means
- * not to explicitly set the gateway in the configuration before writing it.
- * That way, the gateway actually defaults to "::".
- */
-static void
-test_write_wired_static_ip6_only_gw (gconstpointer user_data)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMIPAddress *addr6;
-	GError *error = NULL;
-	char *id = NULL;
-	gs_free char *written_ifcfg_gateway = NULL;
-	const char *gateway6 = user_data;
-	shvarFile *ifcfg;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	id = g_strdup_printf ("Test Write Wired Static IP6 Only With Gateway %s", gateway6 ?: "NULL");
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, id,
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-	g_free (id);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd", NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_DISABLED,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, gateway6,
-	              NULL);
-
-	/* Add addresses */
-	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip6, addr6);
-	nm_ip_address_unref (addr6);
-
-	/* DNS server */
-	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	ifcfg = _svOpenFile (testfile);
-	written_ifcfg_gateway = svGetValueStr_cp (ifcfg, "IPV6_DEFAULTGW");
-	svCloseFile (ifcfg);
-
-	/* access the gateway from the loaded connection. */
-	s_ip6 = nm_connection_get_setting_ip6_config (reread);
-	g_assert (s_ip6 && nm_setting_ip_config_get_num_addresses (s_ip6)==1);
-	addr6 = nm_setting_ip_config_get_address (s_ip6, 0);
-	g_assert (addr6);
-
-	/* assert that the gateway was written and reloaded as expected */
-	if (!gateway6 || !strcmp (gateway6, "::")) {
-		g_assert (nm_setting_ip_config_get_gateway (s_ip6) == NULL);
-		g_assert (written_ifcfg_gateway == NULL);
-	} else {
-		g_assert (nm_setting_ip_config_get_gateway (s_ip6) != NULL);
-		g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip6), ==, gateway6);
-		g_assert_cmpstr (written_ifcfg_gateway, ==, gateway6);
-	}
-}
-
-static void
-test_read_write_static_routes_legacy (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *routefile = NULL;
-	gs_free char *route6file = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	const char *tmp;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-static-routes-legacy",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	/* ID */
-	tmp = nm_setting_connection_get_id (s_con);
-	g_assert (tmp);
-
-	/* Autoconnect */
-	g_assert (nm_setting_connection_get_autoconnect (s_con));
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (s_ip4);
-	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
-
-	g_assert (!nm_setting_ip_config_get_never_default (s_ip4));
-
-	/* Save the ifcfg; use a special different scratch dir to ensure that
-	 * we can clean up after the written connection in both the original
-	 * source tree and for 'make distcheck'.
-	 */
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR_TMP,
-	                        TEST_IFCFG_DIR"/ifcfg-test-static-routes-legacy.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	routefile = utils_get_route_path (testfile);
-	route6file = utils_get_route6_path (testfile);
-	g_assert (!g_file_test (route6file, G_FILE_TEST_EXISTS));
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_static_routes (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *routefile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMIPAddress *addr;
-	NMIPRoute *route;
-	GError *error = NULL;
-	gboolean reread_same = FALSE;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static Routes",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
-	              NM_SETTING_WIRED_MTU, (guint32) 1492,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_DAD_TIMEOUT, 400,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* Write out routes */
-	route = nm_ip_route_new (AF_INET, "1.2.3.0", 24, "222.173.190.239", 0, &error);
-	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
-	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (TRUE));
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_route (s_ip4, route);
-	nm_ip_route_unref (route);
-
-	route = nm_ip_route_new (AF_INET, "3.2.1.0", 24, "202.254.186.190", 77, &error);
-	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (30000));
-	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_route (s_ip4, route);
-	nm_ip_route_unref (route);
-
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
-
-	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
-	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_reread (connection,
-	                               TEST_SCRATCH_DIR,
-	                               &testfile,
-	                               TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Static_Routes.cexpected",
-	                               &reread,
-	                               &reread_same);
-	/* ifcfg does not support setting onlink=0. It gets lost during write+re-read.
-	 * Assert that it's missing, and patch it to check whether the rest of the
-	 * connection equals. */
-	g_assert (!reread_same);
-	nmtst_assert_connection_verifies_without_normalization (reread);
-	s_ip4 = nm_connection_get_setting_ip4_config (reread);
-	g_assert (s_ip4);
-	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 2);
-	route = nm_setting_ip_config_get_route (s_ip4, 1);
-	g_assert (route);
-	g_assert (!nm_ip_route_get_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK));
-	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	routefile = utils_get_route_path (testfile);
-}
-
-static void
-test_write_wired_dhcp_8021x_peap_mschapv2 (void)
-{
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMSetting8021x *s_8021x;
-	gboolean success;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired DHCP 802.1x PEAP MSCHAPv2",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	/* 802.1x setting */
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_IDENTITY, "Bob Saget",
-	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "barney",
-	              NM_SETTING_802_1X_PASSWORD, "Kids, it was back in October 2008...",
-	              NM_SETTING_802_1X_PHASE1_PEAPVER, "1",
-	              NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1",
-	              NM_SETTING_802_1X_PHASE2_AUTH, "mschapv2",
-	              NULL);
-
-	nm_setting_802_1x_add_eap_method (s_8021x, "peap");
-
-	success = nm_setting_802_1x_set_ca_cert (s_8021x,
-	                                         TEST_IFCFG_WIRED_8021x_PEAP_MSCHAPV2_CA_CERT,
-	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                         NULL,
-	                                         &error);
-	nmtst_assert_success (success, error);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	keyfile = utils_get_keys_path (testfile);
-}
-
-static void
-test_write_wired_8021x_tls (gconstpointer test_data)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_free char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMSetting8021x *s_8021x;
-	gboolean success;
-	GError *error = NULL;
-	NMSetting8021xCKFormat format = NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
-	const char *pw;
-	char *tmp;
-	gpointer scheme_p, flags_p;
-	NMSetting8021xCKScheme scheme;
-	NMSettingSecretFlags flags;
-
-	nmtst_test_data_unpack (test_data, &scheme_p, &flags_p);
-	scheme = GPOINTER_TO_INT (scheme_p);
-	flags = GPOINTER_TO_INT (flags_p);
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired 802.1x TLS Blobs",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	/* 802.1x setting */
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-
-	g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, "Bill Smith", NULL);
-	nm_setting_802_1x_add_eap_method (s_8021x, "tls");
-
-	/* CA cert */
-	success = nm_setting_802_1x_set_ca_cert (s_8021x,
-	                                         TEST_IFCFG_DIR"/test_ca_cert.pem",
-	                                         scheme,
-	                                         &format,
-	                                         &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	g_assert (format == NM_SETTING_802_1X_CK_FORMAT_X509);
-
-	/* Client cert */
-	format = NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
-	success = nm_setting_802_1x_set_client_cert (s_8021x,
-	                                             TEST_IFCFG_DIR"/test1_key_and_cert.pem",
-	                                             scheme,
-	                                             &format,
-	                                             &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	g_assert (format == NM_SETTING_802_1X_CK_FORMAT_X509);
-
-	/* Private key */
-	format = NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
-	success = nm_setting_802_1x_set_private_key (s_8021x,
-	                                             TEST_IFCFG_DIR"/test1_key_and_cert.pem",
-	                                             "test1",
-	                                             scheme,
-	                                             &format,
-	                                             &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	g_assert (format == NM_SETTING_802_1X_CK_FORMAT_RAW_KEY);
-
-	/* Set secret flags */
-	g_object_set (s_8021x, NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS, flags, NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_FIXME (connection,
-	                              TEST_SCRATCH_DIR,
-	                              &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	nmtst_file_unlink_if_exists (keyfile);
-
-	/* Ensure the reread connection's certificates and private key are paths; no
-	 * matter what scheme was used in the original connection they will be read
-	 * back in as paths.
-	 */
-	s_8021x = nm_connection_get_setting_802_1x (reread);
-	g_assert (s_8021x);
-	g_assert_cmpint (nm_setting_802_1x_get_ca_cert_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
-	g_assert_cmpint (nm_setting_802_1x_get_client_cert_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
-	g_assert_cmpint (nm_setting_802_1x_get_private_key_scheme (s_8021x), ==, NM_SETTING_802_1X_CK_SCHEME_PATH);
-
-	g_assert_cmpint (nm_setting_802_1x_get_private_key_password_flags (s_8021x), ==, flags);
-	pw = nm_setting_802_1x_get_private_key_password (s_8021x);
-	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
-		/* Ensure the private key password is still set */
-		g_assert (pw != NULL);
-		g_assert_cmpstr (pw, ==, "test1");
-	} else {
-		/* If the secret isn't owned by system settings, make sure its no longer there */
-		g_assert (pw == NULL);
-	}
-
-	if (scheme == NM_SETTING_802_1X_CK_SCHEME_PATH) {
-		/* Do a direct compare if using the path scheme since then the
-		 * certificate and key properties should be the same.  If using blob
-		 * scheme the original connection cert/key properties will be blobs
-		 * but the re-read connection is always path scheme, so we wouldn't
-		 * expect it to compare successfully.
-		 */
-		if (flags != NM_SETTING_SECRET_FLAG_NONE) {
-			/* Clear original connection's private key password because flags
-			 * say it's not system-owned, and therefore it should not show up
-			 * in the re-read connection.
-			 */
-			s_8021x = nm_connection_get_setting_802_1x (connection);
-			g_object_set (s_8021x, NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD, NULL, NULL);
-		}
-
-		nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-	}
-
-	/* Clean up created certs and keys */
-	tmp = utils_cert_path (testfile, "ca-cert", "der");
-	nmtst_file_unlink_if_exists (tmp);
-	g_free (tmp);
-
-	tmp = utils_cert_path (testfile, "client-cert", "der");
-	nmtst_file_unlink_if_exists (tmp);
-	g_free (tmp);
-
-	tmp = utils_cert_path (testfile, "private-key", "pem");
-	nmtst_file_unlink_if_exists (tmp);
-	g_free (tmp);
-}
-
-static void
-test_write_wired_aliases (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	int num_addresses = 4;
-	const char *ip[] = { "1.1.1.1", "1.1.1.2", "1.1.1.3", "1.1.1.4" };
-	const char *label[] = { NULL, "alias0:2", NULL, "alias0:3" };
-	NMIPAddress *addr;
-	GError *error = NULL;
-	shvarFile *ifcfg;
-	int i, j;
-
-	nmtst_file_unlink_if_exists (TEST_SCRATCH_ALIAS_BASE ":2");
-	nmtst_file_unlink_if_exists (TEST_SCRATCH_ALIAS_BASE ":3");
-	nmtst_file_unlink_if_exists (TEST_SCRATCH_ALIAS_BASE ":5");
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "alias0",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	for (i = 0; i < num_addresses; i++) {
-		addr = nm_ip_address_new (AF_INET, ip[i], 24, &error);
-		g_assert_no_error (error);
-		if (label[i])
-			nm_ip_address_set_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL, g_variant_new_string (label[i]));
-		nm_setting_ip_config_add_address (s_ip4, addr);
-		nm_ip_address_unref (addr);
-	}
-
-	nmtst_assert_connection_verifies (connection);
-
-	/* Create some pre-existing alias files, to make sure they get overwritten / deleted. */
-	ifcfg = svCreateFile (TEST_SCRATCH_ALIAS_BASE ":2");
-	svSetValueStr (ifcfg, "DEVICE", "alias0:2");
-	svSetValueStr (ifcfg, "IPADDR", "192.168.1.2");
-	svWriteFile (ifcfg, 0644, NULL);
-	svCloseFile (ifcfg);
-	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":2", G_FILE_TEST_EXISTS));
-
-	ifcfg = svCreateFile (TEST_SCRATCH_ALIAS_BASE ":5");
-	svSetValueStr (ifcfg, "DEVICE", "alias0:5");
-	svSetValueStr (ifcfg, "IPADDR", "192.168.1.5");
-	svWriteFile (ifcfg, 0644, NULL);
-	svCloseFile (ifcfg);
-	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":5", G_FILE_TEST_EXISTS));
-
-	_writer_new_connection_FIXME (connection,
-	                              TEST_SCRATCH_DIR,
-	                              &testfile);
-
-	/* Re-check the alias files */
-	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":2", G_FILE_TEST_EXISTS));
-	g_assert (g_file_test (TEST_SCRATCH_ALIAS_BASE ":3", G_FILE_TEST_EXISTS));
-	g_assert (!g_file_test (TEST_SCRATCH_ALIAS_BASE ":5", G_FILE_TEST_EXISTS));
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-	nmtst_file_unlink (TEST_SCRATCH_ALIAS_BASE ":2");
-	nmtst_file_unlink (TEST_SCRATCH_ALIAS_BASE ":3");
-
-	/* nm_connection_compare() is not guaranteed to succeed, because the
-	 * aliases get read back in essentially random order. So just
-	 * verify the aliases manually.
-	 */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	g_assert (nm_setting_ip_config_get_num_addresses (s_ip4) == num_addresses);
-
-	/* Addresses */
-	for (i = 0; i < num_addresses; i++) {
-		const char *addrstr;
-
-		addr = nm_setting_ip_config_get_address (s_ip4, i);
-		g_assert (addr != NULL);
-
-		addrstr = nm_ip_address_get_address (addr);
-		for (j = 0; j < num_addresses; j++) {
-			if (!g_strcmp0 (addrstr, ip[j]))
-				break;
-		}
-		if (j >= num_addresses)
-			g_assert_not_reached ();
-		else {
-			g_assert_cmpint (nm_ip_address_get_prefix (addr), ==, 24);
-			if (label[j])
-				g_assert_cmpstr (g_variant_get_string (nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL), NULL), ==, label[j]);
-			else
-				g_assert (nm_ip_address_get_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL) == NULL);
-			ip[j] = NULL;
-		}
-	}
-
-	for (i = 0; i < num_addresses; i++)
-		g_assert (!ip[i]);
-
-	/* Gateway */
-	g_assert_cmpstr (nm_setting_ip_config_get_gateway (s_ip4), ==, "1.1.1.1");
-}
-
-static void
-test_write_gateway (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	GError *error = NULL;
-	shvarFile *f;
-	NMIPAddress *addr;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Static Addresses Gateway",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.254",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	addr = nm_ip_address_new (AF_INET, "2.2.2.5", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "IPADDR", "1.1.1.3");
-	_svGetValue_check (f, "IPADDR1", "2.2.2.5");
-	_svGetValue_check (f, "IPADDR0", NULL);
-	_svGetValue_check (f, "PREFIX", "24");
-	_svGetValue_check (f, "PREFIX1", "24");
-	_svGetValue_check (f, "PREFIX0", NULL);
-	_svGetValue_check (f, "GATEWAY", "1.1.1.254");
-	_svGetValue_check (f, "GATEWAY0", NULL);
-	_svGetValue_check (f, "GATEWAY1", NULL);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_open (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
-	shvarFile *ifcfg;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi Open",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_BSSID, "11:22:33:44:55:66",
-	              NM_SETTING_WIRELESS_MAC_ADDRESS, "aa:bb:cc:dd:ee:ff",
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NM_SETTING_WIRELESS_BAND, "bg",
-	              NM_SETTING_WIRELESS_CHANNEL, (guint32) 9,
-	              NM_SETTING_WIRELESS_MTU, (guint32) 1345,
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	ifcfg = _svOpenFile (testfile);
-	_svGetValue_check (ifcfg, "ESSID", "Test SSID");
-	svCloseFile (ifcfg);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_open_hex_ssid (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const unsigned char ssid_data[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd };
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi Open Hex SSID",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wep (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	struct stat statbuf;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
-	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 2,
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
-	              NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "0123456789abcdef0123456789");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 1, "11111111111111111111111111");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 2, "aaaaaaaaaaaaaaaaaaaaaaaaaa");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 3, "BBBBBBBBBBBBBBBBBBBBBBBBBB");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
-	g_assert (S_ISREG (statbuf.st_mode));
-	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wep_adhoc (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GError *error = NULL;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	struct stat statbuf;
-	NMIPAddress *addr;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP AdHoc",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "adhoc",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "0123456789abcdef0123456789");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NULL);
-
-	/* IP Address */
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
-	g_assert (S_ISREG (statbuf.st_mode));
-	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wep_passphrase (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	struct stat statbuf;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP Passphrase",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
-	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0,
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
-	              NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "asdfdjaslfjasd;flasjdfl;aksdf");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
-	g_assert (S_ISREG (statbuf.st_mode));
-	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wep_40_ascii (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah40";
-	struct stat statbuf;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP 40 ASCII",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
-	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 2,
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_KEY,
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
-	              NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "lorem");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 1, "ipsum");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 2, "dolor");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 3, "donec");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
-	g_assert (S_ISREG (statbuf.st_mode));
-	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wep_104_ascii (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah104";
-	struct stat statbuf;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP 104 ASCII",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
-	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0,
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_UNKNOWN,
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open",
-	              NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "LoremIpsumSit");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 1, "AlfaBetaGamma");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 2, "WEP-104 ASCII");
-	nm_setting_wireless_security_set_wep_key (s_wsec, 3, "thisismyascii");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wifi_WEP_104_ASCII.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
-	g_assert (S_ISREG (statbuf.st_mode));
-	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_leap (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	struct stat statbuf;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi LEAP",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
-	              NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, "Bill Smith",
-	              NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, "foobar22",
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Wifi_LEAP.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-	g_assert_cmpint (stat (keyfile, &statbuf), ==, 0);
-	g_assert (S_ISREG (statbuf.st_mode));
-	g_assert_cmpint ((statbuf.st_mode & 0077), ==, 0);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_leap_secret_flags (gconstpointer data)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_free char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	NMSettingSecretFlags flags = GPOINTER_TO_UINT (data);
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi LEAP Secret Flags",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
-	              NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, "Bill Smith",
-	              NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, "foobar22",
-	              NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_FIXME (connection,
-	                              TEST_SCRATCH_DIR,
-	                              &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	/* No key should be written out since the secret is not system owned */
-	keyfile = utils_get_keys_path (testfile);
-	g_assert (g_file_test (keyfile, G_FILE_TEST_EXISTS) == FALSE);
-
-	/* Remove the LEAP password from the original connection since it wont' be
-	 * in the reread connection, as the password is not system owned.
-	 */
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, NULL, NULL);
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wpa_psk (gconstpointer test_data)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	struct {
-		const char *name, *psk;
-		gpointer wep_group_p, wpa_p, wpa2_p;
-	} args;
-
-	nmtst_test_data_unpack (test_data, &args.name, &args.wep_group_p, &args.wpa_p, &args.wpa2_p, &args.psk);
-
-	g_assert (args.psk);
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, args.name,
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
-	              NM_SETTING_WIRELESS_SECURITY_PSK, args.psk,
-	              NM_SETTING_WIRELESS_SECURITY_PMF, (int) NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED,
-	              NULL);
-
-	if (GPOINTER_TO_INT (args.wep_group_p)) {
-		nm_setting_wireless_security_add_group (s_wsec, "wep40");
-		nm_setting_wireless_security_add_group (s_wsec, "wep104");
-	}
-	if (GPOINTER_TO_INT (args.wpa_p)) {
-		nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-		nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-		nm_setting_wireless_security_add_group (s_wsec, "tkip");
-	}
-	if (GPOINTER_TO_INT (args.wpa2_p)) {
-		nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-		nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-		nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-	}
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wpa_psk_adhoc (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GError *error = NULL;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	NMIPAddress *addr;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA PSK",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "adhoc",
-	              NM_SETTING_WIRELESS_CHANNEL, 11,
-	              NM_SETTING_WIRELESS_BAND, "bg",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
-	              NM_SETTING_WIRELESS_SECURITY_PSK, "7d308b11df1b4243b0f78e5f3fc68cdbb9a264ed0edf4c188edf329ff5b467f0",
-	              NULL);
-
-	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NULL);
-
-	/* IP Address */
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 25, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wpa_eap_tls (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSetting8021x *s_8021x;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	gboolean success;
-	GError *error = NULL;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TLS",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap",
-	              NM_SETTING_WIRELESS_SECURITY_FILS, (int) NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,
-	              NULL);
-	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-	nm_setting_wireless_security_add_group (s_wsec, "tkip");
-
-	/* Wireless security setting */
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-
-	g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, "Bill Smith", NULL);
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_PHASE1_AUTH_FLAGS,
-	              (guint) (NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE |
-	                       NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE),
-	              NULL);
-
-	nm_setting_802_1x_add_eap_method (s_8021x, "tls");
-
-	success = nm_setting_802_1x_set_ca_cert (s_8021x,
-	                                         TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
-	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                         NULL,
-	                                         &error);
-	nmtst_assert_success (success, error);
-
-	success = nm_setting_802_1x_set_client_cert (s_8021x,
-	                                             TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
-	                                             NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                             NULL,
-	                                             &error);
-	nmtst_assert_success (success, error);
-
-	success = nm_setting_802_1x_set_private_key (s_8021x,
-	                                             TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
-	                                             "test1",
-	                                             NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                             NULL,
-	                                             &error);
-	nmtst_assert_success (success, error);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wpa_eap_ttls_tls (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSetting8021x *s_8021x;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	gboolean success;
-	GError *error = NULL;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TTLS (TLS)",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
-	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-
-	/* Wireless security setting */
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-
-	nm_setting_802_1x_add_eap_method (s_8021x, "ttls");
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
-	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "foobar22",
-	              NM_SETTING_802_1X_PHASE2_AUTHEAP, "tls",
-	              NULL);
-
-	success = nm_setting_802_1x_set_ca_cert (s_8021x,
-	                                         TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
-	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                         NULL,
-	                                         &error);
-	nmtst_assert_success (success, error);
-
-	/* Phase 2 TLS stuff */
-
-	/* phase2 CA cert */
-	success = nm_setting_802_1x_set_phase2_ca_cert (s_8021x,
-	                                                TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
-	                                                NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                                NULL,
-	                                                &error);
-	nmtst_assert_success (success, error);
-
-	/* phase2 client cert */
-	success = nm_setting_802_1x_set_phase2_client_cert (s_8021x,
-	                                                    TEST_IFCFG_WIFI_WPA_EAP_TLS_CLIENT_CERT,
-	                                                    NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                                    NULL,
-	                                                    &error);
-	nmtst_assert_success (success, error);
-
-	/* phase2 private key */
-	success = nm_setting_802_1x_set_phase2_private_key (s_8021x,
-	                                                    TEST_IFCFG_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
-	                                                    "test1",
-	                                                    NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                                    NULL,
-	                                                    &error);
-	nmtst_assert_success (success, error);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wpa_eap_ttls_mschapv2 (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSetting8021x *s_8021x;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	gboolean success;
-	GError *error = NULL;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TTLS (MSCHAPv2)",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
-	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-	nm_setting_wireless_security_add_group (s_wsec, "tkip");
-	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-
-	/* Wireless security setting */
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-
-	nm_setting_802_1x_add_eap_method (s_8021x, "ttls");
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
-	              NM_SETTING_802_1X_PASSWORD, ";alkdfja;dslkfjsad;lkfjsadf",
-	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "foobar22",
-	              NM_SETTING_802_1X_PHASE2_AUTHEAP, "mschapv2",
-	              NULL);
-
-	success = nm_setting_802_1x_set_ca_cert (s_8021x,
-	                                         TEST_IFCFG_WIFI_WPA_EAP_TLS_CA_CERT,
-	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
-	                                         NULL,
-	                                         &error);
-	nmtst_assert_success (success, error);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	keyfile = utils_get_keys_path (testfile);
-}
-
-static void
-test_write_wifi_wpa_then_open (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_free char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-
-	/* Test that writing out a WPA config then changing that to an open
-	 * config doesn't leave various WPA-related keys lying around in the ifcfg.
-	 */
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "random wifi connection",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
-	              NM_SETTING_WIRELESS_SECURITY_PSK, "some cool PSK",
-	              NULL);
-
-	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-	nm_setting_wireless_security_add_group (s_wsec, "tkip");
-
-	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	g_object_unref (reread);
-
-	nmtst_connection_normalize (connection);
-
-	/* Now change the connection to open and recheck */
-	nm_connection_remove_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY);
-
-	/* Write it back out */
-	_writer_update_connection (connection,
-	                           TEST_SCRATCH_DIR,
-	                           testfile,
-	                           TEST_IFCFG_DIR"/ifcfg-random_wifi_connection.cexpected");
-	keyfile = utils_get_keys_path (testfile);
-	g_assert (!g_file_test (keyfile, G_FILE_TEST_EXISTS));
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wpa_then_wep_with_perms (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	gboolean success;
-	GBytes *ssid;
-	char **perms;
-	const char *ssid_data = "SomeSSID";
-
-	/* Test that writing out a WPA config then changing that to a WEP
-	 * config works and doesn't cause infinite loop or other issues.
-	 */
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	perms = g_strsplit ("user:superman:", ",", -1);
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "random wifi connection 2",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_PERMISSIONS, perms,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-	g_strfreev (perms);
-	g_assert_cmpint (nm_setting_connection_get_num_permissions (s_con), ==, 1);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
-	              NM_SETTING_WIRELESS_SECURITY_PSK, "My cool PSK",
-	              NULL);
-
-	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-	nm_setting_wireless_security_add_group (s_wsec, "tkip");
-
-	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	g_object_unref (reread);
-
-	nmtst_connection_normalize (connection);
-
-	/* Now change the connection to WEP and recheck */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
-	              NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "abraka  dabra");
-
-	/* Write it back out */
-	_writer_update_connection (connection,
-	                           TEST_SCRATCH_DIR,
-	                           testfile,
-	                           TEST_IFCFG_DIR"/ifcfg-random_wifi_connection_2.cexpected");
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	nmtst_connection_normalize (connection);
-	success = nm_connection_compare (connection, reread,
-	                                 NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS |
-	                                 NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS);
-	g_assert (success);
-
-	keyfile = utils_get_keys_path (testfile);
-}
-
-static void
-test_write_wifi_dynamic_wep_leap (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	nmtst_auto_unlinkfile char *keyfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSetting8021x *s_8021x;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	GBytes *ssid;
-	const char *ssid_data = "blahblah";
-	shvarFile *ifcfg;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi Dynamic WEP LEAP",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
-
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-
-	g_bytes_unref (ssid);
-
-	/* Wireless security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x", NULL);
-
-	/* Wireless security setting */
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-
-	nm_setting_802_1x_add_eap_method (s_8021x, "leap");
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
-	              NM_SETTING_802_1X_PASSWORD, ";alkdfja;dslkfjsad;lkfjsadf",
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	keyfile = utils_get_keys_path (testfile);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-
-	/* Check and make sure that an "old-school" LEAP (Network EAP) connection
-	 * did not get written.  Check first that the auth alg is not set to "LEAP"
-	 * and next that the only IEEE 802.1x EAP method is "LEAP".
-	 */
-	ifcfg = _svOpenFile (testfile);
-	_svGetValue_check (ifcfg, "SECURITYMODE", NULL);
-	_svGetValue_check (ifcfg, "IEEE_8021X_EAP_METHODS", "LEAP");
-	svCloseFile (ifcfg);
-}
-
-static void
-test_write_wired_qeth_dhcp (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char **subchans;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired qeth Static",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	subchans = g_strsplit ("0.0.600,0.0.601,0.0.602", ",", -1);
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_S390_SUBCHANNELS, subchans,
-	              NM_SETTING_WIRED_S390_NETTYPE, "qeth",
-	              NULL);
-	g_strfreev (subchans);
-
-	nm_setting_wired_add_s390_option (s_wired, "portname", "FOOBAR");
-	nm_setting_wired_add_s390_option (s_wired, "portno", "1");
-	nm_setting_wired_add_s390_option (s_wired, "layer2", "0");
-	nm_setting_wired_add_s390_option (s_wired, "protocol", "blahbalh");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_ctc_dhcp (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	char **subchans;
-	shvarFile *ifcfg;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired ctc Static",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	subchans = g_strsplit ("0.0.600,0.0.601", ",", -1);
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_S390_SUBCHANNELS, subchans,
-	              NM_SETTING_WIRED_S390_NETTYPE, "ctc",
-	              NULL);
-	g_strfreev (subchans);
-	nm_setting_wired_add_s390_option (s_wired, "ctcprot", "0");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	/* Ensure the CTCPROT item gets written out as its own option */
-	ifcfg = _svOpenFile (testfile);
-
-	_svGetValue_check (ifcfg, "CTCPROT", "0");
-
-	/* And that it's not in the generic OPTIONS string */
-	_svGetValue_check (ifcfg, "OPTIONS", NULL);
-
-	svCloseFile (ifcfg);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_permissions (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Permissions",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	nm_setting_connection_add_permission (s_con, "user", "blahblah", NULL);
-	nm_setting_connection_add_permission (s_con, "user", "foobar", NULL);
-	nm_setting_connection_add_permission (s_con, "user", "asdfasdf", NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Permissions.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wifi_wep_agent_keys (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWireless *s_wifi;
-	NMSettingWirelessSecurity *s_wsec;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	const char *str_ssid = "foobarbaz";
-	GBytes *ssid;
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection != NULL);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP Agent Owned",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	/* Wifi setting */
-	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
-
-	ssid = g_bytes_new (str_ssid, strlen (str_ssid));
-	g_object_set (s_wifi,
-	              NM_SETTING_WIRELESS_SSID, ssid,
-	              NM_SETTING_WIRELESS_MODE, "infrastructure",
-	              NULL);
-	g_bytes_unref (ssid);
-
-	/* Wifi security setting */
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, NM_SETTING_SECRET_FLAG_AGENT_OWNED,
-	              NULL);
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "asdfdjaslfjasd;flasjdfl;aksdf");
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_FIXME (connection,
-	                              TEST_SCRATCH_DIR,
-	                              &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_WIRELESS, NULL);
-
-	/* Remove the WEP key from the original, because it should not have been
-	 * written out to disk as it was agent-owned.  The new connection should
-	 * not have any WEP keys set.
-	 * Also the new connection should not have WEP key type set.
-	 */
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, NULL);
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_UNKNOWN,
-	              NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_wired_pppoe (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingPppoe *s_pppoe;
-	NMSettingPpp *s_ppp;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Wired PPPoE",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* PPPoE setting */
-	s_pppoe = (NMSettingPppoe *) nm_setting_pppoe_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_pppoe));
-
-	g_object_set (G_OBJECT (s_pppoe),
-	              NM_SETTING_PPPOE_SERVICE, "stupid-service",
-	              NM_SETTING_PPPOE_USERNAME, "Bill Smith",
-	              NM_SETTING_PPPOE_PASSWORD, "test1",
-	              NULL);
-
-	/* PPP setting */
-	s_ppp = (NMSettingPpp *) nm_setting_ppp_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ppp));
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_fail (connection,
-	                             TEST_SCRATCH_DIR,
-	                             NULL);
-
-	g_object_unref (connection);
-	g_clear_error (&error);
-}
-
-static void
-test_write_vpn (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMSettingVpn *s_vpn;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write VPN",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_VPN_SETTING_NAME,
-	              NULL);
-
-	/* VPN setting */
-	s_vpn = (NMSettingVpn *) nm_setting_vpn_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_vpn));
-
-	g_object_set (s_vpn,
-	              NM_SETTING_VPN_SERVICE_TYPE, "awesomevpn",
-	              NM_SETTING_VPN_USER_NAME, "Bill Smith",
-	              NULL);
-
-	nm_setting_vpn_add_data_item (s_vpn, "server", "vpn.somewhere.com");
-	nm_setting_vpn_add_secret (s_vpn, "password", "sup3rs3cr3t");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_fail (connection,
-	                             TEST_SCRATCH_DIR,
-	                             NULL);
-
-	g_object_unref (connection);
-	g_clear_error (&error);
-}
-
-static void
-test_write_mobile_broadband (gconstpointer data)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMSettingGsm *s_gsm;
-	NMSettingCdma *s_cdma;
-	NMSettingPpp *s_ppp;
-	NMSettingSerial *s_serial;
-	GError *error = NULL;
-	gboolean gsm = GPOINTER_TO_UINT (data);
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, gsm ? "Test Write GSM" : "Test Write CDMA",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, gsm ? NM_SETTING_GSM_SETTING_NAME : NM_SETTING_CDMA_SETTING_NAME,
-	              NULL);
-
-	if (gsm) {
-		/* GSM setting */
-		s_gsm = (NMSettingGsm *) nm_setting_gsm_new ();
-		nm_connection_add_setting (connection, NM_SETTING (s_gsm));
-	} else {
-		/* CDMA setting */
-		s_cdma = (NMSettingCdma *) nm_setting_cdma_new ();
-		nm_connection_add_setting (connection, NM_SETTING (s_cdma));
-
-		g_object_set (s_cdma, NM_SETTING_CDMA_NUMBER, "#777", NULL);
-	}
-
-	/* Serial setting */
-	s_serial = (NMSettingSerial *) nm_setting_serial_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_serial));
-
-	g_object_set (s_serial,
-	              NM_SETTING_SERIAL_BAUD, 115200,
-	              NM_SETTING_SERIAL_BITS, 8,
-	              NM_SETTING_SERIAL_PARITY, NM_SETTING_SERIAL_PARITY_NONE,
-	              NM_SETTING_SERIAL_STOPBITS, 1,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* PPP setting */
-	s_ppp = (NMSettingPpp *) nm_setting_ppp_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ppp));
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection_fail (connection,
-	                             TEST_SCRATCH_DIR,
-	                             NULL);
-
-	g_object_unref (connection);
-	g_clear_error (&error);
-}
-
-static void
-test_read_bridge_main (void)
-{
-	NMConnection *connection;
-	NMSettingBridge *s_bridge;
-	NMSettingWired *s_wired;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x16, 0x41, 0x11, 0x22, 0x33 };
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-main",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "br0");
-
-	/* ===== Bridging SETTING ===== */
-
-	s_bridge = nm_connection_get_setting_bridge (connection);
-	g_assert (s_bridge);
-	g_assert_cmpuint (nm_setting_bridge_get_forward_delay (s_bridge), ==, 2);
-	g_assert (nm_setting_bridge_get_stp (s_bridge));
-	g_assert_cmpuint (nm_setting_bridge_get_priority (s_bridge), ==, 32744);
-	g_assert_cmpuint (nm_setting_bridge_get_hello_time (s_bridge), ==, 7);
-	g_assert_cmpuint (nm_setting_bridge_get_max_age (s_bridge), ==, 39);
-	g_assert_cmpuint (nm_setting_bridge_get_ageing_time (s_bridge), ==, 235352);
-	g_assert_cmpuint (nm_setting_bridge_get_group_forward_mask (s_bridge), ==, 24);
-	g_assert (!nm_setting_bridge_get_multicast_snooping (s_bridge));
-	g_assert_cmpint (nm_setting_bridge_get_vlan_filtering (s_bridge), ==, TRUE);
-	g_assert_cmpint (nm_setting_bridge_get_vlan_default_pvid (s_bridge), ==, 99);
-
-	/* MAC address */
-	s_wired = nm_connection_get_setting_wired (connection);
-	g_assert (s_wired);
-	mac = nm_setting_wired_get_cloned_mac_address (s_wired);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_bridge_main (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingBridge *s_bridge;
-	NMSettingIPConfig *s_ip4, *s_ip6;
-	NMSettingWired *s_wired;
-	NMIPAddress *addr;
-	static const char *mac = "31:33:33:37:be:cd";
-	GError *error = NULL;
-	gs_unref_ptrarray GPtrArray *vlans = NULL;
-	NMBridgeVlan *vlan;
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Main",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "br0",
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
-	              NULL);
-
-	/* bridge setting */
-	s_bridge = (NMSettingBridge *) nm_setting_bridge_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_bridge));
-
-	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
-	vlan = nm_bridge_vlan_new (10, 16);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (22, 22);
-	nm_bridge_vlan_set_pvid (vlan, TRUE);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (44, 0);
-	g_ptr_array_add (vlans, vlan);
-
-	g_object_set (s_bridge,
-	              NM_SETTING_BRIDGE_MAC_ADDRESS, mac,
-	              NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, 19008,
-	              NM_SETTING_BRIDGE_VLAN_FILTERING, TRUE,
-	              NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, 4000,
-	              NM_SETTING_BRIDGE_VLANS, vlans,
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	nmtst_assert_connection_verifies_without_normalization (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_BRIDGE, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_bridge_component (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingBridgePort *s_port;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-component",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "br0");
-	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BRIDGE_SETTING_NAME);
-
-	s_port = nm_connection_get_setting_bridge_port (connection);
-	g_assert (s_port);
-	g_assert (nm_setting_bridge_port_get_hairpin_mode (s_port));
-	g_assert_cmpuint (nm_setting_bridge_port_get_priority (s_port), ==, 28);
-	g_assert_cmpuint (nm_setting_bridge_port_get_path_cost (s_port), ==, 100);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_bridge_component (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSetting *s_port;
-	static const char *mac = "31:33:33:37:be:cd";
-	guint32 mtu = 1492;
-	gs_unref_ptrarray GPtrArray *vlans = NULL;
-	NMBridgeVlan *vlan;
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Component",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NM_SETTING_CONNECTION_MASTER, "br0",
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
-	              NM_SETTING_WIRED_MTU, mtu,
-	              NULL);
-
-	/* Bridge port */
-	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
-	vlan = nm_bridge_vlan_new (1, 0);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (4, 4094);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (2, 2);
-	nm_bridge_vlan_set_pvid (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-
-	s_port = nm_setting_bridge_port_new ();
-	nm_connection_add_setting (connection, s_port);
-	g_object_set (s_port,
-	              NM_SETTING_BRIDGE_PORT_PRIORITY, 50,
-	              NM_SETTING_BRIDGE_PORT_PATH_COST, 33,
-	              NM_SETTING_BRIDGE_PORT_VLANS, vlans,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Bridge_Component.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_bridge_missing_stp (void)
-{
-	NMConnection *connection;
-	NMSettingBridge *s_bridge;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bridge-missing-stp",
-	                                    NULL, TYPE_BRIDGE, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "br0");
-
-	/* ===== Bridging SETTING ===== */
-
-	s_bridge = nm_connection_get_setting_bridge (connection);
-	g_assert (s_bridge);
-	g_assert (nm_setting_bridge_get_stp (s_bridge) == FALSE);
-
-	g_object_unref (connection);
-}
-
-#define TEST_IFCFG_VLAN_INTERFACE TEST_IFCFG_DIR"/ifcfg-test-vlan-interface"
-
-static void
-test_read_vlan_interface (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-	guint32 from = 0, to = 0;
-
-	connection = _connection_from_file (TEST_IFCFG_VLAN_INTERFACE,
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan43");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 43);
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==,
-	                 NM_VLAN_FLAG_GVRP | NM_VLAN_FLAG_LOOSE_BINDING | NM_VLAN_FLAG_REORDER_HEADERS);
-
-	/* Ingress map */
-	g_assert_cmpint (nm_setting_vlan_get_num_priorities (s_vlan, NM_VLAN_INGRESS_MAP), ==, 2);
-
-	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_INGRESS_MAP, 0, &from, &to));
-	g_assert_cmpint (from, ==, 0);
-	g_assert_cmpint (to, ==, 1);
-
-	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_INGRESS_MAP, 1, &from, &to));
-	g_assert_cmpint (from, ==, 2);
-	g_assert_cmpint (to, ==, 5);
-
-	/* Egress map */
-	g_assert_cmpint (nm_setting_vlan_get_num_priorities (s_vlan, NM_VLAN_EGRESS_MAP), ==, 3);
-
-	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_EGRESS_MAP, 0, &from, &to));
-	g_assert_cmpint (from, ==, 3);
-	g_assert_cmpint (to, ==, 1);
-
-	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_EGRESS_MAP, 1, &from, &to));
-	g_assert_cmpint (from, ==, 12);
-	g_assert_cmpint (to, ==, 3);
-
-	g_assert (nm_setting_vlan_get_priority (s_vlan, NM_VLAN_EGRESS_MAP, 2, &from, &to));
-	g_assert_cmpint (from, ==, 14);
-	g_assert_cmpint (to, ==, 7);
-
-	g_object_unref (connection);
-}
-
-#define TEST_IFCFG_VLAN_ONLY_VLANID TEST_IFCFG_DIR"/ifcfg-test-vlan-only-vlanid"
-
-static void
-test_read_vlan_only_vlan_id (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	connection = _connection_from_file (TEST_IFCFG_VLAN_ONLY_VLANID, NULL, TYPE_ETHERNET, NULL);
-
-	g_assert (nm_connection_get_interface_name (connection) == NULL);
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 43);
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_REORDER_HEADERS);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_vlan_only_device (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-only-device",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "eth0.9");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 9);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_vlan_physdev (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-physdev",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan0.3");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 3);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_vlan_reorder_hdr_1 (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	NMTST_EXPECT_NM_WARN ("*REORDER_HDR key is deprecated, use VLAN_FLAGS*");
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-reorder-hdr-1",
-	                                        NULL, TYPE_ETHERNET, NULL);
-	g_test_assert_expected_messages ();
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan0.3");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 3);
-	/* Check that REORDER_HDR=0 is ignored */
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_REORDER_HEADERS);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_vlan_reorder_hdr_2 (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-reorder-hdr-2",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan0.3");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth0");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 3);
-	/* Check that VLAN_FLAGS=NO_REORDER_HDR works */
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_LOOSE_BINDING);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_vlan_flags_1 (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-flags-1",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "super-vlan");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 44);
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==,
-	                                            NM_VLAN_FLAG_LOOSE_BINDING |
-	                                            NM_VLAN_FLAG_REORDER_HEADERS);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_vlan_flags_2 (void)
-{
-	NMConnection *connection;
-	NMSettingVlan *s_vlan;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-flags-2",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "super-vlan");
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "eth9");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 44);
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==,
-	                                            NM_VLAN_FLAG_GVRP |
-	                                            NM_VLAN_FLAG_LOOSE_BINDING |
-	                                            NM_VLAN_FLAG_REORDER_HEADERS);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_vlan (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_VLAN_INTERFACE,
-	                                    NULL, TYPE_VLAN, NULL);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Vlan_test-vlan-interface.cexpected",
-	                        &testfile);
-}
-
-static void
-test_write_vlan_flags (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-vlan-flags-2",
-	                                    NULL, TYPE_VLAN, NULL);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_vlan_only_vlanid (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-
-	connection = _connection_from_file (TEST_IFCFG_VLAN_ONLY_VLANID,
-	                                    NULL, TYPE_VLAN, NULL);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_vlan_reorder_hdr (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingVlan *s_vlan;
-	NMSettingWired *s_wired;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write VLAN reorder_hdr",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_VLAN_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* VLAN setting */
-	s_vlan = (NMSettingVlan *) nm_setting_vlan_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_vlan));
-
-	g_object_set (s_vlan,
-	              NM_SETTING_VLAN_PARENT, "eth0",
-	              NM_SETTING_VLAN_ID, 444,
-	              NM_SETTING_VLAN_FLAGS, 1,
-	              NULL);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_VLAN_reorder_hdr.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_ethernet_missing_ipv6 (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-
-	connection = nm_simple_connection_new ();
-	g_assert (connection);
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Ethernet Without IPv6 Setting",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, "random-client-id-00:22:33",
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, TRUE,
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, TRUE,
-	              NULL);
-
-	/* IP6 setting */
-	/*
-	 * We intentionally don't add IPv6 setting here. ifcfg-rh plugin should regard
-	 * missing IPv6 as IPv6 with NM_SETTING_IP6_CONFIG_METHOD_AUTO method.
-	 */
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_ibft_ignored (void)
-{
-	gs_free_error GError *error = NULL;
-
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-ibft",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-}
-
-static void
-test_read_bond_main (void)
-{
-	NMConnection *connection;
-	NMSettingBond *s_bond;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-main",
-	                                    NULL, TYPE_ETHERNET,NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "bond0");
-
-	/* ===== Bonding SETTING ===== */
-
-	s_bond = nm_connection_get_setting_bond (connection);
-	g_assert (s_bond);
-
-	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MIIMON), ==, "100");
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_bond_eth_type (void)
-{
-	NMConnection *connection;
-	NMSettingBond *s_bond;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-eth-type",
-	                                    NULL, TYPE_ETHERNET,NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "bond0");
-
-	/* ===== Bonding SETTING ===== */
-
-	s_bond = nm_connection_get_setting_bond (connection);
-	g_assert (s_bond);
-
-	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MIIMON), ==, "213");
-	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE), ==, "1");
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_bond_main (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingBond *s_bond;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMSettingWired *s_wired;
-	NMIPAddress *addr;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Bond Main",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "bond0",
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BOND_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* bond setting */
-	s_bond = (NMSettingBond *) nm_setting_bond_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_bond));
-
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, "5");
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, "10");
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, "100");
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	nmtst_assert_connection_verifies_without_normalization (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Bond_Main.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_BOND, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_bond_slave (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-slave",
-	                                    NULL, TYPE_ETHERNET, NULL);
-	g_test_assert_expected_messages ();
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "bond0");
-
-	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BOND_SETTING_NAME);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_bond_slave (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	static const char *mac = "31:33:33:37:be:cd";
-	guint32 mtu = 1492;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Bond Slave",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NM_SETTING_CONNECTION_MASTER, "bond0",
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	g_object_set (s_wired,
-	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
-	              NM_SETTING_WIRED_MTU, mtu,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_infiniband (void)
-{
-	NMConnection *connection;
-	NMSettingInfiniband *s_infiniband;
-	char *unmanaged = NULL;
-	const char *mac;
-	char expected_mac_address[INFINIBAND_ALEN] = { 0x80, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22 };
-	const char *transport_mode;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-infiniband",
-	                                    NULL, TYPE_INFINIBAND, &unmanaged);
-	g_assert (!unmanaged);
-
-	/* ===== INFINIBAND SETTING ===== */
-
-	s_infiniband = nm_connection_get_setting_infiniband (connection);
-	g_assert (s_infiniband);
-
-	/* MAC address */
-	mac = nm_setting_infiniband_get_mac_address (s_infiniband);
-	g_assert (mac);
-	g_assert (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, sizeof (expected_mac_address)));
-
-	/* Transport mode */
-	transport_mode = nm_setting_infiniband_get_transport_mode (s_infiniband);
-	g_assert (transport_mode);
-	g_assert_cmpstr (transport_mode, ==, "connected");
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_infiniband (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingInfiniband *s_infiniband;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	const char *mac = "80:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22";
-	guint32 mtu = 65520;
-	NMIPAddress *addr;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write InfiniBand",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_INFINIBAND_SETTING_NAME,
-	              NULL);
-
-	/* InfiniBand setting */
-	s_infiniband = (NMSettingInfiniband *) nm_setting_infiniband_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_infiniband));
-
-	g_object_set (s_infiniband,
-	              NM_SETTING_INFINIBAND_MAC_ADDRESS, mac,
-	              NM_SETTING_INFINIBAND_MTU, mtu,
-	              NM_SETTING_INFINIBAND_TRANSPORT_MODE, "connected",
-	              NULL);
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_INFINIBAND, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_bond_slave_ib (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-slave-ib",
-	                                    NULL, NULL, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "bond0");
-	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BOND_SETTING_NAME);
-}
-
-static void
-test_write_bond_slave_ib (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingInfiniband *s_infiniband;
-	static const char *mac = "80:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22";
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Bond Slave InfiniBand",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_INFINIBAND_SETTING_NAME,
-	              NM_SETTING_CONNECTION_MASTER, "bond0",
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
-	              NULL);
-
-	/* InfiniBand setting */
-	s_infiniband = (NMSettingInfiniband *) nm_setting_infiniband_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_infiniband));
-
-	g_object_set (s_infiniband,
-	              NM_SETTING_INFINIBAND_MAC_ADDRESS, mac,
-	              NM_SETTING_INFINIBAND_MTU, 2044,
-	              NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram",
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, NULL, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_bond_opts_mode_numeric (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingBond *s_bond;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-bond-mode-numeric",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "bond0");
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_BOND_SETTING_NAME);
-
-	s_bond = nm_connection_get_setting_bond (connection);
-	g_assert (s_bond);
-	g_assert_cmpstr (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MODE), ==, "802.3ad");
-
-	g_object_unref (connection);
-}
-
-#define DCB_ALL_FLAGS (NM_SETTING_DCB_FLAG_ENABLE | \
-                       NM_SETTING_DCB_FLAG_ADVERTISE | \
-                       NM_SETTING_DCB_FLAG_WILLING)
-
-static void
-test_read_dcb_basic (void)
-{
-	NMConnection *connection;
-	NMSettingDcb *s_dcb;
-	guint i;
-	guint expected_group_ids[8] = { 0, 0, 0, 0, 1, 1, 1, 0xF };
-	guint expected_group_bandwidths[8] = { 25, 0, 0, 75, 0, 0, 0, 0 };
-	guint expected_bandwidths[8] = { 5, 10, 30, 25, 10, 50, 5, 0 };
-	gboolean expected_strict[8] = { FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE };
-	guint expected_traffic_classes[8] = { 7, 6, 5, 4, 3, 2, 1, 0 };
-	gboolean expected_pfcs[8] = { TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE };
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-dcb",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_dcb = nm_connection_get_setting_dcb (connection);
-	g_assert (s_dcb);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_flags (s_dcb), ==, DCB_ALL_FLAGS);
-	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_priority (s_dcb), ==, 7);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_iscsi_flags (s_dcb), ==, DCB_ALL_FLAGS);
-		g_assert_cmpint (nm_setting_dcb_get_app_iscsi_priority (s_dcb), ==, 6);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_fip_flags (s_dcb), ==, DCB_ALL_FLAGS);
-	g_assert_cmpint (nm_setting_dcb_get_app_fip_priority (s_dcb), ==, 2);
-
-	g_assert_cmpint (nm_setting_dcb_get_priority_flow_control_flags (s_dcb), ==, (NM_SETTING_DCB_FLAG_ENABLE | NM_SETTING_DCB_FLAG_ADVERTISE));
-	for (i = 0; i < 8; i++)
-		g_assert_cmpint (nm_setting_dcb_get_priority_flow_control (s_dcb, i), ==, expected_pfcs[i]);
-
-	g_assert_cmpint (nm_setting_dcb_get_priority_group_flags (s_dcb), ==, DCB_ALL_FLAGS);
-
-	/* Group IDs */
-	for (i = 0; i < 8; i++)
-		g_assert_cmpint (nm_setting_dcb_get_priority_group_id (s_dcb, i), ==, expected_group_ids[i]);
-
-	/* Group bandwidth */
-	for (i = 0; i < 8; i++)
-		g_assert_cmpint (nm_setting_dcb_get_priority_group_bandwidth (s_dcb, i), ==, expected_group_bandwidths[i]);
-
-	/* User priority bandwidth */
-	for (i = 0; i < 8; i++)
-		g_assert_cmpint (nm_setting_dcb_get_priority_bandwidth (s_dcb, i), ==, expected_bandwidths[i]);
-
-	/* Strict bandwidth */
-	for (i = 0; i < 8; i++)
-		g_assert_cmpint (nm_setting_dcb_get_priority_strict_bandwidth (s_dcb, i), ==, expected_strict[i]);
-
-	/* Traffic class */
-	for (i = 0; i < 8; i++)
-		g_assert_cmpint (nm_setting_dcb_get_priority_traffic_class (s_dcb, i), ==, expected_traffic_classes[i]);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_dcb_basic (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingDcb *s_dcb;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	guint i;
-	const guint group_ids[8] = { 4, 0xF, 6, 0xF, 1, 7, 3, 0xF };
-	const guint group_bandwidths[8] = { 10, 20, 15, 10, 2, 3, 35, 5 };
-	const guint bandwidths[8] = { 10, 20, 30, 40, 50, 10, 0, 25 };
-	const gboolean strict[8] = { TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE };
-	const guint traffic_classes[8] = { 3, 4, 7, 2, 1, 0, 5, 6 };
-	const gboolean pfcs[8] = { TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE };
-
-	connection = nm_simple_connection_new ();
-
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-	g_object_set (G_OBJECT (s_con),
-	              NM_SETTING_CONNECTION_ID, "dcb-test",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP stuff */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	g_object_set (G_OBJECT (s_ip4), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	g_object_set (G_OBJECT (s_ip6), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO, NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	/* DCB */
-	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_dcb));
-
-	g_object_set (G_OBJECT (s_dcb),
-	              NM_SETTING_DCB_APP_FCOE_FLAGS, DCB_ALL_FLAGS,
-	              NM_SETTING_DCB_APP_FCOE_PRIORITY, 5,
-	              NM_SETTING_DCB_APP_ISCSI_FLAGS, DCB_ALL_FLAGS,
-	              NM_SETTING_DCB_APP_ISCSI_PRIORITY, 1,
-	              NM_SETTING_DCB_APP_FIP_FLAGS, DCB_ALL_FLAGS,
-	              NM_SETTING_DCB_APP_FIP_PRIORITY, 3,
-	              NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS, DCB_ALL_FLAGS,
-	              NM_SETTING_DCB_PRIORITY_GROUP_FLAGS, DCB_ALL_FLAGS,
-	              NULL);
-
-	for (i = 0; i < 8; i++) {
-		nm_setting_dcb_set_priority_flow_control (s_dcb, i, pfcs[i]);
-		nm_setting_dcb_set_priority_group_id (s_dcb, i, group_ids[i]);
-		nm_setting_dcb_set_priority_group_bandwidth (s_dcb, i, group_bandwidths[i]);
-		nm_setting_dcb_set_priority_bandwidth (s_dcb, i, bandwidths[i]);
-		nm_setting_dcb_set_priority_strict_bandwidth (s_dcb, i, strict[i]);
-		nm_setting_dcb_set_priority_traffic_class (s_dcb, i, traffic_classes[i]);
-	}
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"//ifcfg-dcb-test.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_dcb_default_app_priorities (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingDcb *s_dcb;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-dcb-default-app-priorities",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_dcb = nm_connection_get_setting_dcb (connection);
-	g_assert (s_dcb);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
-	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_priority (s_dcb), ==, -1);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_iscsi_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
-	g_assert_cmpint (nm_setting_dcb_get_app_iscsi_priority (s_dcb), ==, -1);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_fip_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
-	g_assert_cmpint (nm_setting_dcb_get_app_fip_priority (s_dcb), ==, -1);
-}
-
-static void
-test_read_dcb_bad_booleans (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_STRICT value*not all 0s and 1s*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-bad-booleans",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "invalid boolean digit"));
-}
-
-static void
-test_read_dcb_short_booleans (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*DCB_PG_STRICT value*8 characters*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-short-booleans",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "boolean array must be 8 characters"));
-}
-
-static void
-test_read_dcb_bad_uints (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_UP2TC value*not 0 - 7*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-bad-uints",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "invalid uint digit"));
-}
-
-static void
-test_read_dcb_short_uints (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*DCB_PG_UP2TC value*8 characters*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-short-uints",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "uint array must be 8 characters"));
-}
-
-static void
-test_read_dcb_bad_percent (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_PCT percentage value*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-bad-percent",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "invalid percent element"));
-}
-
-static void
-test_read_dcb_short_percent (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*invalid DCB_PG_PCT percentage list value*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-short-percent",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "percent array must be 8 elements"));
-}
-
-static void
-test_read_dcb_pgpct_not_100 (void)
-{
-	gs_free_error GError *error = NULL;
-
-	NMTST_EXPECT_NM_WARN ("*DCB_PG_PCT percentages do not equal 100*");
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-dcb-pgpct-not-100",
-	                            NULL, TYPE_ETHERNET, &error);
-	g_test_assert_expected_messages ();
-
-	g_assert_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION);
-	g_assert (strstr (error->message, "invalid percentage sum"));
-}
-
-static void
-test_read_fcoe_mode (gconstpointer user_data)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	gs_free char *file = NULL;
-	const char *expected_mode = user_data;
-	NMSettingDcb *s_dcb;
-
-	file = g_strdup_printf (TEST_IFCFG_DIR"/ifcfg-test-fcoe-%s", expected_mode);
-	connection = _connection_from_file (file, NULL, TYPE_ETHERNET, NULL);
-
-	s_dcb = nm_connection_get_setting_dcb (connection);
-	g_assert (s_dcb);
-
-	g_assert_cmpint (nm_setting_dcb_get_app_fcoe_flags (s_dcb), ==, NM_SETTING_DCB_FLAG_ENABLE);
-	g_assert_cmpstr (nm_setting_dcb_get_app_fcoe_mode (s_dcb), ==, expected_mode);
-}
-
-static void
-test_write_fcoe_mode (gconstpointer user_data)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	const char *expected_mode = user_data;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingDcb *s_dcb;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	shvarFile *ifcfg;
-
-	connection = nm_simple_connection_new ();
-
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-	g_object_set (G_OBJECT (s_con),
-	              NM_SETTING_CONNECTION_ID, "fcoe-test",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP stuff */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	g_object_set (G_OBJECT (s_ip4), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	g_object_set (G_OBJECT (s_ip6), NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO, NULL);
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	/* DCB */
-	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_dcb));
-
-	g_object_set (G_OBJECT (s_dcb),
-	              NM_SETTING_DCB_APP_FCOE_FLAGS, NM_SETTING_DCB_FLAG_ENABLE,
-	              NM_SETTING_DCB_APP_FCOE_MODE, expected_mode,
-	              NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	ifcfg = _svOpenFile (testfile);
-	_svGetValue_check (ifcfg, "DCB_APP_FCOE_MODE", expected_mode);
-	svCloseFile (ifcfg);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_team_master (gconstpointer user_data)
-{
-	const char *const PATH_NAME = user_data;
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingTeam *s_team;
-	const char *expected_config = "{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}";
-
-	connection = _connection_from_file (PATH_NAME, NULL, TYPE_ETHERNET, NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "team0");
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_TEAM_SETTING_NAME);
-
-	s_team = nm_connection_get_setting_team (connection);
-	g_assert (s_team);
-	g_assert_cmpstr (nm_setting_team_get_config (s_team), ==, expected_config);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_team_master_invalid (gconstpointer user_data)
-{
-	const char *const PATH_NAME = user_data;
-	gs_free_error GError *error = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-
-	if (WITH_JSON_VALIDATION) {
-		_connection_from_file_fail (PATH_NAME, NULL, TYPE_ETHERNET, &error);
-
-		g_assert_error (error, NM_CONNECTION_ERROR, NM_CONNECTION_ERROR_INVALID_PROPERTY);
-		g_assert (strstr (error->message, _("invalid json")));
-	} else
-		connection = _connection_from_file (PATH_NAME, NULL, TYPE_ETHERNET, NULL);
-}
-
-static void
-test_write_team_master (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingTeam *s_team;
-	NMSettingWired *s_wired;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	const char *expected_config = "{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}";
-	shvarFile *f;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Team Master",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "team0",
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_TEAM_SETTING_NAME,
-	              NULL);
-
-	/* Team setting */
-	s_team = (NMSettingTeam *) nm_setting_team_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_team));
-
-	g_object_set (s_team,
-	              NM_SETTING_TEAM_CONFIG, expected_config,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	nmtst_assert_connection_verifies_without_normalization (connection);
-
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "DEVICETYPE", "Team");
-	_svGetValue_check (f, "TEAM_CONFIG", expected_config);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_team_port (gconstpointer user_data)
-{
-	const char *const PATH_NAME = user_data;
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingTeamPort *s_team_port;
-	const char *expected_config = "{\"p4p1\": {\"prio\": -10, \"sticky\": true}}";
-
-	connection = _connection_from_file (PATH_NAME, NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "team0");
-
-	s_team_port = nm_connection_get_setting_team_port (connection);
-	g_assert (s_team_port);
-	g_assert_cmpstr (nm_setting_team_port_get_config (s_team_port), ==, expected_config);
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_team_port (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingTeamPort *s_team_port;
-	NMSettingWired *s_wired;
-	const char *expected_config = "{\"p4p1\": {\"prio\": -10, \"sticky\": true}}";
-	shvarFile *f;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Team Port",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NM_SETTING_CONNECTION_MASTER, "team0",
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
-	              NULL);
-
-	/* Team setting */
-	s_team_port = (NMSettingTeamPort *) nm_setting_team_port_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_team_port));
-	g_object_set (s_team_port, NM_SETTING_TEAM_PORT_CONFIG, expected_config, NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Team_Port.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "TYPE", NULL);
-	_svGetValue_check (f, "DEVICETYPE", "TeamPort");
-	_svGetValue_check (f, "TEAM_PORT_CONFIG", expected_config);
-	_svGetValue_check (f, "TEAM_MASTER", "team0");
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET,
-	                                NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_write_team_infiniband_port (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingTeamPort *s_team_port;
-	NMSettingInfiniband *s_inf;
-	const char *expected_config = "{\"inf1\": {\"prio\": -10, \"sticky\": true}}";
-	shvarFile *f;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Team Infiniband Port",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_INFINIBAND_SETTING_NAME,
-	              NM_SETTING_CONNECTION_MASTER, "team0",
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "inf1",
-	              NULL);
-
-	/* Team setting */
-	s_team_port = (NMSettingTeamPort *) nm_setting_team_port_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_team_port));
-	g_object_set (s_team_port, NM_SETTING_TEAM_PORT_CONFIG, expected_config, NULL);
-
-	/* Infiniband setting */
-	s_inf = (NMSettingInfiniband *) nm_setting_infiniband_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_inf));
-	g_object_set (s_inf, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram", NULL);
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Team_Infiniband_Port.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "TYPE", "InfiniBand");
-	_svGetValue_check (f, "DEVICETYPE", "TeamPort");
-	_svGetValue_check (f, "TEAM_PORT_CONFIG", expected_config);
-	_svGetValue_check (f, "TEAM_MASTER", "team0");
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET,
-	                                NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-test_read_team_port_empty_config (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-team-port-empty-config",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_assert (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
-	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "team0");
-
-	/* Normalization adds a team-port setting */
-	g_assert (nm_connection_get_setting_team_port (connection));
-
-	/* empty/missing config */
-	g_assert (!nm_setting_team_port_get_config (nm_connection_get_setting_team_port (connection)));
-
-	g_object_unref (connection);
-}
-
-static void
-test_team_reread_slave (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection_1 = NULL;
-	gs_unref_object NMConnection *connection_2 = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	gboolean reread_same = FALSE;
-	NMSettingConnection *s_con;
-
-	connection_1 = nmtst_create_connection_from_keyfile (
-	        "[connection]\n"
-	        "id=team-slave-enp31s0f1-142\n"
-	        "uuid=74f435bb-ede4-415a-9d48-f580b60eba04\n"
-	        "type=vlan\n"
-	        "autoconnect=false\n"
-	        "interface-name=enp31s0f1-142\n"
-	        "master=team142\n"
-	        "permissions=\n"
-	        "slave-type=team\n"
-	        "\n"
-	        "[vlan]\n"
-	        "egress-priority-map=\n"
-	        "flags=1\n"
-	        "id=142\n"
-	        "ingress-priority-map=\n"
-	        "parent=enp31s0f1\n"
-	        , "/test_team_reread_slave");
-
-	/* to double-check keyfile syntax, re-create the connection by hand. */
-	connection_2 = nmtst_create_minimal_connection ("team-slave-enp31s0f1-142", "74f435bb-ede4-415a-9d48-f580b60eba04", NM_SETTING_VLAN_SETTING_NAME, &s_con);
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "enp31s0f1-142",
-	              NM_SETTING_CONNECTION_MASTER, "team142",
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, "team",
-	              NULL);
-	g_object_set (nm_connection_get_setting_vlan (connection_2),
-	              NM_SETTING_VLAN_FLAGS, 1,
-	              NM_SETTING_VLAN_ID, 142,
-	              NM_SETTING_VLAN_PARENT, "enp31s0f1",
-	              NULL);
-	nm_connection_add_setting (connection_2, nm_setting_team_port_new ());
-	nmtst_connection_normalize (connection_2);
-
-	nmtst_assert_connection_equals (connection_1, FALSE, connection_2, FALSE);
-
-	_writer_new_connection_reread ((nmtst_get_rand_uint32 () % 2) ? connection_1 : connection_2,
-	                               TEST_SCRATCH_DIR,
-	                               &testfile,
-	                               TEST_IFCFG_DIR"/ifcfg-team-slave-enp31s0f1-142.cexpected",
-	                               &reread,
-	                               &reread_same);
-	_assert_reread_same ((nmtst_get_rand_uint32 () % 2) ? connection_1 : connection_2, reread);
-	g_assert (reread_same);
-	g_clear_object (&reread);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_VLAN,
-	                                NULL);
-	nmtst_assert_connection_equals ((nmtst_get_rand_uint32 () % 2) ? connection_1 : connection_2, FALSE,
-	                                reread, FALSE);
-}
-
-static void
-test_read_proxy_basic (void)
-{
-	NMConnection *connection;
-	NMSettingProxy *s_proxy;
-
-	/* Test basic proxy configuration */
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-read-proxy-basic",
-	                                    NULL, TYPE_ETHERNET, NULL);
-
-	/* ===== Proxy setting ===== */
-	s_proxy = nm_connection_get_setting_proxy (connection);
-	g_assert (s_proxy);
-
-	/* Proxy method */
-	g_assert_cmpint (nm_setting_proxy_get_method (s_proxy), ==, NM_SETTING_PROXY_METHOD_AUTO);
-	g_assert (nm_setting_proxy_get_browser_only (s_proxy));
-	g_assert_cmpstr (nm_setting_proxy_get_pac_url (s_proxy), ==, "http://wpad.mycompany.com/wpad.dat");
-
-	g_object_unref (connection);
-}
-
-static void
-test_write_proxy_basic (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingProxy *s_proxy;
-	const char *expected_url = "https://wpad.neverland.org/wpad.dat";
-	shvarFile *f;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write Proxy Basic",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Proxy setting */
-	s_proxy = (NMSettingProxy *) nm_setting_proxy_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_proxy));
-	g_object_set (s_proxy, NM_SETTING_PROXY_METHOD, NM_SETTING_PROXY_METHOD_AUTO, NULL);
-	g_object_set (s_proxy, NM_SETTING_PROXY_PAC_URL, expected_url, NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	nmtst_assert_connection_verifies (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-Test_Write_Proxy_Basic.cexpected",
-	                        &testfile);
-
-	f = _svOpenFile (testfile);
-	_svGetValue_check (f, "TYPE", "Ethernet");
-	_svGetValue_check (f, "PROXY_METHOD", "auto");
-	_svGetValue_check (f, "PAC_URL", expected_url);
-	svCloseFile (f);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET,
-	                                NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-/*****************************************************************************/
-
-static const char *
-_svUnescape (const char *str, char **to_free)
-{
-	const char *s;
-	gs_free char *str_free = NULL;
-
-	g_assert (str);
-	g_assert (to_free);
-
-	if (str[0] == '\0') {
-		/* avoid static string "" */
-		str = (str_free = g_strdup (str));
-	}
-
-	s = svUnescape (str, to_free);
-	if (*to_free) {
-		g_assert (s == *to_free);
-		g_assert (s[0]);
-	} else {
-		g_assert (   s == NULL
-		          || (!s[0] && (s <  str || s >  strchr (str, '\0')))
-		          || ( s[0] &&  s >= str && s <= strchr (str, '\0') ));
-	}
-	return s;
-}
-
-typedef struct {
-	const char *val;
-	const char *exp;
-	bool can_concat:1;
-	bool needs_ascii_separator:1;
-} UnescapeTestData;
-
-static void
-do_svUnescape_assert (const char *str, const char *expected)
-{
-	gs_free char *to_free = NULL;
-	const char *s;
-
-	s = _svUnescape (str, &to_free);
-	g_assert_cmpstr (s, ==, expected);
-
-	/* check we can make a round-trip */
-	if (expected) {
-		gs_free char *s1_free = NULL;
-		gs_free char *s2_free = NULL;
-		const char *s1, *s2;
-
-		s1 = svEscape (expected, &s1_free);
-		g_assert (s1);
-
-		s2 = _svUnescape (s1, &s2_free);
-		g_assert (s2);
-
-		g_assert_cmpstr (s2, ==, expected);
-	}
-}
-
-static void
-do_svUnescape_combine_ansi_append (GString *str_val, GString *str_exp, const UnescapeTestData *data, gboolean honor_needs_ascii_separator)
-{
-	g_string_append (str_val, data->val);
-	g_string_append (str_exp, data->exp);
-	if (honor_needs_ascii_separator && data->needs_ascii_separator) {
-		/* the string has an open escape sequence. We must ensure that when
-		 * combining it with another sequence, that they don't merge into
-		 * something diffent. for example "\xa" + "a" must not result in
-		 * "\xaa". Instead, we add a space in between to get "\xa a". */
-		g_string_append (str_val, " ");
-		g_string_append (str_exp, " ");
-	}
-}
-
-static void
-do_svUnescape_combine_ansi (GString *str_val, GString *str_exp, const UnescapeTestData *data_ansi, gsize data_len, gssize idx)
-{
-	gsize i, j;
-
-	g_string_set_size (str_val, 0);
-	g_string_set_size (str_exp, 0);
-	g_string_append (str_val, "$'");
-	if (idx < 0) {
-		for (i = -idx; i > 0; i--) {
-			j = nmtst_get_rand_uint32 () % data_len;
-			if (!data_ansi[j].can_concat) {
-				i++;
-				continue;
-			}
-			do_svUnescape_combine_ansi_append (str_val, str_exp, &data_ansi[j], i > 1);
-		}
-	} else {
-		g_assert_cmpint (idx, <, data_len);
-		do_svUnescape_combine_ansi_append (str_val, str_exp, &data_ansi[idx], FALSE);
-	}
-	g_string_append (str_val, "'");
-}
-
-static void
-test_svUnescape (void)
-{
-#define V0(v_value, v_expected) { .val = ""v_value"", .exp = v_expected, .can_concat = FALSE, }
-#define V1(v_value, v_expected) { .val = ""v_value"", .exp = v_expected, .can_concat = !!v_expected, }
-#define V2(v_value, v_expected) { .val = ""v_value"", .exp = v_expected, .can_concat = TRUE, .needs_ascii_separator = TRUE, }
-	const UnescapeTestData data_full[] = {
-		V1 ("", ""),
-		V0 ("'", NULL),
-		V1 ("'x'", "x"),
-		V1 ("'  '", "  "),
-		V1 ("'x'", "x"),
-		V0 ("\"", NULL),
-		V0 ("\\", NULL),
-		V0 (" ", ""),
-		V0 ("   ", ""),
-		V0 ("a;   #", "a"),
-		V0 (" ;   #", ""),
-		V0 (";   ", ""),
-		V0 ("; ;", NULL),
-		V0 (" ; a #", NULL),
-		V0 (" ; a;;  #", NULL),
-		V0 ("a; ; #", NULL),
-		V0 ("\t  # ", ""),
-		V0 ("\t  #a", ""),
-		V0 ("\t  #a\r", ""),
-		V0 ("\r", ""),
-		V1 ("\\\"", "\""),
-		V1 ("\\`", "`"),
-		V1 ("\\$", "$"),
-		V1 ("\\\\", "\\"),
-		V1 ("\\a", "a"),
-		V1 ("\\b", "b"),
-		V1 ("\\'", "'"),
-		V1 ("\\~", "~"),
-		V1 ("\\\t", "\t"),
-		V1 ("\"\\\"\"", "\""),
-		V1 ("\"\\`\"", "`"),
-		V1 ("\"\\$\"", "$"),
-		V1 ("\"\\\\\"", "\\"),
-		V1 ("\"\\a\"", "\\a"),
-		V1 ("\"\\b\"", "\\b"),
-		V1 ("\"\\\t\"", "\\\t"),
-		V0 ("ab\r", "ab"),
-		V0 ("a'b'\r ", "ab"),
-		V0 ("a'b' \r", "ab"),
-		V0 ("a#b", "a#b"),
-		V0 ("#b", "#b"),
-		V1 ("\'some string\'", "some string"),
-		V0 ("Bob outside LAN", NULL),
-		V1 ("x", "x"),
-		V1 ("'{ \"device\": \"team0\", \"link_watch\": { \"name\": \"ethtool\" } }'",
-		    "{ \"device\": \"team0\", \"link_watch\": { \"name\": \"ethtool\" } }"),
-		V1 ("'{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}'",
-		    "{\"device\": \"team0\", \"link_watch\": {\"name\": \"ethtool\"}}"),
-		V1 ("x\"\"b", "xb"),
-		V1 ("x\"c\"b", "xcb"),
-		V1 ("\"c\"b", "cb"),
-		V1 ("\"c\"\\'b", "c'b"),
-		V1 ("$''", ""),
-		V1 ("$'\\n'", "\n"),
-		V0 ("$'\\'", NULL),
-		V1 ("$'\\x'", "\\x"),
-		V1 ("$'\\xa'", "\xa"),
-		V0 ("$'\\x0'", ""),
-		V1 ("$'\\x12'", "\x12"),
-		V1 ("$'\\x12A'", "\x12""A"),
-		V1 ("$'\\x12t'", "\x12t"),
-		V1 ("\"aa\\\"\"", "aa\""),
-		V1 ("\"aa\\\"b\"c", "aa\"bc"),
-		V1 ("\"aa\\\"\"b", "aa\"b"),
-
-		/* the following is not shell behavior, but kept for backward compatibility
-		 * with old svEscape(). */
-		V0 ("\"\\'\"", "'"),
-		V0 ("\"\\~\"", "~"),
-		V0 ("\"b\\~b\"", "b~b"),
-		V0 ("\"\\~\\~\"", "~~"),
-		V0 ("\"\\~\\'\"", "~'"),
-
-		/* the following is shell-behavior, because it doesn't look like written
-		 * by old svEscape(). */
-		V1 ("\"\\~~\"", "\\~~"),
-		V1 ("\"\\a\\'\"", "\\a\\'"),
-		V1 ("x\"\\~\"", "x\\~"),
-		V1 ("\"\\'\"''", "\\'"),
-		V0 ("\"b\\~b\" ", "b\\~b"),
-		V1 ("\"b\\~b\"x", "b\\~bx"),
-	};
-	const UnescapeTestData data_ansi[] = {
-		/* strings inside $''. They cannot be compared directly, but must
-		 * be wrapped by do_svUnescape_combine_ansi(). */
-		V1 ("", ""),
-		V1 ("a", "a"),
-		V1 ("b", "b"),
-		V1 ("x", "x"),
-		V1 (" ", " "),
-		V1 ("\\a", "\a"),
-		V1 ("\\b", "\b"),
-		V1 ("\\e", "\e"),
-		V1 ("\\E", "\E"),
-		V1 ("\\f", "\f"),
-		V1 ("\\n", "\n"),
-		V1 ("\\r", "\r"),
-		V1 ("\\t", "\t"),
-		V1 ("\\v", "\v"),
-		V1 ("\\\\", "\\"),
-		V1 ("\\'", "'"),
-		V1 ("\\\"", "\""),
-		V1 ("\\?", "\?"),
-		V1 ("\\?", "?"),
-		V2 ("\\8", "\\8"),
-		V2 ("\\1", "\1"),
-		V1 ("\\1A", "\1A"),
-		V1 ("\\18", "\18"),
-		V2 ("\\01", "\1"),
-		V1 ("\\001", "\1"),
-		V0 ("\\008", ""),
-		V1 ("\\018", "\0018"),
-		V0 ("\\08", ""),
-		V1 ("\\18", "\0018"),
-		V1 ("\\x", "\\x"),
-		V2 ("\\xa", "\xa"),
-		V1 ("\\x12", "\x12"),
-		V1 ("\\x12A", "\x12""A"),
-		V1 ("\\x12a", "\x12""a"),
-		V1 ("\\x12t", "\x12t"),
-		V1 ("\\x1a", "\x1a"),
-		V1 ("\\x1A", "\x1A"),
-		V1 ("\\ut", "\\ut"),
-		V2 ("\\ua", "\xa"),
-		V1 ("\\uat", "\xat"),
-		V2 ("\\uab", "\xc2\xab"),
-		V1 ("\\uabt", "\xc2\xabt"),
-		V2 ("\\uabc", "\xe0\xaa\xbc"),
-		V1 ("\\uabct", "\xe0\xaa\xbct"),
-		V2 ("\\uabcd", "\xea\xaf\x8d"),
-		V1 ("\\uabcdt", "\xea\xaf\x8dt"),
-		V2 ("\\uabcde", "\xea\xaf\x8d""e"),
-		V1 ("\\uabcdet", "\xea\xaf\x8d""et"),
-		V1 ("\\Ut", "\\Ut"),
-		V2 ("\\Ua", "\xa"),
-		V1 ("\\Uat", "\xat"),
-		V2 ("\\Uab", "\xc2\xab"),
-		V1 ("\\Uabt", "\xc2\xabt"),
-		V2 ("\\Uabc", "\xe0\xaa\xbc"),
-		V1 ("\\Uabct", "\xe0\xaa\xbct"),
-		V2 ("\\Uabcd", "\xea\xaf\x8d"),
-		V1 ("\\Uabcdt", "\xea\xaf\x8dt"),
-		V2 ("\\Uabcde", "\xf2\xab\xb3\x9e"),
-		V1 ("\\Uabcdet", "\xf2\xab\xb3\x9et"),
-		V2 ("\\Uabcde0", "\xf8\xaa\xbc\xb7\xa0"),
-		V1 ("\\Uabcde0t", "\xf8\xaa\xbc\xb7\xa0t"),
-		V2 ("\\Uabcde01", "\xfc\x8a\xaf\x8d\xb8\x81"),
-		V1 ("\\Uabcde01t", "\xfc\x8a\xaf\x8d\xb8\x81t"),
-		V2 ("\\U0abcde01", "\xfc\x8a\xaf\x8d\xb8\x81"),
-		V1 ("\\U0abcde01t", "\xfc\x8a\xaf\x8d\xb8\x81t"),
-		V1 ("\\U00abcde01", "\xf8\xaa\xbc\xb7\xa0""1"),
-		V1 ("\\U00abcde01t", "\xf8\xaa\xbc\xb7\xa0""1t"),
-
-		/* control-x sequence is not supported */
-		V1 ("\\c", "\\c"),
-		V1 ("\\c1", "\\c1"),
-	};
-#undef V0
-#undef V1
-#undef V2
-	gsize i;
-	nm_auto_free_gstring GString *str_val = g_string_new (NULL);
-	nm_auto_free_gstring GString *str_val2 = g_string_new (NULL);
-	nm_auto_free_gstring GString *str_exp = g_string_new (NULL);
-	nm_auto_free_gstring GString *str_exp2 = g_string_new (NULL);
-
-	do_svUnescape_assert ( "'  ''  '", "    ");
-
-	for (i = 0; i < G_N_ELEMENTS (data_full); i++)
-		do_svUnescape_assert (data_full[i].val, data_full[i].exp);
-
-	for (i = 0; i < G_N_ELEMENTS (data_ansi); i++) {
-		do_svUnescape_combine_ansi (str_val, str_exp, data_ansi, G_N_ELEMENTS (data_ansi), i);
-		do_svUnescape_assert (str_val->str, str_exp->str);
-	}
-
-	/* different values can be just concatenated... */
-	for (i = 0; i < 200; i++) {
-		gsize num_concat = (nmtst_get_rand_uint32 () % 5) + 2;
-
-		g_string_set_size (str_val, 0);
-		g_string_set_size (str_exp, 0);
-
-		while (num_concat > 0) {
-			gsize idx;
-
-			if ((nmtst_get_rand_uint32 () % 3 == 0)) {
-				do_svUnescape_combine_ansi (str_val2, str_exp2, data_ansi, G_N_ELEMENTS (data_ansi), -((int) ((nmtst_get_rand_uint32 () % 5) + 1)));
-				continue;
-			}
-
-			idx = nmtst_get_rand_uint32 () % G_N_ELEMENTS (data_full);
-			if (!data_full[idx].can_concat)
-				continue;
-			g_string_append (str_val, data_full[idx].val);
-			g_string_append (str_exp, data_full[idx].exp);
-			num_concat--;
-		}
-
-		switch (nmtst_get_rand_uint32 () % 3) {
-		case 0:
-			g_string_append (str_val, " ");
-			break;
-		case 1:
-			g_string_append (str_val, "    ");
-			break;
-		}
-		switch (nmtst_get_rand_uint32 () % 3) {
-		case 0:
-			g_string_append (str_val, " #");
-			break;
-		case 1:
-			g_string_append (str_val, " #foo");
-			break;
-		}
-		do_svUnescape_assert (str_val->str, str_exp->str);
-	}
-}
-
-/*****************************************************************************/
-
-static void
-test_write_unknown (gconstpointer test_data)
-{
-	nmtst_auto_unlinkfile char *filename_tmp_1 = g_strdup (TEST_SCRATCH_DIR_TMP"/tmp-1");
-	const char *testfile = test_data;
-	gs_free char *testfile_expected = g_strconcat (testfile, ".expected", NULL);
-	shvarFile *sv;
-	gs_free_error GError *error = NULL;
-	gboolean success;
-	gs_free char *file_contents_out = NULL;
-	gs_free char *file_contents_exp = NULL;
-
-	sv = _svOpenFile (testfile);
-
-	_nmtst_svFileSetName (sv, filename_tmp_1);
-	_nmtst_svFileSetModified (sv);
-
-	if (g_str_has_suffix (testfile, "ifcfg-test-write-unknown-4")) {
-		_svGetValue_check (sv, "NAME", "l4x");
-		_svGetValue_check (sv, "NAME2", "");
-		_svGetValue_check (sv, "NAME3", "name3-value");
-
-		svSetValue (sv, "NAME", "set-by-test1");
-		svSetValue (sv, "NAME2", NULL);
-		svSetValue (sv, "NAME2", "set-by-test2");
-		svSetValue (sv, "NAME3", "set-by-test3");
-
-		_svGetValue_check (sv, "some_key", NULL);
-		_svGetValue_check (sv, "some_key1", "");
-		_svGetValue_check (sv, "some_key2", "");
-		_svGetValue_check (sv, "some_key3", "x");
-
-		_svGetValue_check (sv, "NAME", "set-by-test1");
-		_svGetValue_check (sv, "NAME2", "set-by-test2");
-		_svGetValue_check (sv, "NAME3", "set-by-test3");
-	}
-
-	success = svWriteFile (sv, 0644, &error);
-	nmtst_assert_success (success, error);
-
-	file_contents_out = nmtst_file_get_contents (filename_tmp_1);
-	file_contents_exp = nmtst_file_get_contents (testfile_expected);
-
-	g_assert_cmpstr (file_contents_out, ==, file_contents_exp);
-
-	svCloseFile (sv);
-}
-
-/*****************************************************************************/
-
-static void
-test_read_vlan_trailing_spaces (void)
-{
-	const char *testfile = TEST_IFCFG_DIR"/ifcfg-test-vlan-trailing-spaces";
-	NMConnection *connection;
-	gboolean success;
-	GError *error = NULL;
-	NMSettingVlan *s_vlan;
-	char *contents = NULL;
-
-	/* Ensure there is whitespace at the end of the VLAN interface name,
-	 * to prevent the whitespace getting stripped off and committed mistakenly
-	 * by something in the future.
-	 */
-	success = g_file_get_contents (testfile, &contents, NULL, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	g_assert (contents && contents[0]);
-	g_assert (strstr (contents, "DEVICE=\"vlan201\"  \n"));
-	g_free (contents);
-
-	connection = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	s_vlan = nm_connection_get_setting_vlan (connection);
-	g_assert (s_vlan);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "vlan201");
-	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, "enccw0.0.fb00");
-	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 201);
-	g_assert_cmpint (nm_setting_vlan_get_flags (s_vlan), ==, NM_VLAN_FLAG_REORDER_HEADERS);
-
-	g_object_unref (connection);
-}
-
-/*****************************************************************************/
-
-static void
-test_sit_read_ignore (void)
-{
-	gs_free_error GError *error = NULL;
-
-	_connection_from_file_fail (TEST_IFCFG_DIR"/ifcfg-test-sit-ignore",
-	                            NULL, TYPE_ETHERNET, &error);
-	nmtst_assert_error (error, 0, 0, "*Ignoring unsupported connection due to IPV6TUNNELIPV4*");
-}
-
-/*****************************************************************************/
-
-static void
-do_test_utils_name (const char *desc,
-                    const char *path,
-                    gboolean only_ifcfg,
-                    const char *expected)
-{
-	const char *result;
-
-	result = utils_get_ifcfg_name (path, only_ifcfg);
-	g_assert_cmpstr (result, ==, expected);
-}
-
-static void
-test_utils_name (void)
-{
-	do_test_utils_name ("get-ifcfg-name-bad", "/foo/bar/adfasdfadf", FALSE, NULL);
-	do_test_utils_name ("get-ifcfg-name-good", "/foo/bar/ifcfg-FooBar", FALSE, "FooBar");
-	do_test_utils_name ("get-ifcfg-name-keys", "/foo/bar/keys-BlahLbah", FALSE, "BlahLbah");
-	do_test_utils_name ("get-ifcfg-name-route", "/foo/bar/route-Lalalala", FALSE, "Lalalala");
-	do_test_utils_name ("get-ifcfg-name-only-ifcfg-route", "/foo/bar/route-Lalalala", TRUE, NULL);
-	do_test_utils_name ("get-ifcfg-name-only-ifcfg-keys", "/foo/bar/keys-Lalalala", TRUE, NULL);
-	do_test_utils_name ("get-ifcfg-name-no-path-ifcfg", "ifcfg-Lalalala", FALSE, "Lalalala");
-	do_test_utils_name ("get-ifcfg-name-no-path-keys", "keys-Lalalala", FALSE, "Lalalala");
-	do_test_utils_name ("get-ifcfg-name-no-path-route", "route-Lalalala", FALSE, "Lalalala");
-
-	do_test_utils_name ("get-ifcfg-name-bad2-ifcfg", "/foo/bar/asdfasifcfg-Foobar", FALSE, NULL);
-	do_test_utils_name ("get-ifcfg-name-bad2-keys", "/foo/bar/asdfaskeys-Foobar", FALSE, NULL);
-	do_test_utils_name ("get-ifcfg-name-bad2-route", "/foo/bar/asdfasroute-Foobar", FALSE, NULL);
-}
-
-/*****************************************************************************/
-
-static void
-do_test_utils_path_ifcfg (const char *desc,
-                          const char *path,
-                          const char *expected)
-{
-	char *result;
-
-	result = utils_get_ifcfg_path (path);
-	g_assert_cmpstr (result, ==, expected);
-	g_free (result);
-}
-
-static void
-do_test_utils_path_keys (const char *desc,
-                         const char *path,
-                         const char *expected)
-{
-	char *result;
-
-	result = utils_get_keys_path (path);
-	g_assert_cmpstr (result, ==, expected);
-	g_free (result);
-}
-
-static void
-do_test_utils_path_route (const char *desc,
-                          const char *path,
-                          const char *expected)
-{
-	char *result;
-
-	result = utils_get_route_path (path);
-	g_assert_cmpstr (result, ==, expected);
-	g_free (result);
-}
-
-static void
-test_utils_path (void)
-{
-	do_test_utils_path_ifcfg ("ifcfg-path-bad", "/foo/bar/adfasdfasdf", NULL);
-	do_test_utils_path_ifcfg ("ifcfg-path-from-keys-no-path", "keys-BlahBlah", "ifcfg-BlahBlah");
-	do_test_utils_path_ifcfg ("ifcfg-path-from-keys", "/foo/bar/keys-BlahBlah", "/foo/bar/ifcfg-BlahBlah");
-	do_test_utils_path_ifcfg ("ifcfg-path-from-route", "/foo/bar/route-BlahBlah", "/foo/bar/ifcfg-BlahBlah");
-
-	do_test_utils_path_keys ("keys-path-bad", "/foo/bar/asdfasdfasdfasdf", NULL);
-	do_test_utils_path_keys ("keys-path-from-ifcfg-no-path", "ifcfg-FooBar", "keys-FooBar");
-	do_test_utils_path_keys ("keys-path-from-ifcfg", "/foo/bar/ifcfg-FooBar", "/foo/bar/keys-FooBar");
-	do_test_utils_path_keys ("keys-path-from-route", "/foo/bar/route-FooBar", "/foo/bar/keys-FooBar");
-
-	do_test_utils_path_route ("route-path-bad", "/foo/bar/asdfasdfasdfasdf", NULL);
-	do_test_utils_path_route ("route-path-from-ifcfg-no-path", "ifcfg-FooBar", "route-FooBar");
-	do_test_utils_path_route ("route-path-from-ifcfg", "/foo/bar/ifcfg-FooBar", "/foo/bar/route-FooBar");
-	do_test_utils_path_route ("route-path-from-keys", "/foo/bar/keys-FooBar", "/foo/bar/route-FooBar");
-}
-
-/*****************************************************************************/
-
-static void
-do_test_utils_ignored (const char *desc, const char *path, gboolean expected_ignored)
-{
-	gboolean result;
-
-	result = utils_should_ignore_file (path, FALSE);
-	g_assert (result == expected_ignored);
-}
-
-static void
-test_utils_ignore (void)
-{
-	do_test_utils_ignored ("ignored-ifcfg", "ifcfg-FooBar", FALSE);
-	do_test_utils_ignored ("ignored-keys", "keys-FooBar", FALSE);
-	do_test_utils_ignored ("ignored-route", "route-FooBar", FALSE);
-	do_test_utils_ignored ("ignored-bak", "ifcfg-FooBar" BAK_TAG, TRUE);
-	do_test_utils_ignored ("ignored-tilde", "ifcfg-FooBar" TILDE_TAG, TRUE);
-	do_test_utils_ignored ("ignored-orig", "ifcfg-FooBar" ORIG_TAG, TRUE);
-	do_test_utils_ignored ("ignored-rej", "ifcfg-FooBar" REJ_TAG, TRUE);
-	do_test_utils_ignored ("ignored-rpmnew", "ifcfg-FooBar" RPMNEW_TAG, TRUE);
-	do_test_utils_ignored ("ignored-augnew", "ifcfg-FooBar" AUGNEW_TAG, TRUE);
-	do_test_utils_ignored ("ignored-augtmp", "ifcfg-FooBar" AUGTMP_TAG, TRUE);
-}
-
-/*****************************************************************************/
-
-static void
-test_sriov_read (void)
-{
-	gs_unref_object NMConnection *connection = NULL;
-	NMSettingSriov *s_sriov;
-	NMSriovVF *vf;
-	GVariant *variant;
-	GError *error = NULL;
-	char *str;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR "/ifcfg-test-sriov",
-	                                    NULL, TYPE_ETHERNET,NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "eth0");
-
-	s_sriov = NM_SETTING_SRIOV (nm_connection_get_setting (connection, NM_TYPE_SETTING_SRIOV));
-	g_assert (s_sriov);
-
-	g_assert_cmpint (nm_setting_sriov_get_total_vfs (s_sriov), ==, 16);
-	g_assert_cmpint (nm_setting_sriov_get_num_vfs (s_sriov), ==, 3);
-	g_assert_cmpint (nm_setting_sriov_get_autoprobe_drivers (s_sriov), ==, NM_TERNARY_FALSE);
-
-	/* VF 3 */
-	vf = nm_setting_sriov_get_vf (s_sriov, 0);
-	g_assert (vf);
-	g_assert_cmpint (nm_sriov_vf_get_index (vf), ==, 3);
-
-	variant = nm_sriov_vf_get_attribute (vf, NM_SRIOV_VF_ATTRIBUTE_MAC);
-	g_assert (variant);
-	g_assert (g_variant_is_of_type (variant, G_VARIANT_TYPE_STRING));
-	g_assert_cmpstr (g_variant_get_string (variant, NULL), ==, "55:44:33:22:11:00");
-
-	variant = nm_sriov_vf_get_attribute (vf, NM_SRIOV_VF_ATTRIBUTE_SPOOF_CHECK);
-	g_assert (variant);
-	g_assert (g_variant_is_of_type (variant, G_VARIANT_TYPE_BOOLEAN));
-	g_assert_cmpint (g_variant_get_boolean (variant), ==, TRUE);
-
-	/* VF 12 */
-	vf = nm_setting_sriov_get_vf (s_sriov, 1);
-	str = nm_utils_sriov_vf_to_str (vf, FALSE, &error);
-	g_assert_no_error (error);
-	g_assert_cmpstr (str, ==, "12 min-tx-rate=100 trust=false vlans=1.200.ad");
-	g_free (str);
-
-	/* VF 15 */
-	vf = nm_setting_sriov_get_vf (s_sriov, 2);
-	str = nm_utils_sriov_vf_to_str (vf, FALSE, &error);
-	g_assert_no_error (error);
-	g_assert_cmpstr (str, ==, "15 mac=01:23:45:67:89:ab max-tx-rate=200 vlans=2");
-	g_free (str);
-}
-
-static void
-test_sriov_write (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMSettingWired *s_wired;
-	NMSettingSriov *s_sriov;
-	NMSriovVF *vf;
-	gs_unref_ptrarray GPtrArray *vfs = NULL;
-	NMIPAddress *addr;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write SR-IOV config",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
-
-	/* SRIOV setting */
-	s_sriov = (NMSettingSriov *) nm_setting_sriov_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_sriov));
-
-	vfs = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_sriov_vf_unref);
-
-	vf = nm_utils_sriov_vf_from_str ("2 mac=55:55:55:55:55:55 vlans=3.10.ad;10", &error);
-	nmtst_assert_success (vf, error);
-	g_ptr_array_add (vfs, vf);
-
-	vf = nm_utils_sriov_vf_from_str ("19 spoof-check=true", &error);
-	nmtst_assert_success (vf, error);
-	g_ptr_array_add (vfs, vf);
-
-	g_object_set (s_sriov,
-	              NM_SETTING_SRIOV_TOTAL_VFS, 64,
-	              NM_SETTING_SRIOV_VFS, vfs,
-	              NM_SETTING_SRIOV_AUTOPROBE_DRIVERS, NM_TERNARY_TRUE,
-	              NULL);
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	nmtst_assert_connection_verifies_without_normalization (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR "/ifcfg-test-sriov-write.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_ETHERNET, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-/*****************************************************************************/
-
-static void
-test_tc_read (void)
-{
-	NMConnection *connection;
-	NMSettingTCConfig *s_tc;
-	NMTCQdisc *qdisc;
-	NMTCTfilter *filter;
-	char *str;
-
-	connection = _connection_from_file (TEST_IFCFG_DIR"/ifcfg-test-tc",
-	                                    NULL, TYPE_ETHERNET,NULL);
-
-	g_assert_cmpstr (nm_connection_get_interface_name (connection), ==, "eth0");
-
-	s_tc = nm_connection_get_setting_tc_config (connection);
-	g_assert (s_tc);
-
-	g_assert_cmpint (nm_setting_tc_config_get_num_qdiscs (s_tc), ==, 1);
-	qdisc = nm_setting_tc_config_get_qdisc (s_tc, 0);
-	g_assert (qdisc);
-	g_assert_cmpint (nm_tc_qdisc_get_parent (qdisc), ==, TC_H_ROOT);
-	g_assert_cmpint (nm_tc_qdisc_get_handle (qdisc), ==, TC_H_UNSPEC);
-	g_assert_cmpstr (nm_tc_qdisc_get_kind (qdisc), ==, "fq_codel");
-
-	g_assert_cmpint (nm_setting_tc_config_get_num_tfilters (s_tc), ==, 1);
-	filter = nm_setting_tc_config_get_tfilter (s_tc, 0);
-	g_assert (filter);
-	str = nm_utils_tc_tfilter_to_str (filter, NULL);
-	g_assert_cmpstr (str, ==, "parent 1234: matchall action simple sdata Hello");
-	g_free (str);
-
-	g_object_unref (connection);
-}
-
-static void
-test_tc_write (void)
-{
-	nmtst_auto_unlinkfile char *testfile = NULL;
-	gs_unref_object NMConnection *connection = NULL;
-	gs_unref_object NMConnection *reread = NULL;
-	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip4;
-	NMSettingIPConfig *s_ip6;
-	NMSettingWired *s_wired;
-	NMSettingTCConfig *s_tc;
-	NMTCQdisc *qdisc;
-	NMTCTfilter *tfilter;
-	NMIPAddress *addr;
-	GError *error = NULL;
-
-	connection = nm_simple_connection_new ();
-
-	/* Connection setting */
-	s_con = (NMSettingConnection *) nm_setting_connection_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "Test Write TC config",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth0",
-	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
-	              NULL);
-
-	/* Wired setting */
-	s_wired = (NMSettingWired *) nm_setting_wired_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
-
-	/* TC setting */
-	s_tc = (NMSettingTCConfig *) nm_setting_tc_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_tc));
-
-	qdisc = nm_tc_qdisc_new ("pfifo_fast", TC_H_MAKE (0x2468 << 16, 0x2), &error);
-	g_assert_no_error (error);
-	nm_setting_tc_config_add_qdisc (s_tc, qdisc);
-	nm_tc_qdisc_unref (qdisc);
-
-	tfilter = nm_utils_tc_tfilter_from_str ("parent 1234: matchall action simple sdata Hello", &error);
-	g_assert_no_error (error);
-	nm_setting_tc_config_add_tfilter (s_tc, tfilter);
-	nm_tc_tfilter_unref (tfilter);
-
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-
-	nmtst_assert_connection_verifies_without_normalization (connection);
-
-	_writer_new_connec_exp (connection,
-	                        TEST_SCRATCH_DIR,
-	                        TEST_IFCFG_DIR"/ifcfg-test-tc-write.cexpected",
-	                        &testfile);
-
-	reread = _connection_from_file (testfile, NULL, TYPE_BOND, NULL);
-
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-/*****************************************************************************/
-
-#define TPATH "/settings/plugins/ifcfg-rh/"
-
-#define TEST_IFCFG_WIFI_OPEN_SSID_LONG_QUOTED TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-long-quoted"
-#define TEST_IFCFG_WIFI_OPEN_SSID_LONG_HEX TEST_IFCFG_DIR"/ifcfg-test-wifi-open-ssid-long-hex"
-
-#define DEFAULT_HEX_PSK "7d308b11df1b4243b0f78e5f3fc68cdbb9a264ed0edf4c188edf329ff5b467f0"
-
-NMTST_DEFINE ();
-
-int main (int argc, char **argv)
-{
-	int errsv;
-
-	nmtst_init_assert_logging (&argc, &argv, "INFO", "DEFAULT");
-
-	if (g_mkdir_with_parents (TEST_SCRATCH_DIR_TMP, 0755) != 0) {
-		errsv = errno;
-		g_error ("failure to create test directory \"%s\": %s", TEST_SCRATCH_DIR_TMP, nm_strerror_native (errsv));
-	}
-
-	g_test_add_func (TPATH "svUnescape", test_svUnescape);
-
-	g_test_add_data_func (TPATH "write-unknown/1", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-1", test_write_unknown);
-	g_test_add_data_func (TPATH "write-unknown/2", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-2", test_write_unknown);
-	g_test_add_data_func (TPATH "write-unknown/3", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-3", test_write_unknown);
-	g_test_add_data_func (TPATH "write-unknown/4", TEST_IFCFG_DIR"/ifcfg-test-write-unknown-4", test_write_unknown);
-
-	g_test_add_func (TPATH "vlan-trailing-spaces", test_read_vlan_trailing_spaces);
-
-	g_test_add_func (TPATH "unmanaged", test_read_unmanaged);
-	g_test_add_func (TPATH "unmanaged-unrecognized", test_read_unmanaged_unrecognized);
-	g_test_add_func (TPATH "unrecognized", test_read_unrecognized);
-	g_test_add_func (TPATH "basic", test_read_basic);
-	g_test_add_func (TPATH "miscellaneous-variables", test_read_miscellaneous_variables);
-	g_test_add_func (TPATH "variables-corner-cases", test_read_variables_corner_cases);
-	g_test_add_data_func (TPATH "no-prefix/8", GUINT_TO_POINTER (8), test_read_wired_static_no_prefix);
-	g_test_add_data_func (TPATH "no-prefix/16", GUINT_TO_POINTER (16), test_read_wired_static_no_prefix);
-	g_test_add_data_func (TPATH "no-prefix/24", GUINT_TO_POINTER (24), test_read_wired_static_no_prefix);
-	g_test_add_data_func (TPATH "static-ip6-only-gw/_NULL_", NULL, test_write_wired_static_ip6_only_gw);
-	g_test_add_data_func (TPATH "static-ip6-only-gw/::", "::", test_write_wired_static_ip6_only_gw);
-	g_test_add_data_func (TPATH "static-ip6-only-gw/2001:db8:8:4::2", "2001:db8:8:4::2", test_write_wired_static_ip6_only_gw);
-	g_test_add_data_func (TPATH "static-ip6-only-gw/::ffff:255.255.255.255", "::ffff:255.255.255.255", test_write_wired_static_ip6_only_gw);
-	g_test_add_func (TPATH "ip6/disabled", test_write_ip6_disabled);
-	g_test_add_func (TPATH "read-dns-options", test_read_dns_options);
-	g_test_add_func (TPATH "clear-master", test_clear_master);
-
-	nmtst_add_test_func (TPATH "read-static",           test_read_wired_static, TEST_IFCFG_DIR"/ifcfg-test-wired-static",           "System test-wired-static",           GINT_TO_POINTER (TRUE));
-	nmtst_add_test_func (TPATH "read-static-bootproto", test_read_wired_static, TEST_IFCFG_DIR"/ifcfg-test-wired-static-bootproto", "System test-wired-static-bootproto", GINT_TO_POINTER (FALSE));
-
-	g_test_add_func (TPATH "read-netmask-1", test_read_netmask_1);
-
-	g_test_add_func (TPATH "read-dhcp", test_read_wired_dhcp);
-	g_test_add_func (TPATH "read-dhcp-plus-ip", test_read_wired_dhcp_plus_ip);
-	g_test_add_func (TPATH "read-shared-plus-ip", test_read_wired_shared_plus_ip);
-	g_test_add_func (TPATH "read-dhcp-send-hostname", test_read_write_wired_dhcp_send_hostname);
-	g_test_add_func (TPATH "read-dhcpv6-hostname-fallback", test_read_wired_dhcpv6_hostname_fallback);
-	g_test_add_func (TPATH "read-global-gateway", test_read_wired_global_gateway);
-	g_test_add_func (TPATH "read-global-gateway-ignore", test_read_wired_global_gateway_ignore);
-	g_test_add_func (TPATH "read-obsolete-gateway-n", test_read_wired_obsolete_gateway_n);
-	g_test_add_func (TPATH "read-never-default", test_read_wired_never_default);
-	g_test_add_func (TPATH "read-defroute-no", test_read_wired_defroute_no);
-	g_test_add_func (TPATH "read-defroute-no-gatewaydev-yes", test_read_wired_defroute_no_gatewaydev_yes);
-	g_test_add_func (TPATH "routes/read-static", test_read_wired_static_routes);
-	g_test_add_func (TPATH "routes/read-static-legacy", test_read_wired_static_routes_legacy);
-
-	nmtst_add_test_func (TPATH "wired/read/manual/1", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-1", "System test-wired-ipv4-manual-1");
-	nmtst_add_test_func (TPATH "wired/read/manual/2", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-2", "System test-wired-ipv4-manual-2");
-	nmtst_add_test_func (TPATH "wired/read/manual/3", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-3", "System test-wired-ipv4-manual-3");
-	nmtst_add_test_func (TPATH "wired/read/manual/4", test_read_wired_ipv4_manual, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv4-manual-4", "System test-wired-ipv4-manual-4");
-
-	g_test_add_func (TPATH "user/1", test_user_1);
-
-	g_test_add_func (TPATH "wired/ipv6-manual", test_read_wired_ipv6_manual);
-
-	nmtst_add_test_func (TPATH "wired-ipv6-only/0", test_read_wired_ipv6_only, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv6-only",   "System test-wired-ipv6-only");
-	nmtst_add_test_func (TPATH "wired-ipv6-only/1", test_read_wired_ipv6_only, TEST_IFCFG_DIR"/ifcfg-test-wired-ipv6-only-1", "System test-wired-ipv6-only-1");
-
-	g_test_add_func (TPATH "wired/dhcpv6-only", test_read_wired_dhcp6_only);
-	g_test_add_func (TPATH "wired/autoip", test_read_wired_autoip);
-	g_test_add_func (TPATH "wired/onboot/no", test_read_onboot_no);
-	g_test_add_func (TPATH "wired/no-ip", test_read_noip);
-	g_test_add_func (TPATH "802-1x/peap/mschapv2", test_read_wired_8021x_peap_mschapv2);
-
-	nmtst_add_test_func (TPATH "test-wired-8021x-tls/agent",  test_read_wired_8021x_tls_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-tls-agent", GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED));
-	nmtst_add_test_func (TPATH "test-wired-8021x-tls/always", test_read_wired_8021x_tls_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wired-8021x-tls-always", GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED));
-
-	g_test_add_func (TPATH "802-1x/subj-matches", test_read_write_802_1X_subj_matches);
-	g_test_add_func (TPATH "802-1x/ttls-eapgtc", test_read_802_1x_ttls_eapgtc);
-	g_test_add_func (TPATH "802-1x/password_raw", test_read_write_802_1x_password_raw);
-	g_test_add_func (TPATH "802-1x/tls-p12-no-client-cert", test_read_802_1x_tls_p12_no_client_cert);
-
-	g_test_add_data_func (TPATH "wired/read/aliases/good/0", GINT_TO_POINTER (0), test_read_wired_aliases_good);
-	g_test_add_data_func (TPATH "wired/read/aliases/good/3", GINT_TO_POINTER (3), test_read_wired_aliases_good);
-	g_test_add_func (TPATH "wired/read/aliases/bad1", test_read_wired_aliases_bad_1);
-	g_test_add_func (TPATH "wired/read/aliases/bad2", test_read_wired_aliases_bad_2);
-	g_test_add_func (TPATH "wifi/read/open", test_read_wifi_open);
-	g_test_add_func (TPATH "wifi/read/open/auto", test_read_wifi_open_auto);
-	g_test_add_func (TPATH "wifi/read/open/hex-ssid", test_read_wifi_open_ssid_hex);
-	g_test_add_func (TPATH "wifi/read/open-ssid/bad-hex", test_read_wifi_open_ssid_hex_bad);
-	g_test_add_data_func (TPATH "wifi/read/open-ssid/long-hex", TEST_IFCFG_WIFI_OPEN_SSID_LONG_HEX, test_read_wifi_open_ssid_bad);
-	g_test_add_data_func (TPATH "wifi/read/open-ssid/long-quoted", TEST_IFCFG_WIFI_OPEN_SSID_LONG_QUOTED, test_read_wifi_open_ssid_bad);
-	g_test_add_func (TPATH "wifi/read/open/quoted-ssid", test_read_wifi_open_ssid_quoted);
-	g_test_add_func (TPATH "wifi/read/wep", test_read_wifi_wep);
-	g_test_add_func (TPATH "wifi/read/wep/adhoc", test_read_wifi_wep_adhoc);
-	g_test_add_func (TPATH "wifi/read/wep/passphrase", test_read_wifi_wep_passphrase);
-	g_test_add_func (TPATH "wifi/read/wep/40-ascii", test_read_wifi_wep_40_ascii);
-	g_test_add_func (TPATH "wifi/read/wep/104-ascii", test_read_wifi_wep_104_ascii);
-	g_test_add_func (TPATH "wifi/read/leap", test_read_wifi_leap);
-
-	nmtst_add_test_func (TPATH "wifi-leap-secret-flags/agent", test_read_wifi_leap_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wifi-leap-agent",      GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED));
-	nmtst_add_test_func (TPATH "wifi-leap-secret-flags/ask",   test_read_wifi_leap_secret_flags, TEST_IFCFG_DIR"/ifcfg-test-wifi-leap-always-ask", GINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED));
-
-	g_test_add_func (TPATH "wifi/read/wpa-psk", test_read_wifi_wpa_psk);
-	g_test_add_func (TPATH "wifi/read/wpa-psk/2", test_read_wifi_wpa_psk_2);
-	g_test_add_func (TPATH "wifi/read/wpa-psk/unquoted", test_read_wifi_wpa_psk_unquoted);
-	g_test_add_func (TPATH "wifi/read/wpa-psk/unquoted2", test_read_wifi_wpa_psk_unquoted2);
-	g_test_add_func (TPATH "wifi/read/wpa-psk/adhoc", test_read_wifi_wpa_psk_adhoc);
-	g_test_add_func (TPATH "wifi/read/wpa-psk/hex", test_read_wifi_wpa_psk_hex);
-	g_test_add_func (TPATH "wifi/read/sae", test_read_wifi_sae);
-	g_test_add_func (TPATH "wifi/read/dynamic-wep/leap", test_read_wifi_dynamic_wep_leap);
-	g_test_add_func (TPATH "wifi/read/wpa/eap/tls", test_read_wifi_wpa_eap_tls);
-	g_test_add_func (TPATH "wifi/read/wpa/eap/ttls/tls", test_read_wifi_wpa_eap_ttls_tls);
-	g_test_add_func (TPATH "wifi/read/dynamic-wep/eap/ttls/chap", test_read_wifi_wep_eap_ttls_chap);
-	g_test_add_func (TPATH "wifi/read-band-a", test_read_wifi_band_a);
-	g_test_add_func (TPATH "wifi/read-band-a-channel-mismatch", test_read_wifi_band_a_channel_mismatch);
-	g_test_add_func (TPATH "wifi/read-band-bg-channel-mismatch", test_read_wifi_band_bg_channel_mismatch);
-	g_test_add_func (TPATH "wifi/read-hidden", test_read_wifi_hidden);
-
-	nmtst_add_test_func (TPATH "wifi/read-mac-random-always",   test_read_wifi_mac_random,  "always",  GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_ALWAYS));
-	nmtst_add_test_func (TPATH "wifi/read-mac-random-never",    test_read_wifi_mac_random,  "never",   GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_NEVER));
-	nmtst_add_test_func (TPATH "wifi/read-mac-random-default",  test_read_wifi_mac_random,  "default", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_DEFAULT));
-	nmtst_add_test_func (TPATH "wifi/read-mac-random-missing",  test_read_wifi_mac_random,  "missing", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_DEFAULT));
-
-	nmtst_add_test_func (TPATH "wifi/write-mac-random-always",  test_write_wifi_mac_random, "always",  GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_ALWAYS),  "always");
-	nmtst_add_test_func (TPATH "wifi/write-mac-random-never",   test_write_wifi_mac_random, "never",   GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_NEVER),   "never");
-	nmtst_add_test_func (TPATH "wifi/write-mac-random-default", test_write_wifi_mac_random, "default", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_DEFAULT), "default");
-	nmtst_add_test_func (TPATH "wifi/write-mac-random-missing", test_write_wifi_mac_random, "missing", GINT_TO_POINTER (NM_SETTING_MAC_RANDOMIZATION_NEVER),   "never");
-
-	g_test_add_func (TPATH "wifi/read/wep-no-keys", test_read_wifi_wep_no_keys);
-	g_test_add_func (TPATH "wifi/read/wep-agent-keys", test_read_wifi_wep_agent_keys);
-	g_test_add_func (TPATH "infiniband/read", test_read_infiniband);
-	g_test_add_func (TPATH "vlan/read", test_read_vlan_interface);
-	g_test_add_func (TPATH "vlan/read-flags-1", test_read_vlan_flags_1);
-	g_test_add_func (TPATH "vlan/read-flags-2", test_read_vlan_flags_2);
-	g_test_add_func (TPATH "vlan/read/only-vlanid", test_read_vlan_only_vlan_id);
-	g_test_add_func (TPATH "vlan/read/only-device", test_read_vlan_only_device);
-	g_test_add_func (TPATH "vlan/read/physdev", test_read_vlan_physdev);
-	g_test_add_func (TPATH "vlan/read/reorder-hdr-1", test_read_vlan_reorder_hdr_1);
-	g_test_add_func (TPATH "vlan/read/reorder-hdr-2", test_read_vlan_reorder_hdr_2);
-	g_test_add_func (TPATH "wired/read/read-wake-on-lan", test_read_wired_wake_on_lan);
-	g_test_add_func (TPATH "wired/read/read-auto-negotiate-off", test_read_wired_auto_negotiate_off);
-	g_test_add_func (TPATH "wired/read/read-auto-negotiate-on", test_read_wired_auto_negotiate_on);
-	g_test_add_func (TPATH "wired/read/unkwnown-ethtool-opt", test_read_wired_unknown_ethtool_opt);
-
-	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
-	g_test_add_func (TPATH "wired/write/static-with-generic", test_write_wired_static_with_generic);
-	g_test_add_func (TPATH "wired/write/static-ip6-only", test_write_wired_static_ip6_only);
-	g_test_add_func (TPATH "wired/write-static-routes", test_write_wired_static_routes);
-	g_test_add_func (TPATH "wired/read-write-static-routes-legacy", test_read_write_static_routes_legacy);
-	g_test_add_func (TPATH "wired/write/dhcp", test_write_wired_dhcp);
-	g_test_add_func (TPATH "wired/write-dhcp-plus-ip", test_write_wired_dhcp_plus_ip);
-	g_test_add_func (TPATH "wired/write/dhcp-8021x-peap-mschapv2", test_write_wired_dhcp_8021x_peap_mschapv2);
-	g_test_add_func (TPATH "wired/write/match", test_write_wired_match);
-	g_test_add_func (TPATH "wired/write/routing-rules", test_write_routing_rules);
-
-#define _add_test_write_wired_8021x_tls(testpath, scheme, flags) \
-	nmtst_add_test_func (testpath, test_write_wired_8021x_tls, GINT_TO_POINTER (scheme), GINT_TO_POINTER (flags))
-	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/1", NM_SETTING_802_1X_CK_SCHEME_PATH, NM_SETTING_SECRET_FLAG_AGENT_OWNED);
-	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/2", NM_SETTING_802_1X_CK_SCHEME_PATH, NM_SETTING_SECRET_FLAG_NOT_SAVED);
-	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/3", NM_SETTING_802_1X_CK_SCHEME_PATH, NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED);
-	_add_test_write_wired_8021x_tls (TPATH "wired-8021x-tls/4", NM_SETTING_802_1X_CK_SCHEME_BLOB, NM_SETTING_SECRET_FLAG_NONE);
-
-	g_test_add_func (TPATH "wired/write-aliases", test_write_wired_aliases);
-	g_test_add_func (TPATH "ipv4/write-static-addresses-GATEWAY", test_write_gateway);
-	g_test_add_func (TPATH "wired/write-wake-on-lan", test_write_wired_wake_on_lan);
-	g_test_add_func (TPATH "wired/write-auto-negotiate-off", test_write_wired_auto_negotiate_off);
-	g_test_add_func (TPATH "wired/write-auto-negotiate-on", test_write_wired_auto_negotiate_on);
-	g_test_add_func (TPATH "wifi/write/open", test_write_wifi_open);
-	g_test_add_func (TPATH "wifi/write/open/hex-ssid", test_write_wifi_open_hex_ssid);
-	g_test_add_func (TPATH "wifi/write/wep", test_write_wifi_wep);
-	g_test_add_func (TPATH "wifi/write/wep/adhoc", test_write_wifi_wep_adhoc);
-	g_test_add_func (TPATH "wifi/write/wep/passphrase", test_write_wifi_wep_passphrase);
-	g_test_add_func (TPATH "wifi/write/wep/40-ascii", test_write_wifi_wep_40_ascii);
-	g_test_add_func (TPATH "wifi/write/wep/104-ascii", test_write_wifi_wep_104_ascii);
-	g_test_add_func (TPATH "wifi/write/leap", test_write_wifi_leap);
-	g_test_add_data_func (TPATH "wifi/write/leap/flags/agent",
-	                      GUINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED),
-	                      test_write_wifi_leap_secret_flags);
-	g_test_add_data_func (TPATH "wifi/write/leap/flags/not-saved",
-	                      GUINT_TO_POINTER (NM_SETTING_SECRET_FLAG_NOT_SAVED),
-	                      test_write_wifi_leap_secret_flags);
-	g_test_add_data_func (TPATH "wifi/write/leap/flags/agent-and-not-saved",
-	                      GUINT_TO_POINTER (NM_SETTING_SECRET_FLAG_AGENT_OWNED | NM_SETTING_SECRET_FLAG_NOT_SAVED),
-	                      test_write_wifi_leap_secret_flags);
-
-#define _add_test_write_wifi_wpa_psk(testpath, name, wep_group, wpa, wpa2, psk) \
-	nmtst_add_test_func (testpath, test_write_wifi_wpa_psk, name, GPOINTER_TO_INT (wep_group), GPOINTER_TO_INT (wpa), GPOINTER_TO_INT (wpa2), psk)
-	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-psk-write",                            "Test Write Wifi WPA PSK",                               FALSE, TRUE,  FALSE, DEFAULT_HEX_PSK);
-	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa2-psk-write",                           "Test Write Wifi WPA2 PSK",                              FALSE, FALSE, TRUE,  DEFAULT_HEX_PSK);
-	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-wpa2-psk-write",                       "Test Write Wifi WPA WPA2 PSK",                          FALSE, TRUE,  TRUE,  DEFAULT_HEX_PSK);
-	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wep-wpa-wpa2-psk-write",                   "Test Write Wifi WEP WPA WPA2 PSK",                      TRUE,  TRUE,  TRUE,  DEFAULT_HEX_PSK);
-	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-wpa2-psk-passphrase-write",            "Test Write Wifi WPA WPA2 PSK Passphrase",               FALSE, TRUE,  TRUE,  "really insecure passphrase04!");
-	_add_test_write_wifi_wpa_psk (TPATH "wifi-wpa-psk/wpa-wpa2-psk-passphrase-write-spec-chars", "Test Write Wifi WPA WPA2 PSK Passphrase Special Chars", FALSE, TRUE,  TRUE,  "blah`oops\"grr'$*@~!%\\");
-
-	g_test_add_func (TPATH "wifi/write/wpa/psk/adhoc", test_write_wifi_wpa_psk_adhoc);
-	g_test_add_func (TPATH "wifi/write/wpa/eap/tls", test_write_wifi_wpa_eap_tls);
-	g_test_add_func (TPATH "wifi/write/wpa/eap/ttls/tls", test_write_wifi_wpa_eap_ttls_tls);
-	g_test_add_func (TPATH "wifi/write/wpa/eap/ttls/mschapv2", test_write_wifi_wpa_eap_ttls_mschapv2);
-	g_test_add_func (TPATH "wifi/write/dynamic-wep/leap", test_write_wifi_dynamic_wep_leap);
-	g_test_add_func (TPATH "wifi/write-wpa-then-open", test_write_wifi_wpa_then_open);
-	g_test_add_func (TPATH "wifi/write-wpa-then-wep-with-perms", test_write_wifi_wpa_then_wep_with_perms);
-	g_test_add_func (TPATH "wifi/write-hidden", test_write_wifi_hidden);
-	g_test_add_func (TPATH "wifi/write-band-a", test_write_wifi_band_a);
-
-	g_test_add_func (TPATH "s390/read-qeth-static", test_read_wired_qeth_static);
-	g_test_add_func (TPATH "s390/write-qeth-dhcp", test_write_wired_qeth_dhcp);
-	g_test_add_func (TPATH "s390/read-ctc-static", test_read_wired_ctc_static);
-	g_test_add_func (TPATH "s390/write-ctc-dhcp", test_write_wired_ctc_dhcp);
-
-	g_test_add_func (TPATH "permissions/read", test_read_permissions);
-	g_test_add_func (TPATH "permissions/write", test_write_permissions);
-	g_test_add_func (TPATH "wifi/write-wep-agent-keys", test_write_wifi_wep_agent_keys);
-	g_test_add_func (TPATH "infiniband/write", test_write_infiniband);
-	g_test_add_func (TPATH "vlan/write", test_write_vlan);
-	g_test_add_func (TPATH "vlan/write-flags", test_write_vlan_flags);
-	g_test_add_func (TPATH "vlan/write-only-vlanid", test_write_vlan_only_vlanid);
-	g_test_add_func (TPATH "vlan/write-vlan-reorder-hdr", test_write_vlan_reorder_hdr);
-	g_test_add_func (TPATH "wired/write-missing-ipv6", test_write_ethernet_missing_ipv6);
-	g_test_add_func (TPATH "write-dns-options", test_write_dns_options);
-
-	g_test_add_func (TPATH "ibft/ignored", test_read_ibft_ignored);
-
-	g_test_add_func (TPATH "dcb/read-basic", test_read_dcb_basic);
-	g_test_add_func (TPATH "dcb/write-basic", test_write_dcb_basic);
-	g_test_add_func (TPATH "dcb/default-app-priorities", test_read_dcb_default_app_priorities);
-	g_test_add_func (TPATH "dcb/bad-booleans", test_read_dcb_bad_booleans);
-	g_test_add_func (TPATH "dcb/short-booleans", test_read_dcb_short_booleans);
-	g_test_add_func (TPATH "dcb/bad-uints", test_read_dcb_bad_uints);
-	g_test_add_func (TPATH "dcb/short-uints", test_read_dcb_short_uints);
-	g_test_add_func (TPATH "dcb/bad-percent", test_read_dcb_bad_percent);
-	g_test_add_func (TPATH "dcb/short-percent", test_read_dcb_short_percent);
-	g_test_add_func (TPATH "dcb/pgpct-not-100", test_read_dcb_pgpct_not_100);
-	g_test_add_data_func (TPATH "fcoe/fabric", (gpointer) NM_SETTING_DCB_FCOE_MODE_FABRIC, test_read_fcoe_mode);
-	g_test_add_data_func (TPATH "fcoe/vn2vn", (gpointer) NM_SETTING_DCB_FCOE_MODE_VN2VN, test_read_fcoe_mode);
-	g_test_add_data_func (TPATH "fcoe/write-fabric", (gpointer) NM_SETTING_DCB_FCOE_MODE_FABRIC, test_write_fcoe_mode);
-	g_test_add_data_func (TPATH "fcoe/write-vn2vn", (gpointer) NM_SETTING_DCB_FCOE_MODE_VN2VN, test_write_fcoe_mode);
-
-	g_test_add_func (TPATH "bond/read-master", test_read_bond_main);
-	g_test_add_func (TPATH "bond/read-master-eth-type", test_read_bond_eth_type);
-	g_test_add_func (TPATH "bond/read-slave", test_read_bond_slave);
-	g_test_add_func (TPATH "bond/read-slave-ib", test_read_bond_slave_ib);
-	g_test_add_func (TPATH "bond/write-master", test_write_bond_main);
-	g_test_add_func (TPATH "bond/write-slave", test_write_bond_slave);
-	g_test_add_func (TPATH "bond/write-slave-ib", test_write_bond_slave_ib);
-	g_test_add_func (TPATH "bond/bonding-opts-numeric-mode", test_read_bond_opts_mode_numeric);
-
-	g_test_add_func (TPATH "bridge/read-master", test_read_bridge_main);
-	g_test_add_func (TPATH "bridge/write-master", test_write_bridge_main);
-	g_test_add_func (TPATH "bridge/read-component", test_read_bridge_component);
-	g_test_add_func (TPATH "bridge/write-component", test_write_bridge_component);
-	g_test_add_func (TPATH "bridge/read-missing-stp", test_read_bridge_missing_stp);
-
-	g_test_add_data_func (TPATH "team/read-master-1", TEST_IFCFG_DIR"/ifcfg-test-team-master-1", test_read_team_master);
-	g_test_add_data_func (TPATH "team/read-master-2", TEST_IFCFG_DIR"/ifcfg-test-team-master-2", test_read_team_master);
-	g_test_add_data_func (TPATH "team/read-master-invalid", TEST_IFCFG_DIR"/ifcfg-test-team-master-invalid", test_read_team_master_invalid);
-	g_test_add_func (TPATH "team/write-master", test_write_team_master);
-	g_test_add_data_func (TPATH "team/read-port-1", TEST_IFCFG_DIR"/ifcfg-test-team-port-1", test_read_team_port);
-	g_test_add_data_func (TPATH "team/read-port-2", TEST_IFCFG_DIR"/ifcfg-test-team-port-2", test_read_team_port);
-	g_test_add_func (TPATH "team/write-port", test_write_team_port);
-	g_test_add_func (TPATH "team/write-infiniband-port", test_write_team_infiniband_port);
-	g_test_add_func (TPATH "team/read-port-empty-config", test_read_team_port_empty_config);
-	g_test_add_func (TPATH "team/reread-slave", test_team_reread_slave);
-
-	g_test_add_func (TPATH "proxy/read-proxy-basic", test_read_proxy_basic);
-	g_test_add_func (TPATH "proxy/write-proxy-basic", test_write_proxy_basic);
-
-	g_test_add_func (TPATH "sit/read/ignore", test_sit_read_ignore);
-
-	/* Stuff we expect to fail for now */
-	g_test_add_func (TPATH "pppoe/write-wired", test_write_wired_pppoe);
-	g_test_add_func (TPATH "vpn/write", test_write_vpn);
-	g_test_add_data_func (TPATH "wwan/write-gsm", GUINT_TO_POINTER (TRUE), test_write_mobile_broadband);
-	g_test_add_data_func (TPATH "wwan/write-cdma", GUINT_TO_POINTER (FALSE), test_write_mobile_broadband);
-
-	g_test_add_func (TPATH "no-trailing-newline", test_ifcfg_no_trailing_newline);
-
-	g_test_add_func (TPATH "utils/name", test_utils_name);
-	g_test_add_func (TPATH "utils/path", test_utils_path);
-	g_test_add_func (TPATH "utils/ignore", test_utils_ignore);
-
-	g_test_add_func (TPATH "sriov/read", test_sriov_read);
-	g_test_add_func (TPATH "sriov/write", test_sriov_write);
-
-	g_test_add_func (TPATH "tc/read", test_tc_read);
-	g_test_add_func (TPATH "tc/write", test_tc_write);
-
-	return g_test_run ();
-}
-- 
2.25.1


From 004a88b6e6d61a409d8d1c0ba77ee1a5ed7efa30 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Wed, 11 Dec 2019 17:14:32 -0500
Subject: [PATCH 03/78] second pass NM plugin

Signed-off-by: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
---
 Makefile.am                                   |    6 +-
 .../plugins/netplan/nms-netplan-plugin.c      |   24 +-
 .../plugins/netplan/nms-netplan-reader.c      | 4812 +++--------------
 .../plugins/netplan/nms-netplan-storage.c     |    4 +-
 .../plugins/netplan/nms-netplan-utils.c       |  106 +-
 .../plugins/netplan/nms-netplan-utils.h       |    2 +-
 .../plugins/netplan/nms-netplan-writer.c      |  468 +-
 7 files changed, 1063 insertions(+), 4359 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index d098587d5e431c406c5b5c8ee13ef199570810dc..0db611c46a1571477c31ff298b102218f591d466 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2880,7 +2880,7 @@ src_settings_plugins_netplan_libnms_netplan_core_la_SOURCES = \
 	src/settings/plugins/netplan/nms-netplan-writer.h \
 	$(NULL)
 
-src_settings_plugins_netplan_libnms_netplan_core_la_CPPFLAGS = $(src_cppflags_base)
+src_settings_plugins_netplan_libnms_netplan_core_la_CPPFLAGS = $(src_cppflags_base) $(UUID_CFLAGS)
 
 $(src_settings_plugins_netplan_libnms_netplan_core_la_OBJECTS): $(libnm_core_lib_h_pub_mkenums)
 
@@ -2893,11 +2893,13 @@ src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_SOURCES = \
 	src/settings/plugins/netplan/nms-netplan-plugin.h \
 	$(NULL)
 
-src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_CPPFLAGS = $(src_cppflags_base)
+src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_CPPFLAGS = $(src_cppflags_base) $(UUID_CFLAGS)
 
 src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_LDFLAGS = \
 	-module -avoid-version \
 	-Wl,--version-script="$(srcdir)/linker-script-settings.ver" \
+	-lnetplan \
+	$(UUID_LIBS) \
 	$(SANITIZER_EXEC_LDFLAGS)
 
 src_settings_plugins_netplan_libnm_settings_plugin_netplan_la_LIBADD = \
diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.c b/src/settings/plugins/netplan/nms-netplan-plugin.c
index bff4a10098b07079825c4682bcca9549b2323092..84c05ea777356de61967c2d434ac86eeb3347462 100644
--- a/src/settings/plugins/netplan/nms-netplan-plugin.c
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.c
@@ -14,6 +14,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include <netplan/parse.h>
+
 #include "nm-std-aux/c-list-util.h"
 #include "nm-glib-aux/nm-c-list.h"
 #include "nm-glib-aux/nm-io-utils.h"
@@ -158,7 +160,9 @@ _load_file (NMSNetplanPlugin *self,
 	gs_free_error GError *load_error = NULL;
 	gs_free char *unhandled_spec = NULL;
 	gboolean load_error_ignore;
+	NMSettingsStorage *storage = NULL;
 	struct stat st;
+	const char *uuid;
 
 	if (stat (filename, &st) != 0) {
 		int errsv = errno;
@@ -176,6 +180,7 @@ _load_file (NMSNetplanPlugin *self,
 	                                   &unhandled_spec,
 	                                   &load_error,
 	                                   &load_error_ignore);
+
 	if (load_error) {
 		if (error) {
 			nm_utils_error_set (error, NM_UTILS_ERROR_UNKNOWN,
@@ -206,6 +211,12 @@ _load_file (NMSNetplanPlugin *self,
 		                                          unmanaged_spec,
 		                                          unrecognized_spec);
 	}
+				uuid = nm_connection_get_uuid (connection);
+
+				if (!storage)
+					storage = nm_settings_storage_new (NM_SETTINGS_PLUGIN (self), uuid, NULL);
+
+				_LOGD ("parse: adding connection \"%s\" (%s)", filename, uuid);
 
 	return nms_netplan_storage_new_connection (self,
 	                                           g_steal_pointer (&connection),
@@ -228,7 +239,7 @@ _load_dir (NMSNetplanPlugin *self,
 		return;
 	}
 
-	dupl_filenames = g_hash_table_new_full (nm_str_hash, g_str_equal, NULL, g_free);
+	dupl_filenames = g_hash_table_new_full (nm_str_hash, g_str_equal, NULL, NULL);
 
 	while ((f_filename = g_dir_read_name (dir))) {
 		gs_free char *full_path = NULL;
@@ -558,7 +569,6 @@ add_connection (NMSettingsPlugin *plugin,
 	gs_free char *full_filename = NULL;
 	GError *local = NULL;
 	gboolean reread_same;
-	struct timespec mtime;
 
 	nm_assert_self (self, TRUE);
 	nm_assert (NM_IS_CONNECTION (connection));
@@ -626,7 +636,6 @@ update_connection (NMSettingsPlugin *plugin,
 	GError *local = NULL;
 	gs_unref_object NMConnection *reread = NULL;
 	gboolean reread_same;
-	struct timespec mtime;
 
 	_LOGT ("MATT: called to update netplan config");
 
@@ -688,9 +697,8 @@ delete_connection (NMSettingsPlugin *plugin,
 	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (plugin);
 	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 	NMSNetplanStorage *storage = NMS_NETPLAN_STORAGE (storage_x);
-	const char *operation_message;
+	const char *operation_message = NULL;
 	const char *full_filename;
-	int errsv;
 
 	nm_assert_self (self, TRUE);
 	nm_assert (!error || !*error);
@@ -706,7 +714,7 @@ delete_connection (NMSettingsPlugin *plugin,
 	_LOGT ("commit: deleted \"%s\", profile %s (%s)",
 	       full_filename,
 	       nms_netplan_storage_get_uuid (storage),
-	       operation_message);
+	       operation_message ? operation_message : "");
 
 	nm_sett_util_storages_steal (&priv->storages, storage);
 	nms_netplan_storage_destroy (storage);
@@ -824,8 +832,8 @@ nms_netplan_plugin_init (NMSNetplanPlugin *self)
 static void
 constructed (GObject *object)
 {
-	NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (object);
-	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
+	//NMSNetplanPlugin *self = NMS_NETPLAN_PLUGIN (object);
+	//NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 
 	G_OBJECT_CLASS (nms_netplan_plugin_parent_class)->constructed (object);
 }
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 77605aee70e415d93b80751f9b44536658bc8b44..03d827ab29d220df806fa78a6b24ebe2ef785216 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -19,6 +19,8 @@
 #include <sys/ioctl.h>
 #include <unistd.h>
 
+#include <netplan/parse.h>
+
 #include "nm-glib-aux/nm-secret-utils.h"
 #include "nm-connection.h"
 #include "nm-dbus-interface.h"
@@ -64,145 +66,9 @@
 
 /*****************************************************************************/
 
-#if 0
-
-static char *
-get_full_file_path (const char *netplan_path, const char *file_path)
-{
-	const char *base = file_path;
-	gs_free char *dirname = NULL;
-	char *p;
-
-	g_return_val_if_fail (netplan_path != NULL, NULL);
-	g_return_val_if_fail (file_path != NULL, NULL);
-
-	if (file_path[0] == '/')
-		return g_strdup (file_path);
-
-	p = strrchr (file_path, '/');
-	if (p)
-		base = p + 1;
-
-	dirname = g_path_get_dirname (netplan_path);
-	return g_build_path ("/", dirname, base, NULL);
-}
-
-/*****************************************************************************/
-
-static NMSettingSecretFlags
-_secret_read_netplan_flags (shvarFile *netplan, const char *flags_key)
-{
-	NMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;
-	gs_free char *val_free = NULL;
-	const char *val;
-
-	nm_assert (flags_key);
-	nm_assert (g_str_has_suffix (flags_key, "_FLAGS"));
-
-	val = svGetValueStr (netplan, flags_key, &val_free);
-	if (val) {
-		if (strstr (val, SECRET_FLAG_AGENT))
-			flags |= NM_SETTING_SECRET_FLAG_AGENT_OWNED;
-		if (strstr (val, SECRET_FLAG_NOT_SAVED))
-			flags |= NM_SETTING_SECRET_FLAG_NOT_SAVED;
-		if (strstr (val, SECRET_FLAG_NOT_REQUIRED))
-			flags |= NM_SETTING_SECRET_FLAG_NOT_REQUIRED;
-	}
-	return flags;
-}
-
-static void
-_secret_read_netplan (shvarFile *netplan,
-                      shvarFile *keys_netplan,
-                      const char *name,
-                      char **value,
-                      NMSettingSecretFlags *flags)
-{
-	char flags_key[250];
-
-	nm_sprintf_buf (flags_key, "%s_FLAGS", name);
-
-	*flags = _secret_read_netplan_flags (netplan, flags_key);
-
-	if (*flags != NM_SETTING_SECRET_FLAG_NONE)
-		*value = NULL;
-	else {
-		*value = svGetValue_cp (netplan, name);
-  		if (!*value && keys_netplan)
-			*  value = svGetV  alue_cp (keys_netplan, name);
-    	}
-    }
-  
-static void
-_secret_set_from_netplan (gpointer setting,
-                          shvarFile *netplan,
-                          shvarFile *keys_netplan,
-                          const char *netplan_key,
-                          const char *property_name)
-  {
-	nm_auto_free_secret char *secret = NULL;
-	NMSettingSecretFlags flags;
-	char flags_key[250];
-
-	nm_assert (NM_IS_SETTING (setting));
-
-	_secret_read_netplan (netplan, keys_netplan, netplan_key, &secret, &flags);
-  
-	g_object_set (setting,
-	              property_name,
-	              secret,
-	              nm_sprintf_buf (flags_key, "%s-flags", property_name),
-	              flags,
-	              NULL);
-}
-
-static gboolean
-_secret_password_raw_to_bytes (const char *netplan_key,
-                               const char *password_raw,
-                               GBytes **out_bytes,
-                               GError **error)
-{
-	nm_auto_free_secret_buf NMSecretBuf *secret = NULL;
-	gsize len;
-
-	if (!password_raw) {
-		NM_SET_OUT (out_bytes, NULL);
-		return TRUE;
-	}
-
-	if (password_raw[0] == '0' && password_raw[1] == 'x')
-		password_raw += 2;
-
-	secret = nm_secret_buf_new (strlen (password_raw) / 2 + 3);
-	if (!nm_utils_hexstr2bin_full (password_raw, FALSE, FALSE, ":", 0, secret->bin, secret->len, &len)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Invalid hex password in %s",
-		             netplan_key);
-		return FALSE;
-	}
-
-	NM_SET_OUT (out_bytes, nm_secret_buf_to_gbytes_take (g_steal_pointer (&secret), len));
-	return TRUE;
-}
-
-/*****************************************************************************/
-
-static GBytes *
-_cert_get_cert_bytes (const char *netplan_path,
-                      const char *value,
-                      GError **error)
-{
-	gs_free char *path = NULL;
-
-	if (NM_STR_HAS_PREFIX (value, "pkcs11:"))
-		return _nm_setting_802_1x_cert_value_to_bytes (NM_SETTING_802_1X_CK_SCHEME_PKCS11, (guint8 *) value, -1, error);
-
-	path = get_full_file_path (netplan_path, value);
-	return _nm_setting_802_1x_cert_value_to_bytes (NM_SETTING_802_1X_CK_SCHEME_PATH, (guint8 *) path, -1, error);
-}
-
+#if 0   /* TODO: Support certs for reading from netplan files. */
 static gboolean
-_cert_get_cert (shvarFile *netplan,
+_cert_get_cert (NetplanNetDefinition *nd,
                 const char *netplan_key,
                 GBytes **out_cert,
                 NMSetting8021xCKScheme *out_scheme,
@@ -246,7 +112,7 @@ err:
 
 static gboolean
 _cert_set_from_netplan (gpointer setting,
-                        shvarFile *netplan,
+                        NetplanNetDefinition *nd,
                         const char *netplan_key,
                         const char *property_name,
                         GBytes **out_cert,
@@ -266,11 +132,13 @@ _cert_set_from_netplan (gpointer setting,
 	NM_SET_OUT (out_cert, g_steal_pointer (&cert));
 	return TRUE;
 }
+#endif /* cert support */
 
 /*****************************************************************************/
 
+#if 0
 static void
-check_if_bond_slave (shvarFile *netplan,
+check_if_bond_slave (NetplanNetDefinition *nd,
                      NMSettingConnection *s_con)
 {
 	gs_free char *value = NULL;
@@ -299,9 +167,11 @@ check_if_bond_slave (shvarFile *netplan,
 	 * so for backward-compatibility, we don't check.
 	 */
 }
+#endif
 
+#if 0  /* TODO: Team support  */
 static void
-check_if_team_slave (shvarFile *netplan,
+check_if_team_slave (NetplanNetDefinition *nd,
                      NMSettingConnection *s_con)
 {
 	gs_free char *value = NULL;
@@ -326,9 +196,10 @@ check_if_team_slave (shvarFile *netplan,
 	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
 	              NULL);
 }
+#endif /* team support */
 
 static char *
-make_connection_name (shvarFile *netplan,
+make_connection_name (NetplanNetDefinition *nd,
                       const char *netplan_name,
                       const char *suggested,
                       const char *prefix)
@@ -336,7 +207,7 @@ make_connection_name (shvarFile *netplan,
 	char *full_name = NULL, *name;
 
 	/* If the netplan file already has a NAME, always use that */
-	name = svGetValueStr_cp (netplan, "NAME");
+	name = nd->id;
 	if (name)
 		return name;
 
@@ -358,46 +229,46 @@ make_connection_name (shvarFile *netplan,
 
 static NMSetting *
 make_connection_setting (const char *file,
-                         shvarFile *netplan,
+                         NetplanNetDefinition *nd,
                          const char *type,
                          const char *suggested,
                          const char *prefix)
 {
 	NMSettingConnection *s_con;
-	NMSettingConnectionLldp lldp;
+	//NMSettingConnectionLldp lldp;
 	const char *netplan_name = NULL;
 	gs_free char *new_id = NULL;
 	const char *uuid;
 	gs_free char *uuid_free = NULL;
-	gs_free char *value = NULL;
 	const char *v;
 	gs_free char *stable_id = NULL;
-	const char *const *iter;
-	int vint64, i_val;
+	//const char *const *iter;
+	//int vint64, i_val;
 
-	netplan_name = utils_get_netplan_name (file, TRUE);
+	netplan_name = utils_get_netplan_name (file);
 	if (!netplan_name)
 		return NULL;
 
 	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
 
-	new_id = make_connection_name (netplan, netplan_name, suggested, prefix);
+	new_id = make_connection_name (nd, netplan_name, suggested, prefix);
 	g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
 
 	/* Try for a UUID key before falling back to hashing the file name */
-	uuid = svGetValueStr (netplan, "UUID", &uuid_free);
+	uuid = nd->backend_settings.nm.uuid;
 	if (!uuid) {
-		uuid_free = nm_utils_uuid_generate_from_string (svFileGetName (netplan), -1, NM_UTILS_UUID_TYPE_LEGACY, NULL);
+		uuid_free = nm_utils_uuid_generate_from_string (netplan_name, -1, NM_UTILS_UUID_TYPE_LEGACY, NULL);
 		uuid = uuid_free;
 	}
 
+	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : nd->backend_settings.nm.name;
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_TYPE, type,
 	              NM_SETTING_CONNECTION_UUID, uuid,
-	              NM_SETTING_CONNECTION_STABLE_ID, svGetValue (netplan, "STABLE_ID", &stable_id),
+	              NM_SETTING_CONNECTION_STABLE_ID, stable_id,
 	              NULL);
 
-	v = svGetValueStr (netplan, "DEVICE", &value);
+	v = nd->backend_settings.nm.device;
 	if (v) {
 		GError *error = NULL;
 
@@ -411,7 +282,7 @@ make_connection_setting (const char *file,
 		}
 	}
 
-	nm_clear_g_free (&value);
+#if 0  /* TODO: handle LLDP, ONBOOT (autoconnect) settings for NM */
 	v = svGetValueStr (netplan, "LLDP", &value);
 	if (nm_streq0 (v, "rx"))
 		lldp = NM_SETTING_CONNECTION_LLDP_ENABLE_RX;
@@ -437,8 +308,10 @@ make_connection_setting (const char *file,
 	              svGetValueBoolean (netplan, "AUTOCONNECT_SLAVES", NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT),
 	              NM_SETTING_CONNECTION_LLDP, lldp,
 	              NULL);
-
 	nm_clear_g_free (&value);
+#endif
+
+#if 0  /* TODO: User permissions handling in netplan syntax */
 	v = svGetValueStr (netplan, "USERS", &value);
 	if (v) {
 		gs_free const char **items = NULL;
@@ -451,6 +324,9 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
+#endif
+
+#if 0  /* TODO: Support ZONE, Secondary UUIDs, etc. */
 	v = svGetValueStr (netplan, "ZONE", &value);
 	g_object_set (s_con, NM_SETTING_CONNECTION_ZONE, v, NULL);
 
@@ -467,6 +343,9 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
+#endif
+
+#if 0  /* TODO: Bridge UUIDs??? */
 	v = svGetValueStr (netplan, "BRIDGE_UUID", &value);
 	if (!v)
 		v = svGetValueStr (netplan, "BRIDGE", &value);
@@ -487,6 +366,9 @@ make_connection_setting (const char *file,
 	check_if_team_slave (netplan, s_con);
 
 	nm_clear_g_free (&value);
+#endif
+
+#if 0  /* TODO: OVS support */
 	v = svGetValueStr (netplan, "OVS_PORT_UUID", &value);
 	if (!v)
 		v = svGetValueStr (netplan, "OVS_PORT", &value);
@@ -504,6 +386,9 @@ make_connection_setting (const char *file,
 	}
 
 	nm_clear_g_free (&value);
+#endif  /* OVS support */
+
+#if 0  /* TODO: more random settings NM-specific */
 	v = svGetValueStr (netplan, "GATEWAY_PING_TIMEOUT", &value);
 	if (v) {
 		gint64 tmp;
@@ -568,52 +453,42 @@ make_connection_setting (const char *file,
 	                     &i_val, NULL))
 		PARSE_WARNING ("invalid MDNS setting");
 	g_object_set (s_con, NM_SETTING_CONNECTION_MDNS, i_val, NULL);
+#endif
 
+#if 0  /* TODO: LLMNR settings support */
 	i_val = NM_SETTING_CONNECTION_LLMNR_DEFAULT;
 	if (!svGetValueEnum (netplan, "LLMNR",
 	                     nm_setting_connection_llmnr_get_type (),
 	                     &i_val, NULL))
 		PARSE_WARNING ("invalid LLMNR setting");
 	g_object_set (s_con, NM_SETTING_CONNECTION_LLMNR, i_val, NULL);
+#endif
 
 	return NM_SETTING (s_con);
 }
 
+#if 0
 static gboolean
-read_ip4_address (shvarFile *netplan,
+read_ip4_address (NetplanNetDefinition *nd,
                   const char *tag,
                   gboolean *out_has_key,
                   guint32 *out_addr,
                   GError **error)
 {
-	gs_free char *value_to_free = NULL;
-	const char *value;
-	in_addr_t a;
+	//const char *value;
+	//in_addr_t a;
 
-	nm_assert (netplan);
+	nm_assert (nd);
 	nm_assert (tag);
 	nm_assert (!error || !*error);
 
-	value = svGetValueStr (netplan, tag, &value_to_free);
-	if (!value) {
-		NM_SET_OUT (out_has_key, FALSE);
-		NM_SET_OUT (out_addr, 0);
-		return TRUE;
-	}
-
-	if (inet_pton (AF_INET, value, &a) != 1) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Invalid %s IP4 address '%s'", tag, value);
-		return FALSE;
-	}
+	// TODO: Parse through the GArray of addresses and pick just the ipv4
 
-	NM_SET_OUT (out_has_key, TRUE);
-	NM_SET_OUT (out_addr, a);
 	return TRUE;
 }
 
 static gboolean
-is_any_ip4_address_defined (shvarFile *netplan, int *idx)
+is_any_ip4_address_defined (NetplanNetDefinition *nd, int *idx)
 {
 	int i, ignore, *ret_idx;
 
@@ -640,686 +515,11 @@ is_any_ip4_address_defined (shvarFile *netplan, int *idx)
 	}
 	return FALSE;
 }
-
-/* Returns TRUE on missing address or valid address */
-static gboolean
-read_full_ip4_address (shvarFile *netplan,
-                       gint32 which,
-                       NMIPAddress *base_addr,
-                       NMIPAddress **out_address,
-                       char **out_gateway,
-                       GError **error)
-{
-	char tag[256];
-	char prefix_tag[256];
-	guint32 ipaddr;
-	gs_free char *value = NULL;
-	const char *v;
-	int prefix = 0;
-	gboolean has_key;
-	guint32 a;
-	char inet_buf[NM_UTILS_INET_ADDRSTRLEN];
-
-	g_return_val_if_fail (which >= -1, FALSE);
-	g_return_val_if_fail (netplan != NULL, FALSE);
-	g_return_val_if_fail (out_address != NULL, FALSE);
-	g_return_val_if_fail (*out_address == NULL, FALSE);
-	g_return_val_if_fail (!error || !*error, FALSE);
-
-	/* IP address */
-	if (!read_ip4_address (netplan,
-	                       numbered_tag (tag, "IPADDR", which),
-	                       &has_key, &ipaddr, error))
-		return FALSE;
-	if (!has_key) {
-		if (!base_addr)
-			return TRUE;
-		nm_ip_address_get_address_binary (base_addr, &ipaddr);
-	}
-
-	/* Gateway */
-	if (out_gateway && !*out_gateway) {
-		if (!read_ip4_address (netplan,
-		                       numbered_tag (tag, "GATEWAY", which),
-		                       &has_key, &a, error))
-			return FALSE;
-		if (has_key)
-			*out_gateway = nm_utils_inet4_ntop_dup (a);
-	}
-
-	/* Prefix */
-	numbered_tag (prefix_tag, "PREFIX", which);
-	v = svGetValueStr (netplan, prefix_tag, &value);
-	if (v) {
-		prefix = _nm_utils_ascii_str_to_int64 (v, 10, 0, 32, -1);
-		if (prefix < 0) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid IP4 prefix '%s'", v);
-			return FALSE;
-		}
-	} else {
-		/* Fall back to NETMASK if no PREFIX was specified */
-		if (!read_ip4_address (netplan,
-		                       numbered_tag (tag, "NETMASK", which),
-		                       &has_key, &a, error))
-			return FALSE;
-		if (has_key)
-			prefix = nm_utils_ip4_netmask_to_prefix (a);
-		else {
-			if (base_addr)
-				prefix = nm_ip_address_get_prefix (base_addr);
-			else {
-				/* Try to autodetermine the prefix for the address' class */
-				prefix = _nm_utils_ip4_get_default_prefix (ipaddr);
-				PARSE_WARNING ("missing %s, assuming %s/%d", prefix_tag, nm_utils_inet4_ntop (ipaddr, inet_buf), prefix);
-			}
-		}
-	}
-
-	*out_address = nm_ip_address_new_binary (AF_INET, &ipaddr, prefix, error);
-	if (*out_address)
-		return TRUE;
-
-	return FALSE;
-}
-
-/*****************************************************************************/
-
-static gboolean
-parse_route_line_is_comment (const char *line)
-{
-	/* we obtained the line from a legacy route file. Here we skip
-	 * empty lines and comments.
-	 *
-	 * initscripts compares: "$line" =~ '^[[:space:]]*(\#.*)?$'
-	 */
-	while (nm_utils_is_separator (line[0]))
-		line++;
-	if (NM_IN_SET (line[0], '\0', '#'))
-		return TRUE;
-	return FALSE;
-}
+#endif
 
 /*****************************************************************************/
 
-typedef struct {
-	const char *key;
-
-	/* the element is not available in this case. */
-	bool disabled:1;
-
-	/* whether the element is to be ignored. Ignord is different from
-	 * "disabled", because we still parse the option, but don't use it. */
-	bool ignore:1;
-
-	bool int_base_16:1;
-
-	/* whether the command line option was found, and @v is
-	 * initialized. */
-	bool has:1;
-
-	/* the type, one of PARSE_LINE_TYPE_* */
-	char type;
-
-	union {
-		guint8 uint8;
-		guint32 uint32;
-		struct {
-			guint32 uint32;
-			bool lock:1;
-		} uint32_with_lock;
-		struct {
-			NMIPAddr addr;
-			guint8 plen;
-			bool has_plen:1;
-		} addr;
-	} v;
-
-} ParseLineInfo;
-
-enum {
-	/* route attributes */
-	PARSE_LINE_ATTR_ROUTE_TABLE,
-	PARSE_LINE_ATTR_ROUTE_SRC,
-	PARSE_LINE_ATTR_ROUTE_FROM,
-	PARSE_LINE_ATTR_ROUTE_TOS,
-	PARSE_LINE_ATTR_ROUTE_ONLINK,
-	PARSE_LINE_ATTR_ROUTE_WINDOW,
-	PARSE_LINE_ATTR_ROUTE_CWND,
-	PARSE_LINE_ATTR_ROUTE_INITCWND,
-	PARSE_LINE_ATTR_ROUTE_INITRWND,
-	PARSE_LINE_ATTR_ROUTE_MTU,
-
-	/* iproute2 arguments that only matter when parsing the file. */
-	PARSE_LINE_ATTR_ROUTE_TO,
-	PARSE_LINE_ATTR_ROUTE_VIA,
-	PARSE_LINE_ATTR_ROUTE_METRIC,
-
-	/* iproute2 parameters that are well known and that we silently ignore. */
-	PARSE_LINE_ATTR_ROUTE_DEV,
-};
-
-#define PARSE_LINE_TYPE_UINT8             '8'
-#define PARSE_LINE_TYPE_UINT32            'u'
-#define PARSE_LINE_TYPE_UINT32_WITH_LOCK  'l'
-#define PARSE_LINE_TYPE_ADDR              'a'
-#define PARSE_LINE_TYPE_ADDR_WITH_PREFIX  'p'
-#define PARSE_LINE_TYPE_IFNAME            'i'
-#define PARSE_LINE_TYPE_FLAG              'f'
-
-/**
- * parse_route_line:
- * @line: the line to parse. This is either a line from the route-* or route6-* file,
- *   or the numbered OPTIONS setting.
- * @addr_family: the address family.
- * @options_route: (in-out): when line is from the OPTIONS setting, this is a pre-created
- *   route object that is completed with the settings from options. Otherwise,
- *   it shall point to %NULL and a new route is created and returned.
- * @out_route: (out) (transfer-full) (allow-none): the parsed %NMIPRoute instance.
- *   In case a @options_route is passed in, it returns the input route that was modified
- *   in-place. But the caller must unref the returned route in either case.
- * @error: the failure description.
- *
- * Parsing the route options line has two modes: one for the numbered OPTIONS
- * setting, and one for initscript's handle_ip_file(), which takes the lines
- * and passes them to `ip route add`. The modes are similar, but certain properties
- * are not allowed for OPTIONS.
- * The mode is differentiated by having an @options_route argument.
- *
- * Returns: returns a negative errno on failure. On success, it returns 0
- *   and @out_route.
- */
-static int
-parse_route_line (const char *line,
-                  int addr_family,
-                  NMIPRoute *options_route,
-                  NMIPRoute **out_route,
-                  GError **error)
-{
-	nm_auto_unref_ip_route NMIPRoute *route = NULL;
-	gs_free const char **words_free = NULL;
-	const char *const*words;
-	const char *s;
-	gsize i_words;
-	guint i;
-	char buf1[256];
-	char buf2[256];
-	ParseLineInfo infos[] = {
-		[PARSE_LINE_ATTR_ROUTE_TABLE]     = { .key = NM_IP_ROUTE_ATTRIBUTE_TABLE,
-		                                      .type = PARSE_LINE_TYPE_UINT32, },
-		[PARSE_LINE_ATTR_ROUTE_SRC]       = { .key = NM_IP_ROUTE_ATTRIBUTE_SRC,
-		                                      .type = PARSE_LINE_TYPE_ADDR, },
-		[PARSE_LINE_ATTR_ROUTE_FROM]      = { .key = NM_IP_ROUTE_ATTRIBUTE_FROM,
-		                                      .type = PARSE_LINE_TYPE_ADDR_WITH_PREFIX,
-		                                      .disabled = (addr_family != AF_INET6), },
-		[PARSE_LINE_ATTR_ROUTE_TOS]       = { .key = NM_IP_ROUTE_ATTRIBUTE_TOS,
-		                                      .type = PARSE_LINE_TYPE_UINT8,
-		                                      .int_base_16 = TRUE,
-		                                      .ignore = (addr_family != AF_INET), },
-		[PARSE_LINE_ATTR_ROUTE_ONLINK]    = { .key = NM_IP_ROUTE_ATTRIBUTE_ONLINK,
-		                                      .type = PARSE_LINE_TYPE_FLAG,
-		                                      .ignore = (addr_family != AF_INET), },
-		[PARSE_LINE_ATTR_ROUTE_WINDOW]    = { .key = NM_IP_ROUTE_ATTRIBUTE_WINDOW,
-		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
-		[PARSE_LINE_ATTR_ROUTE_CWND]      = { .key = NM_IP_ROUTE_ATTRIBUTE_CWND,
-		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
-		[PARSE_LINE_ATTR_ROUTE_INITCWND]  = { .key = NM_IP_ROUTE_ATTRIBUTE_INITCWND,
-		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
-		[PARSE_LINE_ATTR_ROUTE_INITRWND]  = { .key = NM_IP_ROUTE_ATTRIBUTE_INITRWND,
-		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
-		[PARSE_LINE_ATTR_ROUTE_MTU]       = { .key = NM_IP_ROUTE_ATTRIBUTE_MTU,
-		                                      .type = PARSE_LINE_TYPE_UINT32_WITH_LOCK, },
-
-		[PARSE_LINE_ATTR_ROUTE_TO]        = { .key = "to",
-		                                      .type = PARSE_LINE_TYPE_ADDR_WITH_PREFIX,
-		                                      .disabled = (options_route != NULL), },
-		[PARSE_LINE_ATTR_ROUTE_VIA]       = { .key = "via",
-		                                      .type = PARSE_LINE_TYPE_ADDR,
-		                                      .disabled = (options_route != NULL), },
-		[PARSE_LINE_ATTR_ROUTE_METRIC]    = { .key = "metric",
-		                                      .type = PARSE_LINE_TYPE_UINT32,
-		                                      .disabled = (options_route != NULL), },
-
-		[PARSE_LINE_ATTR_ROUTE_DEV]       = { .key = "dev",
-		                                      .type = PARSE_LINE_TYPE_IFNAME,
-		                                      .ignore = TRUE,
-		                                      .disabled = (options_route != NULL), },
-	};
-
-	nm_assert (line);
-	nm_assert_addr_family (addr_family);
-	nm_assert (!options_route || nm_ip_route_get_family (options_route) == addr_family);
-
-	/* initscripts read the legacy route file line-by-line and
-	 * use it as `ip route add $line`, thus doing split+glob.
-	 * Splitting on IFS (which we consider '<space><tab><newline>')
-	 * and globbing (which we obviously don't do).
-	 *
-	 * I think it's a mess, because it doesn't support escaping or
-	 * quoting. In fact, it can only encode benign values.
-	 *
-	 * We also use the same form for the numbered OPTIONS
-	 * variable. I think it's bad not to support any form of
-	 * escaping. But do that for now.
-	 *
-	 * Maybe later we want to support some form of quotation here.
-	 * Which of course, would be incompatible with initscripts.
-	 */
-	words_free = nm_utils_strsplit_set (line, " \t\n");
-
-	words = words_free ?: NM_PTRARRAY_EMPTY (const char *);
-
-	for (i_words = 0; words[i_words]; ) {
-		const gsize i_words0 = i_words;
-		const char *const w = words[i_words0];
-		ParseLineInfo *info;
-		gboolean unqualified_addr = FALSE;
-
-		for (i = 0; i < G_N_ELEMENTS (infos); i++) {
-			info = &infos[i];
-
-			if (info->disabled)
-				continue;
-
-			if (!nm_streq (w, info->key))
-				continue;
-
-			if (info->has) {
-				/* iproute2 for most arguments allows specifying them multiple times.
-				 * Let's not do that. */
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Duplicate option \"%s\"", w);
-				return -EINVAL;
-			}
-
-			info->has = TRUE;
-			switch (info->type) {
-			case PARSE_LINE_TYPE_UINT8:
-				i_words++;
-				goto parse_line_type_uint8;
-			case PARSE_LINE_TYPE_UINT32:
-				i_words++;
-				goto parse_line_type_uint32;
-			case PARSE_LINE_TYPE_UINT32_WITH_LOCK:
-				i_words++;
-				goto parse_line_type_uint32_with_lock;
-			case PARSE_LINE_TYPE_ADDR:
-				i_words++;
-				goto parse_line_type_addr;
-			case PARSE_LINE_TYPE_ADDR_WITH_PREFIX:
-				i_words++;
-				goto parse_line_type_addr_with_prefix;
-			case PARSE_LINE_TYPE_IFNAME:
-				i_words++;
-				goto parse_line_type_ifname;
-			case PARSE_LINE_TYPE_FLAG:
-				i_words++;
-				goto next;
-			default:
-				nm_assert_not_reached ();
-			}
-		}
-
-		/* "to" is also accepted unqualified... (once) */
-		info = &infos[PARSE_LINE_ATTR_ROUTE_TO];
-		if (!info->has && !info->disabled) {
-			unqualified_addr = TRUE;
-			info->has = TRUE;
-			goto parse_line_type_addr;
-		}
-
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Unrecognized argument (\"to\" is duplicate or \"%s\" is garbage)", w);
-		return -EINVAL;
-
-parse_line_type_uint8:
-		s = words[i_words];
-		if (!s)
-			goto err_word_missing_argument;
-		info->v.uint8 = _nm_utils_ascii_str_to_int64 (s,
-		                                              info->int_base_16 ? 16 : 10,
-		                                              0,
-		                                              G_MAXUINT8,
-		                                              0);;
-		if (errno) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Argument for \"%s\" is not a valid number", w);
-			return -EINVAL;
-		}
-		i_words++;
-		goto next;
-
-parse_line_type_uint32:
-parse_line_type_uint32_with_lock:
-		s = words[i_words];
-		if (!s)
-			goto err_word_missing_argument;
-		if (info->type == PARSE_LINE_TYPE_UINT32_WITH_LOCK) {
-			if (nm_streq (s, "lock")) {
-				s = words[++i_words];
-				if (!s)
-					goto err_word_missing_argument;
-				info->v.uint32_with_lock.lock = TRUE;
-			} else
-				info->v.uint32_with_lock.lock = FALSE;
-			info->v.uint32_with_lock.uint32 = _nm_utils_ascii_str_to_int64 (s, 10, 0, G_MAXUINT32, 0);;
-		} else {
-			info->v.uint32 = _nm_utils_ascii_str_to_int64 (s, 10, 0, G_MAXUINT32, 0);
-		}
-		if (errno) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Argument for \"%s\" is not a valid number", w);
-			return -EINVAL;
-		}
-		i_words++;
-		goto next;
-
-parse_line_type_ifname:
-		s = words[i_words];
-		if (!s)
-			goto err_word_missing_argument;
-		i_words++;
-		goto next;
-
-parse_line_type_addr:
-parse_line_type_addr_with_prefix:
-		s = words[i_words];
-		if (!s)
-			goto err_word_missing_argument;
-		{
-			int prefix = -1;
-
-			if (info->type == PARSE_LINE_TYPE_ADDR) {
-				if (!nm_utils_parse_inaddr_bin (addr_family,
-				                                s,
-				                                NULL,
-				                                &info->v.addr.addr)) {
-					if (   info == &infos[PARSE_LINE_ATTR_ROUTE_VIA]
-					    && nm_streq (s, "(null)")) {
-						/* Due to a bug, would older versions of NM write "via (null)"
-						 * (rh#1452648). Workaround that, and accept it.*/
-						memset (&info->v.addr.addr, 0, sizeof (info->v.addr.addr));
-					} else {
-						if (unqualified_addr) {
-							g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-							             "Unrecognized argument (inet prefix is expected rather then \"%s\")", w);
-							return -EINVAL;
-						} else {
-							g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-							             "Argument for \"%s\" is not a valid IPv%c address", w,
-							             addr_family == AF_INET ? '4' : '6');
-						}
-						return -EINVAL;
-					}
-				}
-			} else {
-				nm_assert (info->type == PARSE_LINE_TYPE_ADDR_WITH_PREFIX);
-				if (   info == &infos[PARSE_LINE_ATTR_ROUTE_TO]
-				    && nm_streq (s, "default")) {
-					memset (&info->v.addr.addr, 0, sizeof (info->v.addr.addr));
-					prefix = 0;
-				} else if (!nm_utils_parse_inaddr_prefix_bin (addr_family,
-				                                              s,
-				                                              NULL,
-				                                              &info->v.addr.addr,
-				                                              &prefix)) {
-					g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-					             "Argument for \"%s\" is not ADDR/PREFIX format", w);
-					return -EINVAL;
-				}
-			}
-			if (prefix == -1)
-				info->v.addr.has_plen = FALSE;
-			else {
-				info->v.addr.has_plen = TRUE;
-				info->v.addr.plen = prefix;
-			}
-		}
-		i_words++;
-		goto next;
-
-err_word_missing_argument:
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing argument for \"%s\"", w);
-		return -EINVAL;
-next:
-		;
-	}
-
-	if (options_route) {
-		route = options_route;
-		nm_ip_route_ref (route);
-	} else {
-		ParseLineInfo *info_to = &infos[PARSE_LINE_ATTR_ROUTE_TO];
-		ParseLineInfo *info_via = &infos[PARSE_LINE_ATTR_ROUTE_VIA];
-		ParseLineInfo *info_metric = &infos[PARSE_LINE_ATTR_ROUTE_METRIC];
-		guint prefix;
-
-		if (!info_to->has) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Missing destination prefix");
-			return -EINVAL;
-		}
-
-		prefix =   info_to->v.addr.has_plen
-		         ? info_to->v.addr.plen
-		         : (addr_family == AF_INET ? 32 : 128);
-
-		route = nm_ip_route_new_binary (addr_family,
-		                                &info_to->v.addr.addr,
-		                                prefix,
-		                                info_via->has ? &info_via->v.addr.addr : NULL,
-		                                info_metric->has ? (gint64) info_metric->v.uint32 : (gint64) -1,
-		                                error);
-		info_to->has = FALSE;
-		info_via->has = FALSE;
-		info_metric->has = FALSE;
-		if (!route)
-			return -EINVAL;
-	}
-
-	for (i = 0; i < G_N_ELEMENTS (infos); i++) {
-		ParseLineInfo *info = &infos[i];
-
-		if (!info->has)
-			continue;
-		if (info->ignore || info->disabled)
-			continue;
-		switch (info->type) {
-		case PARSE_LINE_TYPE_UINT8:
-			nm_ip_route_set_attribute (route,
-			                           info->key,
-			                           g_variant_new_byte (info->v.uint8));
-			break;
-		case PARSE_LINE_TYPE_UINT32:
-			nm_ip_route_set_attribute (route,
-			                           info->key,
-			                           g_variant_new_uint32 (info->v.uint32));
-			break;
-		case PARSE_LINE_TYPE_UINT32_WITH_LOCK:
-			if (info->v.uint32_with_lock.lock) {
-				nm_ip_route_set_attribute (route,
-				                           nm_sprintf_buf (buf1, "lock-%s", info->key),
-				                           g_variant_new_boolean (TRUE));
-			}
-			nm_ip_route_set_attribute (route,
-			                           info->key,
-			                           g_variant_new_uint32 (info->v.uint32_with_lock.uint32));
-			break;
-		case PARSE_LINE_TYPE_ADDR:
-		case PARSE_LINE_TYPE_ADDR_WITH_PREFIX:
-			nm_ip_route_set_attribute (route,
-			                           info->key,
-			                           g_variant_new_printf ("%s%s",
-			                                                 inet_ntop (addr_family, &info->v.addr.addr, buf1, sizeof (buf1)),
-			                                                 info->v.addr.has_plen
-			                                                    ? nm_sprintf_buf (buf2, "/%u", (unsigned) info->v.addr.plen)
-			                                                    : ""));
-			break;
-		case PARSE_LINE_TYPE_FLAG:
-			/* NOTE: the flag (for "onlink") only allows to explicitly set "TRUE".
-			 * There is no way to express an explicit "FALSE" setting
-			 * of this attribute, hence, the file format cannot encode
-			 * that configuration. */
-			nm_ip_route_set_attribute (route,
-			                           info->key,
-			                           g_variant_new_boolean (TRUE));
-			break;
-		default:
-			nm_assert_not_reached ();
-			break;
-		}
-	}
-
-	nm_assert (_nm_ip_route_attribute_validate_all (route));
-
-	NM_SET_OUT (out_route, g_steal_pointer (&route));
-	return 0;
-}
-
-/* Returns TRUE on missing route or valid route */
-static gboolean
-read_one_ip4_route (shvarFile *netplan,
-                    guint32 which,
-                    NMIPRoute **out_route,
-                    GError **error)
-{
-	char tag[256];
-	char netmask_tag[256];
-	guint32 dest;
-	guint32 next_hop;
-	guint32 netmask;
-	gboolean has_key;
-	const char *v;
-	gs_free char *value = NULL;
-	gint64 prefix, metric;
-	char inet_buf[NM_UTILS_INET_ADDRSTRLEN];
-
-	g_return_val_if_fail (netplan != NULL, FALSE);
-	g_return_val_if_fail (out_route && !*out_route, FALSE);
-	g_return_val_if_fail (!error || !*error, FALSE);
-
-	/* Destination */
-	if (!read_ip4_address (netplan,
-	                       numbered_tag (tag, "ADDRESS", which),
-	                       &has_key, &dest, error))
-		return FALSE;
-	if (!has_key) {
-		/* missing route = success */
-		*out_route = NULL;
-		return TRUE;
-	}
-
-	/* Next hop */
-	if (!read_ip4_address (netplan,
-	                       numbered_tag (tag, "GATEWAY", which),
-	                       NULL, &next_hop, error))
-		return FALSE;
-	/* We don't make distinction between missing GATEWAY IP and 0.0.0.0 */
-
-	/* Prefix */
-	if (!read_ip4_address (netplan,
-	                       numbered_tag (netmask_tag, "NETMASK", which),
-	                       &has_key, &netmask, error))
-		return FALSE;
-	if (has_key) {
-		prefix = nm_utils_ip4_netmask_to_prefix (netmask);
-		if (netmask != _nm_utils_ip4_prefix_to_netmask (prefix)) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid IP4 netmask '%s' \"%s\"", netmask_tag, nm_utils_inet4_ntop (netmask, inet_buf));
-			return FALSE;
-		}
-	} else {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing IP4 route element '%s'", netmask_tag);
-		return FALSE;
-	}
-
-	/* Metric */
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, numbered_tag (tag, "METRIC", which), &value);
-	if (v) {
-		metric = _nm_utils_ascii_str_to_int64 (v, 10, 0, G_MAXUINT32, -1);
-		if (metric < 0) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid IP4 route metric '%s'", v);
-			return FALSE;
-		}
-	} else
-		metric = -1;
-
-	*out_route = nm_ip_route_new_binary (AF_INET, &dest, prefix, &next_hop, metric, error);
-	if (!*out_route)
-		return FALSE;
-
-	/* Options */
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, numbered_tag (tag, "OPTIONS", which), &value);
-	if (v) {
-		if (parse_route_line (v, AF_INET, *out_route, NULL, error) < 0) {
-			g_clear_pointer (out_route, nm_ip_route_unref);
-			return FALSE;
-		}
-	}
-
-	return TRUE;
-}
-
-static gboolean
-read_route_file (int addr_family,
-                 const char *filename,
-                 NMSettingIPConfig *s_ip,
-                 GError **error)
-{
-	gs_free char *contents = NULL;
-	char *contents_rest = NULL;
-	const char *line;
-	gsize len = 0;
-	gsize line_num;
-
-	g_return_val_if_fail (filename, FALSE);
-	g_return_val_if_fail (   (addr_family == AF_INET  && NM_IS_SETTING_IP4_CONFIG (s_ip))
-	                      || (addr_family == AF_INET6 && NM_IS_SETTING_IP6_CONFIG (s_ip)), FALSE);
-	g_return_val_if_fail (!error || !*error, FALSE);
-
-	if (   !g_file_get_contents (filename, &contents, &len, NULL)
-	    || !len) {
-		return TRUE;  /* missing/empty = success */
-	}
-
-	line_num = 0;
-	for (line = strtok_r (contents, "\n", &contents_rest);
-	     line;
-	     line = strtok_r (NULL, "\n", &contents_rest)) {
-		nm_auto_unref_ip_route NMIPRoute *route = NULL;
-		gs_free_error GError *local = NULL;
-		int e;
-
-		line_num++;
-
-		if (parse_route_line_is_comment (line))
-			continue;
-
-		e = parse_route_line (line, addr_family, NULL, &route, &local);
-
-		if (e < 0) {
-			if (e == -ERANGE)
-				PARSE_WARNING ("ignoring manual default route: '%s' (%s)", line, filename);
-			else {
-				/* we accept all unrecognized lines, because otherwise we would reject the
-				 * entire connection. */
-				PARSE_WARNING ("ignoring invalid route at \"%s\" (%s:%lu): %s", line, filename, (long unsigned) line_num, local->message);
-			}
-			continue;
-		}
-
-		if (!nm_setting_ip_config_add_route (s_ip, route))
-			PARSE_WARNING ("duplicate IPv%c route", addr_family == AF_INET ? '4' : '6');
-	}
-
-	return TRUE;
-}
-
+#if 0
 static void
 parse_dns_options (NMSettingIPConfig *ip_config, const char *value)
 {
@@ -1342,9 +542,11 @@ parse_dns_options (NMSettingIPConfig *ip_config, const char *value)
 		}
 	}
 }
+#endif
 
+#if 0
 static gboolean
-parse_full_ip6_address (shvarFile *netplan,
+parse_full_ip6_address (NetplanNetDefinition *nd,
                         const char *addr_str,
                         int i,
                         NMIPAddress **out_address,
@@ -1378,9 +580,11 @@ parse_full_ip6_address (shvarFile *netplan,
 	*out_address = addr;
 	return TRUE;
 }
+#endif
 
+#if 0   /* TODO: Support user settings in netplan schema */
 static NMSetting *
-make_user_setting (shvarFile *netplan)
+make_user_setting (NetplanNetDefinition *nd)
 {
 	gboolean has_user_data = FALSE;
 	gs_unref_object NMSettingUser *s_user = NULL;
@@ -1389,10 +593,6 @@ make_user_setting (shvarFile *netplan)
 	const char *key;
 	nm_auto_free_gstring GString *str = NULL;
 
-	keys = svGetKeys (netplan, SV_KEY_TYPE_USER);
-	if (!keys)
-		return NULL;
-
 	g_hash_table_iter_init (&iter, keys);
 	while (g_hash_table_iter_next (&iter, (gpointer *) &key, NULL)) {
 		const char *value;
@@ -1423,34 +623,28 @@ make_user_setting (shvarFile *netplan)
 	       ? NM_SETTING (g_steal_pointer (&s_user))
 	       : NULL;
 }
+#endif /* user settings */
 
 static NMSetting *
-make_match_setting (shvarFile *netplan)
+make_match_setting (NetplanNetDefinition *nd)
 {
 	NMSettingMatch *s_match = NULL;
-	gs_free const char **strv = NULL;
-	gs_free char *value = NULL;
 	const char *v;
-	gsize i;
 
-	v = svGetValueStr (netplan, "MATCH_INTERFACE_NAME", &value);
+	s_match = (NMSettingMatch *) nm_setting_match_new ();
+
+	v = nd->match.original_name;
 	if (!v)
 		return NULL;
 
-	strv = nm_utils_escaped_tokens_split (v, NM_ASCII_SPACES);
-	if (strv) {
-		for (i = 0; strv[i]; i++) {
-			if (!s_match)
-				s_match = (NMSettingMatch *) nm_setting_match_new ();
-			nm_setting_match_add_interface_name (s_match, strv[i]);
-		}
-	}
+	nm_setting_match_add_interface_name (s_match, v);
 
 	return (NMSetting *) s_match;
 }
 
+#if 0  /* TODO: proxy support */
 static NMSetting *
-make_proxy_setting (shvarFile *netplan)
+make_proxy_setting (NetplanNetDefinition *nd)
 {
 	NMSettingProxy *s_proxy = NULL;
 	gs_free char *value = NULL;
@@ -1497,26 +691,26 @@ make_proxy_setting (shvarFile *netplan)
 
 	return NM_SETTING (s_proxy);
 }
+#endif  /* proxy support */
 
 static NMSetting *
-make_ip4_setting (shvarFile *netplan,
-                  shvarFile *network_netplan,
-                  gboolean routes_read,
-                  gboolean *out_has_defroute,
-                  GError **error)
+make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 {
 	gs_unref_object NMSettingIPConfig *s_ip4 = NULL;
 	gs_free char *route_path = NULL;
 	gs_free char *value = NULL;
+	gs_free char *dns_options_free = NULL;
+	gs_free char *gateway = NULL;
+
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+
+#if 0  /* TODO: Review defroute magic for never-default */
 	const char *v;
 	char *method;
-	gs_free char *dns_options_free = NULL;
 	const char *dns_options = NULL;
-	gs_free char *gateway = NULL;
 	int i;
 	guint32 a;
 	gboolean has_key;
-	shvarFile *route_netplan;
 	gboolean never_default;
 	gint64 timeout;
 	int priority;
@@ -1525,8 +719,6 @@ make_ip4_setting (shvarFile *netplan,
 
 	nm_assert (out_has_defroute && !*out_has_defroute);
 
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-
 	/* First check if DEFROUTE is set for this device; DEFROUTE has the
 	 * opposite meaning from never-default. The default if DEFROUTE is not
 	 * specified is DEFROUTE=yes which means that this connection can be used
@@ -1591,22 +783,24 @@ make_ip4_setting (shvarFile *netplan,
 		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing (IPV4_ROUTE_TABLE) is ignored");
 		route_table = 0;
 	}
+#endif
 
+	/* TODO: map real values for ipv4 -- method + options */
 	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, method,
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (netplan, "PEERDNS", TRUE),
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (netplan, "PEERROUTES", TRUE),
-	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, never_default,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (netplan, "IPV4_FAILURE_FATAL", FALSE),
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (netplan, "IPV4_ROUTE_METRIC", 10,
-	                                                                  -1, G_MAXUINT32, -1),
-	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, (guint) route_table,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, FALSE,
+	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, FALSE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, FALSE,
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, 100,
+	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, 0,
 	              NULL);
 
-	if (nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED))
-		return NM_SETTING (g_steal_pointer (&s_ip4));
+	//if (nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED))
+	//	return NM_SETTING (g_steal_pointer (&s_ip4));
 
 	/* Handle DHCP settings */
+#if 0
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "DHCP_HOSTNAME", &value);
 	if (v)
@@ -1679,7 +873,9 @@ make_ip4_setting (shvarFile *netplan,
 
 	if (gateway && never_default)
 		PARSE_WARNING ("GATEWAY will be ignored when DEFROUTE is disabled");
+#endif
 
+#if 0  /* TODO: Set up method SHARED. */
 	/* We used to skip saving a lot of unused properties for the ipv4 shared method.
 	 * We want now to persist them but... unfortunately loading DNS or DOMAIN options
 	 * would cause a fail in the ipv4 verify() function. As we don't want any regression
@@ -1729,7 +925,9 @@ make_ip4_setting (shvarFile *netplan,
 	nm_clear_g_free (&value);
 	parse_dns_options (s_ip4, svGetValue (netplan, "RES_OPTIONS", &value));
 	parse_dns_options (s_ip4, dns_options);
+#endif /* shared */
 
+#if 0  /* TODO: DNS prio, routes */
 	/* DNS priority */
 	priority = svGetValueInt64 (netplan, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
 	g_object_set (s_ip4,
@@ -1794,128 +992,19 @@ make_ip4_setting (shvarFile *netplan,
 			timeout *= 1000;
 	}
 	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DAD_TIMEOUT, (int) timeout, NULL);
+#endif  /* DNS prio, routes */
 
 	return NM_SETTING (g_steal_pointer (&s_ip4));
 }
 
-static void
-read_aliases (NMSettingIPConfig *s_ip4, gboolean read_defroute, const char *filename)
-{
-	GDir *dir;
-	gs_free char *dirname  = NULL;
-	gs_free char *base  = NULL;
-	NMIPAddress *base_addr = NULL;
-	GError *err = NULL;
-
-	g_return_if_fail (s_ip4 != NULL);
-	g_return_if_fail (filename != NULL);
-
-	if (nm_setting_ip_config_get_num_addresses (s_ip4) > 0)
-		base_addr = nm_setting_ip_config_get_address (s_ip4, 0);
-
-	dirname = g_path_get_dirname (filename);
-	nm_assert (dirname != NULL);
-	base = g_path_get_basename (filename);
-	nm_assert (base != NULL);
-
-	dir = g_dir_open (dirname, 0, &err);
-	if (dir) {
-		const char *item;
-		NMIPAddress *addr;
-		gboolean ok;
-
-		while ((item = g_dir_read_name (dir))) {
-			nm_auto_shvar_file_close shvarFile *parsed = NULL;
-			gs_free char *gateway = NULL;
-			gs_free char *device_value = NULL;
-			gs_free char *full_path = NULL;
-			const char *device;
-			const char *p;
-
-			if (!utils_is_netplan_alias_file (item, base))
-				continue;
-
-			full_path = g_build_filename (dirname, item, NULL);
-
-			p = strchr (item, ':');
-			g_assert (p != NULL); /* we know this is true from utils_is_netplan_alias_file() */
-			for (p++; *p; p++) {
-				if (!g_ascii_isalnum (*p) && *p != '_')
-					break;
-			}
-			if (*p) {
-				PARSE_WARNING ("ignoring alias file '%s' with invalid name", full_path);
-				continue;
-			}
-
-			parsed = svOpenFile (full_path, &err);
-			if (!parsed) {
-				PARSE_WARNING ("couldn't parse alias file '%s': %s", full_path, err->message);
-				g_clear_error (&err);
-				continue;
-			}
-
-			device = svGetValueStr (parsed, "DEVICE", &device_value);
-			if (!device) {
-				PARSE_WARNING ("alias file '%s' has no DEVICE", full_path);
-				continue;
-			}
-			/* We know that item starts with NETPLAN_TAG from utils_is_netplan_alias_file() */
-			if (strcmp (device, item + strlen (NETPLAN_TAG)) != 0) {
-				PARSE_WARNING ("alias file '%s' has invalid DEVICE (%s) for filename",
-				               full_path, device);
-				continue;
-			}
-
-			addr = NULL;
-			ok = read_full_ip4_address (parsed, -1, base_addr, &addr,
-			                            read_defroute ? &gateway : NULL,
-			                            &err);
-			if (ok) {
-				nm_ip_address_set_attribute (addr, NM_IP_ADDRESS_ATTRIBUTE_LABEL, g_variant_new_string (device));
-				if (!nm_setting_ip_config_add_address (s_ip4, addr))
-					PARSE_WARNING ("duplicate IP4 address in alias file %s", item);
-				if (nm_streq0 (nm_setting_ip_config_get_method (s_ip4), NM_SETTING_IP4_CONFIG_METHOD_DISABLED))
-					g_object_set (s_ip4, NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL, NULL);
-				if (read_defroute) {
-					int i;
-
-					if (gateway) {
-						g_object_set (s_ip4, NM_SETTING_IP_CONFIG_GATEWAY, gateway, NULL);
-						read_defroute = FALSE;
-					}
-					i = svGetValueBoolean (parsed, "DEFROUTE", -1);
-					if (i != -1) {
-						g_object_set (s_ip4,
-						              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, (gboolean) !i,
-						              NULL);
-						read_defroute = FALSE;
-					}
-				}
-			} else {
-				PARSE_WARNING ("error reading IP4 address from alias file '%s': %s",
-				               full_path, err ? err->message : "no address");
-				g_clear_error (&err);
-			}
-			nm_ip_address_unref (addr);
-		}
-
-		g_dir_close (dir);
-	} else {
-		PARSE_WARNING ("can not read directory '%s': %s", dirname, err->message);
-		g_error_free (err);
-	}
-}
-
 static NMSetting *
-make_ip6_setting (shvarFile *netplan,
-                  shvarFile *network_netplan,
-                  gboolean routes_read,
-                  GError **error)
+make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 {
 	gs_unref_object NMSettingIPConfig *s_ip6 = NULL;
-	const char *v;
 	gs_free char *value = NULL;
+	gs_free const char **list = NULL;
+#if 0
+	const char *v;
 	gboolean ipv6init;
 	gboolean ipv6forwarding;
 	gboolean disabled;
@@ -1924,7 +1013,6 @@ make_ip6_setting (shvarFile *netplan,
 	const char *ipv6addr, *ipv6addr_secondaries;
 	gs_free char *ipv6addr_to_free = NULL;
 	gs_free char *ipv6addr_secondaries_to_free = NULL;
-	gs_free const char **list = NULL;
 	const char *const *iter;
 	guint32 i;
 	int i_val;
@@ -1934,16 +1022,20 @@ make_ip6_setting (shvarFile *netplan,
 	gboolean ip6_privacy = FALSE, ip6_privacy_prefer_public_ip;
 	NMSettingIP6ConfigPrivacy ip6_privacy_val;
 	guint32 route_table;
+#endif
 
 	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
 
+#if 0  /* TODO: never-default for ipv6 */
 	/* First check if IPV6_DEFROUTE is set for this device; IPV6_DEFROUTE has the
 	 * opposite meaning from never-default. The default if IPV6_DEFROUTE is not
 	 * specified is IPV6_DEFROUTE=yes which means that this connection can be used
 	 * as a default route
 	 */
 	never_default = !svGetValueBoolean (netplan, "IPV6_DEFROUTE", TRUE);
+#endif
 
+#if 0  /* TODO: ipv6 gateway and all */
 	/* Then check if IPV6_DEFAULTGW or IPV6_DEFAULTDEV is specified;
 	 * they are global and override IPV6_DEFROUTE
 	 * When both are set, the device specified in IPV6_DEFAULTGW takes preference.
@@ -1985,7 +1077,9 @@ make_ip6_setting (shvarFile *netplan,
 		if (network_netplan)
 			ipv6init = svGetValueBoolean (network_netplan, "IPV6INIT", FALSE);
 	}
+#endif  /* defaults ipv6 */
 
+#if 0  /* TODO: ipv6 config methods */
 	if (disabled)
 		method = NM_SETTING_IP6_CONFIG_METHOD_DISABLED;
 	else if (!ipv6init)
@@ -2041,24 +1135,28 @@ make_ip6_setting (shvarFile *netplan,
 		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing (IPV6_ROUTE_TABLE) is ignored");
 		route_table = 0;
 	}
+#endif  /* ipv6 methods and settings */
 
+	// TODO: make a real s_ip6 object
 	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, method,
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, !svGetValueBoolean (netplan, "IPV6_PEERDNS", TRUE),
-	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, !svGetValueBoolean (netplan, "IPV6_PEERROUTES", TRUE),
-	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, never_default,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, !svGetValueBoolean (netplan, "IPV6_FAILURE_FATAL", FALSE),
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, svGetValueInt64 (netplan, "IPV6_ROUTE_METRIC", 10,
-	                                                                  -1, G_MAXUINT32, -1),
-	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, (guint) route_table,
-	              NM_SETTING_IP6_CONFIG_IP6_PRIVACY, ip6_privacy_val,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
+	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, FALSE,
+	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, FALSE,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, FALSE,
+	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, 100,
+	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, 0,
+	              NM_SETTING_IP6_CONFIG_IP6_PRIVACY, NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
 	              NULL);
 
+#if 0
 	/* Don't bother to read IP, DNS and routes when IPv6 is disabled */
 	if (NM_IN_STRSET (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
 	                          NM_SETTING_IP6_CONFIG_METHOD_DISABLED))
 		return NM_SETTING (g_steal_pointer (&s_ip6));
+#endif
 
+#if 0  /* TODO: IPv6 DUID, hostname and special DHCP options */
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "DHCPV6_DUID", &value);
 	if (v)
@@ -2081,7 +1179,9 @@ make_ip6_setting (shvarFile *netplan,
 
 	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME,
 	              svGetValueBoolean (netplan, "DHCPV6_SEND_HOSTNAME", TRUE), NULL);
+#endif  /* IPv6 DUID, hostname and special DHCP options */
 
+#if 0  /* TODO: IPv6: read static addresses. */
 	/* Read static IP addresses.
 	 * Read them even for AUTO and DHCP methods - in this case the addresses are
 	 * added to the automatic ones. Note that this is not currently supported by
@@ -2107,7 +1207,9 @@ make_ip6_setting (shvarFile *netplan,
 			PARSE_WARNING ("duplicate IP6 address");
 		nm_ip_address_unref (addr);
 	}
+#endif  /* IPv6: read static addresses. */
 
+#if 0  /* IPv6: read gateway. */
 	/* Gateway */
 	if (nm_setting_ip_config_get_num_addresses (s_ip6)) {
 		nm_clear_g_free (&value);
@@ -2147,7 +1249,9 @@ make_ip6_setting (shvarFile *netplan,
 	v = svGetValueStr (netplan, "IPV6_TOKEN", &value);
 	if (v)
 		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_TOKEN, v, NULL);
+#endif
 
+#if 0  /* TODO: set dns servers */
 	/* DNS servers
 	 * Pick up just IPv6 addresses (IPv4 addresses are taken by make_ip4_setting())
 	 */
@@ -2172,7 +1276,9 @@ make_ip6_setting (shvarFile *netplan,
 			return NULL;
 		}
 	}
+#endif
 
+#if 0  /* TODO: ipv6 routes */
 	if (!routes_read) {
 		/* NOP */
 	} else {
@@ -2183,7 +1289,9 @@ make_ip6_setting (shvarFile *netplan,
 		if (!read_route_file (AF_INET6, route6_path, s_ip6, error))
 			return NULL;
 	}
+#endif  /* ipv6 routes */
 
+#if 0  /* TODO: IPv6 DNS searches */
 	/* DNS searches */
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "IPV6_DOMAIN", &value);
@@ -2209,2693 +1317,636 @@ make_ip6_setting (shvarFile *netplan,
 	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
 	              priority,
 	              NULL);
+#endif
 
 	return NM_SETTING (g_steal_pointer (&s_ip6));
 }
 
-static NMSetting *
-make_sriov_setting (shvarFile *netplan)
-{
-	gs_unref_hashtable GHashTable *keys = NULL;
-	gs_unref_ptrarray GPtrArray *vfs = NULL;
-	int autoprobe_drivers;
-	NMSettingSriov *s_sriov;
-	gint64 total_vfs;
-
-
-	total_vfs = svGetValueInt64 (netplan, "SRIOV_TOTAL_VFS", 10, 0, G_MAXUINT32, -1);
-
-	autoprobe_drivers = svGetValueInt64 (netplan,
-	                                     "SRIOV_AUTOPROBE_DRIVERS",
-	                                     10,
-	                                     NM_TERNARY_DEFAULT,
-	                                     NM_TERNARY_TRUE,
-	                                     -2);
-
-	keys = svGetKeys (netplan, SV_KEY_TYPE_SRIOV_VF);
-	if (keys) {
-		GHashTableIter iter;
-		const char *key;
-
-		g_hash_table_iter_init (&iter, keys);
-		while (g_hash_table_iter_next (&iter, (gpointer *) &key, NULL)) {
-			gs_free_error GError *error = NULL;
-			gs_free char *value_to_free = NULL;
-			const char *value;
-			NMSriovVF *vf;
-
-			nm_assert (g_str_has_prefix (key, "SRIOV_VF"));
-
-			value = svGetValue (netplan, key, &value_to_free);
-			if (!value)
-				continue;
-
-			key += NM_STRLEN ("SRIOV_VF");
-
-			vf = _nm_utils_sriov_vf_from_strparts (key, value, TRUE, &error);
-			if (!vf) {
-				PARSE_WARNING ("ignoring invalid SR-IOV VF '%s %s': %s",
-				               key, value, error->message);
-				continue;
-			}
-			if (!vfs)
-				vfs = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_sriov_vf_unref);
-			g_ptr_array_add (vfs, vf);
-		}
-	}
-
-	/* Create the setting when at least one key is set */
-	if (   total_vfs < 0
-	    && !vfs
-	    && autoprobe_drivers < NM_TERNARY_DEFAULT)
-		return NULL;
-
-	s_sriov = (NMSettingSriov *) nm_setting_sriov_new ();
-
-	autoprobe_drivers = NM_MAX (autoprobe_drivers, NM_TERNARY_DEFAULT);
-	total_vfs = NM_MAX (total_vfs, 0);
-
-	g_object_set (s_sriov,
-	              NM_SETTING_SRIOV_TOTAL_VFS, (guint) total_vfs,
-	              NM_SETTING_SRIOV_VFS, vfs,
-	              NM_SETTING_SRIOV_AUTOPROBE_DRIVERS, autoprobe_drivers,
-	              NULL);
+/* TODO: SRIOV */
+/* TODO: TC support */
+/* TODO: DCB support */
 
-	return (NMSetting *) s_sriov;
-}
 
-static NMSetting *
-make_tc_setting (shvarFile *netplan)
+static gboolean
+read_wep_keys (NetplanNetDefinition *nd,
+               NMWepKeyType key_type,
+               guint8 def_idx,
+               NMSettingWirelessSecurity *s_wsec,
+               GError **error)
 {
-	NMSettingTCConfig *s_tc = NULL;
-	char tag[256];
-	int i;
-
-	s_tc = (NMSettingTCConfig *) nm_setting_tc_config_new ();
-
-	for (i = 1;; i++) {
-		NMTCQdisc *qdisc = NULL;
-		gs_free char *value_to_free = NULL;
-		const char *value = NULL;
-		GError *local = NULL;
-
-		value = svGetValueStr (netplan, numbered_tag (tag, "QDISC", i), &value_to_free);
-		if (!value)
-			break;
-
-		qdisc = nm_utils_tc_qdisc_from_str (value, &local);
-		if (!qdisc) {
-			PARSE_WARNING ("ignoring bad tc qdisc: '%s': %s", value, local->message);
-			continue;
-		}
-
-		if (!nm_setting_tc_config_add_qdisc (s_tc, qdisc))
-			PARSE_WARNING ("duplicate tc qdisc");
-
-		nm_tc_qdisc_unref (qdisc);
+	if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
+		if (!add_one_wep_key (netplan, "KEY1", 0, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY2", 1, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY3", 2, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY4", 3, FALSE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY", def_idx, FALSE, s_wsec, error))
+			return FALSE;
 	}
 
-	for (i = 1;; i++) {
-		NMTCTfilter *tfilter = NULL;
-		gs_free char *value_to_free = NULL;
-		const char *value = NULL;
-		GError *local = NULL;
-
-		value = svGetValueStr (netplan, numbered_tag (tag, "FILTER", i), &value_to_free);
-		if (!value)
-			break;
-
-		tfilter = nm_utils_tc_tfilter_from_str (value, &local);
-		if (!tfilter) {
-			PARSE_WARNING ("ignoring bad tc filter: '%s': %s", value, local->message);
-			continue;
-		}
-
-		if (!nm_setting_tc_config_add_tfilter (s_tc, tfilter))
-			PARSE_WARNING ("duplicate tc filter");
-
-		nm_tc_tfilter_unref (tfilter);
+	if (key_type != NM_WEP_KEY_TYPE_KEY) {
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
+			return FALSE;
+		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
+			return FALSE;
 	}
 
-	if (   nm_setting_tc_config_get_num_qdiscs (s_tc) > 0
-	    || nm_setting_tc_config_get_num_tfilters (s_tc) > 0)
-		return NM_SETTING (s_tc);
-
-	g_object_unref (s_tc);
-	return NULL;
+	return TRUE;
 }
 
-typedef struct {
-	const char *enable_key;
-	const char *advertise_key;
-	const char *willing_key;
-	const char *flags_prop;
-} DcbFlagsProperty;
-
-enum {
-	DCB_APP_FCOE_FLAGS = 0,
-	DCB_APP_ISCSI_FLAGS = 1,
-	DCB_APP_FIP_FLAGS = 2,
-	DCB_PFC_FLAGS = 3,
-	DCB_PG_FLAGS = 4,
-};
-
-static DcbFlagsProperty dcb_flags_props[] = {
-	{ KEY_DCB_APP_FCOE_ENABLE,  KEY_DCB_APP_FCOE_ADVERTISE,  KEY_DCB_APP_FCOE_WILLING,  NM_SETTING_DCB_APP_FCOE_FLAGS },
-	{ KEY_DCB_APP_ISCSI_ENABLE, KEY_DCB_APP_ISCSI_ADVERTISE, KEY_DCB_APP_ISCSI_WILLING, NM_SETTING_DCB_APP_ISCSI_FLAGS },
-	{ KEY_DCB_APP_FIP_ENABLE,   KEY_DCB_APP_FIP_ADVERTISE,   KEY_DCB_APP_FIP_WILLING,   NM_SETTING_DCB_APP_FIP_FLAGS },
-	{ KEY_DCB_PFC_ENABLE,       KEY_DCB_PFC_ADVERTISE,       KEY_DCB_PFC_WILLING,       NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS },
-	{ KEY_DCB_PG_ENABLE,        KEY_DCB_PG_ADVERTISE,        KEY_DCB_PG_WILLING,        NM_SETTING_DCB_PRIORITY_GROUP_FLAGS },
-	{ NULL },
-};
-
-static NMSettingDcbFlags
-read_dcb_flags (shvarFile *netplan, DcbFlagsProperty *property)
+static NMSetting *
+make_wep_setting (NetplanNetDefinition *nd,
+                  const char *file,
+                  GError **error)
 {
-	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
-
-	if (svGetValueBoolean (netplan, property->enable_key, FALSE))
-		flags |= NM_SETTING_DCB_FLAG_ENABLE;
-	if (svGetValueBoolean (netplan, property->advertise_key, FALSE))
-		flags |= NM_SETTING_DCB_FLAG_ADVERTISE;
-	if (svGetValueBoolean (netplan, property->willing_key, FALSE))
-		flags |= NM_SETTING_DCB_FLAG_WILLING;
+	gs_unref_object NMSettingWirelessSecurity *s_wsec = NULL;
+	gs_free char *value = NULL;
+	int default_key_idx   = 0;
+	gboolean has_defaul  t_key = FALSE;
+	NMSettingSecretFlag  s key_flags;
 
-	return flags;
-}
+	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
 
-static gboolean
-read_dcb_app (shvarFile *netplan,
-              NMSettingDcb *s_dcb,
-              const char *app,
-              DcbFlagsProperty *flags_prop,
-              const char *priority_prop,
-              GError **error)
-{
-	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
-	gs_free char *value = NULL;
-	const char *v;
-	gboolean success = TRUE;
-	int priority = -1;
-	char key[255];
+	/* TODO: support specifying keyidx for WEP */
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0, NULL);
 
-	flags = read_dcb_flags (netplan, flags_prop);
+	/* Read WEP key flags */
+	// TODO: secret flags.
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, NM_SETTING_SECRET_FLAG_NONE, NULL);
 
-	/* Priority */
-	nm_sprintf_buf (key, "DCB_APP_%s_PRIORITY", app);
-	v = svGetValueStr (netplan, key, &value);
-	if (v) {
-		priority = _nm_utils_ascii_str_to_int64 (v, 0, 0, 7, -1);
-		if (priority < 0) {
-			success = FALSE;
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid %s value '%s' (expected 0 - 7)",
-			             key, v);
-		}
+	g_object_set (G_OBJECT (s_wsec),
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
+	              NULL);
 
-		if (!(flags & NM_SETTING_DCB_FLAG_ENABLE))
-			PARSE_WARNING ("ignoring DCB %s priority; app not enabled", app);
-	}
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", NULL);
+	/* TODO: Support WEP-only (apparently) "shared" AUTH_ALG... */
+	//g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared", NULL);
 
-	if (success) {
-		g_object_set (G_OBJECT (s_dcb),
-		              flags_prop->flags_prop, flags,
-		              priority_prop, (guint) priority,
-		              NULL);
-	}
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, nd->auth.password);
 
-	return success;
+	return NM_SETTING (g_steal_pointer (&s_wsec));
 }
 
-typedef void (*DcbSetBoolFunc) (NMSettingDcb *, guint, gboolean);
-
 static gboolean
-read_dcb_bool_array (shvarFile *netplan,
-                     NMSettingDcb *s_dcb,
-                     NMSettingDcbFlags flags,
-                     const char *prop,
-                     const char *desc,
-                     DcbSetBoolFunc set_func,
-                     GError **error)
+fill_wpa_ciphers (NetplanNetDefinition *nd,
+                  NMSettingWirelessSecurity *wsec,
+                  gboolean group,
+                  gboolean adhoc)
 {
 	gs_free char *value = NULL;
-	const char *v;
-	guint i;
-
-	v = svGetValueStr (netplan, prop, &value);
-	if (!v)
-		return TRUE;
+	const char *p;
+	gs_free const char **list = NULL;
+	const char *const *iter;
+	int i = 0;
 
-	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		PARSE_WARNING ("ignoring %s; %s is not enabled", prop, desc);
+#if 0  /* TODO: WPA ciphers */
+	p = svGetValueStr (netplan, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
+	if (!p)
 		return TRUE;
-	}
-
-	if (strlen (v) != 8) {
-		PARSE_WARNING ("%s value '%s' must be 8 characters long", prop, v);
-		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "boolean array must be 8 characters");
-		return FALSE;
-	}
 
-	/* All characters must be either 0 or 1 */
-	for (i = 0; i < 8; i++) {
-		if (v[i] != '0' && v[i] != '1') {
-			PARSE_WARNING ("invalid %s value '%s': not all 0s and 1s", prop, v);
-			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			                     "invalid boolean digit");
-			return FALSE;
+	list = nm_utils_strsplit_set (p, " ");
+	for (iter = list; iter && *iter; iter++, i++) {
+		if (!strcmp (*iter, "CCMP")) {
+			if (group)
+				nm_setting_wireless_security_add_group (wsec, "ccmp");
+			else
+				nm_setting_wireless_security_add_pairwise (wsec, "ccmp");
+		} else if (!strcmp (*iter, "TKIP")) {
+			if (group)
+				nm_setting_wireless_security_add_group (wsec, "tkip");
+			else
+				nm_setting_wireless_security_add_pairwise (wsec, "tkip");
+		} else if (group && !strcmp (*iter, "WEP104"))
+			nm_setting_wireless_security_add_group (wsec, "wep104");
+		else if (group && !strcmp (*iter, "WEP40"))
+			nm_setting_wireless_security_add_group (wsec, "wep40");
+		else {
+			PARSE_WARNING ("ignoring invalid %s cipher '%s'",
+			               group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE",
+			               *iter);
 		}
-		set_func (s_dcb, i, (v[i] == '1'));
 	}
+#endif
 	return TRUE;
 }
 
-typedef void (*DcbSetUintFunc) (NMSettingDcb *, guint, guint);
+#define WPA_PMK_LEN 32
 
-static gboolean
-read_dcb_uint_array (shvarFile *netplan,
-                     NMSettingDcb *s_dcb,
-                     NMSettingDcbFlags flags,
-                     const char *prop,
-                     const char *desc,
-                     gboolean f_allowed,
-                     DcbSetUintFunc set_func,
-                     GError **error)
+static char *
+parse_wpa_psk (NetplanNetDefinition *nd,
+               const char *file,
+               GBytes *ssid,
+               GError **error)
 {
-	gs_free char *val = NULL;
-	guint i;
-
-	val = svGetValueStr_cp (netplan, prop);
-	if (!val)
-		return TRUE;
+	gs_free char *psk = NULL;
+	size_t plen;
+  
+	/* Passphrase must be between 10 and 66 characters in length because WPA
+	 * hex keys are exactly 64 characters (no quoting), and WPA passphrases
+	 * are between 8 and 63 characters (inclusive), plus optional quoting if
+	 * the passphrase contains spaces.
+	 */
+	psk = nd->auth.password;
 
-	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		PARSE_WARNING ("ignoring %s; %s is not enabled", prop, desc);
-		return TRUE;
-	}
+	if (!psk)
+		return NULL;
 
-	if (strlen (val) != 8) {
-		PARSE_WARNING ("%s value '%s' must be 8 characters long", prop, val);
-		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "uint array must be 8 characters");
-		return FALSE;
-	}
+	plen = strlen (psk);
 
-	/* All characters must be either 0 - 7 or (optionally) f */
-	for (i = 0; i < 8; i++) {
-		if (val[i] >= '0' && val[i] <= '7')
-			set_func (s_dcb, i, val[i] - '0');
-		else if (f_allowed && (val[i] == 'f' || val[i] == 'F'))
-			set_func (s_dcb, i, 15);
-		else {
-			PARSE_WARNING ("invalid %s value '%s': not 0 - 7%s",
-			               prop, val, f_allowed ? " or 'f'" : "");
-			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			                     "invalid uint digit");
-			return FALSE;
+	if (g_str_has_prefix(psk, "hash:") && plen == 69) {
+		/* Verify the hex PSK; 64 digits + 5 for "hash:" */
+		if (!NM_STRCHAR_ALL (psk+5, ch, g_ascii_isxdigit (ch))) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid WPA_PSK (contains non-hexadecimal characters)");
+			return NULL;
+		}
+	} else {
+		if (plen < 8 || plen > 63) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid WPA_PSK (passphrases must be between "
+			             "8 and 63 characters long (inclusive))");
+			return NULL;
 		}
 	}
 
-	return TRUE;
+	return g_steal_pointer (&psk);
 }
 
-static gboolean
-read_dcb_percent_array (shvarFile *netplan,
-                        NMSettingDcb *s_dcb,
-                        NMSettingDcbFlags flags,
-                        const char *prop,
-                        const char *desc,
-                        gboolean sum_pct,
-                        DcbSetUintFunc set_func,
-                        GError **error)
+static NMSetting8021x *
+fill_8021x (NetplanNetDefinition *nd,
+            const char *file,
+            const char *key_mgmt,
+            gboolean wifi,
+            GError **error)
 {
-	gs_free char *val = NULL;
-	gs_free const char **split = NULL;
-	const char *const *iter;
-	guint i, sum = 0;
+	gs_unref_object NMSetting8021x *s_8021x = NULL;
 
-	val = svGetValueStr_cp (netplan, prop);
-	if (!val)
-		return TRUE;
-
-	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		PARSE_WARNING ("ignoring %s; %s is not enabled", prop, desc);
-		return TRUE;
-	}
-
-	split = nm_utils_strsplit_set (val, ",");
-	if (NM_PTRARRAY_LEN (split) != 8) {
-		PARSE_WARNING ("invalid %s percentage list value '%s'", prop, val);
-		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "percent array must be 8 elements");
-		return FALSE;
-	}
-
-	for (iter = split, i = 0; iter && *iter; iter++, i++) {
-		int tmp;
-
-		tmp = _nm_utils_ascii_str_to_int64 (*iter, 0, 0, 100, -1);
-		if (tmp < 0) {
-			PARSE_WARNING ("invalid %s percentage value '%s'", prop, *iter);
-			g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			                     "invalid percent element");
-			return FALSE;
-		}
-		set_func (s_dcb, i, (guint) tmp);
-		sum += (guint) tmp;
-	}
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
 
-	if (sum_pct && (sum != 100)) {
-		PARSE_WARNING ("%s percentages do not equal 100%%", prop);
-		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "invalid percentage sum");
-		return FALSE;
-	}
+	// TODO: implement 802.1x reading from hashtable keys
 
-	return TRUE;
+	return g_steal_pointer (&s_8021x);
 }
 
-static gboolean
-make_dcb_setting (shvarFile *netplan,
-                  NMSetting **out_setting,
+static NMSetting *
+make_wpa_setting (NetplanNetDefinition *nd,
+                  const char *file,
+                  GBytes *ssid,
+                  gboolean adhoc,
+                  NMSetting8021x **s_8021x,
                   GError **error)
 {
-	gs_unref_object NMSettingDcb *s_dcb = NULL;
-	gboolean dcb_on;
-	NMSettingDcbFlags flags = NM_SETTING_DCB_FLAG_NONE;
+	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
+	gs_free char *value = NULL;
+	const char *v;
+	gboolean wpa_psk = FALSE, wpa_sae = FALSE, wpa_eap = FALSE, ieee8021x = FALSE;
+	int i_val;
+	GError *local = NULL;
 
-	g_return_val_if_fail (out_setting != NULL, FALSE);
+	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 
-	dcb_on = !!svGetValueBoolean (netplan, "DCB", FALSE);
-	if (!dcb_on)
-		return TRUE;
-
-	s_dcb = (NMSettingDcb *) nm_setting_dcb_new ();
-
-	/* FCOE */
-	if (!read_dcb_app (netplan, s_dcb, "FCOE",
-	                   &dcb_flags_props[DCB_APP_FCOE_FLAGS],
-	                   NM_SETTING_DCB_APP_FCOE_PRIORITY,
-	                   error)) {
-		return FALSE;
-	}
-	if (nm_setting_dcb_get_app_fcoe_flags (s_dcb) & NM_SETTING_DCB_FLAG_ENABLE) {
-		gs_free char *val = NULL;
-
-		val = svGetValueStr_cp (netplan, KEY_DCB_APP_FCOE_MODE);
-		if (val) {
-			if (NM_IN_STRSET (val, NM_SETTING_DCB_FCOE_MODE_FABRIC,
-			                       NM_SETTING_DCB_FCOE_MODE_VN2VN))
-				g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_APP_FCOE_MODE, val, NULL);
-			else {
-				PARSE_WARNING ("invalid FCoE mode '%s'", val);
-				g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				                     "invalid FCoE mode");
-				return FALSE;
-			}
-		}
-	}
-
-	/* iSCSI */
-	if (!read_dcb_app (netplan, s_dcb, "ISCSI",
-	                   &dcb_flags_props[DCB_APP_ISCSI_FLAGS],
-	                   NM_SETTING_DCB_APP_ISCSI_PRIORITY,
-	                   error)) {
-		return FALSE;
-	}
-
-	/* FIP */
-	if (!read_dcb_app (netplan, s_dcb, "FIP",
-	                   &dcb_flags_props[DCB_APP_FIP_FLAGS],
-	                   NM_SETTING_DCB_APP_FIP_PRIORITY,
-	                   error)) {
-		return FALSE;
-	}
-
-	/* Priority Flow Control */
-	flags = read_dcb_flags (netplan, &dcb_flags_props[DCB_PFC_FLAGS]);
-	g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS, flags, NULL);
-
-	if (!read_dcb_bool_array (netplan,
-	                          s_dcb,
-	                          flags,
-	                          KEY_DCB_PFC_UP,
-	                          "PFC",
-	                          nm_setting_dcb_set_priority_flow_control,
-	                          error)) {
-		return FALSE;
-	}
-
-	/* Priority Groups */
-	flags = read_dcb_flags (netplan, &dcb_flags_props[DCB_PG_FLAGS]);
-	g_object_set (G_OBJECT (s_dcb), NM_SETTING_DCB_PRIORITY_GROUP_FLAGS, flags, NULL);
-
-	if (!read_dcb_uint_array (netplan,
-	                          s_dcb,
-	                          flags,
-	                          KEY_DCB_PG_ID,
-	                          "PGID",
-	                          TRUE,
-	                          nm_setting_dcb_set_priority_group_id,
-	                          error)) {
-		return FALSE;
-	}
-
-	/* Group bandwidth */
-	if (!read_dcb_percent_array (netplan,
-	                             s_dcb,
-	                             flags,
-	                             KEY_DCB_PG_PCT,
-	                             "PGPCT",
-	                             TRUE,
-	                             nm_setting_dcb_set_priority_group_bandwidth,
-	                             error)) {
-		return FALSE;
-	}
-
-	/* Priority bandwidth */
-	if (!read_dcb_percent_array (netplan,
-	                             s_dcb,
-	                             flags,
-	                             KEY_DCB_PG_UPPCT,
-	                             "UPPCT",
-	                             FALSE,
-	                             nm_setting_dcb_set_priority_bandwidth,
-	                             error)) {
-		return FALSE;
-	}
-
-	/* Strict Bandwidth */
-	if (!read_dcb_bool_array (netplan,
-	                          s_dcb,
-	                          flags,
-	                          KEY_DCB_PG_STRICT,
-	                          "STRICT",
-	                          nm_setting_dcb_set_priority_strict_bandwidth,
-	                          error)) {
-		return FALSE;
-	}
-
-	if (!read_dcb_uint_array (netplan,
-	                          s_dcb,
-	                          flags,
-	                          KEY_DCB_PG_UP2TC,
-	                          "UP2TC",
-	                          FALSE,
-	                          nm_setting_dcb_set_priority_traffic_class,
-	                          error)) {
-		return FALSE;
-	}
-
-	*out_setting = NM_SETTING (g_steal_pointer (&s_dcb));
-	return TRUE;
-}
-
-static gboolean
-add_one_wep_key (shvarFile *netplan,
-                 const char *shvar_key,
-                 guint8 key_idx,
-                 gboolean passphrase,
-                 NMSettingWirelessSecurity *s_wsec,
-                 GError **error)
-{
-	gs_free char *value_free = NULL;
-	const char *value;
-	const char *key = NULL;
-
-	g_return_val_if_fail (netplan != NULL, FALSE);
-	g_return_val_if_fail (shvar_key != NULL, FALSE);
-	g_return_val_if_fail (key_idx <= 3, FALSE);
-	g_return_val_if_fail (s_wsec != NULL, FALSE);
-
-	value = svGetValueStr (netplan, shvar_key, &value_free);
-	if (!value)
-		return TRUE;
-
-	/* Validate keys */
-	if (passphrase) {
-		if (value[0] && strlen (value) < 64)
-			key = value;
-	} else {
-		if (NM_IN_SET (strlen (value), 10, 26)) {
-			/* Hexadecimal WEP key */
-			if (NM_STRCHAR_ANY (value, ch, !g_ascii_isxdigit (ch))) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Invalid hexadecimal WEP key.");
-				return FALSE;
-			}
-			key = value;
-		} else if (   !strncmp (value, "s:", 2)
-		           && NM_IN_SET (strlen (value), 7, 15)) {
-			/* ASCII key */
-			if (NM_STRCHAR_ANY (value + 2, ch, !g_ascii_isprint (ch))) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Invalid ASCII WEP key.");
-				return FALSE;
-			}
-
-			/* Remove 's:' prefix.
-			 * Don't convert to hex string. wpa_supplicant takes 'wep_key0' option over D-Bus as byte array
-			 * and converts it to hex string itself. Even though we convert hex string keys into a bin string
-			 * before passing to wpa_supplicant, this prevents two unnecessary conversions. And mainly,
-			 * ASCII WEP key doesn't change to HEX WEP key in UI, which could confuse users.
-			 */
-			key = value + 2;
-		}
-	}
-
-	if (!key) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Invalid WEP key length.");
-		return FALSE;
-	}
-
-	nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
-	return TRUE;
-}
-
-static gboolean
-read_wep_keys (shvarFile *netplan,
-               NMWepKeyType key_type,
-               guint8 def_idx,
-               NMSettingWirelessSecurity *s_wsec,
-               GError **error)
-{
-	if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
-		if (!add_one_wep_key (netplan, "KEY1", 0, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY2", 1, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY3", 2, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY4", 3, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY", def_idx, FALSE, s_wsec, error))
-			return FALSE;
-	}
-
-	if (key_type != NM_WEP_KEY_TYPE_KEY) {
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
-			return FALSE;
-	}
-
-	return TRUE;
-}
-
-static NMSetting *
-make_wep_setting (shvarFile *netplan,
-                  const char *file,
-                  GError **error)
-{
-	gs_unref_object NMSettingWirelessSecurity *s_wsec = NULL;
-	gs_free char *value = NULL;
-  	shvarFile *keys_netplan = NULL;
-	int default_key_idx   = 0;
-	gboolean has_defaul  t_key = FALSE;
-	NMSettingSecretFlag  s key_flags;
-
-	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
-
-	value = svGetValueStr_cp (netplan, "DEFAULTKEY");
-	if (value) {
-		default_key_idx = _nm_utils_ascii_str_to_int64 (value, 0, 1, 4, 0);
-		if (default_key_idx == 0) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid default WEP key '%s'", value);
-			return NULL;
-		}
-		has_default_key = TRUE;
-		default_key_idx--;  /* convert to [0...3] */
-		g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, (guint) default_key_idx, NULL);
-		nm_clear_g_free (&value);
-	}
-
-	/* Read WEP key flags */
-	key_flags = _secret_read_netplan_flags (netplan, "WEP_KEY_FLAGS");
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, key_flags, NULL);
-
-	/* Read keys in the netplan file if they are system-owned */
-	if (key_flags == NM_SETTING_SECRET_FLAG_NONE) {
-		NMWepKeyType key_type;
-		const char *v;
-		gs_free char *to_free = NULL;
-
-		v = svGetValueStr (netplan, "KEY_TYPE", &to_free);
-		if (!v)
-			key_type = NM_WEP_KEY_TYPE_UNKNOWN;
-		else if (nm_streq (v, "key"))
-			key_type = NM_WEP_KEY_TYPE_KEY;
-		else if (nm_streq (v, "passphrase"))
-			key_type = NM_WEP_KEY_TYPE_PASSPHRASE;
-		else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid KEY_TYPE value '%s'", v);
-			return FALSE;
-		}
-
-		if (!read_wep_keys (netplan, key_type, default_key_idx, s_wsec, error))
-			return NULL;
-
-		/* Try to get keys from the "shadow" key file */
-		ke  ys_netplan = utils_get_keys_netplan (file, FALSE);
-  		if (keys_netpl  an) {
-			i  f (!read_wep_k    eys (keys_netplan, key_type, default_key_idx, s_wsec, error)) {
-  				svCloseFile (k      eys_netplan);
-				return   NUL    L;
-		    	}
-  			svCloseFile (ke  ys_netplan);
-			g_assert (error =  = NULL || *error == NULL);
-	  	}
-  
-		g_object_set (G_OBJECT (s_wsec),
-		              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, key_type,
-		              NULL);
-	}
-
-	value = svGetValueStr_cp (netplan, "SECURITYMODE");
-	if (value) {
-		gs_free char *lcase = NULL;
-
-		lcase = g_ascii_strdown (value, -1);
-		nm_clear_g_free (&value);
-
-		if (nm_streq (lcase, "open")) {
-			g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", NULL);
-		} else if (nm_streq (lcase, "restricted")) {
-			g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared", NULL);
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid WEP authentication algorithm '%s'",
-			             lcase);
-			return NULL;
-		}
-	}
-
-	/* If no WEP keys were given, and the keys are not agent-owned, and no
-	 * default WEP key index was given, then the connection is unencrypted.
-	 */
-	if (   !nm_setting_wireless_security_get_wep_key (s_wsec, 0)
-	    && !nm_setting_wireless_security_get_wep_key (s_wsec, 1)
-	    && !nm_setting_wireless_security_get_wep_key (s_wsec, 2)
-	    && !nm_setting_wireless_security_get_wep_key (s_wsec, 3)
-	    && (has_default_key == FALSE)
-	    && (key_flags == NM_SETTING_SECRET_FLAG_NONE)) {
-		const char *auth_alg;
-
-		auth_alg = nm_setting_wireless_security_get_auth_alg (s_wsec);
-		if (auth_alg && !strcmp (auth_alg, "shared")) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "WEP Shared Key authentication is invalid for "
-			             "unencrypted connections.");
-			return NULL;
-		}
-
-		/* Unencrypted */
-		return NULL;
-	}
-
-	return NM_SETTING (g_steal_pointer (&s_wsec));
-}
-
-static gboolean
-fill_wpa_ciphers (shvarFile *netplan,
-                  NMSettingWirelessSecurity *wsec,
-                  gboolean group,
-                  gboolean adhoc)
-{
-	gs_free char *value = NULL;
-	const char *p;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-	int i = 0;
-
-	p = svGetValueStr (netplan, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
-	if (!p)
-		return TRUE;
-
-	list = nm_utils_strsplit_set (p, " ");
-	for (iter = list; iter && *iter; iter++, i++) {
-		if (!strcmp (*iter, "CCMP")) {
-			if (group)
-				nm_setting_wireless_security_add_group (wsec, "ccmp");
-			else
-				nm_setting_wireless_security_add_pairwise (wsec, "ccmp");
-		} else if (!strcmp (*iter, "TKIP")) {
-			if (group)
-				nm_setting_wireless_security_add_group (wsec, "tkip");
-			else
-				nm_setting_wireless_security_add_pairwise (wsec, "tkip");
-		} else if (group && !strcmp (*iter, "WEP104"))
-			nm_setting_wireless_security_add_group (wsec, "wep104");
-		else if (group && !strcmp (*iter, "WEP40"))
-			nm_setting_wireless_security_add_group (wsec, "wep40");
-		else {
-			PARSE_WARNING ("ignoring invalid %s cipher '%s'",
-			               group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE",
-			               *iter);
-		}
-	}
-
-	return TRUE;
-}
-
-#define WPA_PMK_LEN 32
-
-static char *
-parse_wpa_psk (shvarFile *netplan,
-               const char *file,
-               GBytes *ssid,
-               GError **error)
-{
-  	shvarFile *keys_netplan;
-	gs_free char *psk = NULL;
-	size_t plen;
-  
-	/* Passphrase must be between 10 and 66 characters in length because WPA
-	 * hex keys are exactly 64 characters (no quoting), and WPA passphrases
-	 * are between 8 and 63 characters (inclusive), plus optional quoting if
-	 * the passphrase contains spaces.
-	 */
-
-	/* Try to get keys from the "shadow" key file */
-	key  s_netplan = utils_get_keys_netplan (file, FALSE);
-  	if (keys_netplan) {
-		psk = svGetValue  (keys_netplan, "WPA_PSK");
-  		svCloseFile (keys_netplan);
-      	}
-    
-	/* Fall back to the   original netplan */
-	if (!psk)
-		psk = svGetValueStr_cp (netplan, "WPA_PSK");
-
-	if (!psk)
-		return NULL;
-
-	plen = strlen (psk);
-
-	if (plen == 64) {
-		/* Verify the hex PSK; 64 digits */
-		if (!NM_STRCHAR_ALL (psk, ch, g_ascii_isxdigit (ch))) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid WPA_PSK (contains non-hexadecimal characters)");
-			return NULL;
-		}
-	} else {
-		if (plen < 8 || plen > 63) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid WPA_PSK (passphrases must be between "
-			             "8 and 63 characters long (inclusive))");
-			return NULL;
-		}
-	}
-
-	return g_steal_pointer (&psk);
-}
-
-static gboolean
-eap_simple_reader (const char *eap_method,
-                   shvarFile *netplan,
-                   shvarFile *keys_netplan,
-                   NMSetting8021x *s_8021x,
-                   gboolean phase2,
-                   GError **error)
-{
-	NMSettingSecretFlags flags;
-	gs_free char *identity_free = NULL;
-	nm_auto_free_secret char *password_raw_str = NULL;
-	gs_unref_bytes GBytes *password_raw_bytes = NULL;
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_IDENTITY,
-	              svGetValueStr (netplan, "IEEE_8021X_IDENTITY", &identity_free),
-	              NULL);
-
-	_secret_set_from_netplan (s_8021x,
-	                          netplan,
-	                          keys_netplan,
-	                          "IEEE_8021X_PASSWORD",
-	                          NM_SETTING_802_1X_PASSWORD);
-  
-	_secret_read_netplan (netplan, keys_netplan, "IEEE_8021X_PASSWORD_RAW", &password_raw_str, &flags);
-	if (!_secret_password_raw_to_bytes ("IEEE_8021X_PASSWORD_RAW",
-	                                      password_raw_str,
-	                                      &password_raw_bytes,
-	                                    error))
-		return FALSE;
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_PASSWORD_RAW_FLAGS,
-	              flags,
-	              NM_SETTING_802_1X_PASSWORD_RAW,
-	              password_raw_bytes,
-	              NULL);
-
-	return TRUE;
-}
-
-static gboolean
-eap_tls_reader (const char *eap_method,
-                shvarFile *netplan,
-                  shvarFile *keys_netplan,
-                NMSetting8021x *s_8021x,
-                gboolean phase2,
-                GError **error)
-{
-	gs_unref_bytes GBytes *privkey = NULL;
-	gs_unref_bytes GBytes *client_cert = NULL;
-	gs_free char *identity_free = NULL;
-	gs_free char *value_to_free = NULL;
-	const char *client_cert_var;
-	const char *client_cert_prop;
-	NMSetting8021xCKFormat format;
-
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_IDENTITY,
-	              svGetValueStr (netplan, "IEEE_8021X_IDENTITY", &identity_free),
-	              NULL);
-
-	/* CA certificate */
-	if (!_cert_set_from_netplan (s_8021x,
-	                             netplan,
-	                             phase2 ? "IEEE_8021X_INNER_CA_CERT" : "IEEE_8021X_CA_CERT",
-	                             phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT : NM_SETTING_802_1X_CA_CERT,
-	                             NULL,
-	                             error))
-		return FALSE;
-	_secret_set_from_netplan (s_8021x,
-	                          netplan,
-	                          keys_netplan,
-	                          phase2 ? "IEEE_8021X_INNER_CA_CERT_PASSWORD" : "IEEE_8021X_CA_CERT_PASSWORD",
-	                          phase2 ? NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD : NM_SETTING_802_1X_CA_CERT_PASSWORD);
-  
-	/* Private key */
-	if (!_cert_set_from_netplan (s_8021x,
-	                             netplan,
-	                             phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY" : "IEEE_8021X_PRIVATE_KEY",
-	                             phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY : NM_SETTING_802_1X_PRIVATE_KEY,
-	                             &privkey,
-	                             error))
-		return FALSE;
-	_secret_set_from_netplan (s_8021x,
-	                          netplan,
-	                          keys_netplan,
-	                          phase2 ? "IEEE_8021X_INNER_PRIVATE_KEY_PASSWORD" : "IEEE_8021X_PRIVATE_KEY_PASSWORD",
-	                          phase2 ? NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD : NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD);
-  
-	/* Client certificate */
-	client_cert_var = phase2 ? "IEEE_8021X_INNER_CLIENT_CERT" : "IEEE_8021X_CLIENT_CERT";
-	client_cert_prop = phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT : NM_SETTING_802_1X_CLIENT_CERT;
-	if (!_cert_set_from_netplan (s_8021x,
-	                             netplan,
-	                             client_cert_var,
-	                             client_cert_prop,
-	                             &client_cert,
-	                             error))
-		return FALSE;
-	_secret_set_from_netplan (s_8021x,
-	                          netplan,
-	                          keys_netplan,
-	                          phase2 ? "IEEE_8021X_INNER_CLIENT_CERT_PASSWORD" : "IEEE_8021X_CLIENT_CERT_PASSWORD",
-	                          phase2 ? NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD : NM_SETTING_802_1X_CLIENT_CERT_PASSWORD);
-  
-	/* In the past when the private key and client certificate
-	 * were the same PKCS #12 file we used to write only the
-	 * private key variable. Still support that even if it means
-	 * that we have to look into the file content, which makes
-	 * the connection not self-contained.
-	 */
-	if (   !client_cert
-	    && privkey
-	    && !svGetValue (netplan, client_cert_var, &value_to_free)) {
-		if (phase2)
-			format = nm_setting_802_1x_get_phase2_private_key_format (s_8021x);
-		else
-			format = nm_setting_802_1x_get_private_key_format (s_8021x);
-
-		if (format == NM_SETTING_802_1X_CK_FORMAT_PKCS12)
-			g_object_set (s_8021x, client_cert_prop, privkey, NULL);
-	}
-
-	return TRUE;
-}
-
-static gboolean
-eap_peap_reader (const char *eap_method,
-                 shvarFile *netplan,
-                   shvarFile *keys_netplan,
-                 NMS  etting8021x *s_8021x,
-                 gbo  olean phase2,
-                 GEr  ror **error)
-{
-	gs_free char *value = NULL;
-	const char *v;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-
-	if (!_cert_set_from_netplan (s_8021x,
-	                             netplan,
-	                             "IEEE_8021X_CA_CERT",
-	                             NM_SETTING_802_1X_CA_CERT,
-	                             NULL,
-	                             error))
-		return FALSE;
-	_secret_set_from_netplan (s_8021x,
-	                          netplan,
-	                          keys_netplan,
-	                          "IEEE_8021X_CA_CERT_PASSWORD",
-	                          NM_SETTING_802_1X_CA_CERT_PASSWORD);
-  
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_PEAP_VERSION", &value);
-	if (v) {
-		if (!strcmp (v, "0"))
-			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPVER, "0", NULL);
-		else if (!strcmp (v, "1"))
-			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPVER, "1", NULL);
-		else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Unknown IEEE_8021X_PEAP_VERSION value '%s'",
-			             v);
-			return FALSE;
-		}
-	}
-
-	if (svGetValueBoolean (netplan, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", FALSE))
-		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1", NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_ANON_IDENTITY", &value);
-	if (v)
-		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_INNER_AUTH_METHODS", &value);
-	if (!v) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
-		return FALSE;
-	}
-
-	/* Handle options for the inner auth method */
-	list = nm_utils_strsplit_set (v, " ");
-	iter = list;
-	if (iter) {
-		if (NM_IN_STRSET (*iter, "MSCHAPV2",
-		                         "MD5",
-		                         "GTC")) {
-			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
-				return F  ALSE;
-		} else if (nm_stre  q (*iter, "TLS")) {
-			i  f (!eap_tls_re  ader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
-				return F  ALSE;
-		} else   {
-			g_set_error (erro  r, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
-			             *iter);
-			return FALSE;
-		}
-
-		{
-			gs_free char *lower = NULL;
-
-			lower = g_ascii_strdown (*iter, -1);
-			g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, lower, NULL);
-		}
-	}
-
-	if (!nm_setting_802_1x_get_phase2_auth (s_8021x)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "No valid IEEE_8021X_INNER_AUTH_METHODS found.");
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-static gboolean
-eap_ttls_reader (const char *eap_method,
-                 shvarFile *netplan,
-                   shvarFile *keys_netplan,
-                 NMS  etting8021x *s_8021x,
-                 gbo  olean phase2,
-                 GEr  ror **error)
-{
-	gs_free char *inner_auth = NULL;
-	gs_free char *value = NULL;
-	const char *v;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-
-	if (!_cert_set_from_netplan (s_8021x,
-	                             netplan,
-	                             "IEEE_8021X_CA_CERT",
-	                             NM_SETTING_802_1X_CA_CERT,
-	                             NULL,
-	                             error))
-		return FALSE;
-	_secret_set_from_netplan (s_8021x,
-	                          netplan,
-	                          keys_netplan,
-	                          "IEEE_8021X_CA_CERT_PASSWORD",
-	                          NM_SETTING_802_1X_CA_CERT_PASSWORD);
-  
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_ANON_IDENTITY", &value);
-	if (v)
-		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_INNER_AUTH_METHODS", &value);
-	if (!v) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
-		return FALSE;
-	}
-
-	inner_auth = g_ascii_strdown (v, -1);
-
-	/* Handle options for the inner auth method */
-	list = nm_utils_strsplit_set (inner_auth, " ");
-	iter = list;
-	if (iter) {
-		if (NM_IN_STRSET (*iter, "mschapv2",
-		                         "mschap",
-		                         "pap",
-		                         "chap")) {
-			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
-				return F  ALSE;
-			g_object_set (s_8  021x, NM_SETTING_802_1X_PHASE2_AUTH, *iter, NULL);
-		} else if (nm_stre  q (*iter, "eap-tls")) {
-			i  f (!eap_tls_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
-				return F  ALSE;
-			g_object_set (s_8  021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, "tls", NULL);
-		} else if (NM_IN_S  TRSET (*iter, "eap-mschapv2",
-		                                "eap-md5",
-		                                "eap-gtc")) {
-			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
-				return F  ALSE;
-			g_object_set (s_8  021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, (*iter + NM_STRLEN ("eap-")), NULL);
-		} else   {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
-			             *iter);
-			return FALSE;
-		}
-	}
-
-	return TRUE;
-}
-
-static gboolean
-eap_fast_reader (const char *eap_method,
-                 shvarFile *netplan,
-                   shvarFile *keys_netplan,
-                 NMS  etting8021x *s_8021x,
-                 gbo  olean phase2,
-                 GEr  ror **error)
-{
-	char *anon_ident = NULL;
-	char *pac_file = NULL;
-	char *real_pac_path = NULL;
-	char *inner_auth = NULL;
-	char *fast_provisioning = NULL;
-	char *lower;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-	const char *pac_prov_str;
-	gboolean allow_unauth = FALSE, allow_auth = FALSE;
-	gboolean success = FALSE;
-
-	pac_file = svGetValueStr_cp (netplan, "IEEE_8021X_PAC_FILE");
-	if (pac_file) {
-		real_pac_path = get_full_file_path (svFileGetName (netplan), pac_file);
-		g_object_set (s_8021x, NM_SETTING_802_1X_PAC_FILE, real_pac_path, NULL);
-	}
-
-	fast_provisioning = svGetValueStr_cp (netplan, "IEEE_8021X_FAST_PROVISIONING");
-	if (fast_provisioning) {
-		gs_free const char **list1 = NULL;
-
-		list1 = nm_utils_strsplit_set (fast_provisioning, " \t");
-		for (iter = list1; iter && *iter; iter++) {
-			if (strcmp (*iter, "allow-unauth") == 0)
-				allow_unauth = TRUE;
-			else if (strcmp (*iter, "allow-auth") == 0)
-				allow_auth = TRUE;
-			else {
-				PARSE_WARNING ("invalid IEEE_8021X_FAST_PROVISIONING '%s' "
-				               "(space-separated list of these values [allow-auth, allow-unauth] expected)",
-				               *iter);
-			}
-		}
-	}
-	pac_prov_str = allow_unauth ? (allow_auth ? "3" : "1") : (allow_auth ? "2" : "0");
-	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING, pac_prov_str, NULL);
-
-	if (!pac_file && !(allow_unauth || allow_auth)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "IEEE_8021X_PAC_FILE not provided and EAP-FAST automatic PAC provisioning disabled.");
-		goto done;
-	}
-
-	anon_ident = svGetValueStr_cp (netplan, "IEEE_8021X_ANON_IDENTITY");
-	if (anon_ident)
-		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, anon_ident, NULL);
-
-	inner_auth = svGetValueStr_cp (netplan, "IEEE_8021X_INNER_AUTH_METHODS");
-	if (!inner_auth) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing IEEE_8021X_INNER_AUTH_METHODS.");
-		goto done;
-	}
-
-	/* Handle options for the inner auth method */
-	list = nm_utils_strsplit_set (inner_auth, " ");
-	iter = list;
-	if (iter) {
-		if (   !strcmp (*iter, "MSCHAPV2")
-		    || !strcmp (*iter, "GTC")) {
-			i  f (!eap_simple_reader (*iter, netplan, keys_netplan, s_8021x, TRUE, error))
-				goto   done;
-		} else   {
-			g_set_error (erro  r, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Unknown IEEE_8021X_INNER_AUTH_METHOD '%s'.",
-			             *iter);
-			goto done;
-		}
-
-		lower = g_ascii_strdown (*iter, -1);
-		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, lower, NULL);
-		g_free (lower);
-	}
-
-	if (!nm_setting_802_1x_get_phase2_auth (s_8021x)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "No valid IEEE_8021X_INNER_AUTH_METHODS found.");
-		goto done;
-	}
-
-	success = TRUE;
-
-done:
-	g_free (inner_auth);
-	g_free (fast_provisioning);
-	g_free (real_pac_path);
-	g_free (pac_file);
-	g_free (anon_ident);
-	return success;
-}
-
-typedef struct {
-	const char *method;
-	gboolean (*reader) (const char *eap_method,
-	                    shvarFile *netplan,
-	                      shvarFile *keys_netplan,
-	                      NMSetting8021x *s_8021x,
-	                      gboolean phase2,
-	                      GError **error);
-	gboolean wifi_phase2_only;
-} EAPReader;
-
-static EAPReader eap_readers[] = {
-	{ "md5", eap_simple_reader, TRUE },
-	{ "pap", eap_simple_reader, TRUE },
-	{ "chap", eap_simple_reader, TRUE },
-	{ "mschap", eap_simple_reader, TRUE },
-	{ "mschapv2", eap_simple_reader, TRUE },
-	{ "leap", eap_simple_reader, FALSE },
-	{ "pwd", eap_simple_reader, FALSE },
-	{ "tls", eap_tls_reader, FALSE },
-	{ "peap", eap_peap_reader, FALSE },
-	{ "ttls", eap_ttls_reader, FALSE },
-	{ "fast", eap_fast_reader, FALSE },
-	{ NULL, NULL }
-};
-
-static void
-read_8021x_list_value (shvarFile *netplan,
-                       const char *netplan_var_name,
-                       NMSetting8021x *setting,
-                       const char *prop_name)
-{
-	gs_free char *value = NULL;
-	gs_free const char **strv = NULL;
-	const char *v;
-
-	g_return_if_fail (netplan != NULL);
-	g_return_if_fail (netplan_var_name != NULL);
-	g_return_if_fail (prop_name != NULL);
-
-	v = svGetValueStr (netplan, netplan_var_name, &value);
-	if (!v)
-		return;
-
-	strv = nm_utils_strsplit_set (v, " \t");
-	if (strv)
-		g_object_set (setting, prop_name, strv, NULL);
-}
-
-static NMSetting8021x *
-fill_8021x (shvarFile *netplan,
-            const char *file,
-            const char *key_mgmt,
-            gboolean wifi,
-            GError **error)
-{
-	nm_  auto_shvar_file_close shvarFile *keys_netplan = NULL;
-	gs_unref_object NMS  etting8021x *s_8021x = NULL;
-	gs_free char *value   = NULL;
-	const char *  v;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-	gint64 timeout;
-	int i_val;
-
-	v = svGetValueStr (netplan, "IEEE_8021X_EAP_METHODS", &value);
-	if (!v) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing IEEE_8021X_EAP_METHODS for key management '%s'",
-		             key_mgmt);
-		return NULL;
-	}
-
-	list = nm_utils_strsplit_set (v, " ");
-
-	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
-
-	/*   Read in the lookaside keys_netplan file, if present */
-	key  s_netplan = ut  ils_get_keys_netplan (file, FALSE);
-    
-	/* Validate and han    dle each EAP method */
-	for (iter = list; i  ter && *iter; iter++) {
-		EAPReader *eap = &eap_readers[0];
-		gboolean found = FALSE;
-		gs_free char *lower = NULL;
-
-		lower = g_ascii_strdown (*iter, -1);
-		while (eap->method) {
-			if (strcmp (eap->method, lower))
-				goto next;
-
-			/* Some EAP methods don't provide keying material, thus they
-			 * cannot be used with Wi-Fi unless they are an inner method
-			 * used with TTLS or PEAP or whatever.
-			 */
-			if (wifi && eap->wifi_phase2_only) {
-				PARSE_WARNING ("ignored invalid IEEE_8021X_EAP_METHOD '%s'; not allowed for wifi.",
-				               lower);
-				goto next;
-			}
-
-			/* Parse EAP method specific options */
-			i  f (!(*eap->reader)(lower, netplan, keys_netplan, s_8021x, FALSE, error))
-				return   NULL;
-  
-			nm_setting_802_1x  _add_eap_method (s_8021x, lower);
-			found = TRUE;
-			break;
-
-next:
-			eap++;
-		}
-
-		if (!found)
-			PARSE_WARNING ("ignored unknown IEEE_8021X_EAP_METHOD '%s'.", lower);
-	}
-
-	if (nm_setting_802_1x_get_num_eap_methods (s_8021x) == 0) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "No valid EAP methods found in IEEE_8021X_EAP_METHODS.");
-		return NULL;
-	}
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_SUBJECT_MATCH", &value);
-	g_object_set (s_8021x, NM_SETTING_802_1X_SUBJECT_MATCH, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_PHASE2_SUBJECT_MATCH", &value);
-	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH, v, NULL);
-
-	i_val = NM_SETTING_802_1X_AUTH_FLAGS_NONE;
-	if (!svGetValueEnum (netplan, "IEEE_8021X_PHASE1_AUTH_FLAGS",
-	                     nm_setting_802_1x_auth_flags_get_type (),
-	                     &i_val, error))
-		return NULL;
-	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE1_AUTH_FLAGS, (guint) i_val, NULL);
-
-	read_8021x_list_value (netplan, "IEEE_8021X_ALTSUBJECT_MATCHES",
-	                       s_8021x, NM_SETTING_802_1X_ALTSUBJECT_MATCHES);
-	read_8021x_list_value (netplan, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES",
-	                       s_8021x, NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_DOMAIN_SUFFIX_MATCH", &value);
-	g_object_set (s_8021x, NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH", &value);
-	g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH, v, NULL);
-
-	timeout = svGetValueInt64 (netplan, "IEEE_8021X_AUTH_TIMEOUT", 10, 0, G_MAXINT32, 0);
-	g_object_set (s_8021x, NM_SETTING_802_1X_AUTH_TIMEOUT, (int) timeout, NULL);
-
-	return g_steal_pointer (&s_8021x);
-}
-
-static NMSetting *
-make_wpa_setting (shvarFile *netplan,
-                  const char *file,
-                  GBytes *ssid,
-                  gboolean adhoc,
-                  NMSetting8021x **s_8021x,
-                  GError **error)
-{
-	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
-	gs_free char *value = NULL;
-	const char *v;
-	gboolean wpa_psk = FALSE, wpa_sae = FALSE, wpa_eap = FALSE, ieee8021x = FALSE;
-	int i_val;
-	GError *local = NULL;
-
-	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
-
-	v = svGetValueStr (netplan, "KEY_MGMT", &value);
-	wpa_psk = nm_streq0 (v, "WPA-PSK");
-	wpa_sae = nm_streq0 (v, "SAE");
-	wpa_eap = nm_streq0 (v, "WPA-EAP");
-	ieee8021x = nm_streq0 (v, "IEEE8021X");
-	if (   !wpa_psk
-	    && !wpa_sae
-	    && !wpa_eap
-	    && !ieee8021x)
-		return NULL; /* Not WPA or Dynamic WEP */
-
-	/* WPS */
-	i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
-	if (!svGetValueEnum (netplan, "WPS_METHOD",
-	                     nm_setting_wireless_security_wps_method_get_type (),
-	                     &i_val, error))
-		return NULL;
-	g_object_set (wsec,
-	              NM_SETTING_WIRELESS_SECURITY_WPS_METHOD, (guint) i_val,
-	              NULL);
-
-	/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
-	if (wpa_psk || wpa_sae || wpa_eap) {
-		fill_wpa_ciphers (netplan, wsec, FALSE, adhoc);
-		fill_wpa_ciphers (netplan, wsec, TRUE, adhoc);
-	}
-
-	/* WPA and/or RSN */
-	if (adhoc) {
-		/* Ad-Hoc mode only supports RSN proto */
-		nm_setting_wireless_security_add_proto (wsec, "rsn");
-	} else {
-		gs_free char *value2 = NULL;
-		const char *v2;
-
-		v2 = svGetValueStr (netplan, "WPA_ALLOW_WPA", &value2);
-		if (v2 && svParseBoolean (v2, TRUE))
-			nm_setting_wireless_security_add_proto (wsec, "wpa");
-
-		nm_clear_g_free (&value2);
-		v2 = svGetValueStr (netplan, "WPA_ALLOW_WPA2", &value2);
-		if (v2 && svParseBoolean (v2, TRUE))
-			nm_setting_wireless_security_add_proto (wsec, "rsn");
-	}
-
-	if (wpa_psk || wpa_sae) {
-		NMSettingSecretFlags psk_flags;
-
-		psk_flags = _secret_read_netplan_flags (netplan, "WPA_PSK_FLAGS");
-		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS, psk_flags, NULL);
-
-		/* Read PSK if it's system-owned */
-		if (psk_flags == NM_SETTING_SECRET_FLAG_NONE) {
-			gs_free char *psk = NULL;
-
-			psk = parse_wpa_psk (netplan, file, ssid, &local);
-			if (psk)
-				g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
-			else if (local) {
-				g_propagate_error (error, local);
-				return NULL;
-			}
-		}
-
-		if (wpa_psk)
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
-		else {
-			nm_assert (wpa_sae);
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "sae", NULL);
-		}
-	} else {
-		nm_assert (wpa_eap || ieee8021x);
-
-		/* Adhoc mode is mutually exclusive with any 802.1x-based authentication */
-		if (adhoc) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Ad-Hoc mode cannot be used with KEY_MGMT type '%s'", v);
-			return NULL;
-		}
-
-		*s_8021x = fill_8021x (netplan, file, v, TRUE, error);
-		if (!*s_8021x)
-			return NULL;
-
-		{
-			gs_free char *lower = g_ascii_strdown (v, -1);
-
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, lower, NULL);
-		}
-	}
-
-	i_val = NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT;
-	if (!svGetValueEnum (netplan, "PMF",
-	                     nm_setting_wireless_security_pmf_get_type (),
-	                     &i_val, error))
-		return NULL;
-	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PMF, i_val, NULL);
-
-	i_val = NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT;
-	if (!svGetValueEnum (netplan, "FILS",
-	                     nm_setting_wireless_security_fils_get_type (),
-	                     &i_val, error))
-		return NULL;
-	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_FILS, i_val, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "SECURITYMODE", &value);
-	if (NM_IN_STRSET (v, NULL, "open"))
-		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, v, NULL);
-
-	return (NMSetting *) g_steal_pointer (&wsec);
-}
-
-static NMSetting *
-make_leap_setting (shvarFile *netplan,
-                   const char *file,
-                   GError **error)
-{
-	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
-  	shvarFile *keys_netplan;
-	gs_free char *value   = NULL;
-	NMSettingSecretFlag  s flags;
-  
-	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
-
-	value = svGetValueStr_cp (netplan, "KEY_MGMT");
-	if (!value || strcmp (value, "IEEE8021X"))
-		return NULL;
-	nm_clear_g_free (&value);
-
-	value = svGetValueStr_cp (netplan, "SECURITYMODE");
-	if (!value || strcasecmp (value, "leap"))
-		return NULL; /* Not LEAP */
-	nm_clear_g_free (&value);
-
-	flags = _secret_read_netplan_flags (netplan, "IEEE_8021X_PASSWORD_FLAGS");
-	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags, NULL);
-
-	/* Read LEAP password if it's system-owned */
-	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
-		value = svGetValueStr_cp (netplan, "IEEE_8021X_PASSWORD");
-		if (!value) {
-			/* Try to get keys from the "shadow" key file */
-			k  eys_netplan = utils_get_keys_netplan (file, FALSE);
-  			if (keys_netpl  an) {
-				  value = svGetV    alueStr_cp (keys_netplan, "IEEE_8021X_PASSWORD");
-  				svCloseFile (k      eys_netplan);
-  		    	}
-	    	}
-		if (value && strle  n (value))
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, value, NULL);
-		nm_clear_g_free (&value);
-	}
-
-	value = svGetValueStr_cp (netplan, "IEEE_8021X_IDENTITY");
-	if (!value) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing LEAP identity");
-		return NULL;
-	}
-	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, value, NULL);
-	nm_clear_g_free (&value);
-
-	g_object_set (wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
-	              NULL);
-
-	return (NMSetting *) g_steal_pointer (&wsec);
-}
-
-static NMSetting *
-make_wireless_security_setting (shvarFile *netplan,
-                                const char *file,
-                                GBytes *ssid,
-                                gboolean adhoc,
-                                NMSetting8021x **s_8021x,
-                                GError **error)
-{
-	NMSetting *wsec;
-
-	g_return_val_if_fail (error && !*error, NULL);
-
-	if (!adhoc) {
-		wsec = make_leap_setting (netplan, file, error);
-		if (wsec)
-			return wsec;
-		else if (*error)
-			return NULL;
-	}
-
-	wsec = make_wpa_setting (netplan, file, ssid, adhoc, s_8021x, error);
-	if (wsec)
-		return wsec;
-	else if (*error)
-		return NULL;
-
-	wsec = make_wep_setting (netplan, file, error);
-	if (wsec)
-		return wsec;
-	else if (*error)
-		return NULL;
-
-	return NULL; /* unencrypted */
-}
-
-static const char **
-transform_hwaddr_blacklist (const char *blacklist)
-{
-	const char **strv;
-	gsize i, j;
-
-	strv = nm_utils_strsplit_set (blacklist, " \t");
-	if (!strv)
-		return NULL;
-	for (i = 0, j = 0; strv[j]; j++) {
-		const char *s = strv[j];
-
-		if (!nm_utils_hwaddr_valid (s, ETH_ALEN)) {
-			PARSE_WARNING ("invalid MAC in HWADDR_BLACKLIST '%s'", s);
-			continue;
-		}
-		strv[i++] = s;
-	}
-	strv[i] = NULL;
-	return strv;
-}
-
-static NMSetting *
-make_wireless_setting (shvarFile *netplan,
-                       GError **error)
-{
-	NMSettingWireless *s_wireless;
-	const char *cvalue;
-	char *value = NULL;
-	gint64 chan = 0;
-	NMSettingMacRandomization mac_randomization;
-	NMSettingWirelessPowersave powersave = NM_SETTING_WIRELESS_POWERSAVE_DEFAULT;
-
-	s_wireless = NM_SETTING_WIRELESS (nm_setting_wireless_new ());
-
-	value = svGetValueStr_cp (netplan, "HWADDR");
-	if (value) {
-		value = g_strstrip (value);
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
-		g_free (value);
-	}
-
-	value = svGetValueStr_cp (netplan, "MACADDR");
-	if (value) {
-		value = g_strstrip (value);
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS, value, NULL);
-		g_free (value);
-	}
-
-	value = svGetValueStr_cp (netplan, "GENERATE_MAC_ADDRESS_MASK");
-	g_object_set (s_wireless, NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK, value, NULL);
-	g_free (value);
-
-	cvalue = svGetValueStr (netplan, "HWADDR_BLACKLIST", &value);
-	if (cvalue) {
-		gs_free const char **strv = NULL;
-
-		strv = transform_hwaddr_blacklist (cvalue);
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST, strv, NULL);
-		g_free (value);
-	}
-
-	value = svGetValueStr_cp (netplan, "ESSID");
-	if (value) {
-		gs_unref_bytes GBytes *bytes = NULL;
-		gsize ssid_len = 0;
-		gsize value_len = strlen (value);
-
-		if (   value_len > 2
-		    && (value_len % 2) == 0
-		    && g_str_has_prefix (value, "0x")
-		    && NM_STRCHAR_ALL (&value[2], ch, g_ascii_isxdigit (ch))) {
-			/* interpret the value as hex-digits iff value starts
-			 * with "0x" followed by pairs of hex digits */
-			bytes = nm_utils_hexstr2bin (&value[2]);
-		} else
-			bytes = g_bytes_new (value, value_len);
-
-		ssid_len = g_bytes_get_size (bytes);
-		if (ssid_len > 32 || ssid_len == 0) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid SSID '%s' (size %zu not between 1 and 32 inclusive)",
-			             value, ssid_len);
-			g_free (value);
-			goto error;
-		}
-
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, bytes, NULL);
-		g_free (value);
-	}
-
-	value = svGetValueStr_cp (netplan, "MODE");
-	if (value) {
-		char *lcase;
-		const char *mode = NULL;
-
-		lcase = g_ascii_strdown (value, -1);
-		g_free (value);
-
-		if (!strcmp (lcase, "ad-hoc")) {
-			mode = "adhoc";
-		} else if (!strcmp (lcase, "ap")) {
-			mode = "ap";
-		} else if (!strcmp (lcase, "managed") || !strcmp (lcase, "auto")) {
-			mode = "infrastructure";
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid mode '%s' (not 'Ad-Hoc', 'Ap', 'Managed', or 'Auto')",
-			             lcase);
-			g_free (lcase);
-			goto error;
-		}
-		g_free (lcase);
-
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, mode, NULL);
-	}
-
-	value = svGetValueStr_cp (netplan, "BSSID");
-	if (value) {
-		value = g_strstrip (value);
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_BSSID, value, NULL);
-		g_free (value);
-	}
-
-	value = svGetValueStr_cp (netplan, "CHANNEL");
-	if (value) {
-		chan = _nm_utils_ascii_str_to_int64 (value, 10, 1, 196, 0);
-		if (chan == 0) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid wireless channel '%s'", value);
-			g_free (value);
-			goto error;
-		}
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_CHANNEL, (guint32) chan, NULL);
-		g_free (value);
-	}
-
-	value = svGetValueStr_cp (netplan, "BAND");
-	if (value) {
-		if (!strcmp (value, "a")) {
-			if (chan && chan <= 14) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Band '%s' invalid for channel %u", value, (guint32) chan);
-				g_free (value);
-				goto error;
-			}
-		} else if (!strcmp (value, "bg")) {
-			if (chan && chan > 14) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Band '%s' invalid for channel %u", value, (guint32) chan);
-				g_free (value);
-				goto error;
-			}
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid wireless band '%s'", value);
-			g_free (value);
-			goto error;
-		}
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, value, NULL);
-		g_free (value);
-	} else if (chan > 0) {
-		if (chan > 14)
-			g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, "a", NULL);
-		else
-			g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, "bg", NULL);
-	}
-
-	value = svGetValueStr_cp (netplan, "MTU");
-	if (value) {
-		int mtu;
-
-		mtu = _nm_utils_ascii_str_to_int64 (value, 10, 0, 50000, -1);
-		if (mtu == -1) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid wireless MTU '%s'", value);
-			g_free (value);
-			goto error;
-		}
-		g_object_set (s_wireless, NM_SETTING_WIRELESS_MTU, (guint) mtu, NULL);
-		g_free (value);
-	}
-
-	g_object_set (s_wireless,
-	              NM_SETTING_WIRELESS_HIDDEN,
-	              svGetValueBoolean (netplan, "SSID_HIDDEN", FALSE),
-	              NULL);
-
-	cvalue = svGetValue (netplan, "POWERSAVE", &value);
-	if (cvalue) {
-		if (!strcmp (cvalue, "default"))
-			powersave = NM_SETTING_WIRELESS_POWERSAVE_DEFAULT;
-		else if (!strcmp (cvalue, "ignore"))
-			powersave = NM_SETTING_WIRELESS_POWERSAVE_IGNORE;
-		else if (!strcmp (cvalue, "disable") || !strcmp (cvalue, "no"))
-			powersave = NM_SETTING_WIRELESS_POWERSAVE_DISABLE;
-		else if (!strcmp (cvalue, "enable") || !strcmp (cvalue, "yes"))
-			powersave = NM_SETTING_WIRELESS_POWERSAVE_ENABLE;
-		else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid POWERSAVE value '%s'", cvalue);
-			g_free (value);
-			goto error;
-		}
-		g_free (value);
-	}
-
-	g_object_set (s_wireless,
-	              NM_SETTING_WIRELESS_POWERSAVE,
-	              powersave,
-	              NULL);
-
-	cvalue = svGetValue (netplan, "MAC_ADDRESS_RANDOMIZATION", &value);
-	if (cvalue) {
-		if (strcmp (cvalue, "default") == 0)
-			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
-		else if (strcmp (cvalue, "never") == 0)
-			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_NEVER;
-		else if (strcmp (cvalue, "always") == 0)
-			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_ALWAYS;
-		else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid MAC_ADDRESS_RANDOMIZATION value '%s'", cvalue);
-			g_free (value);
-			goto error;
-		}
-		g_free (value);
-	} else
-		mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
-
-	g_object_set (s_wireless,
-	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION,
-	              mac_randomization,
-	              NULL);
-
-	return NM_SETTING (s_wireless);
-
-error:
-	if (s_wireless)
-		g_object_unref (s_wireless);
-	return NULL;
-}
-
-static NMConnection *
-wireless_connection_from_netplan (const char *file,
-                                  shvarFile *netplan,
-                                  GError **error)
-{
-	NMConnection *connection = NULL;
-	NMSetting *con_setting = NULL;
-	NMSetting *wireless_setting = NULL;
-	NMSetting8021x *s_8021x = NULL;
-	GBytes *ssid;
-	NMSetting *security_setting = NULL;
-	gs_free char *ssid_utf8 = NULL;
-	const char *mode;
-	gboolean adhoc = FALSE;
-	GError *local = NULL;
-
-	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
-	g_return_val_if_fail (!error || !*error, NULL);
-
-	connection = nm_simple_connection_new ();
-
-	/* Wireless */
-	wireless_setting = make_wireless_setting (netplan, error);
-	if (!wireless_setting) {
-		g_object_unref (connection);
-		return NULL;
-	}
-	nm_connection_add_setting (connection, wireless_setting);
-
-	ssid = nm_setting_wireless_get_ssid (NM_SETTING_WIRELESS (wireless_setting));
-	mode = nm_setting_wireless_get_mode (NM_SETTING_WIRELESS (wireless_setting));
-	if (mode && !strcmp (mode, "adhoc"))
-		adhoc = TRUE;
-
-	/* Wireless security */
-	security_setting = make_wireless_security_setting (netplan, file, ssid, adhoc, &s_8021x, &local);
-	if (local) {
-		g_object_unref (connection);
-		g_propagate_error (error, local);
-		return NULL;
-	}
-	if (security_setting) {
-		nm_connection_add_setting (connection, security_setting);
-		if (s_8021x)
-			nm_connection_add_setting (connection, NM_SETTING (s_8021x));
-	}
-
-	if (ssid)
-		ssid_utf8 = _nm_utils_ssid_to_utf8 (ssid);
-
-	/* Connection */
-	con_setting = make_connection_setting (file,
-	                                       netplan,
-	                                       NM_SETTING_WIRELESS_SETTING_NAME,
-	                                       nm_str_not_empty (ssid_utf8) ?: "unmanaged",
-	                                       NULL);
-
-	if (!con_setting) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Failed to create connection setting.");
-		g_object_unref (connection);
-		return NULL;
-	}
-	nm_connection_add_setting (connection, con_setting);
-
-	return connection;
-}
-
-static void
-parse_ethtool_option (const char *value,
-                      NMSettingWiredWakeOnLan *out_flags,
-                      char **out_password,
-                      gboolean *out_autoneg,
-                      guint32 *out_speed,
-                      const char **out_duplex,
-                      NMSettingEthtool **out_s_ethtool)
-{
-	gs_free const char **words = NULL;
-	guint i;
-
-	words = nm_utils_strsplit_set (value, " \t\n");
-	if (!words)
-		return;
-
-	if (words[0] && words[0][0] == '-') {
-		/* /sbin/ethtool $opts */
-		if (NM_IN_STRSET (words[0], "-K", "--features", "--offload")) {
-			if (!words[1]) {
-				/* first argument must be the interface name. This is invalid. */
-				return;
-			}
-
-			if (!*out_s_ethtool)
-				*out_s_ethtool = NM_SETTING_ETHTOOL (nm_setting_ethtool_new ());
-
-			for (i = 2; words[i]; ) {
-				const char *opt = words[i];
-				const char *opt_val = words[++i];
-				const NMEthtoolData *d = NULL;
-				NMTernary onoff = NM_TERNARY_DEFAULT;
-
-				if (nm_streq0 (opt_val, "on"))
-					onoff = NM_TERNARY_TRUE;
-				else if (nm_streq0 (opt_val, "off"))
-					onoff = NM_TERNARY_FALSE;
-
-				d = nms_netplan_utils_get_ethtool_by_name (opt);
-
-				if (!d) {
-					if (onoff != NM_TERNARY_DEFAULT) {
-						/* the next value is just the on/off argument. Skip it too. */
-						i++;
-					}
-
-					/* silently ignore unsupported offloading features. */
-					continue;
-				}
-
-				i++;
-
-				if (onoff == NM_TERNARY_DEFAULT) {
-					PARSE_WARNING ("Expects on/off argument for feature '%s'", opt);
-					continue;
-				}
-
-				nm_setting_ethtool_set_feature (*out_s_ethtool,
-				                                d->optname,
-				                                onoff);
-			}
-		}
-		return;
-	}
-
-	/* /sbin/ethtool -s ${REALDEVICE} $opts */
-	for (i = 0; words[i]; ) {
-		const char *opt = words[i];
-		const char *opt_val = words[++i];
-
-		if (nm_streq (opt, "autoneg")) {
-			if (!opt_val) {
-				PARSE_WARNING ("Auto-negotiation option missing");
-				break;
-			}
-			i++;
-
-			if (nm_streq (opt_val, "off"))
-				*out_autoneg = FALSE;
-			else if (nm_streq (opt_val, "on"))
-				*out_autoneg = TRUE;
-			else
-				PARSE_WARNING ("Auto-negotiation unknown value: %s", opt_val);
-			continue;
-		}
-
-		if (nm_streq (opt, "speed")) {
-			guint32 speed;
-
-			if (!opt_val) {
-				PARSE_WARNING ("Speed option missing");
-				break;
-			}
-			i++;
-
-			speed =  _nm_utils_ascii_str_to_int64 (opt_val, 10, 0, G_MAXUINT32, 0);
-			if (errno == 0)
-				*out_speed = speed;
-			else
-				PARSE_WARNING ("Speed value '%s' is invalid", opt_val);
-			continue;
-		}
-
-		if (nm_streq (opt, "duplex")) {
-			if (!opt_val) {
-				PARSE_WARNING ("Duplex option missing");
-				break;
-			}
-			i++;
-
-			if (nm_streq (opt_val, "half"))
-				*out_duplex = "half";
-			else if (nm_streq (opt_val, "full"))
-				*out_duplex = "full";
-			else
-				PARSE_WARNING ("Duplex unknown value: %s", opt_val);
-			continue;
-		}
-
-		if (nm_streq (opt, "wol")) {
-			NMSettingWiredWakeOnLan wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_NONE;
-
-			if (!opt_val) {
-				PARSE_WARNING ("Wake-on-LAN options missing");
-				break;
-			}
-			i++;
-
-			for (; *opt_val; opt_val++) {
-				switch (*opt_val) {
-				case 'p':
-					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_PHY;
-					break;
-				case 'u':
-					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST;
-					break;
-				case 'm':
-					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST;
-					break;
-				case 'b':
-					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST;
-					break;
-				case 'a':
-					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_ARP;
-					break;
-				case 'g':
-					wol_flags |= NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC;
-					break;
-				case 's':
-					break;
-				case 'd':
-					wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_NONE;
-					break;
-				default:
-					PARSE_WARNING ("unrecognized Wake-on-LAN option '%c'", *opt_val);
-				}
-			}
-
-			*out_flags = wol_flags;
-			continue;
-		}
-
-		if (nm_streq (opt, "sopass")) {
-			if (!opt_val) {
-				PARSE_WARNING ("Wake-on-LAN password missing");
-				break;
-			}
-			i++;
-
-			if (nm_utils_hwaddr_valid (opt_val, ETH_ALEN)) {
-				g_clear_pointer (out_password, g_free);
-				*out_password = g_strdup (opt_val);
-			} else
-				PARSE_WARNING ("Wake-on-LAN password '%s' is invalid", opt_val);
-			continue;
-		}
-
-		/* Silently skip unknown options */
-	}
-}
-
-static GPtrArray *
-read_routing_rules_parse (shvarFile *netplan,
-                          gboolean routes_read)
-{
-	gs_unref_ptrarray GPtrArray *arr = NULL;
-	gs_free const char **keys = NULL;
-	guint i, len;
-
-	keys = svGetKeysSorted (netplan, SV_KEY_TYPE_ROUTING_RULE4 | SV_KEY_TYPE_ROUTING_RULE6, &len);
-	if (len == 0)
-		return NULL;
-
-	if (!routes_read) {
-		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing rules (ROUTING_RULE*) settings are ignored");
-		return NULL;
-	}
-
-	arr = g_ptr_array_new_full (len, (GDestroyNotify) nm_ip_routing_rule_unref);
-	for (i = 0; i < len; i++) {
-		const char *key = keys[i];
-		nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
-		gs_free_error GError *local = NULL;
-		gs_free char *value_to_free = NULL;
-		const char *value;
-		gboolean key_is_ipv4;
-
-		key_is_ipv4 = (key[NM_STRLEN ("ROUTING_RULE")] == '_');
-		nm_assert (  key_is_ipv4  == NM_STR_HAS_PREFIX (key, "ROUTING_RULE_"));
-		nm_assert ((!key_is_ipv4) == NM_STR_HAS_PREFIX (key, "ROUTING_RULE6_"));
-
-		value = svGetValueStr (netplan, key, &value_to_free);
-		if (!value)
-			continue;
-
-		rule = nm_ip_routing_rule_from_string (value,
-		                                       NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
-		                                       | (key_is_ipv4
-		                                          ? NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET
-		                                          : NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6),
-		                                       NULL,
-		                                       &local);
-		if (!rule) {
-			PARSE_WARNING ("invalid routing rule %s=\"%s\": %s", key, value, local->message);
-			continue;
-		}
-
-		g_ptr_array_add (arr, g_steal_pointer (&rule));
-	}
+	if (nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
+		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP
+		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_8021X)
+		return NULL; /* Not WPA or Dynamic WEP */
 
-	if (arr->len == 0)
+#if 0  /* TODO: support WPS */
+	/* WPS */
+	i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
+	if (!svGetValueEnum (netplan, "WPS_METHOD",
+	                     nm_setting_wireless_security_wps_method_get_type (),
+	                     &i_val, error))
 		return NULL;
+	g_object_set (wsec,
+	              NM_SETTING_WIRELESS_SECURITY_WPS_METHOD, (guint) i_val,
+	              NULL);
+#endif
 
-	return g_steal_pointer (&arr);
-}
-
-static void
-read_routing_rules (shvarFile *netplan,
-                    gboolean routes_read,
-                    NMSettingIPConfig *s_ip4,
-                    NMSettingIPConfig *s_ip6)
-{
-	gs_unref_ptrarray GPtrArray *routing_rules = NULL;
-	guint i;
-
-	routing_rules = read_routing_rules_parse (netplan, routes_read);
-	if (!routing_rules)
-		return;
-
-	for (i = 0; i < routing_rules->len; i++) {
-		NMIPRoutingRule *rule = routing_rules->pdata[i];
-
-		nm_setting_ip_config_add_routing_rule (  (nm_ip_routing_rule_get_addr_family (rule) == AF_INET)
-		                                       ? s_ip4
-		                                       : s_ip6,
-		                                       rule);
-	}
-}
-
-static void
-parse_ethtool_options (shvarFile *netplan, NMConnection *connection)
-{
-	NMSettingWired *s_wired;
-	gs_unref_object NMSettingEthtool *s_ethtool = NULL;
-	NMSettingWiredWakeOnLan wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT;
-	gs_free char *ethtool_opts_free = NULL;
-	const char *ethtool_opts;
-	gs_free char *wol_password = NULL;
-	gs_free char *wol_value_free = NULL;
-	const char *tmp;
-	gboolean autoneg = FALSE;
-	guint32 speed = 0;
-	const char *duplex = NULL;
-	gboolean wired_found = FALSE;
-
-	ethtool_opts = svGetValue (netplan, "ETHTOOL_OPTS", &ethtool_opts_free);
-	if (ethtool_opts) {
-		wired_found = TRUE;
-		/* WAKE_ON_LAN_IGNORE is inferred from a specified but empty ETHTOOL_OPTS */
-		if (!ethtool_opts[0])
-			wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE;
-		else {
-			gs_free const char **opts = NULL;
-			const char *const *iter;
-
-			opts = nm_utils_strsplit_set (ethtool_opts, ";");
-			for (iter = opts; iter && iter[0]; iter++) {
-				/* in case of repeated wol_passwords, parse_ethtool_option()
-				 * will do the right thing and clear wol_password before resetting. */
-				parse_ethtool_option (iter[0],
-				                      &wol_flags,
-				                      &wol_password,
-				                      &autoneg,
-				                      &speed,
-				                      &duplex,
-				                      &s_ethtool);
-			}
-		}
-	}
-
-	/* ETHTOOL_WAKE_ON_LAN = ignore overrides WoL settings in ETHTOOL_OPTS */
-	tmp = svGetValue (netplan, "ETHTOOL_WAKE_ON_LAN", &wol_value_free);
-	if (tmp)
-		wired_found = TRUE;
-	if (nm_streq0 (tmp, "ignore"))
-		wol_flags = NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE;
-	else if (tmp)
-		PARSE_WARNING ("invalid ETHTOOL_WAKE_ON_LAN value '%s'", tmp);
-
-	if (   wol_password
-	    && !NM_FLAGS_HAS (wol_flags, NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC)) {
-		PARSE_WARNING ("Wake-on-LAN password not expected");
-		nm_clear_g_free (&wol_password);
-	}
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	if (!s_wired && wired_found) {
-		s_wired = (NMSettingWired *) nm_setting_wired_new ();
-		nm_connection_add_setting (connection, NM_SETTING (s_wired));
-	}
-	if (s_wired) {
-		g_object_set (s_wired,
-		              NM_SETTING_WIRED_WAKE_ON_LAN, wol_flags,
-		              NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD, wol_password,
-		              NM_SETTING_WIRED_AUTO_NEGOTIATE, autoneg,
-		              NM_SETTING_WIRED_SPEED, speed,
-		              NM_SETTING_WIRED_DUPLEX, duplex,
-		              NULL);
-	}
-
-	if (s_ethtool) {
-		nm_connection_add_setting (connection,
-		                           NM_SETTING (g_steal_pointer (&s_ethtool)));
-	}
-}
-
-static NMSetting *
-make_wired_setting (shvarFile *netplan,
-                    const char *file,
-                    NMSetting8021x **s_8021x,
-                    GError **error)
-{
-	gs_unref_object NMSettingWired *s_wired = NULL;
-	const char *cvalue;
-	gs_free char *value = NULL;
-	gboolean found = FALSE;
-
-	s_wired = NM_SETTING_WIRED (nm_setting_wired_new ());
-
-	cvalue = svGetValue (netplan, "MTU", &value);
-	if (cvalue) {
-		int mtu;
-
-		mtu = _nm_utils_ascii_str_to_int64 (cvalue, 0, 0, 65535, -1);
-		if (mtu >= 0)
-			g_object_set (s_wired, NM_SETTING_WIRED_MTU, (guint) mtu, NULL);
-		else
-			PARSE_WARNING ("invalid MTU '%s'", cvalue);
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-
-	value = svGetValue_cp (netplan, "HWADDR");
-	if (value) {
-		if (value[0] != '\0') {
-			value = g_strstrip (value);
-			g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, value, NULL);
-		}
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-
-	cvalue = svGetValue (netplan, "SUBCHANNELS", &value);
-	if (cvalue) {
-		if (cvalue[0] != '\0') {
-			const char *p = cvalue;
-			gboolean success = TRUE;
-
-			/* basic sanity checks */
-			while (*p) {
-				if (!g_ascii_isxdigit (*p) && (*p != ',') && (*p != '.')) {
-					PARSE_WARNING ("invalid SUBCHANNELS '%s'", cvalue);
-					success = FALSE;
-					break;
-				}
-				p++;
-			}
-
-			if (success) {
-				gs_free const char **chans = NULL;
-				guint32 num_chans;
-
-				chans = nm_utils_strsplit_set (cvalue, ",");
-				num_chans = NM_PTRARRAY_LEN (chans);
-				if (num_chans < 2 || num_chans > 3) {
-					PARSE_WARNING ("invalid SUBCHANNELS '%s' (%u channels, 2 or 3 expected)",
-					               cvalue, (unsigned) NM_PTRARRAY_LEN (chans));
-				} else
-					g_object_set (s_wired, NM_SETTING_WIRED_S390_SUBCHANNELS, chans, NULL);
-			}
-		}
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-
-	cvalue = svGetValue (netplan, "PORTNAME", &value);
-	if (cvalue) {
-		if (cvalue[0] != '\0')
-			nm_setting_wired_add_s390_option (s_wired, "portname", cvalue);
-		found = TRUE;
-		nm_clear_g_free (&value);
-	}
-
-	cvalue = svGetValue (netplan, "CTCPROT", &value);
-	if (cvalue) {
-		if (cvalue[0] != '\0')
-			nm_setting_wired_add_s390_option (s_wired, "ctcprot", cvalue);
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-
-	cvalue = svGetValue (netplan, "NETTYPE", &value);
-	if (cvalue) {
-		if (NM_IN_STRSET (cvalue, "qeth", "lcs", "ctc"))
-			g_object_set (s_wired, NM_SETTING_WIRED_S390_NETTYPE, cvalue, NULL);
-		else
-			PARSE_WARNING ("unknown s390 NETTYPE '%s'", cvalue);
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-
-	cvalue = svGetValue (netplan, "OPTIONS", &value);
-	if (cvalue)
-		found = TRUE;
-	if (cvalue && cvalue[0]) {
-		gs_free const char **options = NULL;
-		gsize i;
-
-		options = nm_utils_escaped_tokens_split (cvalue, NM_ASCII_SPACES);
-		for (i = 0; options && options[i]; i++) {
-			const char *line = options[i];
-			const char *equals;
-			gboolean valid = FALSE;
-
-			equals = strchr (line, '=');
-			if (equals) {
-				((char *) equals)[0] = '\0';
-				valid = nm_setting_wired_add_s390_option (s_wired, line, equals + 1);
-			}
-			if (!valid)
-				PARSE_WARNING ("invalid s390 OPTION '%s'", line);
-		}
-		found = TRUE;
-	}
-	nm_clear_g_free (&value);
-
-	cvalue = svGetValueStr (netplan, "MACADDR", &value);
-	if (cvalue) {
-		if (cvalue[0] != '\0') {
-			g_object_set (s_wired,
-			              NM_SETTING_WIRED_CLONED_MAC_ADDRESS,
-			              cvalue,
-			              NULL);
-		}
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-
-	cvalue = svGetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK", &value);
-	if (cvalue) {
-		if (cvalue[0] != '\0') {
-			g_object_set (s_wired,
-			              NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK,
-			              cvalue,
-			              NULL);
-		}
-		nm_clear_g_free (&value);
-		found = TRUE;
+	/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
+	if (nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
+		|| nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_EAP) {
+		fill_wpa_ciphers (netplan, wsec, FALSE, adhoc);
+		fill_wpa_ciphers (netplan, wsec, TRUE, adhoc);
 	}
 
-	cvalue = svGetValueStr (netplan, "HWADDR_BLACKLIST", &value);
-	if (cvalue) {
-		gs_free const char **strv = NULL;
+	/* Adhoc only supports RSN */
+	if (!adhoc)
+		nm_setting_wireless_security_add_proto (wsec, "wpa");
+	nm_setting_wireless_security_add_proto (wsec, "rsn");
 
-		strv = transform_hwaddr_blacklist (cvalue);
-		g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST, strv, NULL);
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
+	if (nd->auth.password)
+		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, nd->auth.password, NULL);
 
-	cvalue = svGetValue (netplan, "KEY_MGMT", &value);
-	if (cvalue)
-		found = TRUE;
-	if (cvalue && cvalue[0] != '\0') {
-		if (!strcmp (cvalue, "IEEE8021X")) {
-			*s_8021x = fill_8021x (netplan, file, cvalue, FALSE, error);
-			if (!*s_8021x)
-				return NULL;
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Unknown wired KEY_MGMT type '%s'", cvalue);
-			return NULL;
-		}
+	if (nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK)
+		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
+	else {
+		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
 	}
-	nm_clear_g_free (&value);
 
-	if (!found) {
-		g_set_error (error,
-		             NM_UTILS_ERROR,
-		             NM_UTILS_ERROR_SETTING_MISSING,
-		             "The setting is missing.");
+	*s_8021x = fill_8021x (netplan, file, v, TRUE, error);
+	if (!*s_8021x)
 		return NULL;
-	}
 
-	return (NMSetting *) g_steal_pointer (&s_wired);
+	/* TODO: support WPA PMF, FILS */
+
+#if 0
+	v = svGetValueStr (netplan, "SECURITYMODE", &value);
+	if (NM_IN_STRSET (v, NULL, "open"))
+		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, v, NULL);
+#endif
+
+	return (NMSetting *) g_steal_pointer (&wsec);
 }
 
-static NMConnection *
-wired_connection_from_netplan (const char *file,
-                               shvarFile *netplan,
-                               GError **error)
+#if 0  /* TODO: LEAP not yet supported in netplan yaml */
+static NMSetting *
+make_leap_setting (NetplanNetDefinition *nd,
+                   const char *file,
+                   GError **error)
 {
-	NMConnection *connection = NULL;
-	NMSetting *con_setting = NULL;
-	NMSetting *wired_setting = NULL;
-	NMSetting8021x *s_8021x = NULL;
-	GError *local = NULL;
+	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
+	gs_free char *value   = NULL;
+	NMSettingSecretFlag  s flags;
+  
+	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 
-	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
+	if (nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_8021X)
+		return NULL;
 
-	connection = nm_simple_connection_new ();
+	if (nd->auth.eap_method != NETPLAN_AUTH_EAP_LEAP)
+		return NULL; /* Not LEAP */
 
-	con_setting = make_connection_setting (file, netplan, NM_SETTING_WIRED_SETTING_NAME, NULL, NULL);
-	if (!con_setting) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Failed to create connection setting.");
-		g_object_unref (connection);
-		return NULL;
+	flags = _secret_read_netplan_flags (netplan, "IEEE_8021X_PASSWORD_FLAGS");
+	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags, NULL);
+
+	/* Read LEAP password if it's system-owned */
+	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
+		value = svGetValueStr_cp (netplan, "IEEE_8021X_PASSWORD");
+		if (!value) {
+			/* Try to get keys from the "shadow" key file */
+			k  eys_netplan = utils_get_keys_netplan (file, FALSE);
+  			if (keys_netpl  an) {
+				  value = svGetV    alueStr_cp (keys_netplan, "IEEE_8021X_PASSWORD");
+  				svCloseFile (k      eys_netplan);
+  		    	}
+	    	}
+		if (value && strle  n (value))
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, value, NULL);
+		nm_clear_g_free (&value);
 	}
-	nm_connection_add_setting (connection, con_setting);
 
-	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
-	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
-		g_propagate_error (error, local);
-		g_object_unref (connection);
+	value = svGetValueStr_cp (netplan, "IEEE_8021X_IDENTITY");
+	if (!value) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Missing LEAP identity");
 		return NULL;
 	}
-	g_clear_error (&local);
-
-	if (wired_setting)
-		nm_connection_add_setting (connection, wired_setting);
+	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, value, NULL);
+	nm_clear_g_free (&value);
 
-	if (s_8021x)
-		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+	g_object_set (wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
+	              NULL);
 
-	return connection;
+	return (NMSetting *) g_steal_pointer (&wsec);
 }
+#endif
 
-static gboolean
-parse_infiniband_p_key (shvarFile *netplan,
-                        int *out_p_key,
-                        char **out_parent,
-                        GError **error)
+static NMSetting *
+make_wireless_security_setting (NetplanNetDefinition *nd,
+                                const char *file,
+                                GBytes *ssid,
+                                gboolean adhoc,
+                                NMSetting8021x **s_8021x,
+                                GError **error)
 {
-	char *device = NULL, *physdev = NULL, *pkey_id = NULL;
-	char *ifname = NULL;
-	int id;
-	gboolean ret = FALSE;
-
-	device = svGetValueStr_cp (netplan, "DEVICE");
-	if (!device) {
-		PARSE_WARNING ("InfiniBand connection specified PKEY but not DEVICE");
-		goto done;
-	}
-
-	physdev = svGetValueStr_cp (netplan, "PHYSDEV");
-	if (!physdev) {
-		PARSE_WARNING ("InfiniBand connection specified PKEY but not PHYSDEV");
-		goto done;
-	}
-
-	pkey_id = svGetValueStr_cp (netplan, "PKEY_ID");
-	if (!pkey_id) {
-		PARSE_WARNING ("InfiniBand connection specified PKEY but not PKEY_ID");
-		goto done;
-	}
+	NMSetting *wsec;
 
-	id = _nm_utils_ascii_str_to_int64 (pkey_id, 0, 0, 0xFFFF, -1);
-	if (id == -1) {
-		PARSE_WARNING ("invalid InfiniBand PKEY_ID '%s'", pkey_id);
-		goto done;
-	}
-	id = (id | 0x8000);
+	g_return_val_if_fail (error && !*error, NULL);
 
-	ifname = g_strdup_printf ("%s.%04x", physdev, (unsigned) id);
-	if (strcmp (device, ifname) != 0) {
-		PARSE_WARNING ("InfiniBand DEVICE (%s) does not match PHYSDEV+PKEY_ID (%s)",
-		               device, ifname);
-		goto done;
+#if 0  /* TODO: LEAP support */
+	if (!adhoc) {
+		wsec = make_leap_setting (netplan, file, error);
+		if (wsec)
+			return wsec;
+		else if (*error)
+			return NULL;
 	}
+#endif
 
-	*out_p_key = id;
-	*out_parent = g_strdup (physdev);
-	ret = TRUE;
+	wsec = make_wpa_setting (netplan, file, ssid, adhoc, s_8021x, error);
+	if (wsec)
+		return wsec;
+	else if (*error)
+		return NULL;
 
- done:
-	g_free (device);
-	g_free (physdev);
-	g_free (pkey_id);
-	g_free (ifname);
+	wsec = make_wep_setting (netplan, file, error);
+	if (wsec)
+		return wsec;
+	else if (*error)
+		return NULL;
 
-	if (!ret) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Failed to create InfiniBand setting.");
-	}
-	return ret;
+	return NULL; /* unencrypted */
 }
 
 static NMSetting *
-make_infiniband_setting (shvarFile *netplan,
-                         const char *file,
-                         GError **error)
+make_wireless_setting (NetplanNetDefinition *nd,
+                       GError **error)
 {
-	NMSettingInfiniband *s_infiniband;
-	char *value = NULL;
+	NMSettingWireless *s_wireless;
+	//const char *cvalue;
+	//gint64 chan = 0;
+	//NMSettingMacRandomization mac_randomization;
+	//NMSettingWirelessPowersave powersave = NM_SETTING_WIRELESS_POWERSAVE_DEFAULT;
+	GHashTableIter iter;
+	gpointer key, value;
 
-	s_infiniband = NM_SETTING_INFINIBAND (nm_setting_infiniband_new ());
+	s_wireless = NM_SETTING_WIRELESS (nm_setting_wireless_new ());
 
-	value = svGetValueStr_cp (netplan, "MTU");
+	value = nd->set_mac;
 	if (value) {
-		int mtu;
-
-		mtu = _nm_utils_ascii_str_to_int64 (value, 0, 0, 65535, -1);
-		if (mtu >= 0)
-			g_object_set (s_infiniband, NM_SETTING_INFINIBAND_MTU, (guint) mtu, NULL);
-		else
-			PARSE_WARNING ("invalid MTU '%s'", value);
+		value = g_strstrip (value);
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS, value, NULL);
 		g_free (value);
 	}
 
-	value = svGetValueStr_cp (netplan, "HWADDR");
+#if 0  /* TODO: read in generate_mac_address_mask ? */
+	//g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
+
+	value = svGetValueStr_cp (netplan, "GENERATE_MAC_ADDRESS_MASK");
+	g_object_set (s_wireless, NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK, value, NULL);
+	g_free (value);
+#endif
+
+	g_hash_table_iter_init (&iter, nd->access_points);
+	g_hash_table_iter_next (&iter, &key, &value);
 	if (value) {
-		value = g_strstrip (value);
-		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_MAC_ADDRESS, value, NULL);
-		g_free (value);
-	}
+		NetplanWifiAccessPoint *ap = (NetplanWifiAccessPoint *) value;
+		gs_unref_bytes GBytes *bytes = NULL;
+		gsize ssid_len = 0;
+		gsize value_len = strlen (ap->ssid);
+		//char *lcase;
+		const char *mode = NULL;
 
-	if (svGetValueBoolean (netplan, "CONNECTED_MODE", FALSE))
-		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "connected", NULL);
-	else
-		g_object_set (s_infiniband, NM_SETTING_INFINIBAND_TRANSPORT_MODE, "datagram", NULL);
+		if (   value_len > 2
+		    && (value_len % 2) == 0
+		    && g_str_has_prefix (ap->ssid, "0x")
+		    && NM_STRCHAR_ALL (&(ap->ssid[2]), ch, g_ascii_isxdigit (ch))) {
+			/* interpret the value as hex-digits iff value starts
+			 * with "0x" followed by pairs of hex digits */
+			bytes = nm_utils_hexstr2bin (&(ap->ssid[2]));
+		} else
+			bytes = g_bytes_new (ap->ssid, value_len);
+
+		ssid_len = g_bytes_get_size (bytes);
+		if (ssid_len > 32 || ssid_len == 0) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid SSID '%s' (size %zu not between 1 and 32 inclusive)",
+			             ap->ssid, ssid_len);
+			goto error;
+		}
 
-	if (svGetValueBoolean (netplan, "PKEY", FALSE)) {
-		gs_free char *parent = NULL;
-		int p_key;
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, bytes, NULL);
 
-		if (!parse_infiniband_p_key (netplan, &p_key, &parent, error)) {
-			g_object_unref (s_infiniband);
-			return NULL;
+		/* FIXME: Use netplan parse.h DEFINEs instead of hard-coded values */
+		if (ap->mode == 0) {
+			mode = "infrastructure";
+		} else if (ap->mode == 1) {
+			mode = "adhoc";
+		} else if (ap->mode == 2) {
+			mode = "ap";
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid mode '%d' (not 'adhoc', 'ap', or 'infrastructure')",
+			             ap->mode);
+			goto error;
 		}
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, mode, NULL);
 
-		g_object_set (s_infiniband,
-		              NM_SETTING_INFINIBAND_P_KEY, p_key,
-		              NM_SETTING_INFINIBAND_PARENT, parent,
-		              NULL);
+		/* TODO: Handle BSSID ("MAC" for picking a specific AP) */
+		/* TODO: Handle wireless channel (needs netplan work) */
+		/* TODO: Handle wireless band (needs netplan work) */
 	}
 
-	return (NMSetting *) s_infiniband;
+	if (nd->mtubytes > 0)
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MTU, nd->mtubytes, NULL);
+
+	/* TODO: Possibly handle hidden SSIDs need extra flag for broadcasting... */
+	g_object_set (s_wireless, NM_SETTING_WIRELESS_HIDDEN, FALSE, NULL);
+
+	/* TODO: Support toggling powersave for wifi */
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_POWERSAVE,
+	              NM_SETTING_WIRELESS_POWERSAVE_ENABLE,
+	              NULL);
+
+#if 0  /* TODO: Add support for MAC address randomization */
+	cvalue = svGetValue (netplan, "MAC_ADDRESS_RANDOMIZATION", &value);
+	if (cvalue) {
+		if (strcmp (cvalue, "default") == 0)
+			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
+		else if (strcmp (cvalue, "never") == 0)
+			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_NEVER;
+		else if (strcmp (cvalue, "always") == 0)
+			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_ALWAYS;
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid MAC_ADDRESS_RANDOMIZATION value '%s'", cvalue);
+			g_free (value);
+			goto error;
+		}
+		g_free (value);
+	} else
+		mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
+
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION,
+	              mac_randomization,
+	              NULL);
+#endif  /* MAC address randomization */
+
+	return NM_SETTING (s_wireless);
+
+error:
+	if (s_wireless)
+		g_object_unref (s_wireless);
+	return NULL;
 }
 
 static NMConnection *
-infiniband_connection_from_netplan (const char *file,
-                                    shvarFile *netplan,
-                                    GError **error)
+wireless_connection_from_netplan (const char *file,
+                                  NetplanNetDefinition *nd,
+                                  GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
-	NMSetting *infiniband_setting = NULL;
+	NMSetting *wireless_setting = NULL;
+	//NMSetting8021x *s_8021x = NULL;
+	GBytes *ssid;
+	//NMSetting *security_setting = NULL;
+	gs_free char *ssid_utf8 = NULL;
+	//GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
+	g_return_val_if_fail (nd != NULL, NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, netplan, NM_SETTING_INFINIBAND_SETTING_NAME, NULL, NULL);
-	if (!con_setting) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Failed to create connection setting.");
+	/* Wireless */
+	wireless_setting = make_wireless_setting (nd, error);
+	if (!wireless_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
-	nm_connection_add_setting (connection, con_setting);
+	nm_connection_add_setting (connection, wireless_setting);
+
+	ssid = nm_setting_wireless_get_ssid (NM_SETTING_WIRELESS (wireless_setting));
+
+	/* Wireless security */
+	security_setting = make_wireless_security_setting (netplan, file, ssid, adhoc, &s_8021x, &local);
+	if (local) {
+		g_object_unref (connection);
+		g_propagate_error (error, local);
+		return NULL;
+	}
+	if (security_setting) {
+		nm_connection_add_setting (connection, security_setting);
+		if (s_8021x)
+			nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+	}
+
+	if (ssid)
+		ssid_utf8 = _nm_utils_ssid_to_utf8 (ssid);
+
+	/* Connection */
+	con_setting = make_connection_setting (file,
+	                                       nd,
+	                                       NM_SETTING_WIRELESS_SETTING_NAME,
+	                                       nm_str_not_empty (ssid_utf8) ?: "unmanaged",
+	                                       NULL);
 
-	infiniband_setting = make_infiniband_setting (netplan, file, error);
-	if (!infiniband_setting) {
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
 		g_object_unref (connection);
 		return NULL;
 	}
-	nm_connection_add_setting (connection, infiniband_setting);
+	nm_connection_add_setting (connection, con_setting);
 
 	return connection;
 }
 
+/* TODO: Support ethtool settings */
+
+#if 0  /* TODO: Read routing rules (routing-policy) */
 static void
-handle_bond_option (NMSettingBond *s_bond,
-                    const char *key,
-                    const char *value)
+read_routing_rules (NetplanNetDefinition *nd,
+                    gboolean routes_read,
+                    NMSettingIPConfig *s_ip4,
+                    NMSettingIPConfig *s_ip6)
 {
-	char *sanitized = NULL, *j;
-	const char *p = value;
-
-	/* Remove any quotes or +/- from arp_ip_target */
-	if (!g_strcmp0 (key, NM_SETTING_BOND_OPTION_ARP_IP_TARGET) && value && value[0]) {
-		if (*p == '\'' || *p == '"')
-			p++;
-		j = sanitized = g_malloc0 (strlen (p) + 1);
-		while (*p) {
-			if (*p != '+' && *p != '-' && *p != '\'' && *p != '"')
-				*j++ = *p;
-			p++;
-		}
-	}
+	gs_unref_ptrarray GPtrArray *routing_rules = NULL;
+	guint i;
+
+	routing_rules = read_routing_rules_parse (netplan, routes_read);
+	if (!routing_rules)
+		return;
+
+	for (i = 0; i < routing_rules->len; i++) {
+		NMIPRoutingRule *rule = routing_rules->pdata[i];
 
-	if (!nm_setting_bond_add_option (s_bond, key, sanitized ?: value))
-		PARSE_WARNING ("invalid bonding option '%s' = %s",
-		               key, sanitized ?: value);
-	g_free (sanitized);
+		nm_setting_ip_config_add_routing_rule (  (nm_ip_routing_rule_get_addr_family (rule) == AF_INET)
+		                                       ? s_ip4
+		                                       : s_ip6,
+		                                       rule);
+	}
 }
+#endif  /* routing rules */
 
 static NMSetting *
-make_bond_setting (shvarFile *netplan,
-                   const char *file,
-                   GError **error)
+make_wired_setting (NetplanNetDefinition *nd,
+                    const char *file,
+                    NMSetting8021x **s_8021x,
+                    GError **error)
 {
-	NMSettingBond *s_bond;
+	gs_unref_object NMSettingWired *s_wired = NULL;
+	//const char *cvalue;
 	gs_free char *value = NULL;
-	const char *v;
+	//gboolean found = FALSE;
 
-	v = svGetValueStr (netplan, "DEVICE", &value);
-	if (!v) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "mandatory DEVICE keyword missing");
-		return NULL;
-	}
+	s_wired = NM_SETTING_WIRED (nm_setting_wired_new ());
 
-	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
+	if (nd->mtubytes > 0)
+		g_object_set (s_wired, NM_SETTING_WIRED_MTU, nd->mtubytes, NULL);
 
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "BONDING_OPTS", &value);
-	if (v) {
-		gs_free const char **items = NULL;
-		const char *const *iter;
+	value = nd->set_mac;
+	if (value)
+		g_object_set (s_wired, NM_SETTING_WIRED_CLONED_MAC_ADDRESS, value, NULL);
 
-		items = nm_utils_strsplit_set (v, " ");
-		for (iter = items; iter && *iter; iter++) {
-			gs_free char *key = NULL;
-			const char *val;
-
-			val = strchr (*iter, '=');
-			if (!val)
-				continue;
-			key = g_strndup (*iter, val - *iter);
-			val++;
-			if (key[0] && val[0])
-				handle_bond_option (s_bond, key, val);
+	/* TODO: Add subchannels and other s390 options */
+
+#if 0  /* TODO: wired: generate mac address */
+	cvalue = svGetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK", &value);
+	if (cvalue) {
+		if (cvalue[0] != '\0') {
+			g_object_set (s_wired,
+			              NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK,
+			              cvalue,
+			              NULL);
 		}
+		nm_clear_g_free (&value);
+		found = TRUE;
 	}
+#endif  /* generate mac address */
 
-	return (NMSetting *) s_bond;
+#if 0  /* TODO: 802.1x wired settings */
+	cvalue = svGetValue (netplan, "KEY_MGMT", &value);
+	if (cvalue)
+		found = TRUE;
+	if (cvalue && cvalue[0] != '\0') {
+		if (!strcmp (cvalue, "IEEE8021X")) {
+			*s_8021x = fill_8021x (netplan, file, cvalue, FALSE, error);
+			if (!*s_8021x)
+				return NULL;
+		} else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Unknown wired KEY_MGMT type '%s'", cvalue);
+			return NULL;
+		}
+	}
+	nm_clear_g_free (&value);
+#endif  /* 802.1x */
+
+	return (NMSetting *) g_steal_pointer (&s_wired);
 }
 
 static NMConnection *
-bond_connection_from_netplan (const char *file,
-                              shvarFile *netplan,
-                              GError **error)
+wired_connection_from_netplan (const char *file,
+                               NetplanNetDefinition *nd,
+                               GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
-	NMSetting *bond_setting = NULL;
 	NMSetting *wired_setting = NULL;
 	NMSetting8021x *s_8021x = NULL;
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
+	g_return_val_if_fail (nd != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, netplan, NM_SETTING_BOND_SETTING_NAME, NULL, _("Bond"));
+	con_setting = make_connection_setting (file, nd, NM_SETTING_WIRED_SETTING_NAME, NULL, NULL);
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -4904,14 +1955,7 @@ bond_connection_from_netplan (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	bond_setting = make_bond_setting (netplan, file, error);
-	if (!bond_setting) {
-		g_object_unref (connection);
-		return NULL;
-	}
-	nm_connection_add_setting (connection, bond_setting);
-
-	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (nd, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -4928,47 +1972,81 @@ bond_connection_from_netplan (const char *file,
 	return connection;
 }
 
+/* TODO: implement infiniband support for reader */
+
 static NMSetting *
-make_team_setting (shvarFile *netplan,
+make_bond_setting (NetplanNetDefinition *nd,
                    const char *file,
                    GError **error)
 {
-	NMSetting *s_team;
-	gs_free char *value_device = NULL;
-	gs_free char *value = NULL;
+	NMSettingBond *s_bond;
 
-	if (!svGetValueStr (netplan, "DEVICE", &value_device)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "mandatory DEVICE keyword missing");
-		return NULL;
+	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
+
+	/* TODO: map bond_params fields to NM_SETTING_BOND fields */
+#if 0
+   struct {
+        char* lacp_rate;
+        guint min_links;
+        char* transmit_hash_policy;
+        char* selection_logic;
+        gboolean all_slaves_active;
+        char* arp_validate;
+        char* arp_all_targets;
+        char* fail_over_mac_policy;
+        guint gratuitous_arp;
+        /* TODO: unsolicited_na */
+        guint packets_per_slave;
+        char* primary_reselect_policy;
+        guint resend_igmp;
+        char* learn_interval;
+    } bond_params;
+#endif
+
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, nd->bond_params.mode);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, nd->bond_params.primary_slave);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, nd->bond_params.monitor_interval);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, nd->bond_params.down_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, nd->bond_params.up_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_INTERVAL, nd->bond_params.arp_interval);
+
+	if (nd->bond_params.arp_ip_targets) {
+		char *ip_target;
+		GString *ip_targets = g_string_sized_new (200);
+		gint i;
+
+		for (i = 0; (ip_target = (char *)g_array_index(nd->bond_params.arp_ip_targets, gpointer, i)) != NULL; i++) {
+			if (i > 0)
+				g_string_append_printf (ip_targets, ",");
+			g_string_append_printf (ip_targets, "%s", ip_target);
+		}
+
+		nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_IP_TARGET, ip_targets->str);
+		g_string_free (ip_targets, TRUE);
 	}
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, nd->bond_params.lacp_rate);
 
-	s_team = nm_setting_team_new ();
-	g_object_set (s_team,
-	              NM_SETTING_TEAM_CONFIG,
-	              svGetValue (netplan, "TEAM_CONFIG", &value),
-	              NULL);
-	return s_team;
+	return (NMSetting *) s_bond;
 }
 
 static NMConnection *
-team_connection_from_netplan (const char *file,
-                              shvarFile *netplan,
+bond_connection_from_netplan (const char *file,
+                              NetplanNetDefinition *nd,
                               GError **error)
 {
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
-	NMSetting *team_setting = NULL;
+	NMSetting *bond_setting = NULL;
 	NMSetting *wired_setting = NULL;
 	NMSetting8021x *s_8021x = NULL;
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
+	g_return_val_if_fail (nd != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, netplan, NM_SETTING_TEAM_SETTING_NAME, NULL, _("Team"));
+	con_setting = make_connection_setting (file, nd, NM_SETTING_BOND_SETTING_NAME, NULL, _("Bond"));
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -4977,14 +2055,14 @@ team_connection_from_netplan (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	team_setting = make_team_setting (netplan, file, error);
-	if (!team_setting) {
+	bond_setting = make_bond_setting (nd, file, error);
+	if (!bond_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
-	nm_connection_add_setting (connection, team_setting);
+	nm_connection_add_setting (connection, bond_setting);
 
-	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (nd, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -5001,241 +2079,60 @@ team_connection_from_netplan (const char *file,
 	return connection;
 }
 
-typedef enum {
-	BRIDGE_OPT_TYPE_MAIN,
-	BRIDGE_OPT_TYPE_OPTION,
-	BRIDGE_OPT_TYPE_PORT_MAIN,
-	BRIDGE_OPT_TYPE_PORT_OPTION,
-} BridgeOptType;
-
-typedef void (*BridgeOptFunc) (NMSetting *setting,
-                               gboolean stp,
-                               const char *key,
-                               const char *value,
-                               BridgeOptType opt_type);
-
-static void
-handle_bridge_option (NMSetting *setting,
-                      gboolean stp,
-                      const char *key,
-                      const char *value,
-                      BridgeOptType opt_type)
-{
-	static const struct {
-		const char *key;
-		const char *property_name;
-		BridgeOptType opt_type;
-		gboolean only_with_stp;
-		gboolean extended_bool;
-	} m/*etadata*/[] = {
-		{ "DELAY",              NM_SETTING_BRIDGE_FORWARD_DELAY,      BRIDGE_OPT_TYPE_MAIN,   .only_with_stp = TRUE },
-		{ "priority",           NM_SETTING_BRIDGE_PRIORITY,           BRIDGE_OPT_TYPE_OPTION, .only_with_stp = TRUE },
-		{ "hello_time",         NM_SETTING_BRIDGE_HELLO_TIME,         BRIDGE_OPT_TYPE_OPTION, .only_with_stp = TRUE },
-		{ "max_age",            NM_SETTING_BRIDGE_MAX_AGE,            BRIDGE_OPT_TYPE_OPTION, .only_with_stp = TRUE },
-		{ "ageing_time",        NM_SETTING_BRIDGE_AGEING_TIME,        BRIDGE_OPT_TYPE_OPTION },
-		{ "multicast_snooping", NM_SETTING_BRIDGE_MULTICAST_SNOOPING, BRIDGE_OPT_TYPE_OPTION },
-		{ "vlan_filtering",     NM_SETTING_BRIDGE_VLAN_FILTERING,     BRIDGE_OPT_TYPE_OPTION },
-		{ "default_pvid",       NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID,  BRIDGE_OPT_TYPE_OPTION },
-		{ "group_fwd_mask",     NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, BRIDGE_OPT_TYPE_OPTION },
-		{ "priority",           NM_SETTING_BRIDGE_PORT_PRIORITY,      BRIDGE_OPT_TYPE_PORT_OPTION },
-		{ "path_cost",          NM_SETTING_BRIDGE_PORT_PATH_COST,     BRIDGE_OPT_TYPE_PORT_OPTION },
-		{ "hairpin_mode",       NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE,  BRIDGE_OPT_TYPE_PORT_OPTION, .extended_bool = TRUE, },
-	};
-	const char *error_message = NULL;
-	int i;
-	gint64 v;
-
-	for (i = 0; i < G_N_ELEMENTS (m); i++) {
-		GParamSpec *param_spec;
-
-		if (opt_type != m[i].opt_type)
-			continue;
-		if (!nm_streq (key, m[i].key))
-			continue;
-		if (m[i].only_with_stp && !stp) {
-			PARSE_WARNING ("'%s' invalid when STP is disabled", key);
-			return;
-		}
-
-		param_spec = g_object_class_find_property (G_OBJECT_GET_CLASS (setting), m[i].property_name);
-		switch (param_spec->value_type) {
-		case G_TYPE_BOOLEAN:
-			if (m[i].extended_bool) {
-				if (!strcasecmp (value, "on") || !strcasecmp (value, "yes") || !strcmp (value, "1"))
-					v = TRUE;
-				else if (!strcasecmp (value, "off") || !strcasecmp (value, "no"))
-					v = FALSE;
-				else {
-					error_message = "is not a boolean";
-					goto warn;
-				}
-			} else {
-				v = _nm_utils_ascii_str_to_int64 (value, 10, 0, 1, -1);
-				if (v == -1) {
-					error_message = nm_strerror_native (errno);
-					goto warn;
-				}
-			}
-			if (!nm_g_object_set_property_boolean (G_OBJECT (setting), m[i].property_name, v, NULL)) {
-				error_message = "number is out of range";
-				goto warn;
-			}
-			return;
-		case G_TYPE_UINT:
-			v = _nm_utils_ascii_str_to_int64 (value, 10, 0, G_MAXUINT, -1);
-			if (v == -1) {
-				error_message = nm_strerror_native (errno);
-				goto warn;
-			}
-			if (!nm_g_object_set_property_uint (G_OBJECT (setting), m[i].property_name, v, NULL)) {
-				error_message = "number is out of range";
-				goto warn;
-			}
-			return;
-		default:
-			nm_assert_not_reached ();
-			continue;
-		}
-
-warn:
-		PARSE_WARNING ("invalid %s value '%s': %s", key, value, error_message);
-		return;
-	}
-
-	PARSE_WARNING ("unhandled bridge option '%s'", key);
-}
-
-static void
-handle_bridging_opts (NMSetting *setting,
-                      gboolean stp,
-                      const char *value,
-                      BridgeOptFunc func,
-                      BridgeOptType opt_type)
-{
-	gs_free const char **items = NULL;
-	const char *const *iter;
-
-	items = nm_utils_strsplit_set (value, " ");
-	for (iter = items; iter && *iter; iter++) {
-		gs_free char *key = NULL;
-		const char *val;
-
-		val = strchr (*iter, '=');
-		if (!val)
-			continue;
-		key = g_strndup (*iter, val - *iter);
-		val++;
-		if (key[0] && val[0])
-			func (setting, stp, key, val, opt_type);
-	}
-}
-
-static void
-read_bridge_vlans (shvarFile *netplan,
-                   const char *key,
-                   NMSetting *setting,
-                   const char *property)
-{
-	gs_unref_ptrarray GPtrArray *array = NULL;
-	gs_free char *value_to_free = NULL;
-	const char *value;
-
-	value = svGetValueStr (netplan, key, &value_to_free);
-	if (value) {
-		gs_free const char **strv = NULL;
-		const char *const *iter;
-		GError *local = NULL;
-		NMBridgeVlan *vlan;
-
-		array = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
-
-		strv = nm_utils_escaped_tokens_split (value, ",");
-		if (strv) {
-			for (iter = strv; *iter; iter++) {
-				vlan = nm_bridge_vlan_from_str (*iter, &local);
-				if (!vlan) {
-					PARSE_WARNING ("invalid bridge VLAN: %s", local->message);
-					g_clear_error (&local);
-					continue;
-				}
-				g_ptr_array_add (array, vlan);
-			}
-		}
-		nm_clear_g_free (&value_to_free);
-	}
-
-	g_object_set (setting, property, array, NULL);
-}
+/* TODO: add team support for reader */
 
 static NMSetting *
-make_bridge_setting (shvarFile *netplan,
+make_bridge_setting (NetplanNetDefinition *nd,
                      const char *file,
                      GError **error)
 {
 	gs_unref_object NMSettingBridge *s_bridge = NULL;
-	gs_free char *value_to_free = NULL;
 	const char *value;
-	gboolean stp = FALSE;
-	gboolean stp_set = FALSE;
-
-	value = svGetValueStr (netplan, "DEVICE", &value_to_free);
-	if (!value) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "mandatory DEVICE keyword missing");
-		return NULL;
-	}
-	nm_clear_g_free (&value_to_free);
 
 	s_bridge = NM_SETTING_BRIDGE (nm_setting_bridge_new ());
 
-	value = svGetValueStr (netplan, "BRIDGE_MACADDR", &value_to_free);
-	if (value) {
+	value = nd->set_mac;
+	if (value)
 		g_object_set (s_bridge, NM_SETTING_BRIDGE_MAC_ADDRESS, value, NULL);
-		nm_clear_g_free (&value_to_free);
-	}
-
-	value = svGetValueStr (netplan, "STP", &value_to_free);
-	if (value) {
-		if (!strcasecmp (value, "on") || !strcasecmp (value, "yes")) {
-			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, TRUE, NULL);
-			stp = TRUE;
-			stp_set = TRUE;
-		} else if (!strcasecmp (value, "off") || !strcasecmp (value, "no")) {
-			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, FALSE, NULL);
-			stp_set = TRUE;
-		} else
-			PARSE_WARNING ("invalid STP value '%s'", value);
-		nm_clear_g_free (&value_to_free);
-	}
 
-	if (!stp_set) {
-		/* Missing or invalid STP property means "no" */
-		g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, FALSE, NULL);
-	}
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, nd->bridge_params.stp, NULL);
 
-	value = svGetValueStr (netplan, "DELAY", &value_to_free);
-	if (value) {
-		handle_bridge_option (NM_SETTING (s_bridge), stp, "DELAY", value, BRIDGE_OPT_TYPE_MAIN);
-		nm_clear_g_free (&value_to_free);
-	}
+	if (nd->bridge_params.stp) {
+		g_object_set (s_bridge, NM_SETTING_BRIDGE_PRIORITY, (guint16) nd->bridge_params.priority, NULL);
 
-	value = svGetValueStr (netplan, "BRIDGING_OPTS", &value_to_free);
-	if (value) {
-		handle_bridging_opts (NM_SETTING (s_bridge), stp, value, handle_bridge_option, BRIDGE_OPT_TYPE_OPTION);
-		nm_clear_g_free (&value_to_free);
+		if (nd->bridge_params.forward_delay)
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_FORWARD_DELAY,
+			              _nm_utils_ascii_str_to_int64 (nd->bridge_params.forward_delay, 10, 0, G_MAXUINT, -1),
+			              NULL);
+		if (nd->bridge_params.hello_time)
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_HELLO_TIME,
+			              _nm_utils_ascii_str_to_int64 (nd->bridge_params.hello_time, 10, 0, G_MAXUINT, -1),
+			              NULL);
+		if (nd->bridge_params.max_age)
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_MAX_AGE,
+			              _nm_utils_ascii_str_to_int64 (nd->bridge_params.max_age, 10, 0, G_MAXUINT, -1),
+			              NULL);
 	}
 
-	read_bridge_vlans (netplan,
-	                   "BRIDGE_VLANS",
-	                   NM_SETTING (s_bridge),
-	                   NM_SETTING_BRIDGE_VLANS);
+	//g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_PRIORITY, nd->bridge_params.port_priority, NULL);
+	//g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_PATH_COST, nd->bridge_params.path_cost, NULL);
+	
+#if 0  /* TODO: add the other bridge params */
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_AGEING_TIME, nd->bridge_params.stp, NULL);
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_MULTICAST_SNOOPING, nd->bridge_params.stp, NULL);
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_FILTERING, nd->bridge_params.stp, NULL);
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, nd->bridge_params.stp, NULL);
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, nd->bridge_params.stp, NULL);
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, nd->bridge_params.stp, NULL);
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, nd->bridge_params.stp, NULL);
+#endif
 
 	return (NMSetting *) g_steal_pointer (&s_bridge);
 }
 
 static NMConnection *
 bridge_connection_from_netplan (const char *file,
-                                shvarFile *netplan,
+                                NetplanNetDefinition *nd,
                                 GError **error)
 {
 	NMConnection *connection = NULL;
@@ -5246,27 +2143,31 @@ bridge_connection_from_netplan (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
+	g_return_val_if_fail (nd != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, netplan, NM_SETTING_BRIDGE_SETTING_NAME, NULL, _("Bridge"));
+	_LOGT ("netplan bridge %s ", nd->id);
+
+	con_setting = make_connection_setting (file, nd, NM_SETTING_BRIDGE_SETTING_NAME, NULL, _("Bridge"));
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
 		g_object_unref (connection);
 		return NULL;
 	}
+	_LOGT ("netplan setting connection uuid %s", nm_setting_connection_get_uuid ((NMSettingConnection*)con_setting));
 	nm_connection_add_setting (connection, con_setting);
+	_LOGT ("netplan connection uuid %s", nm_connection_get_uuid (connection));
 
-	bridge_setting = make_bridge_setting (netplan, file, error);
+	bridge_setting = make_bridge_setting (nd, file, error);
 	if (!bridge_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
 	nm_connection_add_setting (connection, bridge_setting);
 
-	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (nd, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -5283,8 +2184,9 @@ bridge_connection_from_netplan (const char *file,
 	return connection;
 }
 
+#if 0  /* TODO: bridge-port settings */
 static NMSetting *
-make_bridge_port_setting (shvarFile *netplan)
+make_bridge_port_setting (NetplanNetDefinition *nd)
 {
 	NMSetting *s_port = NULL;
 	gs_free char *value_to_free = NULL;
@@ -5313,9 +2215,11 @@ make_bridge_port_setting (shvarFile *netplan)
 
 	return s_port;
 }
+#endif
 
+#if 0  /* TODO: Team device support */
 static NMSetting *
-make_team_port_setting (shvarFile *netplan)
+make_team_port_setting (NetplanNetDefinition *nd)
 {
 	NMSetting *s_port;
 	gs_free char *value = NULL;
@@ -5331,47 +2235,13 @@ make_team_port_setting (shvarFile *netplan)
 	              NULL);
 	return s_port;
 }
+#endif
 
-static gboolean
-is_bond_device (const char *name, shvarFile *parsed)
-{
-	g_return_val_if_fail (name != NULL, FALSE);
-	g_return_val_if_fail (parsed != NULL, FALSE);
-
-	if (svGetValueBoolean (parsed, "BONDING_MASTER", FALSE))
-		return TRUE;
-
-	return FALSE;
-}
-
-static gboolean
-is_vlan_device (const char *name, shvarFile *parsed)
-{
-	g_return_val_if_fail (name != NULL, FALSE);
-	g_return_val_if_fail (parsed != NULL, FALSE);
-
-	if (svGetValueBoolean (parsed, "VLAN", FALSE))
-		return TRUE;
-
-	return FALSE;
-}
-
-static gboolean
-is_wifi_device (const char *name, shvarFile *parsed)
-{
-	const NMPlatformLink *pllink;
-
-	g_return_val_if_fail (name != NULL, FALSE);
-	g_return_val_if_fail (parsed != NULL, FALSE);
-
-	pllink = nm_platform_link_get_by_ifname (NM_PLATFORM_GET, name);
-	return    pllink
-	       && pllink->type == NM_LINK_TYPE_WIFI;
-}
 
+#if 0   /* TODO: VLAN Support */
 static void
 parse_prio_map_list (NMSettingVlan *s_vlan,
-                     shvarFile *netplan,
+                     NetplanNetDefinition *nd,
                      const char *key,
                      NMVlanPriorityMap map)
 {
@@ -5394,7 +2264,7 @@ parse_prio_map_list (NMSettingVlan *s_vlan,
 }
 
 static NMSetting *
-make_vlan_setting (shvarFile *netplan,
+make_vlan_setting (NetplanNetDefinition *nd,
                    const char *file,
                    GError **error)
 {
@@ -5517,7 +2387,7 @@ make_vlan_setting (shvarFile *netplan,
 
 static NMConnection *
 vlan_connection_from_netplan (const char *file,
-                              shvarFile *netplan,
+                              NetplanNetDefinition *nd,
                               GError **error)
 {
 	NMConnection *connection = NULL;
@@ -5532,7 +2402,7 @@ vlan_connection_from_netplan (const char *file,
 
 	connection = nm_simple_connection_new ();
 
-	con_setting = make_connection_setting (file, netplan, NM_SETTING_VLAN_SETTING_NAME, NULL, "Vlan");
+	con_setting = make_connection_setting (file, nd, NM_SETTING_VLAN_SETTING_NAME, NULL, "Vlan");
 	if (!con_setting) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Failed to create connection setting.");
@@ -5541,14 +2411,14 @@ vlan_connection_from_netplan (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
-	vlan_setting = make_vlan_setting (netplan, file, error);
+	vlan_setting = make_vlan_setting (nd, file, error);
 	if (!vlan_setting) {
 		g_object_unref (connection);
 		return NULL;
 	}
 	nm_connection_add_setting (connection, vlan_setting);
 
-	wired_setting = make_wired_setting (netplan, file, &s_8021x, &local);
+	wired_setting = make_wired_setting (nd, file, &s_8021x, &local);
 	if (local && !g_error_matches (local, NM_UTILS_ERROR, NM_UTILS_ERROR_SETTING_MISSING)) {
 		g_propagate_error (error, local);
 		g_object_unref (connection);
@@ -5564,9 +2434,10 @@ vlan_connection_from_netplan (const char *file,
 
 	return connection;
 }
+#endif
 
 static NMConnection *
-create_unhandled_connection (const char *filename, shvarFile *netplan,
+create_unhandled_connection (const char *filename, NetplanNetDefinition *nd,
                              const char *type, char **out_spec)
 {
 	NMConnection *connection;
@@ -5582,14 +2453,14 @@ create_unhandled_connection (const char *filename, shvarFile *netplan,
 	 * an empty type-specific setting as well, to make sure it passes
 	 * nm_connection_verify() later.
 	 */
-	s_con = make_connection_setting (filename, netplan, NM_SETTING_GENERIC_SETTING_NAME,
+	s_con = make_connection_setting (filename, nd, NM_SETTING_GENERIC_SETTING_NAME,
 	                                 NULL, NULL);
 	nm_connection_add_setting (connection, s_con);
 
 	nm_connection_add_setting (connection, nm_setting_generic_new ());
 
 	/* Get a spec */
-	v = svGetValueStr (netplan, "HWADDR", &value);
+	v = nd->match.mac;
 	if (v) {
 		gs_free char *lower = g_ascii_strdown (v, -1);
 
@@ -5597,15 +2468,15 @@ create_unhandled_connection (const char *filename, shvarFile *netplan,
 		return connection;
 	}
 
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "SUBCHANNELS", &value);
+#if 0  /* TODO: create unhandled matching for s390 subchannels */
+	v = svGetValueStr (nd, "SUBCHANNELS", &value);
 	if (v) {
 		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_S390_SUBCHANNELS_TAG"%s", type, v);
 		return connection;
 	}
+#endif
 
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DEVICE", &value);
+	v = nd->match.original_name;
 	if (v) {
 		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_INTERFACE_NAME_TAG"=%s", type, v);
 		return connection;
@@ -5615,35 +2486,17 @@ create_unhandled_connection (const char *filename, shvarFile *netplan,
 	return NULL;
 }
 
+
+// TODO: trash, for testing only...
 static void
-check_dns_search_domains (shvarFile *netplan, NMSetting *s_ip4, NMSetting *s_ip6)
+netplan_ht_debug (gpointer key,
+                  gpointer value,
+                  gpointer user_data)
 {
-	if (!s_ip6)
-		return;
-
-	/* If there is no IPv4 config or it doesn't contain DNS searches,
-	 * read DOMAIN and put the domains into IPv6.
-	 */
-	if (   !s_ip4
-	    || nm_setting_ip_config_get_num_dns_searches (NM_SETTING_IP_CONFIG (s_ip4)) == 0) {
-		/* DNS searches */
-		gs_free char *value = NULL;
-		const char *v;
-
-		v = svGetValueStr (netplan, "DOMAIN", &value);
-		if (v) {
-			gs_free const char **searches = NULL;
-			const char *const *item;
-
-			searches = nm_utils_strsplit_set (v, " ");
-			if (searches) {
-				for (item = searches; *item; item++) {
-					if (!nm_setting_ip_config_add_dns_search (NM_SETTING_IP_CONFIG (s_ip6), *item))
-						PARSE_WARNING ("duplicate DNS domain '%s'", *item);
-				}
-			}
-		}
-	}
+	NetplanNetDefinition *nd = (NetplanNetDefinition *) value;
+	char *key_id = (char *) key;
+	
+	_LOGT ("netplan expected id %s : hashtable id %s", key_id, nd->id);
 }
 
 static NMConnection *
@@ -5654,17 +2507,17 @@ connection_from_file_full (const char *filename,
                            GError **error,
                            gboolean *out_ignore_error)
 {
-	nm_auto_shvar_file_close shvarFile *main_netplan = NULL;
-	nm_auto_shvar_file_close shvarFile *network_netplan = NULL;
+	NetplanNetDefinition *netdef = NULL;
 	gs_unref_object NMConnection *connection = NULL;
 	gs_free char *type = NULL;
-	char *devtype, *bootproto;
-	NMSetting *s_ip4, *s_ip6, *s_tc, *s_proxy, *s_port, *s_dcb = NULL, *s_user;
-	NMSetting *s_sriov, *s_match;
+	//char *devtype, *bootproto;
+	NMSetting *s_ip4, *s_ip6;
+	//NMSetting *s_tc, *s_proxy, *s_port, *s_dcb = NULL, *s_user, *s_sriov;
+	NMSetting *s_match;
 	const char *netplan_name = NULL;
-	gboolean has_ip4_defroute = FALSE;
-	gboolean has_complex_routes_v4;
-	gboolean has_complex_routes_v6;
+	gboolean ret;
+	GHashTableIter iter;
+	gpointer key;
 
 	g_return_val_if_fail (filename != NULL, NULL);
 	g_return_val_if_fail (out_unhandled && !*out_unhandled, NULL);
@@ -5675,19 +2528,28 @@ connection_from_file_full (const char *filename,
 	if (!network_file)
 		network_file = SYSCONFDIR "/netplan";
 
-	netplan_name = utils_get_netplan_name (filename, TRUE);
+	netplan_name = utils_get_netplan_name (filename);
 	if (!netplan_name) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 		             "Ignoring connection '%s' because it's not an netplan file.", filename);
 		return NULL;
 	}
 
-	main_netplan = svOpenFile (filename, error);
-	if (!main_netplan)
-		return NULL;
+	/* TODO: Support network_file; for unit testing */
+	ret = netplan_parse_yaml (filename, error);
+	if (ret) {
+		_LOGT ("commit: parse successful");
+		netdefs = netplan_finish_parse (error);
+		if (netdefs)
+			g_hash_table_foreach (netdefs, netplan_ht_debug, NULL);
+	}
 
-	network_netplan = svOpenFile (network_file, NULL);
+	if (error && *error) {
+		_LOGT ("commit: parse failed!: %s", (*error)->message);
+		return NULL;
+	}
 
+#if 0
 	if (!svGetValueBoolean (main_netplan, "NM_CONTROLLED", TRUE)) {
 		connection = create_unhandled_connection (filename, main_netplan, "unmanaged", out_unhandled);
 		if (!connection) {
@@ -5721,7 +2583,7 @@ connection_from_file_full (const char *filename,
 
 			if (type) {
 				/* nothing to do */
-			} else if (device && is_vlan_device (device, main_netplan))
+			} else if (device && nd->type == NETPLAN_DEF_TYPE_VLAN)
 				type = g_strdup (TYPE_VLAN);
 			else
 				type = g_strdup (TYPE_ETHERNET);
@@ -5767,67 +2629,9 @@ connection_from_file_full (const char *filename,
 			g_free (device);
 			return NULL;
 		}
+#endif
 
-		if (!test_type) {
-			if (is_bond_device (device, main_netplan))
-				type = g_strdup (TYPE_BOND);
-			else if (is_vlan_device (device, main_netplan))
-				type = g_strdup (TYPE_VLAN);
-			else if (is_wifi_device (device, main_netplan))
-				type = g_strdup (TYPE_WIRELESS);
-			else {
-				gs_free char *p_path = NULL;
-				char *p_device;
-				gsize i;
-
-				/* network-functions detects DEVICETYPE based on the netplan-* name and the existence
-				 * of a ifup script:
-				 *    [ -z "$DEVICETYPE" ] && DEVICETYPE=$(echo ${DEVICE} | sed "s/[0-9]*$//")
-				 * later...
-				 *    OTHERSCRIPT="/etc/sysconfig/network-scripts/ifup-${DEVICETYPE}"
-				 * */
-#define IFUP_PATH_PREFIX "/etc/sysconfig/network-scripts/ifup-"
-				i = strlen (device);
-				p_path = g_malloc (NM_STRLEN (IFUP_PATH_PREFIX) + i + 1);
-				p_device = &p_path[NM_STRLEN (IFUP_PATH_PREFIX)];
-				memcpy (p_device, device, i + 1);
-
-				/* strip trailing numbers */
-				while (i >= 1) {
-					i--;
-					if (p_device[i] < '0' || p_device[i] > '9')
-						break;
-					p_device[i] = '\0';
-				}
-
-				if (nm_streq (p_device, "eth"))
-					type = g_strdup (TYPE_ETHERNET);
-				else if (nm_streq (p_device, "wireless"))
-					type = g_strdup (TYPE_WIRELESS);
-				else if (p_device[0]) {
-					memcpy (p_path, IFUP_PATH_PREFIX, NM_STRLEN (IFUP_PATH_PREFIX));
-					if (access (p_path, X_OK) == 0) {
-						/* for all other types, this is not something we want to handle. */
-						NM_SET_OUT (out_ignore_error, TRUE);
-						g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-						             "Ignore script for unknown device type which has a matching %s script",
-						             p_path);
-						return NULL;
-					}
-				}
-
-				if (!type)
-					type = g_strdup (TYPE_ETHERNET);
-			}
-		} else {
-			/* For the unit tests, there won't necessarily be any
-			 * adapters of the connection's type in the system so the
-			 * type can't be tested with ioctls.
-			 */
-			type = g_strdup (test_type);
-		}
-
-		g_free (device);
+#if 0
 	} else {
 		/* Check for IBM s390 CTC devices and call them Ethernet */
 		if (g_strcmp0 (type, "CTC") == 0) {
@@ -5835,41 +2639,40 @@ connection_from_file_full (const char *filename,
 			type = g_strdup (TYPE_ETHERNET);
 		}
 	}
+#endif
+	g_hash_table_iter_init (&iter, netdefs);
+	g_hash_table_iter_next (&iter, &key, (gpointer) &netdef);
+	_LOGT ("netplan netdef %s : %d", (char *) key, netdef->type);
 
-	if (nm_streq0 (type, TYPE_ETHERNET)) {
-		gs_free char *bond_options = NULL;
-
-		if (svGetValueStr (main_netplan, "BONDING_OPTS", &bond_options)) {
-			/* initscripts consider these as bond masters */
-			g_free (type);
-			type = g_strdup (TYPE_BOND);
-		}
-	}
-
-	if (svGetValueBoolean (main_netplan, "BONDING_MASTER", FALSE) &&
-	    strcasecmp (type, TYPE_BOND)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "BONDING_MASTER=yes key only allowed in TYPE=bond connections");
-		return NULL;
-	}
 
-	/* Construct the connection */
-	if (!strcasecmp (type, TYPE_ETHERNET))
-		connection = wired_connection_from_netplan (filename, main_netplan, error);
-	else if (!strcasecmp (type, TYPE_WIRELESS))
-		connection = wireless_connection_from_netplan (filename, main_netplan, error);
-	else if (!strcasecmp (type, TY  PE_INFINIBAND))
-		connection = infiniband_connection_from_netplan (filename, main_netplan, error);
-	else if (!strcasecmp (type, TYPE_BOND))
-		connection = bond_connection_from_netplan (filename, main_netplan, error);
-	else if (!strcasecmp (type, TYPE_TEAM))
-		connection = team_connection_from_netplan (filename, main_netplan, error);
-	else if (!strcasecmp (type, TYPE_VLAN))
-		connection = vlan_connection_from_netplan (filename, main_netplan, error);
-	else if (!strcasecmp (type, TYPE_BRIDGE))
-		connection = bridge_connection_from_netplan (filename, main_netplan, error);
-	else {
-		connection = create_unhandled_connection (filename, main_netplan, "unrecognized", out_unhandled);
+	switch (netdef->type) {
+	case NETPLAN_DEF_TYPE_ETHERNET:
+		connection = wired_connection_from_netplan (filename, netdef, error);
+		break;
+	case NETPLAN_DEF_TYPE_WIFI:
+		connection = wireless_connection_from_netplan (filename, netdef, error);
+		break;
+	case NETPLAN_DEF_TYPE_BRIDGE:
+		connection = bridge_connection_from_netplan (filename, netdef, error);
+		break;
+	case NETPLAN_DEF_TYPE_BOND:
+		connection = bond_connection_from_netplan (filename, netdef, error);
+		break;
+#if 0  /* skip for now... */
+	case NETPLAN_DEF_TYPE_VLAN:
+		connection = vlan_connection_from_netplan (filename, netdef, error);
+		break;
+#endif
+#if 0  /* not yet implemented */
+	case NETPLAN_DEF_TYPE_INFINIBAND:
+		connection = infiniband_connection_from_netplan (filename, netdef, error);
+		break;
+	case NETPLAN_DEF_TYPE_TEAM:
+		connection = team_connection_from_netplan (filename, netdef, error);
+		break;
+#endif
+	default:
+		connection = create_unhandled_connection (filename, netdef, "unrecognized", out_unhandled);
 		if (!connection) {
 			PARSE_WARNING ("connection type was unrecognized but device was not uniquely identified; device may be managed");
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
@@ -5878,9 +2681,11 @@ connection_from_file_full (const char *filename,
 		return g_steal_pointer (&connection);
 	}
 
+
 	if (!connection)
 		return NULL;
 
+#if 0
 	parse_ethtool_options (main_netplan, connection);
 
 	has_complex_routes_v4 = utils_has_complex_routes (filename, AF_INET);
@@ -5894,27 +2699,27 @@ connection_from_file_full (const char *filename,
 		else
 			PARSE_WARNING ("'rule-' and 'rule6-' files are present; you will need to use a dispatcher script to apply these routes");
 	}
+#endif
 
-	s_ip6 = make_ip6_setting (main_netplan,
-	                          network_netplan,
-	                          !has_complex_routes_v4 && !has_complex_routes_v6,
-	                          error);
+	s_ip6 = make_ip6_setting (netdef, error);
 	if (!s_ip6)
 		return NULL;
 	nm_connection_add_setting (connection, s_ip6);
+	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
 
-	s_ip4 = make_ip4_setting (main_netplan,
-	                          network_netplan,
-	                          !has_complex_routes_v4 && !has_complex_routes_v6,
-	                          &has_ip4_defroute,
-	                          error);
+	s_ip4 = make_ip4_setting (netdef, error);
 	if (!s_ip4)
 		return NULL;
-	read_aliases (NM_SETTING_IP_CONFIG (s_ip4),
-	              !has_ip4_defroute && !nm_setting_ip_config_get_gateway (NM_SETTING_IP_CONFIG (s_ip4)),
-	              filename);
+
 	nm_connection_add_setting (connection, s_ip4);
+	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
+
+	s_match = make_match_setting (netdef);
+	if (s_match)
+		nm_connection_add_setting (connection, s_match);
+	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
 
+#if 0  /* TODO: routing rules, sriov, tc, etc. */
 	read_routing_rules (main_netplan,
 	                    !has_complex_routes_v4 && !has_complex_routes_v6,
 	                    NM_SETTING_IP_CONFIG (s_ip4),
@@ -5928,12 +2733,6 @@ connection_from_file_full (const char *filename,
 	if (s_tc)
 		nm_connection_add_setting (connection, s_tc);
 
-	/* For backwards compatibility, if IPv4 is disabled or the
-	 * config fails for some reason, we read DOMAIN and put the
-	 * values into IPv6 config instead of IPv4.
-	 */
-	check_dns_search_domains (main_netplan, s_ip4, s_ip6);
-
 	s_proxy = make_proxy_setting (main_netplan);
 	if (s_proxy)
 		nm_connection_add_setting (connection, s_proxy);
@@ -5942,10 +2741,6 @@ connection_from_file_full (const char *filename,
 	if (s_user)
 		nm_connection_add_setting (connection, s_user);
 
-	s_match = make_match_setting (main_netplan);
-	if (s_match)
-		nm_connection_add_setting (connection, s_match);
-
 	s_port = make_bridge_port_setting (main_netplan);
 	if (s_port)
 		nm_connection_add_setting (connection, s_port);
@@ -5958,13 +2753,15 @@ connection_from_file_full (const char *filename,
 		return NULL;
 	if (s_dcb)
 		nm_connection_add_setting (connection, s_dcb);
+#endif
 
-	if (!nm_connection_normalize (connection, NULL, NULL, error))
+	if (!nm_connection_normalize (connection, NULL, NULL, error)) {
+		_LOGT ("normalize fail: %s", (*error)->message);
 		return NULL;
+	}
 
 	return g_steal_pointer (&connection);
 }
-#endif
 
 NMConnection *
 connection_from_file (const char *filename,
@@ -5972,13 +2769,10 @@ connection_from_file (const char *filename,
                       GError **error,
                       gboolean *out_ignore_error)
 {
-#if 0
 	return connection_from_file_full (filename, NULL, NULL,
 	                                  out_unhandled,
 	                                  error,
 	                                  out_ignore_error);
-#endif
-	return NULL;
 }
 
 NMConnection *
diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 979c5803048dda8f286546784b1f7461f891665e..99f758bed64898e96bfaf22487b2314f9d81918b 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -50,9 +50,9 @@ nms_netplan_storage_copy_content (NMSNetplanStorage *dst,
 	nm_assert (dst->storage_type == src->storage_type);
 	nm_assert (dst->is_meta_data == src->is_meta_data);
 
-	gs_unref_object NMConnection *connection_to_free = NULL;
+	//NMConnection *connection_to_free;
 
-	connection_to_free = g_steal_pointer (&dst->u.conn_data.connection);
+	//connection_to_free = g_steal_pointer (&dst->u.conn_data.connection);
 	dst->u.conn_data = src->u.conn_data;
 	nm_g_object_ref (dst->u.conn_data.connection);
 }
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.c b/src/settings/plugins/netplan/nms-netplan-utils.c
index e745846f42c789ac8a0d8b4f48ed6f31a3bbc148..31535fc35e8e173b9624f0160d3bb4c0a3284e3f 100644
--- a/src/settings/plugins/netplan/nms-netplan-utils.c
+++ b/src/settings/plugins/netplan/nms-netplan-utils.c
@@ -41,43 +41,6 @@ nms_netplan_util_parse_unhandled_spec (const char *unhandled_spec,
 
 /*****************************************************************************/
 
-/*
- * Check ';[a-fA-F0-9]{8}' file suffix used for temporary files by rpm when
- * installing packages.
- *
- * Implementation taken from upstart.
- */
-static gboolean
-check_rpm_temp_suffix (const char *path)
-{
-	const char *ptr;
-
-	g_return_val_if_fail (path != NULL, FALSE);
-
-	/* Matches *;[a-fA-F0-9]{8}; used by rpm */
-	ptr = strrchr (path, ';');
-	if (   ptr
-	    && strspn (ptr + 1, "abcdefABCDEF0123456789") == 8
-	    && !ptr[9])
-		return TRUE;
-	return FALSE;
-}
-
-static gboolean
-check_suffix (const char *base, const char *tag)
-{
-	int len, tag_len;
-
-	g_return_val_if_fail (base != NULL, TRUE);
-	g_return_val_if_fail (tag != NULL, TRUE);
-
-	len = strlen (base);
-	tag_len = strlen (tag);
-	if ((len > tag_len) && !strcasecmp (base + len - tag_len, tag))
-		return TRUE;
-	return FALSE;
-}
-
 gboolean
 utils_should_ignore_file (const char *filename, gboolean only_netplan)
 {
@@ -102,7 +65,7 @@ utils_cert_path (const char *parent, const char *suffix, const char *extension)
 	g_return_val_if_fail (suffix, NULL);
 	g_return_val_if_fail (extension, NULL);
 
-	name = utils_get_netplan_name (parent, FALSE);
+	name = utils_get_netplan_name (parent);
 	g_return_val_if_fail (name, NULL);
 
 	dir = g_path_get_dirname (parent);
@@ -110,7 +73,7 @@ utils_cert_path (const char *parent, const char *suffix, const char *extension)
 }
 
 const char *
-utils_get_netplan_name (const char *file, gboolean only_netplan)
+utils_get_netplan_name (const char *file)
 {
 	const char *name;
 
@@ -124,71 +87,10 @@ utils_get_netplan_name (const char *file, gboolean only_netplan)
 	if (!*name)
 		return NULL;
 
-	return name;
-}
-
-/* Used to get any netplan/extra file path from any other netplan/extra path
- * in the form <tag><name>.
- */
-static char *
-utils_get_extra_path (const char *parent, const char *tag)
-{
-	char *item_path = NULL, *dirname;
-	const char *name;
-
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (tag != NULL, NULL);
-
-	dirname = g_path_get_dirname (parent);
-	if (!dirname)
-		g_return_val_if_reached (NULL);
-
-	name = utils_get_netplan_name (parent, FALSE);
-	if (name) {
-		if (!strcmp (dirname, "."))
-			item_path = g_strdup_printf ("%s%s", tag, name);
-		else
-			item_path = g_strdup_printf ("%s/%s%s", dirname, tag, name);
-	}
-	g_free (dirname);
-
-	return item_path;
-}
-
-
-#if 0 // TODO: Figure out if we need to be picking these; probably not (single file for netplan)
-shvarFile *
-utils_get_extra_netplan (const char *parent, const char *tag, gboolean should_create)
-{
-	shvarFile *netplan = NULL;
-	char *path;
-
-	path = utils_get_extra_path (parent, tag);
-	if (!path)
-		return NULL;
-
-	if (should_create && !g_file_test (path, G_FILE_TEST_EXISTS))
-		netplan = svCreateFile (path);
-
-	if (!netplan)
-		netplan = svOpenFile (path, NULL);
-
-	g_free (path);
-	return netplan;
-}
-
-shvarFile *
-utils_get_keys_netplan (const char *parent, gboolean should_create)
-{
-	return utils_get_extra_netplan (parent, KEYS_TAG, should_create);
-}
+	// TODO: make sure the name ends in .yaml!!
 
-shvarFile *
-utils_get_route_netplan (const char *parent, gboolean should_create)
-{
-	return utils_get_extra_netplan (parent, ROUTE_TAG, should_create);
+	return name;
 }
-#endif
 
 /* Finds out if route file has new or older format
  * Returns TRUE  - new syntax (ADDRESS<n>=a.b.c.d ...), error opening file or empty
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.h b/src/settings/plugins/netplan/nms-netplan-utils.h
index bcd3ce8a212fe7a61cc49e2adcb92e82ceb12186..ef100bdd348f8343ced4e106837f60c06bd48afc 100644
--- a/src/settings/plugins/netplan/nms-netplan-utils.h
+++ b/src/settings/plugins/netplan/nms-netplan-utils.h
@@ -39,7 +39,7 @@ gboolean nms_netplan_util_parse_unhandled_spec (const char *unhandled_spec,
 
 char *utils_cert_path (const char *parent, const char *suffix, const char *extension);
 
-const char *utils_get_netplan_name (const char *file, gboolean only_netplan);
+const char *utils_get_netplan_name (const char *file);
 
 gboolean utils_should_ignore_file (const char *filename, gboolean only_netplan);
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index feb4c48fd1d414ad9743213959e3cf7ef79194cb..d0140fd99a5219b3333b4ecf39071dad5be52bb3 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -59,6 +59,7 @@
 
 /*****************************************************************************/
 
+#if 0  /* GCC Magic */
 static void
 save_secret_flags (GOutputStream *netplan,
                    const char *key,
@@ -197,11 +198,7 @@ write_object (NMSetting8021x *s_8021x,
 {
 	NMSetting8021xCKScheme scheme;
 	const char *value = NULL;
-	GBytes *blob = NULL;
 	const char *password = NULL;
-	NMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;
-	char secret_name[100];
-	char secret_flags[sizeof (secret_name) + NM_STRLEN ("_FLAGS")];
 	const char *extension;
 	char *standard_file;
 
@@ -213,7 +210,6 @@ write_object (NMSetting8021x *s_8021x,
 	case NM_SETTING_802_1X_CK_SCHEME_UNKNOWN:
 		break;
 	case NM_SETTING_802_1X_CK_SCHEME_BLOB:
-		blob = (*(objtype->vtable->blob_func))(s_8021x);
 		break;
 	case NM_SETTING_802_1X_CK_SCHEME_PATH:
 		value = (*(objtype->vtable->path_func))(s_8021x);
@@ -369,7 +365,9 @@ write_8021x_certs (NMSetting8021x *s_8021x,
 
 	return TRUE;
 }
+#endif  /* GCC magic */
 
+#if 0  /* temp disable: unused?? */
 static gboolean
 write_8021x_setting (NMConnection *connection,
                      GOutputStream *netplan,
@@ -380,7 +378,8 @@ write_8021x_setting (NMConnection *connection,
 {
 	NMSetting8021x *s_8021x;
 	NMSetting8021xAuthFlags auth_flags;
-	const char *value, *match;
+	const char *value;
+	const char *match;
 	gconstpointer ptr;
 	GBytes* bytes;
 	GString *phase2_auth;
@@ -566,6 +565,7 @@ write_8021x_setting (NMConnection *connection,
 
 	return TRUE;
 }
+#endif
 
 static gboolean
 write_wireless_security_setting (NMConnection *connection,
@@ -575,12 +575,12 @@ write_wireless_security_setting (NMConnection *connection,
                                  GError **error)
 {
 	NMSettingWirelessSecurity *s_wsec;
-	const char *key_mgmt, *auth_alg, *key, *proto, *cipher;
+	const char *key_mgmt, *key; //, *auth_alg, *proto, *cipher;
 	const char *psk = NULL;
-	gboolean wep = FALSE, wpa = FALSE, dynamic_wep = FALSE;
-	NMSettingWirelessSecurityWpsMethod wps_method;
-	guint32 i, num;
-	GString *str;
+	gboolean wep = FALSE, wpa = FALSE; //, dynamic_wep = FALSE;
+	//NMSettingWirelessSecurityWpsMethod wps_method;
+	guint32 i;  //, num;
+	//GString *str;
 
 	s_wsec = nm_connection_get_setting_wireless_security (connection);
 	if (!s_wsec) {
@@ -592,7 +592,7 @@ write_wireless_security_setting (NMConnection *connection,
 	key_mgmt = nm_setting_wireless_security_get_key_mgmt (s_wsec);
 	g_assert (key_mgmt);
 
-	auth_alg = nm_setting_wireless_security_get_auth_alg (s_wsec);
+	//auth_alg = nm_setting_wireless_security_get_auth_alg (s_wsec);
 
 	g_output_stream_printf (netplan, 0, NULL, NULL, "          auth:\n");
 
@@ -608,7 +608,7 @@ write_wireless_security_setting (NMConnection *connection,
 		wpa = TRUE;
 	} else if (!strcmp (key_mgmt, "ieee8021x")) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: 802.1x\n");
-		dynamic_wep = TRUE;
+		//dynamic_wep = TRUE;
 	} else if (!strcmp (key_mgmt, "wpa-eap")) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: eap\n");
 		wpa = TRUE;
@@ -649,14 +649,15 @@ write_wireless_security_setting (NMConnection *connection,
 	/* And write the new ones out */
 	if (wep) {
 		NMWepKeyType key_type;
-		const char *key_type_str = NULL;
+		//const char *key_type_str = NULL;
+
+		key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
 
 		/* Default WEP TX key index */
 		// TODO: Fix defaultkey / TX key ID for WEP.
 		//svSetValueInt64 (netplan, "DEFAULTKEY", nm_setting_wireless_security_get_wep_tx_keyidx(s_wsec) + 1);
 
 #if 0 // TODO: differentiate hex key vs. passphrase in netplan for WEP (see below)
-		key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
 		switch (key_type) {
 		case NM_WEP_KEY_TYPE_KEY:
 			key_type_str = "key";
@@ -674,7 +675,7 @@ write_wireless_security_setting (NMConnection *connection,
 			key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
 			if (key) {
 				gs_free char *ascii_key = NULL;
-				char tag[64];
+				//char tag[64];
 				gboolean key_valid = TRUE;
 
 				/* Passphrase needs a different netplan key since with WEP, there
@@ -782,11 +783,12 @@ write_wireless_setting (NMConnection *connection,
 	GBytes *ssid;
 	const guint8 *ssid_data;
 	gsize ssid_len;
-	const char *mode, *bssid;
+	const char *mode; //, *bssid;
 	const char *device_mac, *cloned_mac;
-	guint32 mtu, chan, i;
+	guint32 mtu, i; //, chan;
 	gboolean adhoc = FALSE, hex_ssid = FALSE;
-	const char *const*macaddr_blacklist;
+	//const char *const*macaddr_blacklist;
+	GString *essid;
 
 	// TODO: move type selection to a place that makes sense (wireless)
 	//svSetValueStr (netplan, "TYPE", TYPE_WIRELESS);
@@ -800,12 +802,14 @@ write_wireless_setting (NMConnection *connection,
 
 	// TODO: wireless: fix matching / blacklist / MAC setting
 	device_mac = nm_setting_wireless_get_mac_address (s_wireless);
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "      match: { mac-address: %s }\n", device_mac);
+	if (device_mac)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      match: { macaddress: %s }\n", device_mac);
 
 	cloned_mac = nm_setting_wireless_get_cloned_mac_address (s_wireless);
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "      mac-address: %s\n", cloned_mac);
+	if (cloned_mac)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      macaddress: %s\n", cloned_mac);
 
 #if 0	// TODO: fix MAC setting, blacklist for wireless.
 	svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
@@ -864,7 +868,6 @@ write_wireless_setting (NMConnection *connection,
 		}
 	}
 
-	GString *essid;
 	essid = g_string_sized_new (ssid_len * 2 + 3);
 	if (hex_ssid) {
 
@@ -961,10 +964,10 @@ write_wireless_setting (NMConnection *connection,
 	return TRUE;
 }
 
+#if 0 // TODO: implement infiniband!
 static gboolean
 write_infiniband_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0 // TODO: implement infiniband!
 	NMSettingInfiniband *s_infiniband;
 	const char *mac, *transport_mode, *parent;
 	guint32 mtu;
@@ -997,18 +1000,19 @@ write_infiniband_setting (NMConnection *connection, GOutputStream *netplan, GErr
 	}
 
 	svSetValueStr (netplan, "TYPE", TYPE_INFINIBAND);
-#endif
 
 	return TRUE;
 }
+#endif
 
 static gboolean
 write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingWired *s_wired;
-	const char *const*s390_subchannels;
-	guint32 mtu, num_opts, i;
-	const char *const*macaddr_blacklist;
+	//const char *const*s390_subchannels;
+	guint32 mtu; // i, num_opts;
+	//const char *const*macaddr_blacklist;
+	const char *mac;
 
 	// TODO: move type setting for ethernet devices
 	//svSetValueStr (netplan, "TYPE", TYPE_ETHERNET);
@@ -1020,13 +1024,15 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 		return FALSE;
 	}
 
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "      match: { mac-address: %s }\n",
-	                        nm_setting_wired_get_mac_address (s_wired));
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	if (mac)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      match: { macaddress: %s }\n", mac);
 
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "      mac-address: %s\n",
-	               nm_setting_wired_get_cloned_mac_address (s_wired));
+	mac = nm_setting_wired_get_cloned_mac_address (s_wired);
+	if (mac)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+				        "      macaddress: %s\n", mac);
 
 	// TODO: dedup fields for mac-address to do MAC setting cleanly.
 	//svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
@@ -1114,10 +1120,10 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 	return TRUE;
 }
 
+#if 0 // TODO (cyphermox): add support for ethtool settings in netplan
 static gboolean
 write_ethtool_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0 // TODO (cyphermox): add support for ethtool settings in netplan
 	NMSettingWired *s_wired;
 	NMSettingEthtool *s_ethtool;
 	const char *duplex;
@@ -1243,31 +1249,10 @@ write_ethtool_setting (NMConnection *connection, GOutputStream *netplan, GError
 		svUnsetValue (netplan, "ETHTOOL_OPTS");
 
 	return TRUE;
-#endif
-}
-
-static char *
-vlan_priority_maplist_to_stringlist (NMSettingVlan *s_vlan, NMVlanPriorityMap map)
-{
-	char **strlist;
-	char *value;
-
-	if (map == NM_VLAN_INGRESS_MAP)
-		g_object_get (G_OBJECT (s_vlan), NM_SETTING_VLAN_INGRESS_PRIORITY_MAP, &strlist, NULL);
-	else if (map == NM_VLAN_EGRESS_MAP)
-		g_object_get (G_OBJECT (s_vlan), NM_SETTING_VLAN_EGRESS_PRIORITY_MAP, &strlist, NULL);
-	else
-		return NULL;
-
-	if (strlist[0])
-		value = g_strjoinv (",", strlist);
-	else
-		value = NULL;
-	g_strfreev (strlist);
-
-	return value;
 }
+#endif
 
+#if 0 /* temp disable: only for team? REUSE */
 static gboolean
 write_wired_for_virtual (NMConnection *connection, GOutputStream *netplan)
 {
@@ -1301,15 +1286,16 @@ write_wired_for_virtual (NMConnection *connection, GOutputStream *netplan)
 	}
 	return has_wired;
 }
+#endif
 
 static gboolean
 write_vlan_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
 	NMSettingVlan *s_vlan;
-	char *tmp;
-	guint32 vlan_flags = 0;
-	gsize s_buf_len;
-	char s_buf[50], *s_buf_ptr;
+	//char *tmp;
+	//guint32 vlan_flags = 0;
+	//gsize s_buf_len;
+	//char s_buf[50], *s_buf_ptr;
 
 	s_vlan = nm_connection_get_setting_vlan (connection);
 	if (!s_vlan) {
@@ -1351,6 +1337,48 @@ write_vlan_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 	return TRUE;
 }
 
+static const struct {
+	const char *option;
+	const char *netplan_name;
+} bond_options_mapping[] = {
+	{ NM_SETTING_BOND_OPTION_MIIMON, "mii-monitor-interval" },
+	{ NM_SETTING_BOND_OPTION_UPDELAY, "up-delay" },
+	{ NM_SETTING_BOND_OPTION_DOWNDELAY, "down-delay" },
+	{ NM_SETTING_BOND_OPTION_ARP_INTERVAL, "arp-interval" },
+	{ NM_SETTING_BOND_OPTION_ARP_IP_TARGET, "arp-ip-targets" },
+	{ NM_SETTING_BOND_OPTION_ARP_VALIDATE, "arp-validate" },
+	{ NM_SETTING_BOND_OPTION_PRIMARY, "primary-slave" },
+	{ NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, "primary-reselect-policy" },
+	{ NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, "fail-over-mac-policy" },
+//#define NM_SETTING_BOND_OPTION_USE_CARRIER       "use_carrier"
+	{ NM_SETTING_BOND_OPTION_AD_SELECT, "ad-select" },
+	{ NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, "transmit-hash-policy" },
+	{ NM_SETTING_BOND_OPTION_RESEND_IGMP, "resend-igmp" },
+	{ NM_SETTING_BOND_OPTION_LACP_RATE, "lacp-rate" },
+	{ NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE, "all-slaves-active" },
+	{ NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS, "arp-all-targets" },
+	{ NM_SETTING_BOND_OPTION_MIN_LINKS, "min-links" },
+	{ NM_SETTING_BOND_OPTION_NUM_GRAT_ARP, "gratuitous-arp" },
+//#define NM_SETTING_BOND_OPTION_NUM_UNSOL_NA      "num_unsol_na"
+	{ NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "packets-per-slave" },
+//#define NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB    "tlb_dynamic_lb"
+	{ NM_SETTING_BOND_OPTION_LP_INTERVAL, "learn-packet-interval" },
+};
+
+static void
+_match_bond_option_to_netplan (GString *bond_options, const char *option, const char *value)
+{
+	guint i;
+	const char *name = option;
+
+	for (i = 0; i < G_N_ELEMENTS (bond_options_mapping); i++) {
+		if (nm_streq (option, bond_options_mapping[i].option))
+			name = bond_options_mapping[i].netplan_name;
+	}
+
+	g_string_append_printf (bond_options, "        %s: %s\n", name, value);
+}
+
 static gboolean
 write_bond_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
@@ -1372,7 +1400,7 @@ write_bond_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 		str = g_string_sized_new (64);
 		for (i = 0; i < num_opts; i++) {
 			nm_setting_bond_get_option (s_bond, i, &name, &value);
-			g_string_append_printf (str, "        %s: %s\n", name, value);
+			_match_bond_option_to_netplan (str, name, value);
 		}
 
 		g_output_stream_printf (netplan, 0, NULL, NULL,
@@ -1382,10 +1410,10 @@ write_bond_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 	return TRUE;
 }
 
+#if 0 // TODO (cyphermox): implement team devices in netplan
 static gboolean
 write_team_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0 // TODO (cyphermox): implement team devices in netplan
 	NMSettingTeam *s_team;
 	const char *config;
 
@@ -1402,8 +1430,8 @@ write_team_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 	*wired = write_wired_for_virtual (connection, netplan);
 
 	return TRUE;
-#endif
 }
+#endif
 
 static guint32
 get_setting_default_uint (NMSetting *setting, const char *prop)
@@ -1422,6 +1450,7 @@ get_setting_default_uint (NMSetting *setting, const char *prop)
 	return ret;
 }
 
+#if 0 /* temp disable: unused? */
 static gboolean
 get_setting_default_boolean (NMSetting *setting, const char *prop)
 {
@@ -1438,6 +1467,7 @@ get_setting_default_boolean (NMSetting *setting, const char *prop)
 	g_value_unset (&val);
 	return ret;
 }
+#endif
 
 static gboolean
 write_bridge_vlans (NMSetting *setting,
@@ -1484,7 +1514,7 @@ write_bridge_setting (NMConnection *connection, GOutputStream *netplan, GError *
 {
 	NMSettingBridge *s_bridge;
 	guint32 i;
-	gboolean b;
+	//gboolean b;
 	GString *opts;
 	const char *mac;
 
@@ -1496,8 +1526,9 @@ write_bridge_setting (NMConnection *connection, GOutputStream *netplan, GError *
 	}
 
 	mac = nm_setting_bridge_get_mac_address (s_bridge);
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "      mac-address: %s\n", mac);
+	if (mac)
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "      macaddress: %s\n", mac);
 
 	/* Bridge options */
 	opts = g_string_sized_new (32);
@@ -1628,10 +1659,10 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 	return TRUE;
 }
 
+#if 0 // TODO (cyphermox): TEAM port settings.
 static gboolean
 write_team_port_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0 // TODO (cyphermox): TEAM port settings.
 	NMSettingTeamPort *s_port;
 	const char *config;
 
@@ -1643,133 +1674,13 @@ write_team_port_setting (NMConnection *connection, GOutputStream *netplan, GErro
 	svSetValueStr (netplan, "TEAM_PORT_CONFIG", config);
 
 	return TRUE;
-#endif
 }
-
-static void
-write_dcb_flags (GOutputStream *netplan, const char *tag, NMSettingDcbFlags flags)
-{
-#if 0
-	char prop[NM_STRLEN ("DCB_xxxxxxxxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyyyy")];
-
-	nm_sprintf_buf (prop, "DCB_%s_ENABLE", tag);
-	svSetValueStr (netplan, prop, (flags & NM_SETTING_DCB_FLAG_ENABLE) ? "yes" : NULL);
-
-	nm_sprintf_buf (prop, "DCB_%s_ADVERTISE", tag);
-	svSetValueStr (netplan, prop, (flags & NM_SETTING_DCB_FLAG_ADVERTISE) ? "yes" : NULL);
-
-	nm_sprintf_buf (prop, "DCB_%s_WILLING", tag);
-	svSetValueStr (netplan, prop, (flags & NM_SETTING_DCB_FLAG_WILLING) ? "yes" : NULL);
 #endif
-}
-
-static void
-write_dcb_app (GOutputStream *netplan,
-               const char *tag,
-               NMSettingDcbFlags flags,
-               int priority)
-{
-#if 0
-	char prop[NM_STRLEN ("DCB_xxxxxxxxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyyyy")];
-
-	write_dcb_flags (netplan, tag, flags);
-
-	nm_sprintf_buf (prop, "DCB_%s_PRIORITY", tag);
-	if ((flags & NM_SETTING_DCB_FLAG_ENABLE) && (priority >= 0))
-		svSetValueInt64 (netplan, prop, priority);
-	else
-		svUnsetValue (netplan, prop);
-#endif
-}
-
-typedef gboolean (*DcbGetBoolFunc) (NMSettingDcb *, guint);
-
-static void
-write_dcb_bool_array (GOutputStream *netplan,
-                      const char *key,
-                      NMSettingDcb *s_dcb,
-                      NMSettingDcbFlags flags,
-                      DcbGetBoolFunc get_func)
-{
-#if 0
-	char str[9];
-	guint i;
-
-	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		svUnsetValue (netplan, key);
-		return;
-	}
-
-	str[8] = 0;
-	for (i = 0; i < 8; i++)
-		str[i] = get_func (s_dcb, i) ? '1' : '0';
-	svSetValueStr (netplan, key, str);
-#endif
-}
-
-typedef guint (*DcbGetUintFunc) (NMSettingDcb *, guint);
-
-static void
-write_dcb_uint_array (GOutputStream *netplan,
-                      const char *key,
-                      NMSettingDcb *s_dcb,
-                      NMSettingDcbFlags flags,
-                      DcbGetUintFunc get_func)
-{
-#if 0
-	char str[9];
-	guint i, num;
-
-	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		svUnsetValue (netplan, key);
-		return;
-	}
-
-	str[8] = 0;
-	for (i = 0; i < 8; i++) {
-		num = get_func (s_dcb, i);
-		if (num < 10)
-			str[i] = '0' + num;
-		else if (num == 15)
-			str[i] = 'f';
-		else
-			g_assert_not_reached ();
-	}
-	svSetValueStr (netplan, key, str);
-#endif
-}
-
-static void
-write_dcb_percent_array (GOutputStream *netplan,
-                         const char *key,
-                         NMSettingDcb *s_dcb,
-                         NMSettingDcbFlags flags,
-                         DcbGetUintFunc get_func)
-{
-#if 0
-	GString *str;
-	guint i;
-
-	if (!(flags & NM_SETTING_DCB_FLAG_ENABLE)) {
-		svUnsetValue (netplan, key);
-		return;
-	}
-
-	str = g_string_sized_new (30);
-	for (i = 0; i < 8; i++) {
-		if (str->len)
-			g_string_append_c (str, ',');
-		g_string_append_printf (str, "%d", get_func (s_dcb, i));
-	}
-	svSetValueStr (netplan, key, str->str);
-	g_string_free (str, TRUE);
-#endif
-}
 
+#if 0 // TODO (cyphermox): Implement DCB.
 static gboolean
 write_dcb_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0 // TODO (cyphermox): Implement DCB.
 	NMSettingDcb *s_dcb;
 	NMSettingDcbFlags flags;
 
@@ -1836,10 +1747,10 @@ write_dcb_setting (NMConnection *connection, GOutputStream *netplan, GError **er
 	write_dcb_percent_array (netplan, KEY_DCB_PG_UPPCT, s_dcb, flags, nm_setting_dcb_get_priority_bandwidth);
 	write_dcb_bool_array (netplan, KEY_DCB_PG_STRICT, s_dcb, flags, nm_setting_dcb_get_priority_strict_bandwidth);
 	write_dcb_uint_array (netplan, KEY_DCB_PG_UP2TC, s_dcb, flags, nm_setting_dcb_get_priority_traffic_class);
-#endif
 
 	return TRUE;
 }
+#endif
 
 static void
 write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
@@ -2047,6 +1958,7 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 #endif
 }
 
+#if 0 /* goes with routes!!! */
 static char *
 get_route_attributes_string (NMIPRoute *route, int family)
 {
@@ -2116,7 +2028,9 @@ get_route_attributes_string (NMIPRoute *route, int family)
 
 	return g_string_free (str, FALSE);
 }
+#endif
 
+#if 0 /* temp disable : routes: */
 static GString *
 write_route_settings (NMSettingIPConfig *s_ip)
 {
@@ -2160,11 +2074,12 @@ write_route_settings (NMSettingIPConfig *s_ip)
 
 	return contents;
 }
+#endif
 
+#if 0  // TODO: implement proxy support.
 static gboolean
 write_proxy_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0  // TODO: implement proxy support.
 	NMSettingProxy *s_proxy;
 	NMSettingProxyMethod method;
 	const char *pac_url, *pac_script;
@@ -2197,9 +2112,9 @@ write_proxy_setting (NMConnection *connection, GOutputStream *netplan, GError **
 	}
 
 	svSetValueBoolean (netplan, "BROWSER_ONLY", nm_setting_proxy_get_browser_only (s_proxy));
-#endif
 	return TRUE;
 }
+#endif
 
 static gboolean
 write_user_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
@@ -2235,10 +2150,10 @@ write_user_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 	return TRUE;
 }
 
+#if 0  // TODO: implement SR-IOV settings
 static void
 write_sriov_setting (NMConnection *connection, GHashTable *netplan)
 {
-#if 0  // TODO: implement SR-IOV settings
 	NMSettingSriov *s_sriov;
 	guint i, num = 0;
 	NMTernary b;
@@ -2266,13 +2181,13 @@ write_sriov_setting (NMConnection *connection, GHashTable *netplan)
 		svSetValueStr (netplan, key, str);
 		g_free (str);
 	}
-#endif
 }
+#endif
 
+#if 0 // TODO: implement TC settings for netplan
 static gboolean
 write_tc_setting (NMConnection *connection, GHashTable *netplan, GError **error)
 {
-#if 0 // TODO: implement TC settings for netplan
 	NMSettingTCConfig *s_tc;
 	guint i, num, n;
 	char tag[64];
@@ -2310,9 +2225,9 @@ write_tc_setting (NMConnection *connection, GHashTable *netplan, GError **error)
 		svSetValueStr (netplan, numbered_tag (tag, "FILTER", n), str);
 		n++;
 	}
-#endif
 	return TRUE;
 }
+#endif
 
 static gboolean
 write_match_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
@@ -2350,10 +2265,10 @@ write_match_setting (NMConnection *connection, GOutputStream *netplan, GError **
 	return TRUE;
 }
 
+#if 0  // TODO: implement DNS options (edns0, etc.)
 static void
 write_res_options (GHashTable *netplan, NMSettingIPConfig *s_ip, const char *var)
 {
-#if 0  // TODO: implement DNS options (edns0, etc.)
 	nm_auto_free_gstring GString *value = NULL;
 	guint i, num_options;
 
@@ -2366,8 +2281,8 @@ write_res_options (GHashTable *netplan, NMSettingIPConfig *s_ip, const char *var
 	}
 
 	svSetValue (netplan, var, value->str);
-#endif
 }
+#endif
 
 static gboolean
 write_ip4_setting (NMConnection *connection,
@@ -2379,16 +2294,17 @@ write_ip4_setting (NMConnection *connection,
 {
 	NMSettingIPConfig *s_ip4;
 	const char *value;
-	char *tmp;
-	char tag[64];
-	int j;
+	//char *tmp;
+	//char tag[64];
+	//int j;
 	guint i, num, n;
-	gint64 route_metric;
-	NMIPRouteTableSyncMode route_table;
-	int priority;
-	int timeout;
+	//gint64 route_metric;
+	//NMIPRouteTableSyncMode route_table;
+	//int priority;
+	//int timeout;
 	const char *method = NULL;
-	gboolean has_netmask;
+	const char *gateway = NULL;
+	//gboolean has_netmask;
 
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	method = nm_setting_ip_config_get_method (s_ip4);
@@ -2449,8 +2365,10 @@ write_ip4_setting (NMConnection *connection,
 		                     nm_ip_address_get_address (addr));
 #endif
 
-	g_output_stream_printf(netplan, 0, NULL, NULL,
-	                       "      gateway4: %s\n", nm_setting_ip_config_get_gateway (s_ip4));
+	gateway = nm_setting_ip_config_get_gateway (s_ip4);
+	if (gateway)
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+		                       "      gateway4: %s\n", gateway);
 
 	num = nm_setting_ip_config_get_num_dns (s_ip4);
 	for (i = 0; i < num; i++) {
@@ -2547,14 +2465,15 @@ write_ip4_setting (NMConnection *connection,
 	return TRUE;
 }
 
+#if 0 /* temp disable; write addresses: */
 static void
 write_ip4_aliases (NMConnection *connection, GArray *addresses, const char *base_netplan_path)
 {
 	NMSettingIPConfig *s_ip4;
 	gs_free char *base_netplan_dir = NULL, *base_netplan_name = NULL;
-	const char *base_name;
-	int i, num, base_netplan_name_len, base_name_len;
-	GDir *dir;
+	//const char *base_name;
+	int i, num, base_netplan_name_len; //, base_name_len;
+	//GDir *dir;
 
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	if (!s_ip4)
@@ -2577,6 +2496,7 @@ write_ip4_aliases (NMConnection *connection, GArray *addresses, const char *base
 		g_array_append_val(addresses, address);
 	}
 }
+#endif
 
 static void
 write_ip6_setting_dhcp_hostname (NMSettingIPConfig *s_ip6,
@@ -2601,16 +2521,15 @@ write_ip6_setting (NMConnection *connection,
                    GError **error)
 {
 	NMSettingIPConfig *s_ip6;
-	NMSettingIPConfig *s_ip4;
 	const char *value;
-	guint i, num, num4;
-	int priority;
+	guint i, num; //, num4;
+	//int priority;
 	NMIPAddress *addr;
 	const char *dns;
-	gint64 route_metric;
-	NMIPRouteTableSyncMode route_table;
+	//gint64 route_metric;
+	//NMIPRouteTableSyncMode route_table;
 	GString *ip_str;
-	NMSettingIP6ConfigAddrGenMode addr_gen_mode;
+	//NMSettingIP6ConfigAddrGenMode addr_gen_mode;
 
 	s_ip6 = nm_connection_get_setting_ip6_config (connection);
 	if (!s_ip6) {
@@ -2659,7 +2578,7 @@ write_ip6_setting (NMConnection *connection,
 	}
 
 	/* Write out DNS - 'DNS' key is used both for IPv4 and IPv6 */
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	//s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	num = nm_setting_ip_config_get_num_dns (s_ip6);
 	for (i = 0; i < num; i++) {
 		dns = nm_setting_ip_config_get_dns (s_ip6, i);
@@ -2686,10 +2605,12 @@ write_ip6_setting (NMConnection *connection,
 	//svSetValueStr (netplan, "IPV6_FAILURE_FATAL",
 	//               nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes");
 
+#if 0  /* TODO: metric! */
 	route_metric = nm_setting_ip_config_get_route_metric (s_ip6);
 	if (route_metric != -1)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "      metric: %ld\n", route_metric);
+#endif
 
 #if 0
     // TODO: (cyphermox)  Currently can't set what route table in netplan.
@@ -2747,10 +2668,11 @@ static void
 write_ip_routing_rules (NMConnection *connection,
                         GOutputStream *netplan)
 {
-	gsize idx = 0;
+	//gsize idx = 0;
 	int is_ipv4;
+	GString *routing_policy;
 
-	g_output_stream_printf(netplan, 0, NULL, NULL, "      routing-policy:\n");
+	routing_policy = g_string_sized_new (200);
 
 	for (is_ipv4 = 1; is_ipv4 >= 0; is_ipv4--) {
 		const int addr_family = is_ipv4 ? AF_INET : AF_INET6;
@@ -2765,22 +2687,28 @@ write_ip_routing_rules (NMConnection *connection,
 		for (i = 0; i < num; i++) {
 			NMIPRoutingRule *rule = nm_setting_ip_config_get_routing_rule (s_ip, i);
 			gs_free const char *s = NULL;
-			char key[64];
+			//char key[64];
 
-			g_output_stream_printf(netplan, 0, NULL, NULL, "        - to: %s\n",
+			g_string_append_printf(routing_policy, "        - to: %s\n",
 			                       nm_ip_routing_rule_get_to(rule));
-			g_output_stream_printf(netplan, 0, NULL, NULL, "          from: %s\n",
+			g_string_append_printf(routing_policy, "          from: %s\n",
 			                       nm_ip_routing_rule_get_from(rule));
-			g_output_stream_printf(netplan, 0, NULL, NULL, "          table: %d\n",
+			g_string_append_printf(routing_policy, "          table: %d\n",
 			                       nm_ip_routing_rule_get_table(rule));
-			g_output_stream_printf(netplan, 0, NULL, NULL, "          mark: %d\n",
+			g_string_append_printf(routing_policy, "          mark: %d\n",
 			                       nm_ip_routing_rule_get_fwmark(rule));
-			g_output_stream_printf(netplan, 0, NULL, NULL, "          type-of-service: %d\n",
+			g_string_append_printf(routing_policy, "          type-of-service: %d\n",
 			                       nm_ip_routing_rule_get_tos(rule));
-			g_output_stream_printf(netplan, 0, NULL, NULL, "          priority: %ld\n",
+			g_string_append_printf(routing_policy, "          priority: %ld\n",
 			                       nm_ip_routing_rule_get_priority(rule));
 		}
 	}
+
+	if (routing_policy->len > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+		                       "      routing-policy:\n%s", routing_policy->str);
+
+	g_string_free (routing_policy, TRUE);
 }
 
 static gboolean
@@ -2789,8 +2717,8 @@ do_write_construct (NMConnection *connection,
                     GError **error)
 {
 	NMSettingConnection *s_con;
-	NMSettingIPConfig *s_ip6;
-	NMSettingIPConfig *s_ip4;
+	//NMSettingIPConfig *s_ip4;
+	//NMSettingIPConfig *s_ip6;
 	const gchar *type = NULL;
 	GArray *addresses, *nameservers, *searches;
 	GHashTable *dhcp_overrides;
@@ -2798,6 +2726,11 @@ do_write_construct (NMConnection *connection,
 	nm_assert (NM_IS_CONNECTION (connection));
 	nm_assert (_nm_connection_verify (connection, NULL) == NM_SETTING_VERIFY_SUCCESS);
 
+	addresses = g_array_new (TRUE, FALSE, sizeof(char *));
+	nameservers = g_array_new (TRUE, FALSE, sizeof(char *));
+	searches = g_array_new (TRUE, FALSE, sizeof(char *));
+	dhcp_overrides = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
+
 	if (!nms_netplan_writer_can_write_connection (connection, error))
 		return FALSE;
 
@@ -2810,6 +2743,9 @@ do_write_construct (NMConnection *connection,
 		return FALSE;
 	}
 
+	g_output_stream_printf (netplan, 0, NULL, NULL,
+			        "network:\n  version: 2\n  renderer: NetworkManager\n");
+
 	if (!strcmp (type, NM_SETTING_WIRED_SETTING_NAME)) {
 		// FIXME: can't write PPPoE at this time
 		if (nm_connection_get_setting_pppoe (connection)) {
@@ -2819,24 +2755,49 @@ do_write_construct (NMConnection *connection,
 			return FALSE;
 		}
 
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  ethernets:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_wired_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_VLAN_SETTING_NAME)) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  vlans:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_vlan_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  wifis:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_wireless_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_INFINIBAND_SETTING_NAME)) {
+#if 0
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  ethernets:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_infiniband_setting (connection, netplan, error))
+#endif
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_BOND_SETTING_NAME)) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  bonds:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_bond_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_TEAM_SETTING_NAME)) {
+#if 0
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  ethernets:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_team_setting (connection, netplan, error))
+#endif
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_BRIDGE_SETTING_NAME)) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  bridges:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
 		if (!write_bridge_setting (connection, netplan, error))
 			return FALSE;
 	} else {
@@ -2871,8 +2832,8 @@ do_write_construct (NMConnection *connection,
 	//if (!write_tc_setting (connection, netplan, error))
 	//	return FALSE;
 
-	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	//s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	//s_ip6 = nm_connection_get_setting_ip6_config (connection);
 
 	if (!write_ip4_setting (connection,
 	                        netplan,
@@ -2911,10 +2872,12 @@ do_write_to_disk (NMConnection *connection,
                   GString *route6_content,
                   GError **error)
 {
+	gboolean ret = FALSE;
 	/* From here on, we persist data to disk. Before, it was all in-memory
 	 * only. But we loaded the netplan files from disk, and managled our
 	 * new settings (in-memory). */
 
+	ret = g_output_stream_close (netplan, NULL, error);
 #if 0  // TODO: (cyphermox) Do actually write everything together to disk...
 	if (!svWriteFile (netplan, 0644, error))
 		return FALSE;
@@ -2930,7 +2893,7 @@ do_write_to_disk (NMConnection *connection,
 	}
 #endif
 
-	return TRUE;
+	return ret;
 }
 
 gboolean
@@ -2945,14 +2908,47 @@ nms_netplan_writer_write_connection (NMConnection *connection,
                                      GError **error)
 {
 	GOutputStream *netplan;
-	gboolean ret = TRUE;
+	//gboolean ret = TRUE;
 	nm_auto_free_gstring GString *route_content = NULL;
+	nm_auto_free_gstring GString *filename_str = NULL;
 	gboolean route_ignore = FALSE;
 	gs_unref_hashtable GHashTable *secrets = NULL;
 	gs_unref_hashtable GHashTable *blobs = NULL;
+	GFile *netplan_yaml;
+	char *netplan_yaml_path;
 
 	nm_assert (!out_reread || !*out_reread);
 
+
+	if (!filename) {
+		filename_str = g_string_sized_new (120);
+		g_string_printf (filename_str, "NM-%s.yaml", nm_connection_get_uuid (connection));
+
+		netplan_yaml_path = g_build_filename (netplan_dir,
+		                                      filename_str->str,
+		                                      NULL);
+	} else {
+		netplan_yaml_path = g_strdup(filename);
+	}
+
+	netplan_yaml = g_file_new_for_path (netplan_yaml_path);
+	_LOGT ("write: path %s / %s / %p", netplan_dir, g_file_get_path(netplan_yaml),
+				out_filename);
+
+	if (out_filename && !filename)
+		*out_filename = g_file_get_path(netplan_yaml);
+
+	netplan = (GOutputStream *) g_file_replace (netplan_yaml,
+	                                            NULL, FALSE,
+	                                            G_FILE_CREATE_REPLACE_DESTINATION,
+				                    NULL,
+				                    error);
+	if (error && *error)
+		_LOGT ("netplan: %s", (*error)->message);
+		
+	if (!netplan)
+		return FALSE;
+
 	if (!do_write_construct (connection,
 	                         netplan,
 	                         error))
@@ -2972,6 +2968,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 	                       error))
 		return FALSE;
 
+#if 0
 	/* Note that we just wrote the connection to disk, and re-read it from there.
 	 * That is racy if somebody else modifies the connection.
 	 * That race is why we must not tread a failure to re-read the profile
@@ -3019,6 +3016,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 	/* Only return the filename if this was a newly written netplan */
 	if (out_filename && !filename)
 		*out_filename = g_strdup (filename);
+#endif
 
 	return TRUE;
 }
-- 
2.25.1


From 2ca98e5a9b0641ecfa018421f83a47d962ca5e12 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Wed, 18 Dec 2019 14:59:23 -0500
Subject: [PATCH 04/78] Use netplan's defines for WIFI mode rather than
 hard-coded values

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 03d827ab29d220df806fa78a6b24ebe2ef785216..72b641af9e95d44256a0755771c4eb8537e161e0 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1717,12 +1717,11 @@ make_wireless_setting (NetplanNetDefinition *nd,
 
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, bytes, NULL);
 
-		/* FIXME: Use netplan parse.h DEFINEs instead of hard-coded values */
-		if (ap->mode == 0) {
+		if (ap->mode == NETPLAN_WIFI_MODE_INFRASTRUCTURE) {
 			mode = "infrastructure";
-		} else if (ap->mode == 1) {
+		} else if (ap->mode == NETPLAN_WIFI_MODE_ADHOC) {
 			mode = "adhoc";
-		} else if (ap->mode == 2) {
+		} else if (ap->mode == NETPLAN_WIFI_MODE_AP) {
 			mode = "ap";
 		} else {
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-- 
2.25.1


From 09697cd0060f756b22cfe7154612e6326e83b246 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Wed, 18 Dec 2019 15:24:22 -0500
Subject: [PATCH 05/78] cleanup TODO comments

---
 .../plugins/netplan/nms-netplan-reader.c      | 34 ++++----
 .../plugins/netplan/nms-netplan-utils.c       |  5 +-
 .../plugins/netplan/nms-netplan-writer.c      | 80 ++++++++-----------
 3 files changed, 54 insertions(+), 65 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 72b641af9e95d44256a0755771c4eb8537e161e0..c608d01fda5d8050d7047920fc6a6520865c4c5f 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -169,7 +169,7 @@ check_if_bond_slave (NetplanNetDefinition *nd,
 }
 #endif
 
-#if 0  /* TODO: Team support  */
+#if 0  /* TODO: Implement (read) Team support  */
 static void
 check_if_team_slave (NetplanNetDefinition *nd,
                      NMSettingConnection *s_con)
@@ -326,7 +326,7 @@ make_connection_setting (const char *file,
 	nm_clear_g_free (&value);
 #endif
 
-#if 0  /* TODO: Support ZONE, Secondary UUIDs, etc. */
+#if 0  /* TODO: Support ZONE (firewall), Secondary UUIDs, etc. */
 	v = svGetValueStr (netplan, "ZONE", &value);
 	g_object_set (s_con, NM_SETTING_CONNECTION_ZONE, v, NULL);
 
@@ -388,7 +388,7 @@ make_connection_setting (const char *file,
 	nm_clear_g_free (&value);
 #endif  /* OVS support */
 
-#if 0  /* TODO: more random settings NM-specific */
+#if 0  /* TODO: more random settings that are NM-specific */
 	v = svGetValueStr (netplan, "GATEWAY_PING_TIMEOUT", &value);
 	if (v) {
 		gint64 tmp;
@@ -482,7 +482,7 @@ read_ip4_address (NetplanNetDefinition *nd,
 	nm_assert (tag);
 	nm_assert (!error || !*error);
 
-	// TODO: Parse through the GArray of addresses and pick just the ipv4
+	// TODO: Parse through the GArray of addresses and pick just the ipv4 (static addresses)
 
 	return TRUE;
 }
@@ -875,7 +875,7 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 		PARSE_WARNING ("GATEWAY will be ignored when DEFROUTE is disabled");
 #endif
 
-#if 0  /* TODO: Set up method SHARED. */
+#if 0  /* TODO: Implement read for connection sharing. */
 	/* We used to skip saving a lot of unused properties for the ipv4 shared method.
 	 * We want now to persist them but... unfortunately loading DNS or DOMAIN options
 	 * would cause a fail in the ipv4 verify() function. As we don't want any regression
@@ -927,7 +927,7 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	parse_dns_options (s_ip4, dns_options);
 #endif /* shared */
 
-#if 0  /* TODO: DNS prio, routes */
+#if 0  /* TODO: DNS priority, routes */
 	/* DNS priority */
 	priority = svGetValueInt64 (netplan, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
 	g_object_set (s_ip4,
@@ -1109,7 +1109,6 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 				method = NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL;
 		}
 	}
-	/* TODO - handle other methods */
 
 	/* Read IPv6 Privacy Extensions configuration */
 	nm_clear_g_free (&value);
@@ -1137,7 +1136,7 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	}
 #endif  /* ipv6 methods and settings */
 
-	// TODO: make a real s_ip6 object
+	// TODO: make a real s_ip6 object (map from the real values, not just DHCP)
 	g_object_set (s_ip6,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
@@ -1156,7 +1155,7 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		return NM_SETTING (g_steal_pointer (&s_ip6));
 #endif
 
-#if 0  /* TODO: IPv6 DUID, hostname and special DHCP options */
+#if 0  /* TODO: Implement IPv6 DUID, hostname and special DHCP options */
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "DHCPV6_DUID", &value);
 	if (v)
@@ -1322,9 +1321,10 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	return NM_SETTING (g_steal_pointer (&s_ip6));
 }
 
-/* TODO: SRIOV */
-/* TODO: TC support */
-/* TODO: DCB support */
+/* TODO: Implement SRIOV support */
+/* TODO: Implement TC support */
+/* TODO: Implement DCB support */
+/* There is useful code to look at in ifcfg-rh plugin ~cyphermox */
 
 
 static gboolean
@@ -1379,7 +1379,7 @@ make_wep_setting (NetplanNetDefinition *nd,
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0, NULL);
 
 	/* Read WEP key flags */
-	// TODO: secret flags.
+	// TODO: read wifi WEP secret flags.
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, NM_SETTING_SECRET_FLAG_NONE, NULL);
 
 	g_object_set (G_OBJECT (s_wsec),
@@ -1407,7 +1407,7 @@ fill_wpa_ciphers (NetplanNetDefinition *nd,
 	const char *const *iter;
 	int i = 0;
 
-#if 0  /* TODO: WPA ciphers */
+#if 0  /* TODO: WPA ciphers selection (not yet in netplan) */
 	p = svGetValueStr (netplan, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
 	if (!p)
 		return TRUE;
@@ -1491,7 +1491,7 @@ fill_8021x (NetplanNetDefinition *nd,
 
 	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
 
-	// TODO: implement 802.1x reading from hashtable keys
+	// TODO: read 802.1x settings from hashtable keys (just mapping values already in netplan structures)
 
 	return g_steal_pointer (&s_8021x);
 }
@@ -1982,7 +1982,7 @@ make_bond_setting (NetplanNetDefinition *nd,
 
 	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
 
-	/* TODO: map bond_params fields to NM_SETTING_BOND fields */
+	/* TODO: map the other bond_params fields to NM_SETTING_BOND fields */
 #if 0
    struct {
         char* lacp_rate;
@@ -2486,7 +2486,7 @@ create_unhandled_connection (const char *filename, NetplanNetDefinition *nd,
 }
 
 
-// TODO: trash, for testing only...
+// XXX: This is debug code only, get rid of it before upstreaming.
 static void
 netplan_ht_debug (gpointer key,
                   gpointer value,
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.c b/src/settings/plugins/netplan/nms-netplan-utils.c
index 31535fc35e8e173b9624f0160d3bb4c0a3284e3f..52e842422cc947ac01cbcb57713fc79a50810b7f 100644
--- a/src/settings/plugins/netplan/nms-netplan-utils.c
+++ b/src/settings/plugins/netplan/nms-netplan-utils.c
@@ -51,6 +51,8 @@ utils_should_ignore_file (const char *filename, gboolean only_netplan)
 	base = g_path_get_basename (filename);
 
 	// TODO: Implement any file ignore logic necessary?
+        //       We probably want to ignore any file not ending in .yaml,
+        //       as netplan itself does.
 
 	return FALSE;
 }
@@ -128,6 +130,8 @@ utils_has_complex_routes (const char *filename, int addr_family)
 	g_return_val_if_fail (filename, TRUE);
 
 	// TODO: Do we need to handle complex routes specially??
+        //       This might just be fluff unneeded since I cribbed the code
+        //       from ifcfg-rh.
 
 	return FALSE;
 }
@@ -169,7 +173,6 @@ utils_detect_netplan_path (const char *path, gboolean only_netplan)
 	if (only_netplan)
 		return NULL;
 
-	// TODO: utils_get_netplan_path (path) ???
 	return NULL;
 }
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index d0140fd99a5219b3333b4ecf39071dad5be52bb3..8e58adbbb4e6febba3934f7ae0169ddda254d93f 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -700,7 +700,7 @@ write_wireless_security_setting (NMConnection *connection,
 					key_valid = FALSE;
 				}
 
-				// FIXME: use set_secret??
+				// TODO: use set_secret??
 				if (key_valid) {
 					g_output_stream_printf(netplan, 0, NULL, NULL,
 							       "          password: %s\n", key);
@@ -847,7 +847,7 @@ write_wireless_setting (NMConnection *connection,
 	/* If the SSID contains any non-printable characters, we need to use the
 	 * hex notation of the SSID instead.
 	 */
-	// XXX (cyphermox): Is this true for netplan? Do we support this correctly?
+	// TODO: Make sure SSID with non-printable is well supported in netplan
 	if (   ssid_len > 2
 	    && ssid_data[0] == '0'
 	    && ssid_data[1] == 'x') {
@@ -1120,7 +1120,7 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 	return TRUE;
 }
 
-#if 0 // TODO (cyphermox): add support for ethtool settings in netplan
+#if 0 // TODO: add support for ethtool settings in netplan
 static gboolean
 write_ethtool_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
@@ -1275,7 +1275,7 @@ write_wired_for_virtual (NMConnection *connection, GOutputStream *netplan)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 				        "      mac-address: %s\n", cloned_mac);
 
-		// TODO: (cyphermox) suport generate_mac_address_mask 
+		// TODO: support generate_mac_address_mask
 		//svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
 		//               nm_setting_wired_get_generate_mac_address_mask (s_wired));
 
@@ -1309,7 +1309,7 @@ write_vlan_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 	g_output_stream_printf (netplan, 0, NULL, NULL,
 			        "      link: %s\n", nm_setting_vlan_get_parent (s_vlan));
 
-#if 0  /* TODO: (cyphermox) add support for vlan flags / advanced settings */
+#if 0  /* TODO: add support for vlan flags / advanced settings */
 	vlan_flags = nm_setting_vlan_get_flags (s_vlan);
 	svSetValueBoolean (netplan, "REORDER_HDR", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS));
 	svSetValueBoolean (netplan, "GVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_GVRP));
@@ -1410,7 +1410,7 @@ write_bond_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 	return TRUE;
 }
 
-#if 0 // TODO (cyphermox): implement team devices in netplan
+#if 0 // TODO: implement team devices in netplan
 static gboolean
 write_team_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
@@ -1476,7 +1476,7 @@ write_bridge_vlans (NMSetting *setting,
                     const char *key,
                     GError **error)
 {
-#if 0 // TODO (cyphermox): Implement brdige VLANs printif settings.
+#if 0 // TODO: Implement bridge VLANs printif settings.
 	gs_unref_ptrarray GPtrArray *vlans = NULL;
 	NMBridgeVlan *vlan;
 	GString *string;
@@ -1636,7 +1636,7 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 		g_string_append_printf (string, "        path-cost: %u", i);
 	}
 
-#if 0 // TODO (cyphermox): hairpin mode support in networkd/netplan
+#if 0 // TODO: need hairpin mode support in networkd/netplan
 	if (nm_setting_bridge_port_get_hairpin_mode (s_port)) {
 		if (string->len)
 			g_string_append_c (string, ' ');
@@ -1659,7 +1659,7 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 	return TRUE;
 }
 
-#if 0 // TODO (cyphermox): TEAM port settings.
+#if 0 // TODO: implement Team port settings.
 static gboolean
 write_team_port_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
@@ -1677,7 +1677,7 @@ write_team_port_setting (NMConnection *connection, GOutputStream *netplan, GErro
 }
 #endif
 
-#if 0 // TODO (cyphermox): Implement DCB.
+#if 0 // TODO: Implement DCB.
 static gboolean
 write_dcb_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
@@ -1820,7 +1820,7 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 	g_hash_table_insert (netplan, "LLDP", tmp);
 #endif
 
-#if 0 // TODO (cyphermox): handle user permissions for connections
+#if 0 // TODO: handle user permissions for connections
 	/* Permissions */
 	g_hash_table_insert (netplan, "USERS");
 	n = nm_setting_connection_get_num_permissions (s_con);
@@ -1881,7 +1881,7 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 	}
 #endif
 
-#if 0 // TODO (cyphermox): use devicetype code for bridgeport detection
+#if 0 // TODO: use devicetype code for bridgeport detection
 	if (nm_streq0 (type, NM_SETTING_TEAM_SETTING_NAME))
 		g_hash_table_insert (netplan, "DEVICETYPE", TYPE_TEAM);
 	else if (master_iface && nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME))
@@ -2119,7 +2119,7 @@ write_proxy_setting (NMConnection *connection, GOutputStream *netplan, GError **
 static gboolean
 write_user_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-#if 0  // TODO: (cyphermox)  implement user permission settings stat.
+#if 0  // TODO: implement user permission settings
 	NMSettingUser *s_user;
 	guint i, len;
 	const char *const*keys;
@@ -2318,13 +2318,13 @@ write_ip4_setting (NMConnection *connection,
 	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO))
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "      dhcp4: yes\n");
-#if 0
+#if 0  /* TODO: implement setting statically assigned IPs: append to GArray for addresses */
 	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)) {
 		// Static addresses addressed below.
 	} else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
 		link_local &= 0x2;
 	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED))
-		// FIXME: (cyphermox) implement connection sharing.
+		// TODO: implement connection sharing.
 #endif
 
 	/* Write out IPADDR<n>, PREFIX<n>, GATEWAY<n> for current IP addresses
@@ -2353,9 +2353,9 @@ write_ip4_setting (NMConnection *connection,
 		g_array_append_val (addresses, value);
 	}
 
-#if 0
+#if 0  /* TODO: improve routes handling */
 		routes = g_array_new(...)
-	    // (cyphermox) Routes -> split up into routes section
+	    // Routes -> split up into routes section
 	    // routes = g_array_new (...)
 	    // ...
 	    // g_hash_table_insert (netplan, "routes", <routes>)
@@ -2388,8 +2388,7 @@ write_ip4_setting (NMConnection *connection,
 		}
 	}
 
-	// TODO: (cyphermox) dhcp overrides in part here...
-#if 0  // TODO: (cyphermox) def-route toggles and peer, dhcp settings.
+#if 0  // TODO: default-route toggles and peer, dhcp settings.
 	/* DEFROUTE; remember that it has the opposite meaning from never-default */
 	svSetValueBoolean (netplan, "DEFROUTE", !nm_setting_ip_config_get_never_default (s_ip4));
 
@@ -2541,26 +2540,26 @@ write_ip6_setting (NMConnection *connection,
 	if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
 		return TRUE;
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DISABLED)) {
-		// TODO: (cyphermox) set optional
+		// TODO: set optional flag in netplan
 		return TRUE;
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp6: yes\n");
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp6: yes\n");
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_MANUAL)) {
-		// TODO: (cyphermox) implement addresses: [] separately; below
+		// TODO: implement addresses: [] separately; below
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)) {
-		// TODO: (cyphermox) set optional
+		// TODO: set optional flag in netplan
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
-		// TODO: (cyphermox) implement sharing
+		// TODO: implement sharing
 	}
 
-	// TODO: (cyphermox) not in netplan yet (DUID)
+	// TODO: implement DUID selection in netplan
 	//svSetValueStr (netplan, "DHCPV6_DUID",
 	//               nm_setting_ip6_config_get_dhcp_duid (NM_SETTING_IP6_CONFIG (s_ip6)));
 
 	write_ip6_setting_dhcp_hostname (s_ip6, dhcp_overrides);
-	// TODO: (cyphermox) write out dhcp_overrides to GOutputStream
+	// TODO: Write out dhcp_overrides to GOutputStream
 
 	/* Write out IP addresses */
 	num = nm_setting_ip_config_get_num_addresses (s_ip6);
@@ -2601,11 +2600,11 @@ write_ip6_setting (NMConnection *connection,
 		g_output_stream_printf(netplan, 0, NULL, NULL, "        use-routes: no\n");
 	}
 
-	// TODO: (cyphermox)  more about "optional" (see above)
+	// TODO: more about "optional" (see above)
 	//svSetValueStr (netplan, "IPV6_FAILURE_FATAL",
 	//               nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes");
 
-#if 0  /* TODO: metric! */
+#if 0  /* TODO: Implement proper writing of the metric value to netplan YAML */
 	route_metric = nm_setting_ip_config_get_route_metric (s_ip6);
 	if (route_metric != -1)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
@@ -2613,8 +2612,8 @@ write_ip6_setting (NMConnection *connection,
 #endif
 
 #if 0
-    // TODO: (cyphermox)  Currently can't set what route table in netplan.
-    // Implement RouteTable= (networkd)  for DHCP.
+    // TODO: Implement this route as a formal route (rather than gatewayN) to set route table
+    // TODO: Implement RouteTable= (networkd)  for DHCP.
 
 	route_table = nm_setting_ip_config_get_route_table (s_ip6);
 	svSetValueInt64_cond (netplan,
@@ -2626,7 +2625,7 @@ write_ip6_setting (NMConnection *connection,
 	/* IPv6 Privacy Extensions */
 	switch (nm_setting_ip6_config_get_ip6_privacy (NM_SETTING_IP6_CONFIG (s_ip6))) {
 	case NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR:
-		// FIXME: not implemented; use the temporary always.
+		// TODO: not implemented; for now fallback to always use temporary
 	case NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR:
 		g_output_stream_printf(netplan, 0, NULL, NULL, "      ipv6-privacy: yes\n");
 	break;
@@ -2635,7 +2634,7 @@ write_ip6_setting (NMConnection *connection,
 	}
 
 #if 0
-    // TODO: (cyphermox) Address generation and interface identified. (not in netplan yet)
+    // TODO: Support address generation and interface identified. (not in netplan yet)
 	/* IPv6 Address generation mode */
 	addr_gen_mode = nm_setting_ip6_config_get_addr_gen_mode (NM_SETTING_IP6_CONFIG (s_ip6));
 	if (addr_gen_mode != NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64) {
@@ -2650,7 +2649,7 @@ write_ip6_setting (NMConnection *connection,
 	svSetValueStr (netplan, "IPV6_TOKEN", value);
 #endif
 
-    // TODO: (cyphermox) Implement priority for connections
+    // TODO: Implement priority for connections (probably NM-specific)
 #if 0
 	priority = nm_setting_ip_config_get_dns_priority (s_ip6);
 	if (priority)
@@ -2747,7 +2746,7 @@ do_write_construct (NMConnection *connection,
 			        "network:\n  version: 2\n  renderer: NetworkManager\n");
 
 	if (!strcmp (type, NM_SETTING_WIRED_SETTING_NAME)) {
-		// FIXME: can't write PPPoE at this time
+		// TODO: Implement PPPoE support.
 		if (nm_connection_get_setting_pppoe (connection)) {
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
 			             "Can't write connection type '%s'",
@@ -2878,20 +2877,7 @@ do_write_to_disk (NMConnection *connection,
 	 * new settings (in-memory). */
 
 	ret = g_output_stream_close (netplan, NULL, error);
-#if 0  // TODO: (cyphermox) Do actually write everything together to disk...
-	if (!svWriteFile (netplan, 0644, error))
-		return FALSE;
-
-	if (!write_blobs (blobs, error))
-		return FALSE;
-
-	if (!write_secrets (netplan, secrets, error))
-		return FALSE;
-
-	if (route_ignore) {
-		// TODO: write out ignore routes settings
-	}
-#endif
+        // TODO: Do we need to take more steps to ensure writes to disk?
 
 	return ret;
 }
-- 
2.25.1


From c9403d4dffcdce6a3dd3e2c18529076a7010768d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C5=81ukasz=20=27sil2100=27=20Zemczak?=
 <lukasz.zemczak@canonical.com>
Date: Tue, 3 Mar 2020 15:59:13 +0100
Subject: [PATCH 06/78] Make the netplan plugin buildable, attempt fixing
 leftover files from deleted connections.

---
 .../plugins/netplan/nms-netplan-reader.c      | 132 ++++++++++++++----
 .../plugins/netplan/nms-netplan-storage.c     |  13 ++
 .../plugins/netplan/nms-netplan-writer.c      |   3 +
 3 files changed, 120 insertions(+), 28 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index c608d01fda5d8050d7047920fc6a6520865c4c5f..fe98e06f2e11b2fd84f18cecb6d0228ddcc3a2a7 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1326,6 +1326,69 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 /* TODO: Implement DCB support */
 /* There is useful code to look at in ifcfg-rh plugin ~cyphermox */
 
+#if 0 /* TODO: It looks like we don't really support WEP right now */
+static gboolean
+add_one_wep_key (NetplanNetDefinition *nd,
+                 const char *shvar_key,
+                 guint8 key_idx,
+                 gboolean passphrase,
+                 NMSettingWirelessSecurity *s_wsec,
+                 GError **error)
+{
+	gs_free char *value_free = NULL;
+	const char *value;
+	const char *key = NULL;
+
+	g_return_val_if_fail (nd != NULL, FALSE);
+	g_return_val_if_fail (shvar_key != NULL, FALSE);
+	g_return_val_if_fail (key_idx <= 3, FALSE);
+	g_return_val_if_fail (s_wsec != NULL, FALSE);
+
+	value = svGetValueStr (ifcfg, shvar_key, &value_free);
+	if (!value)
+		return TRUE;
+
+	/* Validate keys */
+	if (passphrase) {
+		if (value[0] && strlen (value) < 64)
+			key = value;
+	} else {
+		if (NM_IN_SET (strlen (value), 10, 26)) {
+			/* Hexadecimal WEP key */
+			if (NM_STRCHAR_ANY (value, ch, !g_ascii_isxdigit (ch))) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Invalid hexadecimal WEP key.");
+				return FALSE;
+			}
+			key = value;
+		} else if (   !strncmp (value, "s:", 2)
+		           && NM_IN_SET (strlen (value), 7, 15)) {
+			/* ASCII key */
+			if (NM_STRCHAR_ANY (value + 2, ch, !g_ascii_isprint (ch))) {
+				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+				             "Invalid ASCII WEP key.");
+				return FALSE;
+			}
+
+			/* Remove 's:' prefix.
+			 * Don't convert to hex string. wpa_supplicant takes 'wep_key0' option over D-Bus as byte array
+			 * and converts it to hex string itself. Even though we convert hex string keys into a bin string
+			 * before passing to wpa_supplicant, this prevents two unnecessary conversions. And mainly,
+			 * ASCII WEP key doesn't change to HEX WEP key in UI, which could confuse users.
+			 */
+			key = value + 2;
+		}
+	}
+
+	if (!key) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Invalid WEP key length.");
+		return FALSE;
+	}
+
+	nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
+	return TRUE;
+}
 
 static gboolean
 read_wep_keys (NetplanNetDefinition *nd,
@@ -1335,31 +1398,32 @@ read_wep_keys (NetplanNetDefinition *nd,
                GError **error)
 {
 	if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
-		if (!add_one_wep_key (netplan, "KEY1", 0, FALSE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY1", 0, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY2", 1, FALSE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY2", 1, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY3", 2, FALSE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY3", 2, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY4", 3, FALSE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY4", 3, FALSE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY", def_idx, FALSE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY", def_idx, FALSE, s_wsec, error))
 			return FALSE;
 	}
 
 	if (key_type != NM_WEP_KEY_TYPE_KEY) {
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
 			return FALSE;
-		if (!add_one_wep_key (netplan, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
+		if (!add_one_wep_key (nd, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
 			return FALSE;
 	}
 
 	return TRUE;
 }
+#endif
 
 static NMSetting *
 make_wep_setting (NetplanNetDefinition *nd,
@@ -1368,9 +1432,9 @@ make_wep_setting (NetplanNetDefinition *nd,
 {
 	gs_unref_object NMSettingWirelessSecurity *s_wsec = NULL;
 	gs_free char *value = NULL;
-	int default_key_idx   = 0;
-	gboolean has_defaul  t_key = FALSE;
-	NMSettingSecretFlag  s key_flags;
+	//int default_key_idx = 0;
+	//gboolean has_default_key = FALSE;
+	//NMSettingSecretFlags key_flags;
 
 	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
@@ -1401,13 +1465,13 @@ fill_wpa_ciphers (NetplanNetDefinition *nd,
                   gboolean group,
                   gboolean adhoc)
 {
+#if 0  /* TODO: WPA ciphers selection (not yet in netplan) */
 	gs_free char *value = NULL;
 	const char *p;
 	gs_free const char **list = NULL;
 	const char *const *iter;
 	int i = 0;
 
-#if 0  /* TODO: WPA ciphers selection (not yet in netplan) */
 	p = svGetValueStr (netplan, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
 	if (!p)
 		return TRUE;
@@ -1507,15 +1571,14 @@ make_wpa_setting (NetplanNetDefinition *nd,
 	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
 	gs_free char *value = NULL;
 	const char *v;
-	gboolean wpa_psk = FALSE, wpa_sae = FALSE, wpa_eap = FALSE, ieee8021x = FALSE;
-	int i_val;
+	//int i_val;
 	GError *local = NULL;
 
 	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
 
 	if (nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
 		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP
-		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_8021X)
+		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_8021X)
 		return NULL; /* Not WPA or Dynamic WEP */
 
 #if 0  /* TODO: support WPS */
@@ -1532,9 +1595,9 @@ make_wpa_setting (NetplanNetDefinition *nd,
 
 	/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
 	if (nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
-		|| nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_EAP) {
-		fill_wpa_ciphers (netplan, wsec, FALSE, adhoc);
-		fill_wpa_ciphers (netplan, wsec, TRUE, adhoc);
+		|| nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP) {
+		fill_wpa_ciphers (nd, wsec, FALSE, adhoc);
+		fill_wpa_ciphers (nd, wsec, TRUE, adhoc);
 	}
 
 	/* Adhoc only supports RSN */
@@ -1542,8 +1605,16 @@ make_wpa_setting (NetplanNetDefinition *nd,
 		nm_setting_wireless_security_add_proto (wsec, "wpa");
 	nm_setting_wireless_security_add_proto (wsec, "rsn");
 
-	if (nd->auth.password)
-		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, nd->auth.password, NULL);
+	if (nd->auth.password) {
+		gs_free char *psk = NULL;
+		psk = parse_wpa_psk (nd, file, ssid, &local);
+		if (psk)
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
+		else if (local) {
+			g_propagate_error (error, local);
+			return NULL;
+		}
+	}
 
 	if (nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK)
 		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
@@ -1551,7 +1622,7 @@ make_wpa_setting (NetplanNetDefinition *nd,
 		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
 	}
 
-	*s_8021x = fill_8021x (netplan, file, v, TRUE, error);
+	*s_8021x = fill_8021x (nd, file, v, TRUE, error);
 	if (!*s_8021x)
 		return NULL;
 
@@ -1643,13 +1714,13 @@ make_wireless_security_setting (NetplanNetDefinition *nd,
 	}
 #endif
 
-	wsec = make_wpa_setting (netplan, file, ssid, adhoc, s_8021x, error);
+	wsec = make_wpa_setting (nd, file, ssid, adhoc, s_8021x, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
 		return NULL;
 
-	wsec = make_wep_setting (netplan, file, error);
+	wsec = make_wep_setting (nd, file, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
@@ -1789,11 +1860,13 @@ wireless_connection_from_netplan (const char *file,
 	NMConnection *connection = NULL;
 	NMSetting *con_setting = NULL;
 	NMSetting *wireless_setting = NULL;
-	//NMSetting8021x *s_8021x = NULL;
+	NMSetting8021x *s_8021x = NULL;
 	GBytes *ssid;
-	//NMSetting *security_setting = NULL;
+	NMSetting *security_setting = NULL;
 	gs_free char *ssid_utf8 = NULL;
-	//GError *local = NULL;
+	const char *mode;
+	gboolean adhoc = FALSE;
+	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
 	g_return_val_if_fail (nd != NULL, NULL);
@@ -1810,9 +1883,12 @@ wireless_connection_from_netplan (const char *file,
 	nm_connection_add_setting (connection, wireless_setting);
 
 	ssid = nm_setting_wireless_get_ssid (NM_SETTING_WIRELESS (wireless_setting));
+	mode = nm_setting_wireless_get_mode (NM_SETTING_WIRELESS (wireless_setting));
+	if (mode && !strcmp (mode, "adhoc"))
+		adhoc = TRUE;
 
 	/* Wireless security */
-	security_setting = make_wireless_security_setting (netplan, file, ssid, adhoc, &s_8021x, &local);
+	security_setting = make_wireless_security_setting (nd, file, ssid, adhoc, &s_8021x, &local);
 	if (local) {
 		g_object_unref (connection);
 		g_propagate_error (error, local);
diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 99f758bed64898e96bfaf22487b2314f9d81918b..22e6c89c27e3699ee245b50c2113c6bc86422b29 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -197,6 +197,19 @@ nms_netplan_storage_new_connection (NMSNetplanPlugin *plugin,
 static void
 _storage_clear (NMSNetplanStorage *self)
 {
+	const char *netplan_yaml_path;
+	GFile *netplan_yaml;
+	GError *error = NULL;
+
+	/* Make sure that the related netplan .yaml config file gets removed. */
+	netplan_yaml_path = nms_netplan_storage_get_filename (self);
+	if (g_file_test (full_filename, G_FILE_TEST_EXISTS)) {
+		netplan_yaml = g_file_new_for_path (netplan_yaml_path);
+		g_file_delete (netplan_yaml, NULL, &error);
+		if (error && *error)
+			_LOGT ("netplan: %s", (*error)->message);
+	}
+	
 	c_list_unlink (&self->parent._storage_lst);
 	c_list_unlink (&self->parent._storage_by_uuid_lst);
 	g_clear_object (&self->u.conn_data.connection);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 8e58adbbb4e6febba3934f7ae0169ddda254d93f..cf3470e056ea4e6bd10384d09e33de6712d7fa4b 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -3021,6 +3021,9 @@ nms_netplan_writer_can_write_connection (NMConnection *connection, GError **erro
 	                  NM_SETTING_TEAM_SETTING_NAME,
 	                  NM_SETTING_BRIDGE_SETTING_NAME))
 		return TRUE;
+	if (nm_streq0 (type, NM_SETTING_WIRED_SETTING_NAME)
+	    && !nm_connection_get_setting_pppoe (connection))
+		return TRUE;
 
 	id = nm_connection_get_id (connection);
 	g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-- 
2.25.1


From 2322d01eb58ff6a2b3c40c90915abbcfc60879e3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C5=81ukasz=20=27sil2100=27=20Zemczak?=
 <lukasz.zemczak@canonical.com>
Date: Tue, 3 Mar 2020 16:45:51 +0100
Subject: [PATCH 07/78] Missing pieces.

---
 .../plugins/netplan/nms-netplan-storage.c       | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 22e6c89c27e3699ee245b50c2113c6bc86422b29..536132fd8fe48e2aa0fdca50ab9ad9c1f930a96d 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -16,6 +16,17 @@
 
 /*****************************************************************************/
 
+#define _NMLOG_DOMAIN  LOGD_SETTINGS
+#define _NMLOG(level, ...) \
+    G_STMT_START { \
+        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
+                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
+                "netplan: " \
+                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
+    } G_STMT_END
+
+/*****************************************************************************/
+
 struct _NMSNetplanStorageClass {
 	NMSettingsStorageClass parent;
 };
@@ -203,13 +214,13 @@ _storage_clear (NMSNetplanStorage *self)
 
 	/* Make sure that the related netplan .yaml config file gets removed. */
 	netplan_yaml_path = nms_netplan_storage_get_filename (self);
-	if (g_file_test (full_filename, G_FILE_TEST_EXISTS)) {
+	if (g_file_test (netplan_yaml, G_FILE_TEST_EXISTS)) {
 		netplan_yaml = g_file_new_for_path (netplan_yaml_path);
 		g_file_delete (netplan_yaml, NULL, &error);
 		if (error && *error)
-			_LOGT ("netplan: %s", (*error)->message);
+			_LOGW ("netplan: %s", (*error)->message);
 	}
-	
+
 	c_list_unlink (&self->parent._storage_lst);
 	c_list_unlink (&self->parent._storage_by_uuid_lst);
 	g_clear_object (&self->u.conn_data.connection);
-- 
2.25.1


From 24962881c84c17fdef2aec14c8af571e5e84d463 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C5=81ukasz=20=27sil2100=27=20Zemczak?=
 <lukasz.zemczak@canonical.com>
Date: Mon, 9 Mar 2020 18:31:00 +0100
Subject: [PATCH 08/78] Attempt fixing the netplan plugin's meson.build

---
 src/settings/plugins/netplan/meson.build | 37 ++++++++++++++----------
 1 file changed, 21 insertions(+), 16 deletions(-)

diff --git a/src/settings/plugins/netplan/meson.build b/src/settings/plugins/netplan/meson.build
index 692a863b851e3d34e5741e27fb7979f06f2f0250..9e446c7c4a8fe834cc64820cb446005dd8ecbaac 100644
--- a/src/settings/plugins/netplan/meson.build
+++ b/src/settings/plugins/netplan/meson.build
@@ -1,44 +1,49 @@
 sources = files(
-  'nms-ifupdown-interface-parser.c',
-  'nms-ifupdown-parser.c',
+  'nms-netplan-utils.c',
+  'nms-netplan-storage.c',
+  'nms-netplan-writer.c',
+  'nms-netplan-reader.c',
 )
 
 deps = [
-  libudev_dep,
+  glib_dep,
   nm_dep,
 ]
 
-libnms_ifupdown_core = static_library(
-  'nms-ifupdown-core',
+libnms_netplan_core = static_library(
+  'nms-netplan-core',
   sources: sources,
   dependencies: deps,
 )
 
 sources = files(
-  'nms-ifupdown-plugin.c',
+  'nms-netplan-plugin.c',
 )
 
-libnm_settings_plugin_ifupdown = shared_module(
-  'nm-settings-plugin-ifupdown',
+libnm_settings_plugin_netplan = shared_module(
+  'nm-settings-plugin-netplan',
   sources: sources,
   dependencies: deps,
-  link_with: libnms_ifupdown_core,
-  link_args: ldflags_linker_script_settings,
+  link_with: libnms_netplan_core,
+  link_args: [
+    ldflags_linker_script_settings,
+    '-lnetplan',
+  ],
   link_depends: linker_script_settings,
   install: true,
   install_dir: nm_plugindir,
 )
 
-core_plugins += libnm_settings_plugin_ifupdown
+core_plugins += libnm_settings_plugin_netplan
 
 # FIXME: check_so_symbols replacement
 '''
 run_target(
-  'check-local-symbols-settings-ifupdown',
-  command: [check_so_symbols, libnm_settings_plugin_ifupdown.full_path()],
-  depends: libnm_settings_plugin_ifupdown,
+  'check-local-symbols-settings-netplan',
+  command: [check_so_symbols, libnm_settings_plugin_netplan.full_path()],
+  depends: libnm_settings_plugin_netplan,
 )
 
-check-local-symbols-settings-ifupdown: src/settings/plugins/ifupdown/libnm-settings-plugin-ifupdown.la
-  $(call check_so_symbols,$(builddir)/src/settings/plugins/ifupdown/.libs/libnm-settings-plugin-ifupdown.so)
+check-local-symbols-settings-netplan: src/settings/plugins/netplan/libnm-settings-plugin-netplan.la
+  $(call check_so_symbols,$(builddir)/src/settings/plugins/netplan/.libs/libnm-settings-plugin-netplan.so)
 '''
-- 
2.25.1


From cbd7f0e83120fe1bf65955fd71d4a993a748620a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 26 Mar 2020 08:44:41 +0100
Subject: [PATCH 09/78] Meson:options: add netplan plugin for Ubuntu

---
 meson_options.txt | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/meson_options.txt b/meson_options.txt
index 041d9bfc38532450f414c02777b45aa8b0b5d164..de95d49804b6120a4c8b20510782214ff56e1097 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -44,7 +44,8 @@ option('ebpf', type: 'combo', choices : ['auto', 'true', 'false'], description:
 # configuration plugins
 option('config_plugins_default', type: 'string', value: '', description: 'Default configuration option for main.plugins setting, used as fallback if the configuration option is unset')
 option('ifcfg_rh', type: 'boolean', value: false, description: 'enable ifcfg-rh configuration plugin (Fedora/RHEL)')
-option('ifupdown', type: 'boolean', value: false, description: 'enable ifupdown configuration plugin (Debian/Ubuntu)')
+option('netplan', type: 'boolean', value: false, description: 'enable netplan configuration plugin (Ubuntu)')
+option('ifupdown', type: 'boolean', value: false, description: 'enable ifupdown configuration plugin (Debian)')
 
 # handlers for resolv.conf
 option('resolvconf', type: 'string', value: '', description: 'Enable resolvconf support')
-- 
2.25.1


From d10607fb8d1358662890d575b0e8fc4eec4ecd6d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 26 Mar 2020 08:45:35 +0100
Subject: [PATCH 10/78] settings:plugin:netplan: fix compilation

---
 src/settings/plugins/netplan/nms-netplan-storage.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 536132fd8fe48e2aa0fdca50ab9ad9c1f930a96d..6666b132cab8f9dcd03983783f26083767238e4b 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -217,8 +217,9 @@ _storage_clear (NMSNetplanStorage *self)
 	if (g_file_test (netplan_yaml, G_FILE_TEST_EXISTS)) {
 		netplan_yaml = g_file_new_for_path (netplan_yaml_path);
 		g_file_delete (netplan_yaml, NULL, &error);
-		if (error && *error)
-			_LOGW ("netplan: %s", (*error)->message);
+		if (error)
+			_LOGW ("netplan: %s", error->message);
+			g_error_free(error);
 	}
 
 	c_list_unlink (&self->parent._storage_lst);
-- 
2.25.1


From 547aeeb9b0a314e31724339d88216cf312969382 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 27 Mar 2020 08:23:47 +0100
Subject: [PATCH 11/78] settings:plugin:netplan: add some FIXME/TODO comments

---
 .../plugins/netplan/nms-netplan-storage.c         | 15 +++++++++++++++
 src/settings/plugins/netplan/nms-netplan-writer.c | 10 ++++++++++
 2 files changed, 25 insertions(+)

diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 6666b132cab8f9dcd03983783f26083767238e4b..713dea262c74da038222e37a6c662876864fad17 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -205,6 +205,21 @@ nms_netplan_storage_new_connection (NMSNetplanPlugin *plugin,
 	return self;
 }
 
+/* FIXME:
+  CC       src/settings/plugins/netplan/libnm_settings_plugin_netplan_la-nms-netplan-storage.lo
+src/settings/plugins/netplan/nms-netplan-storage.c: In function â_storage_clearâ:
+src/settings/plugins/netplan/nms-netplan-storage.c:217:19: warning: passing argument 1 of âg_file_testâ from incompatible pointer type [-Wincompatible-pointer-types]
+  217 |  if (g_file_test (netplan_yaml, G_FILE_TEST_EXISTS)) {
+      |                   ^~~~~~~~~~~~
+      |                   |
+      |                   GFile * {aka struct _GFile *}
+In file included from /usr/include/glib-2.0/glib.h:48,
+                 from ./shared/nm-default.h:191,
+                 from src/settings/plugins/netplan/nms-netplan-storage.c:9:
+/usr/include/glib-2.0/glib/gfileutils.h:82:45: note: expected âconst gchar *â {aka âconst char *â} but argument is of type âGFile *â {aka âstruct _GFile *â}
+   82 | gboolean g_file_test         (const gchar  *filename,
+      |                               ~~~~~~~~~~~~~~^~~~~~~~
+*/
 static void
 _storage_clear (NMSNetplanStorage *self)
 {
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index cf3470e056ea4e6bd10384d09e33de6712d7fa4b..31b981eff8caf8bb74e6e9dd1f41a7b83dbcea9a 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -752,6 +752,8 @@ write_wireless_security_setting (NMConnection *connection,
 		psk = nm_setting_wireless_security_get_psk (s_wsec);
 
 	// XXX: Should be using set_secret() here?
+	// FIXME: Add quotes IFF type=WPA-PSK AND length=8-63, otherwise 64 HEX chars
+	//        see: https://github.com/CanonicalLtd/netplan/commit/2427ab267b24daa3504345be4ee6be7f286056a3
 	g_output_stream_printf(netplan, 0, NULL, NULL,
 			       "          password: %s\n", psk);
 
@@ -2765,6 +2767,13 @@ do_write_construct (NMConnection *connection,
 		                        nm_connection_get_interface_name (connection));
 		if (!write_vlan_setting (connection, netplan, error))
 			return FALSE;
+	} else if (!strcmp (type, NM_SETTING_GSM_SETTING_NAME)) {
+		// TODO: add NM_SETTING_GSM_SETTING_NAME
+		//       see: https://github.com/CanonicalLtd/netplan/commit/76aa65e67c6a406548cdc4b866e0e0f54ab2b363
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			         "Can't write connection type '%s'",
+			         NM_SETTING_GSM_SETTING_NAME);
+		return FALSE;
 	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "  wifis:\n    %s:\n",
@@ -3014,6 +3023,7 @@ nms_netplan_writer_can_write_connection (NMConnection *connection, GError **erro
 
 	type = nm_connection_get_connection_type (connection);
 	_LOGW ("MATT: writing \"%s\"", type);
+	// TODO: add NM_SETTING_GSM_SETTING_NAME
 	if (NM_IN_STRSET (type,
 	                  NM_SETTING_VLAN_SETTING_NAME,
 	                  NM_SETTING_WIRELESS_SETTING_NAME,
-- 
2.25.1


From f6fbaf72d2e68675e94c624c675d1c8f18da37b8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 27 Mar 2020 11:22:35 +0100
Subject: [PATCH 12/78] settings:plugins:netplan: setup unit-tests

---
 Makefile.am                                   |  28 ++++
 src/settings/plugins/netplan/meson.build      |   4 +
 .../plugins/netplan/nms-netplan-reader.c      |   5 -
 .../plugins/netplan/tests/meson.build         |  17 ++
 .../plugins/netplan/tests/test-netplan.c      | 157 ++++++++++++++++++
 .../plugins/netplan/tests/yaml/basic.yaml     |   7 +
 6 files changed, 213 insertions(+), 5 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/meson.build
 create mode 100644 src/settings/plugins/netplan/tests/test-netplan.c
 create mode 100644 src/settings/plugins/netplan/tests/yaml/basic.yaml

diff --git a/Makefile.am b/Makefile.am
index 0db611c46a1571477c31ff298b102218f591d466..7a197786a47bf4262eaf162e38bcb2d955c49d4a 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2912,8 +2912,36 @@ check-local-symbols-settings-netplan: src/settings/plugins/netplan/libnm-setting
 
 check_local += check-local-symbols-settings-netplan
 
+###############################################################################
+# src/settings/plugins/netplan/tests
+###############################################################################
+
+check_programs += src/settings/plugins/netplan/tests/test-netplan
+
+src_settings_plugins_netplan_tests_test_netplan_SOURCES = \
+	src/settings/plugins/netplan/tests/test-netplan.c
+
+src_settings_plugins_netplan_tests_test_netplan_CPPFLAGS = $(src_cppflags_base_test)
+
+src_settings_plugins_netplan_tests_test_netplan_LDFLAGS = \
+	$(GLIB_LIBS) \
+	$(CODE_COVERAGE_LDFLAGS) \
+	$(SANITIZER_EXEC_LDFLAGS)
+
+src_settings_plugins_netplan_tests_test_netplan_LDADD = \
+	src/settings/plugins/netplan/libnms-netplan-core.la \
+	src/libNetworkManagerTest.la \
+	-lnetplan
+
+$(src_settings_plugins_netplan_tests_test_netplan_OBJECTS): $(libnm_core_lib_h_pub_mkenums)
+
 endif
 
+EXTRA_DIST += \
+	src/settings/plugins/netplan/tests/yaml/basic.yaml \
+	src/settings/plugins/netplan/meson.build \
+	src/settings/plugins/netplan/tests/meson.build
+
 ###############################################################################
 # src/settings/plugins/ifcfg-rh
 ###############################################################################
diff --git a/src/settings/plugins/netplan/meson.build b/src/settings/plugins/netplan/meson.build
index 9e446c7c4a8fe834cc64820cb446005dd8ecbaac..70071c74234f55e625a5833a4717c017e0512a2e 100644
--- a/src/settings/plugins/netplan/meson.build
+++ b/src/settings/plugins/netplan/meson.build
@@ -47,3 +47,7 @@ run_target(
 check-local-symbols-settings-netplan: src/settings/plugins/netplan/libnm-settings-plugin-netplan.la
   $(call check_so_symbols,$(builddir)/src/settings/plugins/netplan/.libs/libnm-settings-plugin-netplan.so)
 '''
+
+if enable_tests
+  subdir('tests')
+endif
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index fe98e06f2e11b2fd84f18cecb6d0228ddcc3a2a7..ff97f5d9296194917f23ecf9358ecd752f4958a6 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2857,15 +2857,10 @@ nmtst_connection_from_file (const char *filename,
                             char **out_unhandled,
                             GError **error)
 {
-#if 0
 	return connection_from_file_full (filename,
 	                                  network_file,
 	                                  test_type,
 	                                  out_unhandled,
 	                                  error,
 	                                  NULL);
-#endif
-	g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-	             "Not implemented yet");
-	return NULL;
 }
diff --git a/src/settings/plugins/netplan/tests/meson.build b/src/settings/plugins/netplan/tests/meson.build
new file mode 100644
index 0000000000000000000000000000000000000000..dcc18d8b68c2eecf3257bb83ccf3cba201a36e53
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/meson.build
@@ -0,0 +1,17 @@
+test_unit = 'test-netplan'
+
+test_netplan_dir = meson.current_source_dir()
+
+exe = executable(
+  test_unit,
+  test_unit + '.c',
+  dependencies: test_nm_dep,
+  link_with: libnms_netplan_core,
+)
+
+test(
+  'netplan/' + test_unit,
+  test_script,
+  timeout: 90,
+  args: test_args + [exe.full_path()],
+)
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
new file mode 100644
index 0000000000000000000000000000000000000000..f253704182768dcf418be0b9ac286c9b057d1ae8
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager settings service - netplan plugin
+ *
+ * Copyright (C) 2020 Canonical, Ltd.
+ * Author: Lukas MÃ¤rdian <lukas.maerdian@canoncial.com>
+ */
+
+#include "nm-default.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <linux/pkt_sched.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+//#include <netplan/parse.h>
+
+#include "nm-utils.h"
+#include "nm-setting-connection.h"
+#include "nm-setting-wired.h"
+#include "nm-setting-user.h"
+#include "nm-setting-wireless.h"
+#include "nm-setting-wireless-security.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-ip6-config.h"
+#include "nm-setting-8021x.h"
+#include "nm-setting-pppoe.h"
+#include "nm-setting-ppp.h"
+#include "nm-setting-vpn.h"
+#include "nm-setting-ethtool.h"
+#include "nm-setting-gsm.h"
+#include "nm-setting-cdma.h"
+#include "nm-setting-serial.h"
+#include "nm-setting-vlan.h"
+#include "nm-setting-dcb.h"
+#include "nm-core-internal.h"
+#include "nm-libnm-core-intern/nm-ethtool-utils.h"
+
+#include "NetworkManagerUtils.h"
+
+#include "settings/plugins/netplan/nms-netplan-reader.h"
+#include "settings/plugins/netplan/nms-netplan-writer.h"
+#include "settings/plugins/netplan/nms-netplan-utils.h"
+
+#include "nm-test-utils-core.h"
+
+#define TEST_NETPLAN_DIR        NM_BUILD_SRCDIR"/src/settings/plugins/netplan/tests/yaml"
+#define TEST_SCRATCH_DIR        NM_BUILD_BUILDDIR"/src/settings/plugins/netplan/tests/yaml"
+#define TEST_SCRATCH_DIR_TMP    TEST_SCRATCH_DIR"/tmp"
+
+/*****************************************************************************/
+
+static NMConnection *
+_connection_from_file (const char *filename,
+                       const char *network_file,
+                       const char *test_type,
+                       char **out_unhandled)
+{
+	NMConnection *connection;
+	GError *error = NULL;
+	char *unhandled_fallback = NULL;
+
+	g_assert (!out_unhandled || !*out_unhandled);
+
+	connection = nmtst_connection_from_file (filename, network_file, test_type,
+	                                         out_unhandled ?: &unhandled_fallback, &error);
+	g_assert_no_error (error);
+	g_assert (!unhandled_fallback);
+
+	if (out_unhandled && *out_unhandled)
+		nmtst_assert_connection_verifies (connection);
+	else
+		nmtst_assert_connection_verifies_without_normalization (connection);
+	return connection;
+}
+
+/*****************************************************************************/
+
+static void
+test_read_basic (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe };
+
+	connection = _connection_from_file (TEST_NETPLAN_DIR"/basic.yaml",
+	                                    NULL, "Ethernet", NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert_true (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "basic-test");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert_true (nm_setting_connection_get_autoconnect (s_con));
+	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
+
+	/* UUID can't be tested if the netplan does not contain the UUID key, because
+	 * the UUID is generated on the full path of the netplan file, which can change
+	 * depending on where the tests are run.
+	 */
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert_true (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* MAC address */
+	/* FIXME: s_wired does not seem to have NM_SETTING_WIRED_MAC_ADDRESS set.
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	g_assert_true (mac);
+	g_assert_true (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
+	*/
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert_true (s_ip4);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+	g_assert_true (nm_setting_ip_config_get_never_default (s_ip4) == FALSE);
+
+	/* ===== IPv6 SETTING ===== */
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert_true (s_ip6);
+	g_assert_cmpstr (nm_setting_ip_config_get_method (s_ip6), ==, NM_SETTING_IP6_CONFIG_METHOD_AUTO);
+	g_assert_true (nm_setting_ip_config_get_never_default (s_ip6) == FALSE);
+
+	g_object_unref (connection);
+}
+
+/*****************************************************************************/
+
+#define TPATH "/settings/plugins/neptlan/"
+
+NMTST_DEFINE ();
+
+int main (int argc, char **argv)
+{
+	int errsv;
+
+	nmtst_init_assert_logging (&argc, &argv, "INFO", "DEFAULT");
+
+	if (g_mkdir_with_parents (TEST_SCRATCH_DIR_TMP, 0755) != 0) {
+		errsv = errno;
+		g_error ("failure to create test directory \"%s\": %s", TEST_SCRATCH_DIR_TMP, nm_strerror_native (errsv));
+	}
+
+	g_test_add_func (TPATH "basic", test_read_basic);
+
+	return g_test_run ();
+}
diff --git a/src/settings/plugins/netplan/tests/yaml/basic.yaml b/src/settings/plugins/netplan/tests/yaml/basic.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..7cc850b341c04d5247fcff7377071b036107aef7
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/basic.yaml
@@ -0,0 +1,7 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    basic-test:
+      match:
+        macaddress: "de:ad:be:ef:ca:fe"
\ No newline at end of file
-- 
2.25.1


From 3692d5298939918635d9c37ee7058b55aeafb4a0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 27 Mar 2020 11:24:37 +0100
Subject: [PATCH 13/78] settings:plugins:netplan: implement setting of
 NM_SETTING_WIRED_MAC_ADDRESS via match->macaddress

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 4 ++++
 src/settings/plugins/netplan/tests/test-netplan.c | 2 --
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index ff97f5d9296194917f23ecf9358ecd752f4958a6..6d88992ba2ee156ea887290619c51ac87ab40690 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1964,6 +1964,10 @@ make_wired_setting (NetplanNetDefinition *nd,
 	if (nd->mtubytes > 0)
 		g_object_set (s_wired, NM_SETTING_WIRED_MTU, nd->mtubytes, NULL);
 
+	value = nd->match.mac;
+	if (value)
+		g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, value, NULL);
+
 	value = nd->set_mac;
 	if (value)
 		g_object_set (s_wired, NM_SETTING_WIRED_CLONED_MAC_ADDRESS, value, NULL);
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index f253704182768dcf418be0b9ac286c9b057d1ae8..6f882fff5ebd31245fc497c1952b2828f17904d7 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -113,11 +113,9 @@ test_read_basic (void)
 	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
 
 	/* MAC address */
-	/* FIXME: s_wired does not seem to have NM_SETTING_WIRED_MAC_ADDRESS set.
 	mac = nm_setting_wired_get_mac_address (s_wired);
 	g_assert_true (mac);
 	g_assert_true (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
-	*/
 
 	/* ===== IPv4 SETTING ===== */
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
-- 
2.25.1


From 15b09e561e9bab2277f28cb38396ec67067a05ec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 27 Mar 2020 15:45:27 +0100
Subject: [PATCH 14/78] netplan: add test, implement network_file, clear
 netplans before each test

---
 Makefile.am                                   |  4 +-
 .../plugins/netplan/nms-netplan-reader.c      | 10 ++-
 .../plugins/netplan/tests/test-netplan.c      | 89 +++++++++++++++----
 .../netplan/tests/yaml/basic-dhcp.yaml        |  3 +
 .../{basic.yaml => ethernet-match-mac.yaml}   |  2 +-
 .../netplan/tests/yaml/wired-default.yaml     |  6 ++
 6 files changed, 92 insertions(+), 22 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml
 rename src/settings/plugins/netplan/tests/yaml/{basic.yaml => ethernet-match-mac.yaml} (57%)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/wired-default.yaml

diff --git a/Makefile.am b/Makefile.am
index 7a197786a47bf4262eaf162e38bcb2d955c49d4a..22bb8ef443098d474641646f6d7d112714639f8a 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2921,7 +2921,9 @@ check_programs += src/settings/plugins/netplan/tests/test-netplan
 src_settings_plugins_netplan_tests_test_netplan_SOURCES = \
 	src/settings/plugins/netplan/tests/test-netplan.c
 
-src_settings_plugins_netplan_tests_test_netplan_CPPFLAGS = $(src_cppflags_base_test)
+src_settings_plugins_netplan_tests_test_netplan_CPPFLAGS = \
+	$(src_cppflags_base_test) \
+	$(UUID_CFLAGS)
 
 src_settings_plugins_netplan_tests_test_netplan_LDFLAGS = \
 	$(GLIB_LIBS) \
diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 6d88992ba2ee156ea887290619c51ac87ab40690..e4904b3c728be57d7ff9a1905a6a2d340b3cdbf3 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2603,9 +2603,10 @@ connection_from_file_full (const char *filename,
 
 	NM_SET_OUT (out_ignore_error, FALSE);
 
-	/* Non-NULL only for unit tests; normally use /etc/netplan */
+	/* Non-NULL only for unit tests; normally use /etc/netplan/*.yaml
 	if (!network_file)
 		network_file = SYSCONFDIR "/netplan";
+	*/
 
 	netplan_name = utils_get_netplan_name (filename);
 	if (!netplan_name) {
@@ -2614,8 +2615,9 @@ connection_from_file_full (const char *filename,
 		return NULL;
 	}
 
-	/* TODO: Support network_file; for unit testing */
 	ret = netplan_parse_yaml (filename, error);
+	if (ret && network_file)
+		ret = netplan_parse_yaml (network_file, error);
 	if (ret) {
 		_LOGT ("commit: parse successful");
 		netdefs = netplan_finish_parse (error);
@@ -2721,6 +2723,10 @@ connection_from_file_full (const char *filename,
 #endif
 	g_hash_table_iter_init (&iter, netdefs);
 	g_hash_table_iter_next (&iter, &key, (gpointer) &netdef);
+	if (!netdef) {
+		_LOGE ("invalid netdef");
+		return NULL;
+	}
 	_LOGT ("netplan netdef %s : %d", (char *) key, netdef->type);
 
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 6f882fff5ebd31245fc497c1952b2828f17904d7..46aacf607051aec67c93c5fcb23b8dc97c111592 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -17,7 +17,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
-//#include <netplan/parse.h>
+#include <netplan/parse.h>
 
 #include "nm-utils.h"
 #include "nm-setting-connection.h"
@@ -54,6 +54,20 @@
 
 /*****************************************************************************/
 
+#define _NMLOG_DOMAIN      LOGD_SETTINGS
+#define _NMLOG_PREFIX_NAME "test-netplan"
+#define _NMLOG(level, ...) \
+    G_STMT_START { \
+        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
+                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
+                _NMLOG_PREFIX_NAME": " \
+                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
+    } G_STMT_END
+
+#define PARSE_WARNING(...) _LOGW ("%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), "    " _NM_UTILS_MACRO_REST(__VA_ARGS__))
+
+/*****************************************************************************/
+
 static NMConnection *
 _connection_from_file (const char *filename,
                        const char *network_file,
@@ -78,45 +92,47 @@ _connection_from_file (const char *filename,
 	return connection;
 }
 
+static void
+_clear_all_netdefs (void)
+{
+	// Clear all netdefs before each test, so we only access the connection under test.
+	if(netdefs) {
+		guint n = g_hash_table_size (netdefs);
+		// TODO: make sure that any dynamically allocated netdef data is freed
+		g_hash_table_remove_all (netdefs);
+		_LOGT ("cleared %u prior netdefs", n);
+	}
+}
+
 /*****************************************************************************/
 
 static void
-test_read_basic (void)
+test_read_basic_dhcp (void)
 {
 	NMConnection *connection;
 	NMSettingConnection *s_con;
 	NMSettingWired *s_wired;
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
-	const char *mac;
-	char expected_mac_address[ETH_ALEN] = { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe };
 
-	connection = _connection_from_file (TEST_NETPLAN_DIR"/basic.yaml",
-	                                    NULL, "Ethernet", NULL);
+	_clear_all_netdefs ();
+	connection = _connection_from_file (TEST_NETPLAN_DIR"/basic-dhcp.yaml",
+	                                    TEST_NETPLAN_DIR"/wired-default.yaml",
+										NULL, NULL);
 
 	/* ===== CONNECTION SETTING ===== */
 	s_con = nm_connection_get_setting_connection (connection);
 	g_assert_true (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "basic-test");
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "wired-default");
 	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
 	g_assert_true (nm_setting_connection_get_autoconnect (s_con));
 	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
 
-	/* UUID can't be tested if the netplan does not contain the UUID key, because
-	 * the UUID is generated on the full path of the netplan file, which can change
-	 * depending on where the tests are run.
-	 */
-
 	/* ===== WIRED SETTING ===== */
 	s_wired = nm_connection_get_setting_wired (connection);
 	g_assert_true (s_wired);
 	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
 
-	/* MAC address */
-	mac = nm_setting_wired_get_mac_address (s_wired);
-	g_assert_true (mac);
-	g_assert_true (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
-
 	/* ===== IPv4 SETTING ===== */
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	g_assert_true (s_ip4);
@@ -132,6 +148,42 @@ test_read_basic (void)
 	g_object_unref (connection);
 }
 
+static void
+test_read_ethernet_match_mac (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char *mac;
+	char expected_mac_address[ETH_ALEN] = { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe };
+
+	_clear_all_netdefs ();
+	connection = _connection_from_file (TEST_NETPLAN_DIR"/ethernet-match-mac.yaml",
+	                                    NULL, NULL, NULL);
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert_true (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "eth0");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert_true (nm_setting_connection_get_autoconnect (s_con));
+	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert_true (s_wired);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* MAC address */
+	mac = nm_setting_wired_get_mac_address (s_wired);
+	g_assert_true (mac);
+	g_assert_true (nm_utils_hwaddr_matches (mac, -1, expected_mac_address, ETH_ALEN));
+
+	g_object_unref (connection);
+}
+
 /*****************************************************************************/
 
 #define TPATH "/settings/plugins/neptlan/"
@@ -149,7 +201,8 @@ int main (int argc, char **argv)
 		g_error ("failure to create test directory \"%s\": %s", TEST_SCRATCH_DIR_TMP, nm_strerror_native (errsv));
 	}
 
-	g_test_add_func (TPATH "basic", test_read_basic);
+	g_test_add_func (TPATH "basic-dhcp", test_read_basic_dhcp);
+	g_test_add_func (TPATH "ethernet-match-mac", test_read_ethernet_match_mac);
 
 	return g_test_run ();
 }
diff --git a/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml b/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..1d2a7f8a4b5796f0ea0c2f47f7af7ecfd44aa7da
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml
@@ -0,0 +1,3 @@
+network:
+  version: 2
+  renderer: NetworkManager
\ No newline at end of file
diff --git a/src/settings/plugins/netplan/tests/yaml/basic.yaml b/src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml
similarity index 57%
rename from src/settings/plugins/netplan/tests/yaml/basic.yaml
rename to src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml
index 7cc850b341c04d5247fcff7377071b036107aef7..466ca0c4a36805532ac97bcda9bed5b45a7767f0 100644
--- a/src/settings/plugins/netplan/tests/yaml/basic.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml
@@ -2,6 +2,6 @@ network:
   version: 2
   renderer: NetworkManager
   ethernets:
-    basic-test:
+    eth0:
       match:
         macaddress: "de:ad:be:ef:ca:fe"
\ No newline at end of file
diff --git a/src/settings/plugins/netplan/tests/yaml/wired-default.yaml b/src/settings/plugins/netplan/tests/yaml/wired-default.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..ee887ceb4f57fa0035fd9eb36229e38b94fe9e15
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/wired-default.yaml
@@ -0,0 +1,6 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    wired-default:
+      renderer: NetworkManager
-- 
2.25.1


From b0881b15fce2f87a2ddab6c74d6a9f19b3ba0985 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 30 Mar 2020 10:47:32 +0200
Subject: [PATCH 15/78] netplan: use connection name from NM backend, if set

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index e4904b3c728be57d7ff9a1905a6a2d340b3cdbf3..b0c3a548cc26d2a2bd1d790c1de6b29d9a2b0444 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -206,6 +206,11 @@ make_connection_name (NetplanNetDefinition *nd,
 {
 	char *full_name = NULL, *name;
 
+	/* If the NetworkManager backend already has a NAME, use that */
+	name = nd->backend_settings.nm.name;
+	if (name)
+		return name;
+
 	/* If the netplan file already has a NAME, always use that */
 	name = nd->id;
 	if (name)
-- 
2.25.1


From 5fbc50a6261a9dd88b78b332095c63bae4cd81f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 30 Mar 2020 11:08:46 +0200
Subject: [PATCH 16/78] netplan: disable non-implemented default settings

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index b0c3a548cc26d2a2bd1d790c1de6b29d9a2b0444..af29c7a4c125d6c5c97d550803ac183cb5f684c3 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -796,8 +796,8 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, FALSE,
 	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, FALSE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, FALSE,
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, 100,
+	              //NM_SETTING_IP_CONFIG_MAY_FAIL, FALSE,
+	              //NM_SETTING_IP_CONFIG_ROUTE_METRIC, 100,
 	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, 0,
 	              NULL);
 
@@ -1147,8 +1147,8 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, FALSE,
 	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, FALSE,
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, FALSE,
-	              NM_SETTING_IP_CONFIG_ROUTE_METRIC, 100,
+	              //NM_SETTING_IP_CONFIG_MAY_FAIL, FALSE,
+	              //NM_SETTING_IP_CONFIG_ROUTE_METRIC, 100,
 	              NM_SETTING_IP_CONFIG_ROUTE_TABLE, 0,
 	              NM_SETTING_IP6_CONFIG_IP6_PRIVACY, NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
 	              NULL);
-- 
2.25.1


From 22b55cb2bb04bb431235b272e3bc5c22c72c9f99 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 30 Mar 2020 12:35:17 +0200
Subject: [PATCH 17/78] netplan: initial basic write + reread test

---
 .../plugins/netplan/nms-netplan-writer.c      |  14 +-
 .../plugins/netplan/tests/test-netplan.c      | 249 ++++++++++++++++++
 2 files changed, 256 insertions(+), 7 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 31b981eff8caf8bb74e6e9dd1f41a7b83dbcea9a..fbf8a95327a21a1a9786d8927b22ef865610c53b 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2952,7 +2952,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 	_LOGT ("write: write connection %s (%s) to file \"%s\"",
 	       nm_connection_get_id (connection),
 	       nm_connection_get_uuid (connection),
-	       filename);
+	       *out_filename);
 
 	if (!do_write_to_disk (connection,
 	                       netplan,
@@ -2963,7 +2963,6 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 	                       error))
 		return FALSE;
 
-#if 0
 	/* Note that we just wrote the connection to disk, and re-read it from there.
 	 * That is racy if somebody else modifies the connection.
 	 * That race is why we must not tread a failure to re-read the profile
@@ -2979,7 +2978,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 		gs_free_error GError *local = NULL;
 		gs_free char *unhandled = NULL;
 
-		reread = connection_from_file (filename,
+		reread = connection_from_file (*out_filename,
 		                               &unhandled,
 		                               &local,
 		                               NULL);
@@ -2987,11 +2986,11 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 
 		if (!reread) {
 			_LOGW ("write: failure to re-read connection \"%s\": %s",
-			       filename, local->message);
+			       *out_filename, local->message);
 		} else if (unhandled) {
 			g_clear_object (&reread);
 			_LOGW ("write: failure to re-read connection \"%s\": %s",
-			       filename, "connection is unhandled");
+			       *out_filename, "connection is unhandled");
 		} else {
 			if (out_reread_same) {
 				reread_same = nm_connection_compare (reread, connection, NM_SETTING_COMPARE_FLAG_EXACT);
@@ -2999,7 +2998,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 					_LOGD ("write: connection %s (%s) was modified by persisting it to \"%s\" ",
 					       nm_connection_get_id (connection),
 					       nm_connection_get_uuid (connection),
-					       filename);
+					       *out_filename);
 				}
 			}
 		}
@@ -3008,6 +3007,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 		NM_SET_OUT (out_reread_same, reread_same);
 	}
 
+#if 0
 	/* Only return the filename if this was a newly written netplan */
 	if (out_filename && !filename)
 		*out_filename = g_strdup (filename);
@@ -3022,7 +3022,7 @@ nms_netplan_writer_can_write_connection (NMConnection *connection, GError **erro
 	const char *type, *id;
 
 	type = nm_connection_get_connection_type (connection);
-	_LOGW ("MATT: writing \"%s\"", type);
+	_LOGD ("MATT: writing \"%s\"", type);
 	// TODO: add NM_SETTING_GSM_SETTING_NAME
 	if (NM_IN_STRSET (type,
 	                  NM_SETTING_VLAN_SETTING_NAME,
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 46aacf607051aec67c93c5fcb23b8dc97c111592..c5f50c604371dc360a79a004a64c0c0797569ff7 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -104,6 +104,184 @@ _clear_all_netdefs (void)
 	}
 }
 
+/* dummy path for an "expected" file, meaning: don't check for expected
+ * written ifcfg file. */
+static const char NO_EXPECTED[1];
+
+static void
+_assert_expected_content (NMConnection *connection, const char *filename, const char *expected)
+{
+	gs_free char *content_expectd = NULL;
+	gs_free char *content_written = NULL;
+	GError *error = NULL;
+	gsize len_expectd = 0;
+	gsize len_written = 0;
+	gboolean success;
+	const char *uuid = NULL;
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (filename);
+	g_assert (g_file_test (filename, G_FILE_TEST_EXISTS));
+
+	g_assert (expected);
+	if (expected == NO_EXPECTED)
+		return;
+
+	success = g_file_get_contents (filename, &content_written, &len_written, &error);
+	nmtst_assert_success (success, error);
+
+	success = g_file_get_contents (expected, &content_expectd, &len_expectd, &error);
+	nmtst_assert_success (success, error);
+
+	{
+		gsize i, j;
+
+		for (i = 0; i < len_expectd; ) {
+			if (content_expectd[i] != '$') {
+				i++;
+				continue;
+			}
+			if (g_str_has_prefix (&content_expectd[i], "${UUID}")) {
+				GString *str;
+
+				if (!uuid) {
+					uuid = nm_connection_get_uuid (connection);
+					g_assert (uuid);
+				}
+
+				j = strlen (uuid);
+
+				str = g_string_new_len (content_expectd, len_expectd);
+				g_string_erase (str, i, NM_STRLEN ("${UUID}"));
+				g_string_insert_len (str, i, uuid, j);
+
+				g_free (content_expectd);
+				len_expectd = str->len;
+				content_expectd = g_string_free (str, FALSE);
+				i += j;
+				continue;
+			}
+
+			/* other '$' is not supported. If need be, support escaping of
+			 * '$' via '$$'. */
+			g_assert_not_reached ();
+		}
+	}
+
+	if (   len_expectd != len_written
+	    || memcmp (content_expectd, content_written, len_expectd) != 0) {
+		if (   g_getenv ("NMTST_NETPLAN_UPDATE_EXPECTED")
+		    || nm_streq0 (g_getenv ("NM_TEST_REGENERATE"), "1")) {
+			if (uuid) {
+				gs_free char *search = g_strdup_printf ("UUID=%s\n", uuid);
+				const char *s;
+				gsize i;
+				GString *str;
+
+				s = content_written;
+				while (TRUE) {
+					s = strstr (s, search);
+					g_assert (s);
+					if (   s == content_written
+					    || s[-1] == '\n')
+						break;
+					s += strlen (search);
+				}
+
+				i = s - content_written;
+
+				str = g_string_new_len (content_written, len_written);
+				g_string_erase (str, i, strlen (search));
+				g_string_insert (str, i, "UUID=${UUID}\n");
+
+				len_written = str->len;
+				content_written = g_string_free (str, FALSE);
+			}
+			success = g_file_set_contents (expected, content_written, len_written, &error);
+			nmtst_assert_success (success, error);
+		} else {
+			g_error ("The content of \"%s\" (%zu) differs from \"%s\" (%zu). Set NMTST_NETPLAN_UPDATE_EXPECTED=yes to update the files inplace\n\n>>>%s<<<\n\n>>>%s<<<\n",
+			         filename, len_written,
+			         expected, len_expectd,
+			         content_written,
+			         content_expectd);
+		}
+	}
+}
+
+static void
+_assert_reread_same (NMConnection *connection, NMConnection *reread)
+{
+	nmtst_assert_connection_verifies_without_normalization (reread);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+_writer_new_connection_reread (NMConnection *connection,
+                               const char *netplan_dir,
+                               char **out_filename,
+                               const char *expected,
+                               NMConnection **out_reread,
+                               gboolean *out_reread_same)
+{
+	gboolean success;
+	GError *error = NULL;
+	char *filename = NULL;
+	gs_unref_object NMConnection *con_verified = NULL;
+	gs_unref_object NMConnection *reread_copy = NULL;
+	NMConnection **reread = out_reread ?: ((nmtst_get_rand_uint32 () % 2) ? &reread_copy : NULL);
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (netplan_dir);
+
+	con_verified = nmtst_connection_duplicate_and_normalize (connection);
+
+	success = nms_netplan_writer_write_connection (con_verified,
+	                                               netplan_dir,
+	                                               NULL,
+	                                               NULL,
+	                                               NULL,
+	                                               &filename,
+	                                               reread,
+	                                               out_reread_same,
+	                                               &error);
+	nmtst_assert_success (success, error);
+	g_assert (filename && filename[0]);
+
+	if (reread)
+		nmtst_assert_connection_verifies_without_normalization (*reread);
+
+	_assert_expected_content (con_verified, filename, expected);
+
+	if (out_filename)
+		*out_filename = filename;
+	else
+		g_free (filename);
+
+}
+
+static void
+_writer_new_connec_exp (NMConnection *connection,
+                        const char *netplan_dir,
+                        const char *expected,
+                        char **out_filename)
+{
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean reread_same = FALSE;
+
+	_writer_new_connection_reread (connection, netplan_dir, out_filename, expected, &reread, &reread_same);
+	_assert_reread_same (connection, reread);
+	g_assert (reread_same);
+}
+
+static void
+_writer_new_connection (NMConnection *connection,
+                        const char *netplan_dir,
+                        char **out_filename)
+{
+	_writer_new_connec_exp (connection, netplan_dir, NO_EXPECTED, out_filename);
+}
+
 /*****************************************************************************/
 
 static void
@@ -184,6 +362,75 @@ test_read_ethernet_match_mac (void)
 	g_object_unref (connection);
 }
 
+static void
+test_write_wired_basic (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *route6file = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4, *reread_s_ip4;
+	NMSettingIPConfig *s_ip6, *reread_s_ip6;
+	NMIPAddress *addr;
+	NMIPAddress *addr6;
+	NMIPRoute *route6;
+	GError *error = NULL;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "write-test",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+				  NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test",
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	_clear_all_netdefs ();
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
 /*****************************************************************************/
 
 #define TPATH "/settings/plugins/neptlan/"
@@ -204,5 +451,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "basic-dhcp", test_read_basic_dhcp);
 	g_test_add_func (TPATH "ethernet-match-mac", test_read_ethernet_match_mac);
 
+	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
+
 	return g_test_run ();
 }
-- 
2.25.1


From 4265fe97b0f28c9353d5e64bf805256b60fe130c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 30 Mar 2020 15:39:24 +0200
Subject: [PATCH 18/78] netplan: read+write static IP4

---
 .../plugins/netplan/nms-netplan-reader.c      | 68 ++++++--------
 .../plugins/netplan/nms-netplan-writer.c      | 22 ++++-
 .../plugins/netplan/tests/test-netplan.c      | 92 ++++++++++++++++++-
 3 files changed, 139 insertions(+), 43 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index af29c7a4c125d6c5c97d550803ac183cb5f684c3..ac2c19eb14a28533f58a4e861f77c32f817bfd16 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -705,13 +705,15 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	gs_free char *route_path = NULL;
 	gs_free char *value = NULL;
 	gs_free char *dns_options_free = NULL;
+	NMIPAddress *addr;
 	gs_free char *gateway = NULL;
+	GError *local = NULL;
+	char *method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
 
 	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
 
 #if 0  /* TODO: Review defroute magic for never-default */
 	const char *v;
-	char *method;
 	const char *dns_options = NULL;
 	int i;
 	guint32 a;
@@ -790,9 +792,15 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	}
 #endif
 
+	if (nd->ip4_addresses)
+		method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
+
+	if (nd->gateway4)
+		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_GATEWAY, nd->gateway4, NULL);
+
 	/* TODO: map real values for ipv4 -- method + options */
 	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_METHOD, method,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, FALSE,
 	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, FALSE,
@@ -829,57 +837,39 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	v = svGetValueStr (netplan, "DHCP_CLIENT_ID", &value);
 	if (v)
 		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, v, NULL);
+#endif
 
 	/* Read static IP addresses.
 	 * Read them even for AUTO method - in this case the addresses are
 	 * added to the automatic ones. Note that this is not currently supported by
 	 * the legacy 'network' service (ifup-eth).
 	 */
-	for (i = -1;; i++) {
-		NMIPAddress *addr = NULL;
-
-		/* gateway will only be set if still unset. Hence, we don't leak gateway
-		 * here by calling read_full_ip4_address() repeatedly */
-		if (!read_full_ip4_address (netplan, i, NULL, &addr, &gateway, error))
-			return NULL;
-
-		if (!addr) {
-			/* The first mandatory variable is 2-indexed (IPADDR2)
-			 * Variables IPADDR, IPADDR0 and IPADDR1 are optional */
-			if (i > 1)
-				break;
-			continue;
+	if (nd->ip4_addresses) {
+		for (unsigned i = 0; i < nd->ip4_addresses->len; ++i) {
+			gchar** ipmask = g_strsplit (g_array_index(nd->ip4_addresses, char*, i), "/", 2);
+			addr = nm_ip_address_new (AF_INET, ipmask[0], atoi(ipmask[1]), &local);
+			g_assert_no_error (local);
+			nm_setting_ip_config_add_address (s_ip4, addr);
+			nm_ip_address_unref (addr);
 		}
-
-		if (!nm_setting_ip_config_add_address (s_ip4, addr))
-			PARSE_WARNING ("duplicate IP4 address");
-		nm_ip_address_unref (addr);
 	}
 
-	/* Gateway */
-	if (!gateway) {
-		if (network_netplan) {
-			gboolean read_success;
-
-			read_success = read_ip4_address (network_netplan, "GATEWAY", &has_key, &a, error);
-			if (!read_success)
-				return NULL;
-			if (has_key) {
-				if (nm_setting_ip_config_get_num_addresses (s_ip4) == 0) {
-					gs_free char *f = g_path_get_basename (svFileGetName (netplan));
-					PARSE_WARNING ("ignoring GATEWAY (/etc/sysconfig/network) for %s "
-					               "because the connection has no static addresses", f);
-				} else
-					gateway = nm_utils_inet4_ntop_dup (a);
-			}
-		}
-	}
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_GATEWAY, gateway, NULL);
+#if 0
 
 	if (gateway && never_default)
 		PARSE_WARNING ("GATEWAY will be ignored when DEFROUTE is disabled");
 #endif
 
+	if (nd->ip4_nameservers)
+		for (unsigned i = 0; i < nd->ip4_nameservers->len; ++i)
+			nm_setting_ip_config_add_dns (s_ip4,
+										  g_array_index(nd->ip4_nameservers, char*, i));
+
+	if (nd->search_domains)
+		for (unsigned i = 0; i < nd->search_domains->len; ++i)
+			nm_setting_ip_config_add_dns_search (s_ip4,
+												 g_array_index(nd->search_domains, char*, i));
+
 #if 0  /* TODO: Implement read for connection sharing. */
 	/* We used to skip saving a lot of unused properties for the ipv4 shared method.
 	 * We want now to persist them but... unfortunately loading DNS or DOMAIN options
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index fbf8a95327a21a1a9786d8927b22ef865610c53b..5684408ec2d573abd006f5e4b061302ae0cfe895 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2320,9 +2320,11 @@ write_ip4_setting (NMConnection *connection,
 	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO))
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "      dhcp4: yes\n");
-#if 0  /* TODO: implement setting statically assigned IPs: append to GArray for addresses */
 	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)) {
+		// Do nothing:
 		// Static addresses addressed below.
+	}
+#if 0  /* TODO: implement setting statically assigned IPs: append to GArray for addresses */
 	} else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
 		link_local &= 0x2;
 	else if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED))
@@ -2333,6 +2335,9 @@ write_ip4_setting (NMConnection *connection,
 	 * without labels. Unset obsolete NETMASK<n>.
 	 */
 
+	if (num > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+							   "      addresses:\n");
 	for (i = n = 0; i < num; i++) {
 		NMIPAddress *addr;
 		GString *address;
@@ -2351,6 +2356,9 @@ write_ip4_setting (NMConnection *connection,
 		g_string_printf(address, "%s/%d",
 		                nm_ip_address_get_address (addr),
 		                nm_ip_address_get_prefix (addr));
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+							   "        - %s/%d\n", nm_ip_address_get_address (addr),
+							   nm_ip_address_get_prefix (addr));
 		value = g_string_free(address, FALSE);
 		g_array_append_val (addresses, value);
 	}
@@ -2372,20 +2380,32 @@ write_ip4_setting (NMConnection *connection,
 		g_output_stream_printf(netplan, 0, NULL, NULL,
 		                       "      gateway4: %s\n", gateway);
 
+
+	if (nm_setting_ip_config_get_num_dns (s_ip4) > 0 ||
+		nm_setting_ip_config_get_num_dns_searches (s_ip4) > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      nameservers:\n");
+
 	num = nm_setting_ip_config_get_num_dns (s_ip4);
+	if (num > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        addresses:\n");
 	for (i = 0; i < num; i++) {
 		const char *dns;
 
 		dns = nm_setting_ip_config_get_dns (s_ip4, i);
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+							   "          - %s\n", dns);
 		g_array_append_val(nameservers, dns);
 	}
 
 	num = nm_setting_ip_config_get_num_dns_searches (s_ip4);
 	if (num > 0) {
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        search:\n");
 		for (i = 0; i < num; i++) {
 			const char *search;
 
 			search = nm_setting_ip_config_get_dns_search (s_ip4, i);
+			g_output_stream_printf(netplan, 0, NULL, NULL,
+								   "          - %s\n", search);
 			g_array_append_val (searches, search);
 		}
 	}
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index c5f50c604371dc360a79a004a64c0c0797569ff7..a4fb1cfb15171989e5cb63d998d7e0cb8aa7f247 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -364,6 +364,71 @@ test_read_ethernet_match_mac (void)
 
 static void
 test_write_wired_basic (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GError *error = NULL;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "write-test",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+				  NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test",
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	_clear_all_netdefs ();
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
+static void
+test_write_wired_static (void)
 {
 	nmtst_auto_unlinkfile char *testfile = NULL;
 	nmtst_auto_unlinkfile char *route6file = NULL;
@@ -371,6 +436,7 @@ test_write_wired_basic (void)
 	gs_unref_object NMConnection *reread = NULL;
 	NMSettingConnection *s_con;
 	NMSettingWired *s_wired;
+	guint32 mtu = 1492;
 	NMSettingIPConfig *s_ip4, *reread_s_ip4;
 	NMSettingIPConfig *s_ip6, *reread_s_ip6;
 	NMIPAddress *addr;
@@ -386,9 +452,9 @@ test_write_wired_basic (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_con));
 
 	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, "write-test",
+	              NM_SETTING_CONNECTION_ID, "write-test-static",
 	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-				  NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test",
+				  NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test-static",
 				  NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
 	              NULL);
@@ -399,6 +465,7 @@ test_write_wired_basic (void)
 
 	g_object_set (s_wired,
 	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
+	              NM_SETTING_WIRED_MTU, mtu,
 	              NULL);
 
 	/* IP4 setting */
@@ -406,9 +473,27 @@ test_write_wired_basic (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
 
 	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              //NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
 	              NULL);
 
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
+
+	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
+	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
 
 	/* IP6 setting */
 	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
@@ -452,6 +537,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "ethernet-match-mac", test_read_ethernet_match_mac);
 
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
+	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
 	return g_test_run ();
 }
-- 
2.25.1


From 41214d2876b73a2d36a27e32f7408187ba6c19b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 30 Mar 2020 16:44:27 +0200
Subject: [PATCH 19/78] netplan: implement method/addresses/dns/gateway6
 read+write for IP6

FIXME: How can we differentiate dns-search domains between IP4/IP6
connections?
---
 .../plugins/netplan/nms-netplan-reader.c      | 33 ++++++++++++++-----
 .../plugins/netplan/nms-netplan-writer.c      | 19 +++++++++++
 .../plugins/netplan/tests/test-netplan.c      | 30 ++++++++++++++++-
 3 files changed, 73 insertions(+), 9 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index ac2c19eb14a28533f58a4e861f77c32f817bfd16..6c84e5000465825aa300c39daf55f2ce0cf9f1be 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -998,20 +998,21 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	gs_unref_object NMSettingIPConfig *s_ip6 = NULL;
 	gs_free char *value = NULL;
 	gs_free const char **list = NULL;
+	char *method = NM_SETTING_IP6_CONFIG_METHOD_AUTO;
+	NMIPAddress *addr6;
+	GError *local = NULL;
 #if 0
 	const char *v;
 	gboolean ipv6init;
 	gboolean ipv6forwarding;
 	gboolean disabled;
 	gboolean dhcp6 = FALSE;
-	char *method = NM_SETTING_IP6_CONFIG_METHOD_MANUAL;
 	const char *ipv6addr, *ipv6addr_secondaries;
 	gs_free char *ipv6addr_to_free = NULL;
 	gs_free char *ipv6addr_secondaries_to_free = NULL;
 	const char *const *iter;
 	guint32 i;
 	int i_val;
-	GError *local = NULL;
 	int priority;
 	gboolean never_default = FALSE;
 	gboolean ip6_privacy = FALSE, ip6_privacy_prefer_public_ip;
@@ -1130,10 +1131,15 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		route_table = 0;
 	}
 #endif  /* ipv6 methods and settings */
+	if (nd->ip6_addresses)
+		method = NM_SETTING_IP6_CONFIG_METHOD_MANUAL;
+
+	if (nd->gateway6)
+		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_GATEWAY, nd->gateway6, NULL);
 
 	// TODO: make a real s_ip6 object (map from the real values, not just DHCP)
 	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_METHOD, method,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS, FALSE,
 	              NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES, FALSE,
 	              NM_SETTING_IP_CONFIG_NEVER_DEFAULT, FALSE,
@@ -1175,12 +1181,23 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	              svGetValueBoolean (netplan, "DHCPV6_SEND_HOSTNAME", TRUE), NULL);
 #endif  /* IPv6 DUID, hostname and special DHCP options */
 
+	/* Read static IP addresses. */
+	if (nd->ip6_addresses) {
+		for (unsigned i = 0; i < nd->ip6_addresses->len; ++i) {
+			gchar** ipmask = g_strsplit (g_array_index(nd->ip6_addresses, char*, i), "/", 2);
+			addr6 = nm_ip_address_new (AF_INET6, ipmask[0], atoi(ipmask[1]), &local);
+			g_assert_no_error (local);
+			nm_setting_ip_config_add_address (s_ip6, addr6);
+			nm_ip_address_unref (addr6);
+		}
+	}
+
+	if (nd->ip6_nameservers)
+		for (unsigned i = 0; i < nd->ip6_nameservers->len; ++i)
+			nm_setting_ip_config_add_dns (s_ip6,
+										  g_array_index(nd->ip6_nameservers, char*, i));
+
 #if 0  /* TODO: IPv6: read static addresses. */
-	/* Read static IP addresses.
-	 * Read them even for AUTO and DHCP methods - in this case the addresses are
-	 * added to the automatic ones. Note that this is not currently supported by
-	 * the legacy 'network' service (ifup-eth).
-	 */
 	ipv6addr = svGetValueStr (netplan, "IPV6ADDR", &ipv6addr_to_free);
 	ipv6addr_secondaries = svGetValueStr (netplan, "IPV6ADDR_SECONDARIES", &ipv6addr_secondaries_to_free);
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 5684408ec2d573abd006f5e4b061302ae0cfe895..c98df0f42a4ecde6db95897f1dfb07147af39910 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2547,6 +2547,7 @@ write_ip6_setting (NMConnection *connection,
 	//int priority;
 	NMIPAddress *addr;
 	const char *dns;
+	const char *gateway = NULL;
 	//gint64 route_metric;
 	//NMIPRouteTableSyncMode route_table;
 	GString *ip_str;
@@ -2557,6 +2558,11 @@ write_ip6_setting (NMConnection *connection,
 		return TRUE;
 	}
 
+	gateway = nm_setting_ip_config_get_gateway (s_ip6);
+	if (gateway)
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+		                       "      gateway6: %s\n", gateway);
+
 	value = nm_setting_ip_config_get_method (s_ip6);
 	g_assert (value);
 	if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
@@ -2585,6 +2591,8 @@ write_ip6_setting (NMConnection *connection,
 
 	/* Write out IP addresses */
 	num = nm_setting_ip_config_get_num_addresses (s_ip6);
+	if (num > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      addresses:\n");
 	for (i = 0; i < num; i++) {
 		ip_str = g_string_new (NULL);
 
@@ -2593,6 +2601,9 @@ write_ip6_setting (NMConnection *connection,
 		g_string_printf (ip_str, "%s/%u",
 		                 nm_ip_address_get_address (addr),
 		                 nm_ip_address_get_prefix (addr));
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        - %s/%u\n",
+							   nm_ip_address_get_address (addr),
+							   nm_ip_address_get_prefix (addr));
 
 		value = g_string_free(ip_str, FALSE);
 		g_array_append_val(addresses, value);
@@ -2600,17 +2611,25 @@ write_ip6_setting (NMConnection *connection,
 
 	/* Write out DNS - 'DNS' key is used both for IPv4 and IPv6 */
 	//s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (nm_setting_ip_config_get_num_dns (s_ip6) > 0 ||
+		nm_setting_ip_config_get_num_dns_searches (s_ip6) > 0)
+	g_output_stream_printf(netplan, 0, NULL, NULL, "      nameservers:\n");
 	num = nm_setting_ip_config_get_num_dns (s_ip6);
+	if (num > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        addresses:\n");
 	for (i = 0; i < num; i++) {
 		dns = nm_setting_ip_config_get_dns (s_ip6, i);
+		g_output_stream_printf(netplan, 0, NULL, NULL, "          - %s\n", dns);
 		g_array_append_val(nameservers, dns);
 	}
 
 	/* Write out DNS domains */
 	num = nm_setting_ip_config_get_num_dns_searches (s_ip6);
 	if (num > 0) {
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        search:\n");
 		for (i = 0; i < num; i++) {
 			value = nm_setting_ip_config_get_dns_search (s_ip6, i);
+			g_output_stream_printf(netplan, 0, NULL, NULL, "          - %s\n", value);
 			g_array_append_val (searches, value);
 		}
 	}
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index a4fb1cfb15171989e5cb63d998d7e0cb8aa7f247..c709b347504928454f5e1626ad46124fbea3e536 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -500,9 +500,37 @@ test_write_wired_static (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
 
 	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "2001:dead:beef::1",
+	              //NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64) 204,
 	              NULL);
 
+	/* Add addresses */
+	addr6 = nm_ip_address_new (AF_INET6, "1003:1234:abcd::1", 11, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	addr6 = nm_ip_address_new (AF_INET6, "2003:1234:abcd::2", 22, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	addr6 = nm_ip_address_new (AF_INET6, "3003:1234:abcd::3", 33, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip6, addr6);
+	nm_ip_address_unref (addr6);
+
+	/* DNS servers */
+	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
+	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
+
+	/* DNS domains */
+	// FIXME: How to differentiate ip4/ip6 search domains??
+	//nm_setting_ip_config_add_dns_search (s_ip6, "foobar6.com");
+	//nm_setting_ip_config_add_dns_search (s_ip6, "lab6.foobar.com");
+
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connection (connection,
-- 
2.25.1


From 94bad58d74aea5ab762a6837e288f44503efe7f8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 8 Apr 2020 11:58:36 +0200
Subject: [PATCH 20/78] netplan: write combined IP4/6 addresses sequence

---
 .../plugins/netplan/nms-netplan-writer.c      | 42 +++++++++----------
 1 file changed, 21 insertions(+), 21 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index c98df0f42a4ecde6db95897f1dfb07147af39910..5623c1003fd20d306b70f8deb75a6044ff83fe85 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2335,9 +2335,6 @@ write_ip4_setting (NMConnection *connection,
 	 * without labels. Unset obsolete NETMASK<n>.
 	 */
 
-	if (num > 0)
-		g_output_stream_printf(netplan, 0, NULL, NULL,
-							   "      addresses:\n");
 	for (i = n = 0; i < num; i++) {
 		NMIPAddress *addr;
 		GString *address;
@@ -2356,9 +2353,6 @@ write_ip4_setting (NMConnection *connection,
 		g_string_printf(address, "%s/%d",
 		                nm_ip_address_get_address (addr),
 		                nm_ip_address_get_prefix (addr));
-		g_output_stream_printf(netplan, 0, NULL, NULL,
-							   "        - %s/%d\n", nm_ip_address_get_address (addr),
-							   nm_ip_address_get_prefix (addr));
 		value = g_string_free(address, FALSE);
 		g_array_append_val (addresses, value);
 	}
@@ -2591,20 +2585,12 @@ write_ip6_setting (NMConnection *connection,
 
 	/* Write out IP addresses */
 	num = nm_setting_ip_config_get_num_addresses (s_ip6);
-	if (num > 0)
-		g_output_stream_printf(netplan, 0, NULL, NULL, "      addresses:\n");
 	for (i = 0; i < num; i++) {
 		ip_str = g_string_new (NULL);
-
 		addr = nm_setting_ip_config_get_address (s_ip6, i);
-
 		g_string_printf (ip_str, "%s/%u",
 		                 nm_ip_address_get_address (addr),
 		                 nm_ip_address_get_prefix (addr));
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        - %s/%u\n",
-							   nm_ip_address_get_address (addr),
-							   nm_ip_address_get_prefix (addr));
-
 		value = g_string_free(ip_str, FALSE);
 		g_array_append_val(addresses, value);
 	}
@@ -2884,21 +2870,35 @@ do_write_construct (NMConnection *connection,
 
 	if (!write_ip4_setting (connection,
 	                        netplan,
-				addresses,
-				nameservers,
-				searches,
+	                        addresses,
+	                        nameservers,
+	                        searches,
 	                        error))
 		return FALSE;
 
 	if (!write_ip6_setting (connection,
 	                        netplan,
-				addresses,
-				nameservers,
-				searches,
-				dhcp_overrides,
+	                        addresses,
+	                        nameservers,
+	                        searches,
+	                        dhcp_overrides,
 	                        error))
 		return FALSE;
 
+	/**
+	 * Write IP4 & IP6 addresses in CIDR format
+	 */
+	if (addresses->len > 0) {
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      addresses: [");
+		for (unsigned i = 0; i < addresses->len; ++i) {
+			g_output_stream_printf(netplan, 0, NULL, NULL, "%s",
+			                       g_array_index(addresses, char*, i));
+			if (i < addresses->len-1)
+				g_output_stream_printf(netplan, 0, NULL, NULL, ", ");
+		}
+		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
+	}
+
 	write_ip_routing_rules (connection,
 	                        netplan);
 
-- 
2.25.1


From 5edb4a2b8e02ab6ccdef8401f76fb427397b18ad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 8 Apr 2020 12:10:20 +0200
Subject: [PATCH 21/78] netplan: write combined IP4/6
 nameservers:addresses:search: fields

---
 .../plugins/netplan/nms-netplan-writer.c      | 66 +++++++++----------
 1 file changed, 33 insertions(+), 33 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 5623c1003fd20d306b70f8deb75a6044ff83fe85..759b129ab889c36feea6f2141b21e7586e6ad564 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2374,34 +2374,18 @@ write_ip4_setting (NMConnection *connection,
 		g_output_stream_printf(netplan, 0, NULL, NULL,
 		                       "      gateway4: %s\n", gateway);
 
-
-	if (nm_setting_ip_config_get_num_dns (s_ip4) > 0 ||
-		nm_setting_ip_config_get_num_dns_searches (s_ip4) > 0)
-		g_output_stream_printf(netplan, 0, NULL, NULL, "      nameservers:\n");
-
 	num = nm_setting_ip_config_get_num_dns (s_ip4);
-	if (num > 0)
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        addresses:\n");
 	for (i = 0; i < num; i++) {
 		const char *dns;
-
 		dns = nm_setting_ip_config_get_dns (s_ip4, i);
-		g_output_stream_printf(netplan, 0, NULL, NULL,
-							   "          - %s\n", dns);
 		g_array_append_val(nameservers, dns);
 	}
 
 	num = nm_setting_ip_config_get_num_dns_searches (s_ip4);
-	if (num > 0) {
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        search:\n");
-		for (i = 0; i < num; i++) {
-			const char *search;
-
-			search = nm_setting_ip_config_get_dns_search (s_ip4, i);
-			g_output_stream_printf(netplan, 0, NULL, NULL,
-								   "          - %s\n", search);
-			g_array_append_val (searches, search);
-		}
+	for (i = 0; i < num; i++) {
+		const char *search;
+		search = nm_setting_ip_config_get_dns_search (s_ip4, i);
+		g_array_append_val (searches, search);
 	}
 
 #if 0  // TODO: default-route toggles and peer, dhcp settings.
@@ -2597,27 +2581,17 @@ write_ip6_setting (NMConnection *connection,
 
 	/* Write out DNS - 'DNS' key is used both for IPv4 and IPv6 */
 	//s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	if (nm_setting_ip_config_get_num_dns (s_ip6) > 0 ||
-		nm_setting_ip_config_get_num_dns_searches (s_ip6) > 0)
-	g_output_stream_printf(netplan, 0, NULL, NULL, "      nameservers:\n");
 	num = nm_setting_ip_config_get_num_dns (s_ip6);
-	if (num > 0)
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        addresses:\n");
 	for (i = 0; i < num; i++) {
 		dns = nm_setting_ip_config_get_dns (s_ip6, i);
-		g_output_stream_printf(netplan, 0, NULL, NULL, "          - %s\n", dns);
 		g_array_append_val(nameservers, dns);
 	}
 
 	/* Write out DNS domains */
 	num = nm_setting_ip_config_get_num_dns_searches (s_ip6);
-	if (num > 0) {
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        search:\n");
-		for (i = 0; i < num; i++) {
-			value = nm_setting_ip_config_get_dns_search (s_ip6, i);
-			g_output_stream_printf(netplan, 0, NULL, NULL, "          - %s\n", value);
-			g_array_append_val (searches, value);
-		}
+	for (i = 0; i < num; i++) {
+		value = nm_setting_ip_config_get_dns_search (s_ip6, i);
+		g_array_append_val (searches, value);
 	}
 
 	/* handle IPV6_DEFROUTE */
@@ -2899,6 +2873,32 @@ do_write_construct (NMConnection *connection,
 		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
 	}
 
+	/**
+	 * Write IP4 & IP6 DNS nameserver addresses and search
+	 */
+	if (nameservers->len > 0 || searches->len > 0)
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      nameservers:\n");
+	if (nameservers->len > 0) {
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        addresses: [");
+		for (unsigned i = 0; i < nameservers->len; ++i) {
+			g_output_stream_printf(netplan, 0, NULL, NULL, "%s",
+			                       g_array_index(nameservers, char*, i));
+			if (i < nameservers->len-1)
+				g_output_stream_printf(netplan, 0, NULL, NULL, ", ");
+		}
+		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
+	}
+	if (searches->len > 0) {
+		g_output_stream_printf(netplan, 0, NULL, NULL, "        search: [");
+		for (unsigned i = 0; i < searches->len; ++i) {
+			g_output_stream_printf(netplan, 0, NULL, NULL, "%s",
+			                       g_array_index(searches, char*, i));
+			if (i < searches->len-1)
+				g_output_stream_printf(netplan, 0, NULL, NULL, ", ");
+		}
+		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
+	}
+
 	write_ip_routing_rules (connection,
 	                        netplan);
 
-- 
2.25.1


From c1053ca3e110d6e44f9040018a54a6e17e4a98ef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 14 Apr 2020 14:05:54 +0200
Subject: [PATCH 22/78] name/id cleanup & dhcp-hostname test

---
 .../plugins/netplan/nms-netplan-reader.c      |  22 ++-
 .../plugins/netplan/nms-netplan-writer.c      | 128 ++++++++++++------
 .../plugins/netplan/tests/test-netplan.c      |  92 ++++++++++---
 .../netplan/tests/yaml/dhcp-hostname.yaml     |  17 +++
 4 files changed, 193 insertions(+), 66 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 6c84e5000465825aa300c39daf55f2ce0cf9f1be..00a0341557d5086e065901d9d4586bf7b94e176c 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -211,12 +211,8 @@ make_connection_name (NetplanNetDefinition *nd,
 	if (name)
 		return name;
 
-	/* If the netplan file already has a NAME, always use that */
-	name = nd->id;
-	if (name)
-		return name;
-
 	/* Otherwise construct a new NAME */
+	/* XXX: Should we stick to netplan's "netplan-IFNAME[-SSID]" naming scheme? */
 	if (!prefix)
 		prefix = "System";
 
@@ -257,6 +253,7 @@ make_connection_setting (const char *file,
 	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
 
 	new_id = make_connection_name (nd, netplan_name, suggested, prefix);
+	g_assert_nonnull (nm_str_not_empty(new_id));
 	g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
 
 	/* Try for a UUID key before falling back to hashing the file name */
@@ -266,6 +263,7 @@ make_connection_setting (const char *file,
 		uuid = uuid_free;
 	}
 
+	/* XXX: nm.name might be unset, fall back to new_id instead */
 	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : nd->backend_settings.nm.name;
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_TYPE, type,
@@ -273,7 +271,9 @@ make_connection_setting (const char *file,
 	              NM_SETTING_CONNECTION_STABLE_ID, stable_id,
 	              NULL);
 
-	v = nd->backend_settings.nm.device;
+	/* Get iface/device name from NM backend settings. If missing, fall back to netdef ID. */
+	v = nd->backend_settings.nm.device ? nd->backend_settings.nm.device : nd->id;
+	g_assert_nonnull (nm_str_not_empty(v));
 	if (v) {
 		GError *error = NULL;
 
@@ -813,6 +813,10 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	//	return NM_SETTING (g_steal_pointer (&s_ip4));
 
 	/* Handle DHCP settings */
+	if (nd->dhcp4 && nd->dhcp4_overrides.hostname)
+		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, nd->dhcp4_overrides.hostname, NULL);
+	if (nd->dhcp4 && !nd->dhcp4_overrides.send_hostname)
+		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
 #if 0
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "DHCP_HOSTNAME", &value);
@@ -1156,6 +1160,12 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		return NM_SETTING (g_steal_pointer (&s_ip6));
 #endif
 
+	/* Handle DHCP settings */
+	if (nd->dhcp6 && nd->dhcp6_overrides.hostname)
+		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, nd->dhcp6_overrides.hostname, NULL);
+	if (nd->dhcp6 && !nd->dhcp6_overrides.send_hostname)
+		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
+
 #if 0  /* TODO: Implement IPv6 DUID, hostname and special DHCP options */
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "DHCPV6_DUID", &value);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 759b129ab889c36feea6f2141b21e7586e6ad564..a05cfccac91246f6461d552dfe1feae45c67e433 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -59,6 +59,32 @@
 
 /*****************************************************************************/
 
+static void
+write_array_to_sequence(GArray* arr, GOutputStream* s, char* start)
+{
+	g_output_stream_printf(s, 0, NULL, NULL, "%s [", start);
+	for (unsigned i = 0; i < arr->len; ++i) {
+		g_output_stream_printf(s, 0, NULL, NULL, "%s",
+								g_array_index(arr, char*, i));
+		if (i < arr->len-1)
+			g_output_stream_printf(s, 0, NULL, NULL, ", ");
+	}
+	g_output_stream_printf(s, 0, NULL, NULL, "]\n");
+}
+
+static struct HashToDict {
+	GOutputStream* stream;
+	gchar* indent;
+} HashToDict;
+
+static void
+write_hashtable_to_dict(gpointer key, gpointer value, gpointer user_data)
+{
+	struct HashToDict* d = user_data;
+	g_output_stream_printf(d->stream, 0, NULL, NULL, "%s%s: %s\n",
+	                       d->indent, (gchar*)key, (gchar*)value);
+}
+
 #if 0  /* GCC Magic */
 static void
 save_secret_flags (GOutputStream *netplan,
@@ -1769,12 +1795,12 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 
 	g_output_stream_printf (netplan, 0, NULL, NULL, "      networkmanager:\n");
 	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        name: %s\n", nm_setting_connection_get_id(s_con));
+	                        "        name: %s\n", nm_setting_connection_get_id(s_con));
 	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        uuid: %s\n", nm_setting_connection_get_uuid (s_con));
+	                        "        uuid: %s\n", nm_setting_connection_get_uuid (s_con));
+	// FIXME: avoid "stable-id: (null)"
 	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        stable-id: %s\n", nm_setting_connection_get_stable_id (s_con));
-	
+	                        "        stable-id: %s\n", nm_setting_connection_get_stable_id (s_con));
 	
 	// TODO: MOVE to header to identify the device / connection it is under
 	g_output_stream_printf (netplan, 0, NULL, NULL,
@@ -2286,12 +2312,27 @@ write_res_options (GHashTable *netplan, NMSettingIPConfig *s_ip, const char *var
 }
 #endif
 
+static void
+write_ip4_setting_dhcp_hostname (NMSettingIPConfig *s_ip4,
+                                 GHashTable *dhcp_overrides)
+{
+	const char *hostname;
+
+	hostname = nm_setting_ip_config_get_dhcp_hostname (s_ip4);
+	if (hostname)
+		g_hash_table_insert (dhcp_overrides, "hostname", g_strdup(hostname));
+
+	if (!nm_setting_ip_config_get_dhcp_send_hostname (s_ip4))
+		g_hash_table_insert (dhcp_overrides, "send-hostname", g_strdup("no"));
+}
+
 static gboolean
 write_ip4_setting (NMConnection *connection,
                    GOutputStream *netplan,
-		   GArray *addresses,
-		   GArray *nameservers,
-		   GArray *searches,
+                   GArray *addresses,
+                   GArray *nameservers,
+                   GArray *searches,
+                   GHashTable *dhcp_overrides,
                    GError **error)
 {
 	NMSettingIPConfig *s_ip4;
@@ -2388,6 +2429,7 @@ write_ip4_setting (NMConnection *connection,
 		g_array_append_val (searches, search);
 	}
 
+	write_ip4_setting_dhcp_hostname (s_ip4, dhcp_overrides);
 #if 0  // TODO: default-route toggles and peer, dhcp settings.
 	/* DEFROUTE; remember that it has the opposite meaning from never-default */
 	svSetValueBoolean (netplan, "DEFROUTE", !nm_setting_ip_config_get_never_default (s_ip4));
@@ -2504,7 +2546,8 @@ write_ip6_setting_dhcp_hostname (NMSettingIPConfig *s_ip6,
 	const char *hostname;
 
 	hostname = nm_setting_ip_config_get_dhcp_hostname (s_ip6);
-	g_hash_table_insert (dhcp_overrides, "use-hostname", g_strdup(hostname));
+	if (hostname)
+		g_hash_table_insert (dhcp_overrides, "hostname", g_strdup(hostname));
 
 	if (!nm_setting_ip_config_get_dhcp_send_hostname (s_ip6))
 		g_hash_table_insert (dhcp_overrides, "send-hostname", g_strdup("no"));
@@ -2721,7 +2764,7 @@ do_write_construct (NMConnection *connection,
 	//NMSettingIPConfig *s_ip6;
 	const gchar *type = NULL;
 	GArray *addresses, *nameservers, *searches;
-	GHashTable *dhcp_overrides;
+	GHashTable *dhcp4_overrides, *dhcp6_overrides;
 
 	nm_assert (NM_IS_CONNECTION (connection));
 	nm_assert (_nm_connection_verify (connection, NULL) == NM_SETTING_VERIFY_SUCCESS);
@@ -2729,7 +2772,8 @@ do_write_construct (NMConnection *connection,
 	addresses = g_array_new (TRUE, FALSE, sizeof(char *));
 	nameservers = g_array_new (TRUE, FALSE, sizeof(char *));
 	searches = g_array_new (TRUE, FALSE, sizeof(char *));
-	dhcp_overrides = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
+	dhcp6_overrides = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
+	dhcp4_overrides = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
 
 	if (!nms_netplan_writer_can_write_connection (connection, error))
 		return FALSE;
@@ -2847,6 +2891,7 @@ do_write_construct (NMConnection *connection,
 	                        addresses,
 	                        nameservers,
 	                        searches,
+	                        dhcp4_overrides,
 	                        error))
 		return FALSE;
 
@@ -2855,52 +2900,51 @@ do_write_construct (NMConnection *connection,
 	                        addresses,
 	                        nameservers,
 	                        searches,
-	                        dhcp_overrides,
+	                        dhcp6_overrides,
 	                        error))
 		return FALSE;
 
 	/**
 	 * Write IP4 & IP6 addresses in CIDR format
 	 */
-	if (addresses->len > 0) {
-		g_output_stream_printf(netplan, 0, NULL, NULL, "      addresses: [");
-		for (unsigned i = 0; i < addresses->len; ++i) {
-			g_output_stream_printf(netplan, 0, NULL, NULL, "%s",
-			                       g_array_index(addresses, char*, i));
-			if (i < addresses->len-1)
-				g_output_stream_printf(netplan, 0, NULL, NULL, ", ");
-		}
-		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
-	}
+	if (addresses->len > 0)
+		write_array_to_sequence(addresses, netplan, "      addresses:");
 
 	/**
 	 * Write IP4 & IP6 DNS nameserver addresses and search
 	 */
 	if (nameservers->len > 0 || searches->len > 0)
 		g_output_stream_printf(netplan, 0, NULL, NULL, "      nameservers:\n");
-	if (nameservers->len > 0) {
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        addresses: [");
-		for (unsigned i = 0; i < nameservers->len; ++i) {
-			g_output_stream_printf(netplan, 0, NULL, NULL, "%s",
-			                       g_array_index(nameservers, char*, i));
-			if (i < nameservers->len-1)
-				g_output_stream_printf(netplan, 0, NULL, NULL, ", ");
-		}
-		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
-	}
-	if (searches->len > 0) {
-		g_output_stream_printf(netplan, 0, NULL, NULL, "        search: [");
-		for (unsigned i = 0; i < searches->len; ++i) {
-			g_output_stream_printf(netplan, 0, NULL, NULL, "%s",
-			                       g_array_index(searches, char*, i));
-			if (i < searches->len-1)
-				g_output_stream_printf(netplan, 0, NULL, NULL, ", ");
-		}
-		g_output_stream_printf(netplan, 0, NULL, NULL, "]\n");
+	if (nameservers->len > 0)
+		write_array_to_sequence(nameservers, netplan, "        addresses:");
+	if (searches->len > 0)
+		write_array_to_sequence(searches, netplan, "        search:");
+
+	/**
+	 * Write dhcp6-overrides
+	 */
+	if (g_hash_table_size(dhcp6_overrides) > 0) {
+		struct HashToDict htd;
+		htd.stream = netplan;
+		htd.indent = g_strdup("        ");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp6-overrides:\n");
+		g_hash_table_foreach(dhcp6_overrides, write_hashtable_to_dict, &htd);
+		g_free(htd.indent);
+	}
+
+	/**
+	 * Write dhcp4-overrides
+	 */
+	if (g_hash_table_size(dhcp4_overrides) > 0) {
+		struct HashToDict htd;
+		htd.stream = netplan;
+		htd.indent = g_strdup("        ");
+		g_output_stream_printf(netplan, 0, NULL, NULL, "      dhcp4-overrides:\n");
+		g_hash_table_foreach(dhcp4_overrides, write_hashtable_to_dict, &htd);
+		g_free(htd.indent);
 	}
 
-	write_ip_routing_rules (connection,
-	                        netplan);
+	write_ip_routing_rules (connection, netplan);
 
 	write_connection_setting (s_con, netplan);
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index c709b347504928454f5e1626ad46124fbea3e536..8c2741115b22d0a9cafad459944df96a97d4e9ee 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -68,6 +68,28 @@
 
 /*****************************************************************************/
 
+static void
+_log_keyfile (NMConnection *con)
+{
+	gs_unref_keyfile GKeyFile *kf = NULL;
+	gs_free char *str = NULL;
+	kf = nm_keyfile_write (con, NULL, NULL, NULL);
+	str = g_key_file_to_data (kf, NULL, NULL);
+	printf("===== Keyfile =====\n%s\n===== Keyfile End =====\n", str);
+}
+
+static void
+_clear_all_netdefs (void)
+{
+	// Clear all netdefs before each test, so we only access the connection under test.
+	if(netdefs) {
+		guint n = g_hash_table_size (netdefs);
+		// TODO: make sure that any dynamically allocated netdef data is freed
+		g_hash_table_remove_all (netdefs);
+		_LOGT ("cleared %u prior netdefs", n);
+	}
+}
+
 static NMConnection *
 _connection_from_file (const char *filename,
                        const char *network_file,
@@ -80,6 +102,8 @@ _connection_from_file (const char *filename,
 
 	g_assert (!out_unhandled || !*out_unhandled);
 
+	/* Clear netdefs before reading new data from file */
+	_clear_all_netdefs();
 	connection = nmtst_connection_from_file (filename, network_file, test_type,
 	                                         out_unhandled ?: &unhandled_fallback, &error);
 	g_assert_no_error (error);
@@ -92,18 +116,6 @@ _connection_from_file (const char *filename,
 	return connection;
 }
 
-static void
-_clear_all_netdefs (void)
-{
-	// Clear all netdefs before each test, so we only access the connection under test.
-	if(netdefs) {
-		guint n = g_hash_table_size (netdefs);
-		// TODO: make sure that any dynamically allocated netdef data is freed
-		g_hash_table_remove_all (netdefs);
-		_LOGT ("cleared %u prior netdefs", n);
-	}
-}
-
 /* dummy path for an "expected" file, meaning: don't check for expected
  * written ifcfg file. */
 static const char NO_EXPECTED[1];
@@ -234,7 +246,9 @@ _writer_new_connection_reread (NMConnection *connection,
 	g_assert (NM_IS_CONNECTION (connection));
 	g_assert (netplan_dir);
 
+	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
 	con_verified = nmtst_connection_duplicate_and_normalize (connection);
+	_clear_all_netdefs();
 
 	success = nms_netplan_writer_write_connection (con_verified,
 	                                               netplan_dir,
@@ -293,7 +307,7 @@ test_read_basic_dhcp (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	_clear_all_netdefs ();
+	// XXX: is wired-default.yaml still needed?
 	connection = _connection_from_file (TEST_NETPLAN_DIR"/basic-dhcp.yaml",
 	                                    TEST_NETPLAN_DIR"/wired-default.yaml",
 										NULL, NULL);
@@ -301,7 +315,7 @@ test_read_basic_dhcp (void)
 	/* ===== CONNECTION SETTING ===== */
 	s_con = nm_connection_get_setting_connection (connection);
 	g_assert_true (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "wired-default");
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System basic-dhcp.yaml");
 	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
 	g_assert_true (nm_setting_connection_get_autoconnect (s_con));
 	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
@@ -337,14 +351,13 @@ test_read_ethernet_match_mac (void)
 	const char *mac;
 	char expected_mac_address[ETH_ALEN] = { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe };
 
-	_clear_all_netdefs ();
 	connection = _connection_from_file (TEST_NETPLAN_DIR"/ethernet-match-mac.yaml",
 	                                    NULL, NULL, NULL);
 
 	/* ===== CONNECTION SETTING ===== */
 	s_con = nm_connection_get_setting_connection (connection);
 	g_assert_true (s_con);
-	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "eth0");
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "System ethernet-match-mac.yaml");
 	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
 	g_assert_true (nm_setting_connection_get_autoconnect (s_con));
 	g_assert_cmpint (nm_setting_connection_get_autoconnect_retries (s_con), ==, -1);
@@ -420,7 +433,6 @@ test_write_wired_basic (void)
 	                        TEST_SCRATCH_DIR,
 	                        &testfile);
 
-	_clear_all_netdefs ();
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
 	nm_connection_add_setting (connection, nm_setting_proxy_new ());
@@ -537,13 +549,56 @@ test_write_wired_static (void)
 	                        TEST_SCRATCH_DIR,
 	                        &testfile);
 
-	_clear_all_netdefs ();
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
 	nm_connection_add_setting (connection, nm_setting_proxy_new ());
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
 
+static void
+test_read_write_wired_dhcp_send_hostname (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	const char * dhcp_hostname = "some-hostname";
+
+	connection = _connection_from_file (TEST_NETPLAN_DIR"/dhcp-hostname.yaml",
+	                                    NULL, NULL, NULL);
+
+	/* Check dhcp-hostname and dhcp-send-hostname */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	s_ip6 = nm_connection_get_setting_ip6_config (connection);
+	g_assert (s_ip4);
+	g_assert (s_ip6);
+	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) == TRUE);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, "test-name4");
+	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip6) == TRUE);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, "test-name6");
+
+	/* Set dhcp-send-hostname=false dhcp-hostname="some-hostname" and write the connection. */
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
+	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, dhcp_hostname, NULL);
+	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
+	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, dhcp_hostname, NULL);
+
+	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	/* Check dhcp-hostname and dhcp-send-hostname from the re-read connection. */
+	s_ip4 = nm_connection_get_setting_ip4_config (reread);
+	s_ip6 = nm_connection_get_setting_ip6_config (reread);
+	g_assert (s_ip4);
+	g_assert (s_ip6);
+	g_assert (nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) == FALSE);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip4), ==, dhcp_hostname);
+	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
+}
+
 /*****************************************************************************/
 
 #define TPATH "/settings/plugins/neptlan/"
@@ -563,6 +618,7 @@ int main (int argc, char **argv)
 
 	g_test_add_func (TPATH "basic-dhcp", test_read_basic_dhcp);
 	g_test_add_func (TPATH "ethernet-match-mac", test_read_ethernet_match_mac);
+	g_test_add_func (TPATH "read-dhcp-send-hostname", test_read_write_wired_dhcp_send_hostname);
 
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
diff --git a/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml b/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..c3a0e86f5c51a2b85c36ab42290a081cbb6d6554
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml
@@ -0,0 +1,17 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    eth42:
+      dhcp4: yes
+      dhcp4-overrides:
+        hostname: test-name4
+        send-hostname: true
+        use-hostname: true
+      dhcp6: yes
+      dhcp6-overrides:
+        hostname: test-name6
+        send-hostname: true
+        use-hostname: true
+      networkmanager:
+        stable-id: netplan-eth42-stable
-- 
2.25.1


From 6759ad21c3c105387cf11dc069acc4cf94044479 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 14 Apr 2020 14:19:36 +0200
Subject: [PATCH 23/78] netplan: improve stable-id handling

---
 src/settings/plugins/netplan/nms-netplan-reader.c        | 4 ++--
 src/settings/plugins/netplan/nms-netplan-writer.c        | 9 +++++----
 .../plugins/netplan/tests/yaml/dhcp-hostname.yaml        | 2 --
 3 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 00a0341557d5086e065901d9d4586bf7b94e176c..715cbc0b307056001bd50d3ea86b1cee3dbc5a68 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -263,8 +263,8 @@ make_connection_setting (const char *file,
 		uuid = uuid_free;
 	}
 
-	/* XXX: nm.name might be unset, fall back to new_id instead */
-	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : nd->backend_settings.nm.name;
+	/* xxx: Could the stable-id also stay unset? */
+	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : g_strdup(new_id);
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_TYPE, type,
 	              NM_SETTING_CONNECTION_UUID, uuid,
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index a05cfccac91246f6461d552dfe1feae45c67e433..2ece9cbeb16f57a217e9e73ba69680be152e0f0f 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1791,16 +1791,17 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 	//NMSettingConnectionMdns mdns;
 	//NMSettingConnectionLlmnr llmnr;
 	//guint32 vuint32;
-	//const char *tmp;
+	const char *tmp;
 
 	g_output_stream_printf (netplan, 0, NULL, NULL, "      networkmanager:\n");
 	g_output_stream_printf (netplan, 0, NULL, NULL,
 	                        "        name: %s\n", nm_setting_connection_get_id(s_con));
 	g_output_stream_printf (netplan, 0, NULL, NULL,
 	                        "        uuid: %s\n", nm_setting_connection_get_uuid (s_con));
-	// FIXME: avoid "stable-id: (null)"
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-	                        "        stable-id: %s\n", nm_setting_connection_get_stable_id (s_con));
+	tmp = nm_setting_connection_get_stable_id (s_con);
+	if (tmp)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "        stable-id: %s\n", tmp);
 	
 	// TODO: MOVE to header to identify the device / connection it is under
 	g_output_stream_printf (netplan, 0, NULL, NULL,
diff --git a/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml b/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml
index c3a0e86f5c51a2b85c36ab42290a081cbb6d6554..992bddbbe987303dc15e42f4926fc724ada6cd13 100644
--- a/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/dhcp-hostname.yaml
@@ -13,5 +13,3 @@ network:
         hostname: test-name6
         send-hostname: true
         use-hostname: true
-      networkmanager:
-        stable-id: netplan-eth42-stable
-- 
2.25.1


From 16499e014141eb96d8c3f9c35eaaf29fbeae242c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 14 Apr 2020 17:19:24 +0200
Subject: [PATCH 24/78] netplan: wifi sec & mac, add field example test case

---
 .../plugins/netplan/nms-netplan-reader.c      | 123 +++++++++---------
 .../plugins/netplan/nms-netplan-writer.c      |   1 +
 .../plugins/netplan/tests/test-netplan.c      |  85 ++++++++++++
 3 files changed, 149 insertions(+), 60 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 715cbc0b307056001bd50d3ea86b1cee3dbc5a68..c79787e90181a288b8bcf1de5a939c6686b2677d 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -263,8 +263,8 @@ make_connection_setting (const char *file,
 		uuid = uuid_free;
 	}
 
-	/* xxx: Could the stable-id also stay unset? */
-	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : g_strdup(new_id);
+	/* XXX: Can the stable-id be unset, or do we need to create one? E.g. via g_strdup(new_id)? */
+	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : NULL;
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_TYPE, type,
 	              NM_SETTING_CONNECTION_UUID, uuid,
@@ -1527,7 +1527,7 @@ fill_wpa_ciphers (NetplanNetDefinition *nd,
 #define WPA_PMK_LEN 32
 
 static char *
-parse_wpa_psk (NetplanNetDefinition *nd,
+parse_wpa_psk (NetplanWifiAccessPoint *ap,
                const char *file,
                GBytes *ssid,
                GError **error)
@@ -1540,7 +1540,7 @@ parse_wpa_psk (NetplanNetDefinition *nd,
 	 * are between 8 and 63 characters (inclusive), plus optional quoting if
 	 * the passphrase contains spaces.
 	 */
-	psk = nd->auth.password;
+	psk = ap->auth.password;
 
 	if (!psk)
 		return NULL;
@@ -1595,59 +1595,66 @@ make_wpa_setting (NetplanNetDefinition *nd,
 	const char *v;
 	//int i_val;
 	GError *local = NULL;
+	GHashTableIter iter;
+	gpointer key, val;
 
-	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
-
-	if (nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
-		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP
-		&& nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_8021X)
-		return NULL; /* Not WPA or Dynamic WEP */
-
-#if 0  /* TODO: support WPS */
-	/* WPS */
-	i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
-	if (!svGetValueEnum (netplan, "WPS_METHOD",
-	                     nm_setting_wireless_security_wps_method_get_type (),
-	                     &i_val, error))
-		return NULL;
-	g_object_set (wsec,
-	              NM_SETTING_WIRELESS_SECURITY_WPS_METHOD, (guint) i_val,
-	              NULL);
-#endif
-
-	/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
-	if (nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
-		|| nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP) {
-		fill_wpa_ciphers (nd, wsec, FALSE, adhoc);
-		fill_wpa_ciphers (nd, wsec, TRUE, adhoc);
-	}
-
-	/* Adhoc only supports RSN */
-	if (!adhoc)
-		nm_setting_wireless_security_add_proto (wsec, "wpa");
-	nm_setting_wireless_security_add_proto (wsec, "rsn");
-
-	if (nd->auth.password) {
-		gs_free char *psk = NULL;
-		psk = parse_wpa_psk (nd, file, ssid, &local);
-		if (psk)
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
-		else if (local) {
-			g_propagate_error (error, local);
+	g_hash_table_iter_init (&iter, nd->access_points);
+	g_hash_table_iter_next (&iter, &key, &val);
+	if (val) {
+		NetplanWifiAccessPoint *ap = (NetplanWifiAccessPoint *) val;
+
+		wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+
+		if (ap->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
+			&& ap->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP
+			&& ap->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_8021X)
+			return NULL; /* Not WPA or Dynamic WEP */
+
+	#if 0  /* TODO: support WPS */
+		/* WPS */
+		i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
+		if (!svGetValueEnum (netplan, "WPS_METHOD",
+							nm_setting_wireless_security_wps_method_get_type (),
+							&i_val, error))
 			return NULL;
+		g_object_set (wsec,
+					NM_SETTING_WIRELESS_SECURITY_WPS_METHOD, (guint) i_val,
+					NULL);
+	#endif
+
+		/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
+		if (ap->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
+			|| ap->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_EAP) {
+			fill_wpa_ciphers (nd, wsec, FALSE, adhoc);
+			fill_wpa_ciphers (nd, wsec, TRUE, adhoc);
 		}
-	}
-
-	if (nd->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK)
-		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
-	else {
-		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
-	}
 
-	*s_8021x = fill_8021x (nd, file, v, TRUE, error);
-	if (!*s_8021x)
-		return NULL;
+		/* Adhoc only supports RSN */
+		if (adhoc)
+			nm_setting_wireless_security_add_proto (wsec, "rsn");
+		/* Else: Stay with the default, i.e.: wpa;rsn; */
+
+		if (ap->auth.password) {
+			gs_free char *psk = NULL;
+			psk = parse_wpa_psk (val, file, ssid, &local);
+			if (psk)
+				g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
+			else if (local) {
+				g_propagate_error (error, local);
+				return NULL;
+			}
+		}
 
+		if (ap->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK)
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
+		else {
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
+		}
+	} else {
+		*s_8021x = fill_8021x (nd, file, v, TRUE, error);
+		if (!*s_8021x)
+			return NULL;
+	}
 	/* TODO: support WPA PMF, FILS */
 
 #if 0
@@ -1772,13 +1779,9 @@ make_wireless_setting (NetplanNetDefinition *nd,
 		g_free (value);
 	}
 
-#if 0  /* TODO: read in generate_mac_address_mask ? */
-	//g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
-
-	value = svGetValueStr_cp (netplan, "GENERATE_MAC_ADDRESS_MASK");
-	g_object_set (s_wireless, NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK, value, NULL);
-	g_free (value);
-#endif
+	value = nd->match.mac;
+	if (value)
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
 
 	g_hash_table_iter_init (&iter, nd->access_points);
 	g_hash_table_iter_next (&iter, &key, &value);
@@ -1838,7 +1841,7 @@ make_wireless_setting (NetplanNetDefinition *nd,
 	/* TODO: Support toggling powersave for wifi */
 	g_object_set (s_wireless,
 	              NM_SETTING_WIRELESS_POWERSAVE,
-	              NM_SETTING_WIRELESS_POWERSAVE_ENABLE,
+	              NM_SETTING_WIRELESS_POWERSAVE_DEFAULT,
 	              NULL);
 
 #if 0  /* TODO: Add support for MAC address randomization */
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 2ece9cbeb16f57a217e9e73ba69680be152e0f0f..57460c46abe411eeec1d4784b1d959f1c8ee285c 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2791,6 +2791,7 @@ do_write_construct (NMConnection *connection,
 	g_output_stream_printf (netplan, 0, NULL, NULL,
 			        "network:\n  version: 2\n  renderer: NetworkManager\n");
 
+	// XXX: How to handle unknown iface name in netplan?
 	if (!strcmp (type, NM_SETTING_WIRED_SETTING_NAME)) {
 		// TODO: Implement PPPoE support.
 		if (nm_connection_get_setting_pppoe (connection)) {
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 8c2741115b22d0a9cafad459944df96a97d4e9ee..1d37f8ac62da57e45c5f8dac02c9483c5debe239 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -599,6 +599,89 @@ test_read_write_wired_dhcp_send_hostname (void)
 	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
 }
 
+static void
+test_example_field_1 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GError *error = NULL;
+	GBytes *ssid;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "H369AAB53B0",
+	              NM_SETTING_CONNECTION_UUID, "cbe5d88b-b891-48e5-af35-3397891cea62",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+				  //NM_SETTING_CONNECTION_PERMISSIONS, "",
+				  //NM_SETTING_CONNECTION_SECONDARIES, "",
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
+	              NULL);
+
+	/* Wireless setting */
+	s_wireless = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wireless));
+	ssid = g_bytes_new ("H369AAB53B0", 11);
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_MAC_ADDRESS, "00:23:A7:FA:76:E4",
+				  //NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST, "",
+				  NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, 0,
+				  NM_SETTING_WIRELESS_MODE, NM_SETTING_WIRELESS_MODE_INFRA,
+				  //NM_SETTING_WIRELESS_SEEN_BSSIDS, "",
+				  NM_SETTING_WIRELESS_SSID, ssid,
+	              NULL);
+
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+	g_object_set (s_wsec,
+				  //NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", // XXX: This seems to be invalid: Only valid for WEP, not WPA-PSK
+				  //NM_SETTING_WIRELESS_SECURITY_GROUP, "",
+				  NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+				  //NM_SETTING_WIRELESS_SECURITY_PAIRWISE, ""
+				  //NM_SETTING_WIRELESS_SECURITY_PROTO, "",
+				  NM_SETTING_WIRELESS_SECURITY_PSK, "passw0rd",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+				  //TODO: dns-search=
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+				  NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
+				  //TODO: dns-search=
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
 /*****************************************************************************/
 
 #define TPATH "/settings/plugins/neptlan/"
@@ -623,5 +706,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
+	g_test_add_func (TPATH "example/field/1", test_example_field_1);
+
 	return g_test_run ();
 }
-- 
2.25.1


From eca0fd7774c407bfbc6b43d5e311c8c612571823 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 15 Apr 2020 11:07:32 +0200
Subject: [PATCH 25/78] netplan:reader: fix make_match_setting

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index c79787e90181a288b8bcf1de5a939c6686b2677d..e173f11277fe9e3da2de6a633879d28352f6f57e 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -639,7 +639,7 @@ make_match_setting (NetplanNetDefinition *nd)
 	s_match = (NMSettingMatch *) nm_setting_match_new ();
 
 	v = nd->match.original_name;
-	if (!v)
+	if (!nd->has_match || !v)
 		return NULL;
 
 	nm_setting_match_add_interface_name (s_match, v);
-- 
2.25.1


From 51cc69697abfd64445122dce5811351631a4c891 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 15 Apr 2020 11:15:22 +0200
Subject: [PATCH 26/78] netplan: initial skeleton for read-write modem
 (GSM/CDMA) connections

---
 .../plugins/netplan/nms-netplan-reader.c      | 87 +++++++++++++++++++
 .../plugins/netplan/nms-netplan-writer.c      | 53 +++++++++--
 .../plugins/netplan/tests/test-netplan.c      | 70 ++++++++++++++-
 3 files changed, 199 insertions(+), 11 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index e173f11277fe9e3da2de6a633879d28352f6f57e..e89938dc2d70676f0ac2d0faccf4a4eed8f8d8de 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1946,6 +1946,90 @@ wireless_connection_from_netplan (const char *file,
 	return connection;
 }
 
+static NMSetting *
+make_modem_setting (NetplanNetDefinition *nd,
+                    GError **error,
+                    gboolean is_gsm)
+{
+	void *s_modem;
+	const char *tmp;
+	const char *field;
+
+	s_modem = is_gsm ?
+	          NM_SETTING_GSM (nm_setting_gsm_new ()) :
+	          NM_SETTING_CDMA (nm_setting_cdma_new());
+
+	/* Make GSM only settings */
+	if (is_gsm) {
+		tmp = nd->modem_params.apn;
+		if (tmp)
+			g_object_set (s_modem, NM_SETTING_GSM_APN, tmp, NULL);
+	}
+
+	/* Make GSM/CDMA settings */
+	tmp = nd->modem_params.number;
+	field = is_gsm ? NM_SETTING_GSM_NUMBER : NM_SETTING_CDMA_NUMBER;
+	if (tmp)
+		g_object_set (s_modem, field, tmp, NULL);
+
+	return NM_SETTING (s_modem);
+
+error:
+	if (s_modem)
+		g_object_unref (s_modem);
+	return NULL;
+}
+
+static NMConnection *
+modem_connection_from_netplan (const char *file,
+                               NetplanNetDefinition *nd,
+                               GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *modem_setting = NULL;
+	gboolean is_gsm = FALSE;
+	GError *local = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (nd != NULL, NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	connection = nm_simple_connection_new ();
+
+	// XXX: make this part of the netplan library
+	/* Same check as defined in netplan/src/nm.c:modem_is_gsm() */
+	if (nd->modem_params.apn ||  nd->modem_params.auto_config ||
+	    nd->modem_params.device_id || nd->modem_params.network_id ||
+		nd->modem_params.pin || nd->modem_params.sim_id ||
+		nd->modem_params.sim_operator_id)
+        is_gsm = TRUE;
+
+	/* Modem */
+	modem_setting = make_modem_setting (nd, error, is_gsm);
+	if (!modem_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, modem_setting);
+
+	/* Connection */
+	con_setting = make_connection_setting (file, nd, is_gsm ?
+	                                       NM_SETTING_GSM_SETTING_NAME :
+										   NM_SETTING_CDMA_SETTING_NAME,
+	                                       NULL, NULL);
+
+	if (!con_setting) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	return connection;
+}
+
 /* TODO: Support ethtool settings */
 
 #if 0  /* TODO: Read routing rules (routing-policy) */
@@ -2762,6 +2846,9 @@ connection_from_file_full (const char *filename,
 	case NETPLAN_DEF_TYPE_WIFI:
 		connection = wireless_connection_from_netplan (filename, netdef, error);
 		break;
+	case NETPLAN_DEF_TYPE_MODEM:
+		connection = modem_connection_from_netplan (filename, netdef, error);
+		break;
 	case NETPLAN_DEF_TYPE_BRIDGE:
 		connection = bridge_connection_from_netplan (filename, netdef, error);
 		break;
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 57460c46abe411eeec1d4784b1d959f1c8ee285c..87552858e58c89dcafea4789c2a439bd336765ce 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -992,6 +992,43 @@ write_wireless_setting (NMConnection *connection,
 	return TRUE;
 }
 
+static gboolean
+write_modem_setting (NMConnection *connection,
+                     GOutputStream *netplan,
+                     GError **error,
+                     const char* type)
+{
+	void *s_modem = NULL;
+	const char* tmp;
+	gboolean is_gsm = FALSE;
+
+	if (!strcmp(type, NM_SETTING_GSM_SETTING_NAME)) {
+		is_gsm = TRUE;
+		s_modem = (NMSettingGsm *) nm_connection_get_setting_gsm (connection);
+	} else if (!strcmp(type, NM_SETTING_CDMA_SETTING_NAME))
+		s_modem = (NMSettingCdma *) nm_connection_get_setting_cdma (connection);
+
+	if (!s_modem) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", type);
+		return FALSE;
+	}
+
+	/* Write GSM only features */
+	if (is_gsm) {
+		tmp = nm_setting_gsm_get_apn (s_modem);
+		if (nm_str_not_empty(tmp))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      apn: %s\n", tmp);
+	}
+
+	/* Write GSM/CDMA features */
+	tmp = is_gsm ? nm_setting_gsm_get_number (s_modem) : nm_setting_cdma_get_number (s_modem);
+	if (nm_str_not_empty(tmp))
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      number: \"%s\"\n", tmp);
+
+	return TRUE;
+}
+
 #if 0 // TODO: implement infiniband!
 static gboolean
 write_infiniband_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
@@ -2812,13 +2849,12 @@ do_write_construct (NMConnection *connection,
 		                        nm_connection_get_interface_name (connection));
 		if (!write_vlan_setting (connection, netplan, error))
 			return FALSE;
-	} else if (!strcmp (type, NM_SETTING_GSM_SETTING_NAME)) {
-		// TODO: add NM_SETTING_GSM_SETTING_NAME
-		//       see: https://github.com/CanonicalLtd/netplan/commit/76aa65e67c6a406548cdc4b866e0e0f54ab2b363
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			         "Can't write connection type '%s'",
-			         NM_SETTING_GSM_SETTING_NAME);
-		return FALSE;
+	} else if (NM_IN_STRSET (type, NM_SETTING_GSM_SETTING_NAME, NM_SETTING_CDMA_SETTING_NAME)) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "  modems:\n    %s:\n",
+		                        nm_connection_get_interface_name (connection));
+		if (!write_modem_setting (connection, netplan, error, type))
+			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "  wifis:\n    %s:\n",
@@ -3108,10 +3144,11 @@ nms_netplan_writer_can_write_connection (NMConnection *connection, GError **erro
 
 	type = nm_connection_get_connection_type (connection);
 	_LOGD ("MATT: writing \"%s\"", type);
-	// TODO: add NM_SETTING_GSM_SETTING_NAME
 	if (NM_IN_STRSET (type,
 	                  NM_SETTING_VLAN_SETTING_NAME,
 	                  NM_SETTING_WIRELESS_SETTING_NAME,
+	                  NM_SETTING_GSM_SETTING_NAME,
+	                  NM_SETTING_CDMA_SETTING_NAME,
 	                  NM_SETTING_BOND_SETTING_NAME,
 	                  NM_SETTING_TEAM_SETTING_NAME,
 	                  NM_SETTING_BRIDGE_SETTING_NAME))
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 1d37f8ac62da57e45c5f8dac02c9483c5debe239..170d6bd30d6a006831ec6e551ffc215bf20dcf10 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -600,7 +600,7 @@ test_read_write_wired_dhcp_send_hostname (void)
 }
 
 static void
-test_example_field_1 (void)
+test_example_field_wifi (void)
 {
 	nmtst_auto_unlinkfile char *testfile = NULL;
 	gs_unref_object NMConnection *connection = NULL;
@@ -610,7 +610,6 @@ test_example_field_1 (void)
 	NMSettingWirelessSecurity *s_wsec;
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
-	GError *error = NULL;
 	GBytes *ssid;
 
 	_clear_all_netdefs ();
@@ -682,6 +681,70 @@ test_example_field_1 (void)
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
 
+static void
+test_example_field_lte (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingGsm *s_gsm;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "lte",
+	              NM_SETTING_CONNECTION_UUID, "b22d8f0f-3f34-46bd-ac28-801fa87f1eb6",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_GSM_SETTING_NAME,
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "cdc-wdm0",
+				  //NM_SETTING_CONNECTION_PERMISSIONS, "",
+				  //NM_SETTING_CONNECTION_SECONDARIES, "",
+	              NULL);
+
+	/* Wireless setting */
+	s_gsm = (NMSettingGsm *) nm_setting_gsm_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_gsm));
+	g_object_set (s_gsm,
+	              NM_SETTING_GSM_APN, "bicsapn",
+				  NM_SETTING_GSM_NUMBER, "*99#",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+				  //TODO: dns-search=
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+				  NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
+				  //TODO: dns-search=
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
 /*****************************************************************************/
 
 #define TPATH "/settings/plugins/neptlan/"
@@ -706,7 +769,8 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
-	g_test_add_func (TPATH "example/field/1", test_example_field_1);
+	g_test_add_func (TPATH "example/field/wifi", test_example_field_wifi);
+	g_test_add_func (TPATH "example/field/lte", test_example_field_lte);
 
 	return g_test_run ();
 }
-- 
2.25.1


From 27379b08fec486ac490629f6a5fed1d61dfe8756 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 15 Apr 2020 12:02:22 +0200
Subject: [PATCH 27/78] netplan: read/write ip6 addr-gen-mode

---
 .../plugins/netplan/nms-netplan-reader.c      | 17 ++++---
 .../plugins/netplan/nms-netplan-writer.c      | 18 +++----
 .../plugins/netplan/tests/test-netplan.c      | 48 +++++++++----------
 3 files changed, 41 insertions(+), 42 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index e89938dc2d70676f0ac2d0faccf4a4eed8f8d8de..144eb2092e0f05edf47b96b97243e5ceef1842a1 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1256,15 +1256,6 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		}
 	}
 
-	i_val = NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64;
-	if (!svGetValueEnum (netplan, "IPV6_ADDR_GEN_MODE",
-	                     nm_setting_ip6_config_addr_gen_mode_get_type (),
-	                     &i_val, &local)) {
-		PARSE_WARNING ("%s", local->message);
-		g_clear_error (&local);
-	}
-	g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, i_val, NULL);
-
 	/* IPv6 tokenized interface identifier */
 	nm_clear_g_free (&value);
 	v = svGetValueStr (netplan, "IPV6_TOKEN", &value);
@@ -1272,6 +1263,14 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_TOKEN, v, NULL);
 #endif
 
+	/* IPv6 Address generation mode */
+	if (nd->ip6_addr_gen_mode == NETPLAN_ADDRGEN_STABLEPRIVACY)
+		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE,
+					  NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY, NULL);
+	else if (nd->ip6_addr_gen_mode == NETPLAN_ADDRGEN_EUI64)
+		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE,
+		              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64, NULL);
+
 #if 0  /* TODO: set dns servers */
 	/* DNS servers
 	 * Pick up just IPv6 addresses (IPv4 addresses are taken by make_ip4_setting())
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 87552858e58c89dcafea4789c2a439bd336765ce..4de3df571d2588205581554fc5b442f3fe5f8586 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2610,7 +2610,7 @@ write_ip6_setting (NMConnection *connection,
 	//gint64 route_metric;
 	//NMIPRouteTableSyncMode route_table;
 	GString *ip_str;
-	//NMSettingIP6ConfigAddrGenMode addr_gen_mode;
+	NMSettingIP6ConfigAddrGenMode addr_gen_mode;
 
 	s_ip6 = nm_connection_get_setting_ip6_config (connection);
 	if (!s_ip6) {
@@ -2715,17 +2715,17 @@ write_ip6_setting (NMConnection *connection,
 	break;
 	}
 
-#if 0
-    // TODO: Support address generation and interface identified. (not in netplan yet)
 	/* IPv6 Address generation mode */
 	addr_gen_mode = nm_setting_ip6_config_get_addr_gen_mode (NM_SETTING_IP6_CONFIG (s_ip6));
-	if (addr_gen_mode != NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64) {
-		svSetValueEnum (netplan, "IPV6_ADDR_GEN_MODE", nm_setting_ip6_config_addr_gen_mode_get_type (),
-		                addr_gen_mode);
-	} else {
-		svUnsetValue (netplan, "IPV6_ADDR_GEN_MODE");
-	}
+	if (addr_gen_mode == NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY)
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+		                       "      ipv6-address-generation: stable-privacy\n");
+	else if (addr_gen_mode == NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64)
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+		                       "      ipv6-address-generation: eui64\n");
 
+#if 0
+	// TODO: Support interface identifier. (not in netplan yet)
 	/* IPv6 tokenized interface identifier */
 	value = nm_setting_ip6_config_get_token (NM_SETTING_IP6_CONFIG (s_ip6));
 	svSetValueStr (netplan, "IPV6_TOKEN", value);
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 170d6bd30d6a006831ec6e551ffc215bf20dcf10..806a8c5a1a08d4a95c87f6078dfc610687d4c92e 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -622,9 +622,9 @@ test_example_field_wifi (void)
 	              NM_SETTING_CONNECTION_ID, "H369AAB53B0",
 	              NM_SETTING_CONNECTION_UUID, "cbe5d88b-b891-48e5-af35-3397891cea62",
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-				  //NM_SETTING_CONNECTION_PERMISSIONS, "",
-				  //NM_SETTING_CONNECTION_SECONDARIES, "",
-				  NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
+	              //NM_SETTING_CONNECTION_PERMISSIONS, "",
+	              //NM_SETTING_CONNECTION_SECONDARIES, "",
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
 	              NULL);
 
 	/* Wireless setting */
@@ -633,22 +633,22 @@ test_example_field_wifi (void)
 	ssid = g_bytes_new ("H369AAB53B0", 11);
 	g_object_set (s_wireless,
 	              NM_SETTING_WIRELESS_MAC_ADDRESS, "00:23:A7:FA:76:E4",
-				  //NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST, "",
-				  NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, 0,
-				  NM_SETTING_WIRELESS_MODE, NM_SETTING_WIRELESS_MODE_INFRA,
-				  //NM_SETTING_WIRELESS_SEEN_BSSIDS, "",
-				  NM_SETTING_WIRELESS_SSID, ssid,
+	              //NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST, "",
+	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, 0,
+	              NM_SETTING_WIRELESS_MODE, NM_SETTING_WIRELESS_MODE_INFRA,
+	              //NM_SETTING_WIRELESS_SEEN_BSSIDS, "",
+	              NM_SETTING_WIRELESS_SSID, ssid,
 	              NULL);
 
 	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
 	g_object_set (s_wsec,
-				  //NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", // XXX: This seems to be invalid: Only valid for WEP, not WPA-PSK
-				  //NM_SETTING_WIRELESS_SECURITY_GROUP, "",
-				  NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
-				  //NM_SETTING_WIRELESS_SECURITY_PAIRWISE, ""
-				  //NM_SETTING_WIRELESS_SECURITY_PROTO, "",
-				  NM_SETTING_WIRELESS_SECURITY_PSK, "passw0rd",
+	              //NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", // XXX: This seems to be invalid: Only valid for WEP, not WPA-PSK
+	              //NM_SETTING_WIRELESS_SECURITY_GROUP, "",
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              //NM_SETTING_WIRELESS_SECURITY_PAIRWISE, ""
+	              //NM_SETTING_WIRELESS_SECURITY_PROTO, "",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, "passw0rd",
 	              NULL);
 
 	/* IP4 setting */
@@ -656,7 +656,7 @@ test_example_field_wifi (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
 	g_object_set (s_ip4,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-				  //TODO: dns-search=
+	              //TODO: dns-search=
 	              NULL);
 
 	/* IP6 setting */
@@ -665,8 +665,8 @@ test_example_field_wifi (void)
 
 	g_object_set (s_ip6,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-				  NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
-				  //TODO: dns-search=
+	              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
+	              //TODO: dns-search=
 	              NULL);
 
 	nmtst_assert_connection_verifies (connection);
@@ -702,12 +702,12 @@ test_example_field_lte (void)
 	              NM_SETTING_CONNECTION_ID, "lte",
 	              NM_SETTING_CONNECTION_UUID, "b22d8f0f-3f34-46bd-ac28-801fa87f1eb6",
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_GSM_SETTING_NAME,
-				  NM_SETTING_CONNECTION_INTERFACE_NAME, "cdc-wdm0",
-				  //NM_SETTING_CONNECTION_PERMISSIONS, "",
-				  //NM_SETTING_CONNECTION_SECONDARIES, "",
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "cdc-wdm0",
+	              //NM_SETTING_CONNECTION_PERMISSIONS, "",
+	              //NM_SETTING_CONNECTION_SECONDARIES, "",
 	              NULL);
 
-	/* Wireless setting */
+	/* Modem setting */
 	s_gsm = (NMSettingGsm *) nm_setting_gsm_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_gsm));
 	g_object_set (s_gsm,
@@ -720,7 +720,7 @@ test_example_field_lte (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
 	g_object_set (s_ip4,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-				  //TODO: dns-search=
+	              //TODO: dns-search=
 	              NULL);
 
 	/* IP6 setting */
@@ -729,8 +729,8 @@ test_example_field_lte (void)
 
 	g_object_set (s_ip6,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-				  NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
-				  //TODO: dns-search=
+	              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
+	              //TODO: dns-search=
 	              NULL);
 
 	nmtst_assert_connection_verifies (connection);
-- 
2.25.1


From 4f53619cf848d425b46c08c79d336bcc0e0bf178 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 15 Apr 2020 13:47:04 +0200
Subject: [PATCH 28/78] netplan: implement GSM/CDMA modem settings

---
 .../plugins/netplan/nms-netplan-reader.c      |  37 ++++++
 .../plugins/netplan/nms-netplan-writer.c      |  36 +++++
 .../plugins/netplan/tests/test-netplan.c      | 125 ++++++++++++++++++
 3 files changed, 198 insertions(+)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 144eb2092e0f05edf47b96b97243e5ceef1842a1..47819e959b600aa8224e4a88eb2d999b5b8cff1a 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1960,9 +1960,32 @@ make_modem_setting (NetplanNetDefinition *nd,
 
 	/* Make GSM only settings */
 	if (is_gsm) {
+		if (nd->modem_params.auto_config)
+			g_object_set (s_modem, NM_SETTING_GSM_AUTO_CONFIG, TRUE, NULL);
+
 		tmp = nd->modem_params.apn;
 		if (tmp)
 			g_object_set (s_modem, NM_SETTING_GSM_APN, tmp, NULL);
+
+		tmp = nd->modem_params.device_id;
+		if (tmp)
+			g_object_set (s_modem, NM_SETTING_GSM_DEVICE_ID, tmp, NULL);
+
+		tmp = nd->modem_params.network_id;
+		if (tmp)
+			g_object_set (s_modem, NM_SETTING_GSM_NETWORK_ID, tmp, NULL);
+
+		tmp = nd->modem_params.pin;
+		if (tmp)
+			g_object_set (s_modem, NM_SETTING_GSM_PIN, tmp, NULL);
+
+		tmp = nd->modem_params.sim_id;
+		if (tmp)
+			g_object_set (s_modem, NM_SETTING_GSM_SIM_ID, tmp, NULL);
+
+		tmp = nd->modem_params.sim_operator_id;
+		if (tmp)
+			g_object_set (s_modem, NM_SETTING_GSM_SIM_OPERATOR_ID, tmp, NULL);
 	}
 
 	/* Make GSM/CDMA settings */
@@ -1971,6 +1994,20 @@ make_modem_setting (NetplanNetDefinition *nd,
 	if (tmp)
 		g_object_set (s_modem, field, tmp, NULL);
 
+	tmp = nd->modem_params.password;
+	field = is_gsm ? NM_SETTING_GSM_PASSWORD : NM_SETTING_CDMA_PASSWORD;
+	if (tmp)
+		g_object_set (s_modem, field, tmp, NULL);
+
+	tmp = nd->modem_params.username;
+	field = is_gsm ? NM_SETTING_GSM_USERNAME : NM_SETTING_CDMA_USERNAME;
+	if (tmp)
+		g_object_set (s_modem, field, tmp, NULL);
+
+	field = is_gsm ? NM_SETTING_GSM_MTU : NM_SETTING_CDMA_MTU;
+	if (nd->mtubytes > 0)
+		g_object_set (s_modem, field, nd->mtubytes, NULL);
+
 	return NM_SETTING (s_modem);
 
 error:
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 4de3df571d2588205581554fc5b442f3fe5f8586..aad7eb5d28516e236910d667b0489ef117f8b25a 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1001,6 +1001,7 @@ write_modem_setting (NMConnection *connection,
 	void *s_modem = NULL;
 	const char* tmp;
 	gboolean is_gsm = FALSE;
+	guint32 mtu = 0;
 
 	if (!strcmp(type, NM_SETTING_GSM_SETTING_NAME)) {
 		is_gsm = TRUE;
@@ -1016,9 +1017,32 @@ write_modem_setting (NMConnection *connection,
 
 	/* Write GSM only features */
 	if (is_gsm) {
+		if (nm_setting_gsm_get_auto_config (s_modem))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      auto-config: true\n");
+
 		tmp = nm_setting_gsm_get_apn (s_modem);
 		if (nm_str_not_empty(tmp))
 			g_output_stream_printf (netplan, 0, NULL, NULL, "      apn: %s\n", tmp);
+
+		tmp = nm_setting_gsm_get_device_id (s_modem);
+		if (nm_str_not_empty(tmp))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      device-id: %s\n", tmp);
+
+		tmp = nm_setting_gsm_get_network_id (s_modem);
+		if (nm_str_not_empty(tmp))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      network-id: %s\n", tmp);
+
+		tmp = nm_setting_gsm_get_pin (s_modem);
+		if (nm_str_not_empty(tmp))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      pin: %s\n", tmp);
+
+		tmp = nm_setting_gsm_get_sim_id (s_modem);
+		if (nm_str_not_empty(tmp))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      sim-id: %s\n", tmp);
+
+		tmp = nm_setting_gsm_get_sim_operator_id (s_modem);
+		if (nm_str_not_empty(tmp))
+			g_output_stream_printf (netplan, 0, NULL, NULL, "      sim-operator-id: %s\n", tmp);
 	}
 
 	/* Write GSM/CDMA features */
@@ -1026,6 +1050,18 @@ write_modem_setting (NMConnection *connection,
 	if (nm_str_not_empty(tmp))
 		g_output_stream_printf (netplan, 0, NULL, NULL, "      number: \"%s\"\n", tmp);
 
+	tmp = is_gsm ? nm_setting_gsm_get_password (s_modem) : nm_setting_cdma_get_password (s_modem);
+	if (nm_str_not_empty(tmp))
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      password: \"%s\"\n", tmp);
+
+	tmp = is_gsm ? nm_setting_gsm_get_username (s_modem) : nm_setting_cdma_get_username (s_modem);
+	if (nm_str_not_empty(tmp))
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      username: \"%s\"\n", tmp);
+
+	mtu = is_gsm ? nm_setting_gsm_get_mtu (s_modem) : nm_setting_cdma_get_mtu (s_modem);
+	if (mtu > 0)
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      mtu: \"%u\"\n", mtu);
+
 	return TRUE;
 }
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 806a8c5a1a08d4a95c87f6078dfc610687d4c92e..8f63db30a6b233e5efff0015a9eb48f70a7815c3 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -599,6 +599,128 @@ test_read_write_wired_dhcp_send_hostname (void)
 	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
 }
 
+static void
+test_write_modem_gsm (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingGsm *s_modem;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "gsm",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_GSM_SETTING_NAME,
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "cdc-wdm0",
+	              NULL);
+
+	/* Modem setting */
+	s_modem = (NMSettingGsm *) nm_setting_gsm_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_modem));
+	g_object_set (s_modem,
+	              NM_SETTING_GSM_AUTO_CONFIG, FALSE,
+	              NM_SETTING_GSM_APN, "internet",
+	              NM_SETTING_GSM_DEVICE_ID, "dev-123",
+	              NM_SETTING_GSM_NETWORK_ID, "123456",
+	              NM_SETTING_GSM_PIN, "0000",
+	              NM_SETTING_GSM_SIM_ID, "sim-123",
+	              NM_SETTING_GSM_SIM_OPERATOR_ID, "123456",
+	              NM_SETTING_GSM_NUMBER, "*99#",
+	              NM_SETTING_GSM_USERNAME, "user",
+	              NM_SETTING_GSM_PASSWORD, "passw0rd",
+	              NM_SETTING_GSM_MTU, 1600,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
+static void
+test_write_modem_cdma (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingCdma *s_modem;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "cdma",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_CDMA_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "cdc-wdm0",
+	              NULL);
+
+	/* Modem setting */
+	s_modem = (NMSettingGsm *) nm_setting_cdma_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_modem));
+	g_object_set (s_modem,
+	              NM_SETTING_GSM_NUMBER, "*99#",
+	              NM_SETTING_GSM_USERNAME, "user",
+	              NM_SETTING_GSM_PASSWORD, "passw0rd",
+	              NM_SETTING_GSM_MTU, 1600,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
 static void
 test_example_field_wifi (void)
 {
@@ -769,6 +891,9 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
+	g_test_add_func (TPATH "modem/write/gsm", test_write_modem_gsm);
+	g_test_add_func (TPATH "modem/write/cdma", test_write_modem_cdma);
+
 	g_test_add_func (TPATH "example/field/wifi", test_example_field_wifi);
 	g_test_add_func (TPATH "example/field/lte", test_example_field_lte);
 
-- 
2.25.1


From 3fc08b05c515244e409c42073fb0bcbd8876b0a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 17 Apr 2020 09:35:50 +0200
Subject: [PATCH 29/78] netplan: test gsm auto-config & ip6-address-generation
 eui64, fix CDMA test

---
 .../plugins/netplan/tests/test-netplan.c      | 68 ++++++++++++++++++-
 1 file changed, 66 insertions(+), 2 deletions(-)

diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 8f63db30a6b233e5efff0015a9eb48f70a7815c3..6e6750cd5824ecd59ef3337dbdbd0a84882180b8 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -599,6 +599,69 @@ test_read_write_wired_dhcp_send_hostname (void)
 	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
 }
 
+static void
+test_write_modem_gsm_auto_eui64 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingGsm *s_modem;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIP6Config *s_ip6;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "gsm-auto",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_GSM_SETTING_NAME,
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "cdc-wdm0",
+	              NULL);
+
+	/* Modem setting */
+	s_modem = (NMSettingGsm *) nm_setting_gsm_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_modem));
+	g_object_set (s_modem, NM_SETTING_GSM_AUTO_CONFIG, TRUE, NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	/* Verify auto-config was written & re-read correctly. */
+	s_modem = nm_connection_get_setting_gsm (reread);
+	g_assert_true (s_modem);
+	g_assert_true (nm_setting_gsm_get_auto_config (s_modem));
+
+	/* Verify eui64 was written & re-read correctly. */
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting_ip6_config (reread);
+	g_assert_true (s_ip6);
+	g_assert_true (nm_setting_ip6_config_get_addr_gen_mode (s_ip6) == NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
 static void
 test_write_modem_gsm (void)
 {
@@ -652,7 +715,7 @@ test_write_modem_gsm (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
 	g_object_set (s_ip6,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
+	              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE, NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
 	              NULL);
 
 	nmtst_assert_connection_verifies (connection);
@@ -689,7 +752,7 @@ test_write_modem_cdma (void)
 	              NULL);
 
 	/* Modem setting */
-	s_modem = (NMSettingGsm *) nm_setting_cdma_new ();
+	s_modem = (NMSettingCdma *) nm_setting_cdma_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_modem));
 	g_object_set (s_modem,
 	              NM_SETTING_GSM_NUMBER, "*99#",
@@ -891,6 +954,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
+	g_test_add_func (TPATH "modem/write/gsm-auto-eui64", test_write_modem_gsm_auto_eui64);
 	g_test_add_func (TPATH "modem/write/gsm", test_write_modem_gsm);
 	g_test_add_func (TPATH "modem/write/cdma", test_write_modem_cdma);
 
-- 
2.25.1


From 815f432fe97bb5767ca26a86bcf9a1d58e6bcacf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 17 Apr 2020 12:43:20 +0200
Subject: [PATCH 30/78] netplan: implement wake-on-wlan

---
 .../plugins/netplan/nms-netplan-reader.c      |  3 +
 .../plugins/netplan/nms-netplan-writer.c      | 33 +++++++-
 .../plugins/netplan/tests/test-netplan.c      | 80 +++++++++++++++++++
 3 files changed, 115 insertions(+), 1 deletion(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 47819e959b600aa8224e4a88eb2d999b5b8cff1a..436a61de4f574d265d60bd09a50a595f6a2ae786 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1782,6 +1782,9 @@ make_wireless_setting (NetplanNetDefinition *nd,
 	if (value)
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_MAC_ADDRESS, value, NULL);
 
+	if (nd->wowlan > NM_SETTING_WIRELESS_WAKE_ON_WLAN_NONE)
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_WAKE_ON_WLAN, nd->wowlan, NULL);
+
 	g_hash_table_iter_init (&iter, nd->access_points);
 	g_hash_table_iter_next (&iter, &key, &value);
 	if (value) {
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index aad7eb5d28516e236910d667b0489ef117f8b25a..06fcda2858e124373496a171cf424b34161eb3dc 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -19,6 +19,7 @@
 #include <stdio.h>
 
 #include <gio/gio.h>
+#include <netplan/parse.h>
 
 #include "nm-glib-aux/nm-enum-utils.h"
 #include "nm-glib-aux/nm-io-utils.h"
@@ -802,6 +803,26 @@ write_wireless_security_setting (NMConnection *connection,
 	return TRUE;
 }
 
+static gchar*
+wowlan_flags_str(NMSettingWirelessWakeOnWLan flags, GError **error)
+{
+	GString *out = g_string_sized_new (200);
+	for (unsigned i = 0; NETPLAN_WIFI_WOWLAN_TYPES[i].name != NULL; ++i) {
+		if (flags & NETPLAN_WIFI_WOWLAN_TYPES[i].flag)
+			g_string_append_printf (out, "%s, ", NETPLAN_WIFI_WOWLAN_TYPES[i].name);
+	}
+	if (out->len == 0) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Invalid WakeOnWLan flags: '0x%x' not supported by netplan.", flags);
+		return g_string_free (out, TRUE);
+	}
+
+	// cut last ", "
+	out = g_string_truncate (out, out->len-2);
+	// returned gchar* must be freed by caller
+	return g_string_free (out, FALSE);
+}
+
 static gboolean
 write_wireless_setting (NMConnection *connection,
                         GOutputStream *netplan,
@@ -813,7 +834,7 @@ write_wireless_setting (NMConnection *connection,
 	gsize ssid_len;
 	const char *mode; //, *bssid;
 	const char *device_mac, *cloned_mac;
-	guint32 mtu, i; //, chan;
+	guint32 mtu, i, wowlan; //, chan;
 	gboolean adhoc = FALSE, hex_ssid = FALSE;
 	//const char *const*macaddr_blacklist;
 	GString *essid;
@@ -859,6 +880,16 @@ write_wireless_setting (NMConnection *connection,
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 				        "      mtu: %d\n", mtu);
 
+	wowlan = nm_setting_wireless_get_wake_on_wlan (s_wireless);
+	if (wowlan != NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT) {
+		gchar *tmp = wowlan_flags_str(wowlan, error);
+		if (!tmp)
+			return FALSE;
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "      wakeonwlan: [%s]\n", tmp);
+		g_free (tmp);
+	}
+
 	ssid = nm_setting_wireless_get_ssid (s_wireless);
 	if (!ssid) {
 		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 6e6750cd5824ecd59ef3337dbdbd0a84882180b8..c678ed9a577adaf5f3cb801ca856415ec9926e8a 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -599,6 +599,84 @@ test_read_write_wired_dhcp_send_hostname (void)
 	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
 }
 
+static void
+test_wifi_wowlan_mac_randomization (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "wowlan-macrandom",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
+	              NULL);
+
+	/* Wireless setting */
+	s_wireless = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wireless));
+	ssid = g_bytes_new ("open-net", 8);
+	g_object_set (s_wireless,
+	              //NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, NM_SETTING_MAC_RANDOMIZATION_ALWAYS, // TODO: needs to be implemented in netplan
+	              NM_SETTING_WIRELESS_MODE, NM_SETTING_WIRELESS_MODE_INFRA,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+				  NM_SETTING_WIRELESS_WAKE_ON_WLAN, NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL,
+	              NULL);
+
+	// TODO: test/implement non-encrypted open network
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, "passw0rd",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	/* Verify WoWLan & MAC address randomization */
+	s_wireless = nm_connection_get_setting_wireless (reread);
+	_log_keyfile(reread);
+	g_assert_true (s_wireless);
+	g_assert_true (nm_setting_wireless_get_wake_on_wlan (s_wireless) == NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL);
+	//g_assert_true (nm_setting_wireless_get_mac_address_randomization (s_wireless) == NM_SETTING_MAC_RANDOMIZATION_ALWAYS);
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+}
+
 static void
 test_write_modem_gsm_auto_eui64 (void)
 {
@@ -954,6 +1032,8 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
+	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
+
 	g_test_add_func (TPATH "modem/write/gsm-auto-eui64", test_write_modem_gsm_auto_eui64);
 	g_test_add_func (TPATH "modem/write/gsm", test_write_modem_gsm);
 	g_test_add_func (TPATH "modem/write/cdma", test_write_modem_cdma);
-- 
2.25.1


From dd64afc1c1216661a786b1f578770d9e6f7cb9e4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 17 Apr 2020 14:26:00 +0200
Subject: [PATCH 31/78] netplan: disable WEP wireless security handling

netplan currently supports only: none, psk, eap and 802.1x
---
 src/settings/plugins/netplan/nms-netplan-reader.c |  8 +++++++-
 src/settings/plugins/netplan/tests/test-netplan.c | 10 ----------
 2 files changed, 7 insertions(+), 11 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 436a61de4f574d265d60bd09a50a595f6a2ae786..15d5918fc7841f62e06b46729b985cb0c5bc2d66 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1446,6 +1446,7 @@ read_wep_keys (NetplanNetDefinition *nd,
 }
 #endif
 
+#if 0 /* TODO: Implement WEP in netplan */
 static NMSetting *
 make_wep_setting (NetplanNetDefinition *nd,
                   const char *file,
@@ -1479,6 +1480,7 @@ make_wep_setting (NetplanNetDefinition *nd,
 
 	return NM_SETTING (g_steal_pointer (&s_wsec));
 }
+#endif
 
 static gboolean
 fill_wpa_ciphers (NetplanNetDefinition *nd,
@@ -1742,19 +1744,23 @@ make_wireless_security_setting (NetplanNetDefinition *nd,
 	}
 #endif
 
+	/* Handle key-management = 'psk', 'eap' or '802.1x' */
 	wsec = make_wpa_setting (nd, file, ssid, adhoc, s_8021x, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
 		return NULL;
 
+	/* XXX: WEP is not supported with netplan.
+	 *   Only 'none', 'psk', 'eap' and '802.1x' as handled by make_wpa_setting().
 	wsec = make_wep_setting (nd, file, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
 		return NULL;
+	*/
 
-	return NULL; /* unencrypted */
+	return NULL; /* unencrypted, open network */
 }
 
 static NMSetting *
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index c678ed9a577adaf5f3cb801ca856415ec9926e8a..168432bdf51314dce9b2c5c77fac5f75befeb7d3 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -607,7 +607,6 @@ test_wifi_wowlan_mac_randomization (void)
 	gs_unref_object NMConnection *reread = NULL;
 	NMSettingConnection *s_con;
 	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wsec;
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 	GBytes *ssid;
@@ -636,14 +635,6 @@ test_wifi_wowlan_mac_randomization (void)
 				  NM_SETTING_WIRELESS_WAKE_ON_WLAN, NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL,
 	              NULL);
 
-	// TODO: test/implement non-encrypted open network
-	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
-	g_object_set (s_wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
-	              NM_SETTING_WIRELESS_SECURITY_PSK, "passw0rd",
-	              NULL);
-
 	/* IP4 setting */
 	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
@@ -668,7 +659,6 @@ test_wifi_wowlan_mac_randomization (void)
 
 	/* Verify WoWLan & MAC address randomization */
 	s_wireless = nm_connection_get_setting_wireless (reread);
-	_log_keyfile(reread);
 	g_assert_true (s_wireless);
 	g_assert_true (nm_setting_wireless_get_wake_on_wlan (s_wireless) == NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL);
 	//g_assert_true (nm_setting_wireless_get_mac_address_randomization (s_wireless) == NM_SETTING_MAC_RANDOMIZATION_ALWAYS);
-- 
2.25.1


From 4dcfb8de755920b133ec61c3463ee8f6124da0e6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 17 Apr 2020 16:19:22 +0200
Subject: [PATCH 32/78] netplan: add wifi band

---
 .../plugins/netplan/nms-netplan-reader.c      | 16 +++-
 .../plugins/netplan/nms-netplan-writer.c      | 20 +++-
 .../plugins/netplan/tests/test-netplan.c      | 93 ++++++++++++++++++-
 .../netplan/tests/yaml/wifi-band-a.yaml       | 16 ++++
 4 files changed, 141 insertions(+), 4 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 15d5918fc7841f62e06b46729b985cb0c5bc2d66..9490b36e9938ab07581eafae5e4de181215071ae 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1799,7 +1799,7 @@ make_wireless_setting (NetplanNetDefinition *nd,
 		gsize ssid_len = 0;
 		gsize value_len = strlen (ap->ssid);
 		//char *lcase;
-		const char *mode = NULL;
+		const char *mode, *band = NULL;
 
 		if (   value_len > 2
 		    && (value_len % 2) == 0
@@ -1837,7 +1837,19 @@ make_wireless_setting (NetplanNetDefinition *nd,
 
 		/* TODO: Handle BSSID ("MAC" for picking a specific AP) */
 		/* TODO: Handle wireless channel (needs netplan work) */
-		/* TODO: Handle wireless band (needs netplan work) */
+		if (ap->band == NETPLAN_WIFI_BAND_DEFAULT)
+			band = NULL;
+		else if (ap->band == NETPLAN_WIFI_BAND_5)
+			band = "a";
+		else if (ap->band == NETPLAN_WIFI_BAND_24)
+			band = "bg";
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			             "Invalid band '%d' (not '5GHz' or '2.4GHz')",
+			             ap->band);
+			goto error;
+		}
+		g_object_set (s_wireless, NM_SETTING_WIRELESS_BAND, band, NULL);
 	}
 
 	if (nd->mtubytes > 0)
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 06fcda2858e124373496a171cf424b34161eb3dc..872fd6d69a33330062996f7eb12c514cce761264 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -832,7 +832,7 @@ write_wireless_setting (NMConnection *connection,
 	GBytes *ssid;
 	const guint8 *ssid_data;
 	gsize ssid_len;
-	const char *mode; //, *bssid;
+	const char *mode, *band; //, *bssid;
 	const char *device_mac, *cloned_mac;
 	guint32 mtu, i, wowlan; //, chan;
 	gboolean adhoc = FALSE, hex_ssid = FALSE;
@@ -946,6 +946,7 @@ write_wireless_setting (NMConnection *connection,
 			        "        %s:\n", essid->str);
 	g_string_free(essid, TRUE);
 
+	/* Write WiFi mode */
 	mode = nm_setting_wireless_get_mode (s_wireless);
 	if (nm_streq (mode, NM_SETTING_WIRELESS_MODE_INFRA))
 		g_output_stream_printf (netplan, 0, NULL, NULL,
@@ -964,6 +965,23 @@ write_wireless_setting (NMConnection *connection,
 		return FALSE;
 	}
 
+	/* Write WiFi band, if set. */
+	band = nm_setting_wireless_get_band (s_wireless);
+	if (nm_str_not_empty (band)) {
+		if (nm_streq (band, "a"))
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "          band: 5GHz\n");
+		else if (nm_streq (band, "bg"))
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "          band: 2.4GHz\n");
+		else {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			            "Invalid band '%s' in '%s' setting",
+			             band, NM_SETTING_WIRELESS_SETTING_NAME);
+			return FALSE;
+		}
+	}
+
 #if 0 // TODO: implement channel, band, bssid selection in netplan
 	svUnsetValue (netplan, "CHANNEL");
 	svUnsetValue (netplan, "BAND");
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 168432bdf51314dce9b2c5c77fac5f75befeb7d3..9bbc2bbb15d8dfea3c4c84f2f28264e375f0139d 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -103,7 +103,7 @@ _connection_from_file (const char *filename,
 	g_assert (!out_unhandled || !*out_unhandled);
 
 	/* Clear netdefs before reading new data from file */
-	_clear_all_netdefs();
+	_clear_all_netdefs ();
 	connection = nmtst_connection_from_file (filename, network_file, test_type,
 	                                         out_unhandled ?: &unhandled_fallback, &error);
 	g_assert_no_error (error);
@@ -599,6 +599,95 @@ test_read_write_wired_dhcp_send_hostname (void)
 	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
 }
 
+static void
+test_write_wifi_band_a (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Band A",
+	              NM_SETTING_CONNECTION_UUID, "eda52185-2feb-41d7-a34d-cf7ad470a590",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_BAND, "a",
+	              NULL);
+	g_bytes_unref (ssid);
+
+	nmtst_assert_connection_verifies (connection);
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR,
+	                        TEST_NETPLAN_DIR"/wifi-band-a.yaml",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_band_bg (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	GBytes *ssid;
+	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Band BG",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+	ssid = g_bytes_new (ssid_data, sizeof (ssid_data));
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_BAND, "bg",
+	              NULL);
+	g_bytes_unref (ssid);
+
+	nmtst_assert_connection_verifies (connection);
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_wifi_wowlan_mac_randomization (void)
 {
@@ -1022,6 +1111,8 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 
+	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
+	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
 
 	g_test_add_func (TPATH "modem/write/gsm-auto-eui64", test_write_modem_gsm_auto_eui64);
diff --git a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..09b095cad5274419373cfa5581f92e869b2a3b8a
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
@@ -0,0 +1,16 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  wifis:
+    wlan0:
+      access-points:
+        Test SSID:
+          mode: infrastructure
+          band: 5GHz
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write Wi-Fi Band A
+        uuid: eda52185-2feb-41d7-a34d-cf7ad470a590
+        device: wlan0
-- 
2.25.1


From 48b17b109de8715ffeca7a479af8bc74fb572e98 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 17 Apr 2020 16:34:11 +0200
Subject: [PATCH 33/78] netplan: implement wifi channel

---
 .../plugins/netplan/nms-netplan-reader.c      | 13 +++++++++----
 .../plugins/netplan/nms-netplan-writer.c      | 19 ++++++++-----------
 .../plugins/netplan/tests/test-netplan.c      |  2 ++
 .../netplan/tests/yaml/wifi-band-a.yaml       |  1 +
 4 files changed, 20 insertions(+), 15 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 9490b36e9938ab07581eafae5e4de181215071ae..23f4d202e349ff5ec271151ab930e8bbde7a739b 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1836,14 +1836,19 @@ make_wireless_setting (NetplanNetDefinition *nd,
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, mode, NULL);
 
 		/* TODO: Handle BSSID ("MAC" for picking a specific AP) */
-		/* TODO: Handle wireless channel (needs netplan work) */
 		if (ap->band == NETPLAN_WIFI_BAND_DEFAULT)
 			band = NULL;
-		else if (ap->band == NETPLAN_WIFI_BAND_5)
+		else if (ap->band == NETPLAN_WIFI_BAND_5) {
 			band = "a";
-		else if (ap->band == NETPLAN_WIFI_BAND_24)
+			/* Set channel for selected band, if set */
+			if (ap->channel)
+				g_object_set (s_wireless, NM_SETTING_WIRELESS_CHANNEL, ap->channel, NULL);
+		} else if (ap->band == NETPLAN_WIFI_BAND_24) {
 			band = "bg";
-		else {
+			/* Set channel for selected band, if set */
+			if (ap->channel)
+				g_object_set (s_wireless, NM_SETTING_WIRELESS_CHANNEL, ap->channel, NULL);
+		} else {
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
 			             "Invalid band '%d' (not '5GHz' or '2.4GHz')",
 			             ap->band);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 872fd6d69a33330062996f7eb12c514cce761264..deb19b5abd6bc3a279bae8d99d9208a46133e183 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -834,7 +834,7 @@ write_wireless_setting (NMConnection *connection,
 	gsize ssid_len;
 	const char *mode, *band; //, *bssid;
 	const char *device_mac, *cloned_mac;
-	guint32 mtu, i, wowlan; //, chan;
+	guint32 mtu, i, wowlan, chan;
 	gboolean adhoc = FALSE, hex_ssid = FALSE;
 	//const char *const*macaddr_blacklist;
 	GString *essid;
@@ -980,19 +980,16 @@ write_wireless_setting (NMConnection *connection,
 			             band, NM_SETTING_WIRELESS_SETTING_NAME);
 			return FALSE;
 		}
-	}
 
-#if 0 // TODO: implement channel, band, bssid selection in netplan
-	svUnsetValue (netplan, "CHANNEL");
-	svUnsetValue (netplan, "BAND");
-	chan = nm_setting_wireless_get_channel (s_wireless);
-	if (chan) {
-		svSetValueInt64 (netplan, "CHANNEL", chan);
-	} else {
-		/* Band only set if channel is not, since channel implies band */
-		svSetValueStr (netplan, "BAND", nm_setting_wireless_get_band (s_wireless));
+		/* Write channel. Can only be set if band is known. */
+		chan = nm_setting_wireless_get_channel (s_wireless);
+		if (chan) {
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "          channel: %u\n", chan);
+		}
 	}
 
+#if 0 // TODO: implement bssid selection in netplan
 	bssid = nm_setting_wireless_get_bssid (s_wireless);
 	svSetValueStr (netplan, "BSSID", bssid);
 #endif
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 9bbc2bbb15d8dfea3c4c84f2f28264e375f0139d..08f6070efc3fad6132cd9e53272eb98ecf433153 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -631,6 +631,7 @@ test_write_wifi_band_a (void)
 	              NM_SETTING_WIRELESS_SSID, ssid,
 	              NM_SETTING_WIRELESS_MODE, "infrastructure",
 	              NM_SETTING_WIRELESS_BAND, "a",
+	              NM_SETTING_WIRELESS_CHANNEL, 7,
 	              NULL);
 	g_bytes_unref (ssid);
 
@@ -676,6 +677,7 @@ test_write_wifi_band_bg (void)
 	              NM_SETTING_WIRELESS_SSID, ssid,
 	              NM_SETTING_WIRELESS_MODE, "infrastructure",
 	              NM_SETTING_WIRELESS_BAND, "bg",
+	              NM_SETTING_WIRELESS_CHANNEL, 11,
 	              NULL);
 	g_bytes_unref (ssid);
 
diff --git a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
index 09b095cad5274419373cfa5581f92e869b2a3b8a..1c96fffcb51d64253a5370df4aa331252ff558b7 100644
--- a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
@@ -7,6 +7,7 @@ network:
         Test SSID:
           mode: infrastructure
           band: 5GHz
+          channel: 7
       dhcp4: yes
       dhcp6: yes
       ipv6-address-generation: stable-privacy
-- 
2.25.1


From 798079e9463b2905c40a9240a241fd47882c92de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 17 Apr 2020 16:47:08 +0200
Subject: [PATCH 34/78] netplan: implement wifi bssid

---
 src/settings/plugins/netplan/nms-netplan-reader.c      |  7 ++++++-
 src/settings/plugins/netplan/nms-netplan-writer.c      | 10 ++++++----
 src/settings/plugins/netplan/tests/test-netplan.c      |  1 +
 .../plugins/netplan/tests/yaml/wifi-band-a.yaml        |  1 +
 4 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 23f4d202e349ff5ec271151ab930e8bbde7a739b..1f8d641ad903dd54e0b0ad8aa31edca3157e5c18 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1821,6 +1821,7 @@ make_wireless_setting (NetplanNetDefinition *nd,
 
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, bytes, NULL);
 
+		/* Read WiFi mode */
 		if (ap->mode == NETPLAN_WIFI_MODE_INFRASTRUCTURE) {
 			mode = "infrastructure";
 		} else if (ap->mode == NETPLAN_WIFI_MODE_ADHOC) {
@@ -1835,7 +1836,11 @@ make_wireless_setting (NetplanNetDefinition *nd,
 		}
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, mode, NULL);
 
-		/* TODO: Handle BSSID ("MAC" for picking a specific AP) */
+		/* Read BSSID ("MAC" for picking a specific AP) */
+		if (ap->bssid)
+			g_object_set (s_wireless, NM_SETTING_WIRELESS_BSSID, ap->bssid, NULL);
+
+		/* Read WiFi band and corresponding channel */
 		if (ap->band == NETPLAN_WIFI_BAND_DEFAULT)
 			band = NULL;
 		else if (ap->band == NETPLAN_WIFI_BAND_5) {
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index deb19b5abd6bc3a279bae8d99d9208a46133e183..f58a089033268dec5ba457eb9549e277e3f24e8c 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -832,7 +832,7 @@ write_wireless_setting (NMConnection *connection,
 	GBytes *ssid;
 	const guint8 *ssid_data;
 	gsize ssid_len;
-	const char *mode, *band; //, *bssid;
+	const char *mode, *band, *bssid;
 	const char *device_mac, *cloned_mac;
 	guint32 mtu, i, wowlan, chan;
 	gboolean adhoc = FALSE, hex_ssid = FALSE;
@@ -989,10 +989,12 @@ write_wireless_setting (NMConnection *connection,
 		}
 	}
 
-#if 0 // TODO: implement bssid selection in netplan
+	/* Write BSSID, if set. */
 	bssid = nm_setting_wireless_get_bssid (s_wireless);
-	svSetValueStr (netplan, "BSSID", bssid);
-#endif
+	if (nm_str_not_empty (bssid)) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "          bssid: %s\n", bssid);
+	}
 
 	if (nm_connection_get_setting_wireless_security (connection)) {
 		if (!write_wireless_security_setting (connection, netplan, NULL, adhoc, error))
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 08f6070efc3fad6132cd9e53272eb98ecf433153..fd39bee6fa6cc5af25b7a02fffda98126ee59043 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -632,6 +632,7 @@ test_write_wifi_band_a (void)
 	              NM_SETTING_WIRELESS_MODE, "infrastructure",
 	              NM_SETTING_WIRELESS_BAND, "a",
 	              NM_SETTING_WIRELESS_CHANNEL, 7,
+	              NM_SETTING_WIRELESS_BSSID, "de:ad:be:ef:ca:fe",
 	              NULL);
 	g_bytes_unref (ssid);
 
diff --git a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
index 1c96fffcb51d64253a5370df4aa331252ff558b7..9574d388ada7a0fd5b0c9d0a77d3b7c91ae67bdd 100644
--- a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
@@ -8,6 +8,7 @@ network:
           mode: infrastructure
           band: 5GHz
           channel: 7
+          bssid: de:ad:be:ef:ca:fe
       dhcp4: yes
       dhcp6: yes
       ipv6-address-generation: stable-privacy
-- 
2.25.1


From b971fa0513eba4335904e353f517ef87c858a6bf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 20 Apr 2020 14:02:47 +0200
Subject: [PATCH 35/78] netplan: handle unkonwn ifname

---
 .../plugins/netplan/nms-netplan-reader.c      |  5 ++-
 .../plugins/netplan/nms-netplan-writer.c      | 42 ++++++++++---------
 .../plugins/netplan/tests/test-netplan.c      |  4 --
 .../netplan/tests/yaml/wifi-band-a.yaml       |  3 +-
 4 files changed, 26 insertions(+), 28 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 1f8d641ad903dd54e0b0ad8aa31edca3157e5c18..e8de2db2bd286b7fdb980cc71ef23bb79e5c2388 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -272,8 +272,9 @@ make_connection_setting (const char *file,
 	              NULL);
 
 	/* Get iface/device name from NM backend settings. If missing, fall back to netdef ID. */
-	v = nd->backend_settings.nm.device ? nd->backend_settings.nm.device : nd->id;
-	g_assert_nonnull (nm_str_not_empty(v));
+	v = nd->backend_settings.nm.device;
+	if (!v && nm_utils_is_valid_iface_name (nd->id, NULL))
+		v = nd->id;
 	if (v) {
 		GError *error = NULL;
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index f58a089033268dec5ba457eb9549e277e3f24e8c..263745e2d632c47aa6ff17e6d923b88aa400e90d 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1925,8 +1925,10 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 		                        "        stable-id: %s\n", tmp);
 	
 	// TODO: MOVE to header to identify the device / connection it is under
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        device: %s\n", nm_setting_connection_get_interface_name (s_con));
+	tmp = nm_setting_connection_get_interface_name (s_con);
+	if (tmp)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "        device: %s\n", tmp);
 
 	// TODO: hook up autoconnect ???
 	//g_output_stream_printf (netplan, "ONBOOT", nm_setting_connection_get_autoconnect (s_con));
@@ -2884,7 +2886,8 @@ do_write_construct (NMConnection *connection,
 	NMSettingConnection *s_con;
 	//NMSettingIPConfig *s_ip4;
 	//NMSettingIPConfig *s_ip6;
-	const gchar *type = NULL;
+	const gchar *type = NULL, *id = NULL;
+	GString *id_str = NULL;
 	GArray *addresses, *nameservers, *searches;
 	GHashTable *dhcp4_overrides, *dhcp6_overrides;
 
@@ -2912,7 +2915,14 @@ do_write_construct (NMConnection *connection,
 	g_output_stream_printf (netplan, 0, NULL, NULL,
 			        "network:\n  version: 2\n  renderer: NetworkManager\n");
 
-	// XXX: How to handle unknown iface name in netplan?
+	id = nm_connection_get_interface_name (connection);
+	/* Fallback to "NM-<UUID>" based naming, if ifname is not set. */
+	if (!nm_str_not_empty (id)) {
+		id_str = g_string_new (nm_connection_get_uuid (connection));
+		id_str = g_string_prepend(id_str, "NM-");
+		id = g_string_free(id_str, FALSE);
+	}
+
 	if (!strcmp (type, NM_SETTING_WIRED_SETTING_NAME)) {
 		// TODO: Implement PPPoE support.
 		if (nm_connection_get_setting_pppoe (connection)) {
@@ -2923,54 +2933,46 @@ do_write_construct (NMConnection *connection,
 		}
 
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  ethernets:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  ethernets:\n    %s:\n", id);
 		if (!write_wired_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_VLAN_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  vlans:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  vlans:\n    %s:\n", id);
 		if (!write_vlan_setting (connection, netplan, error))
 			return FALSE;
 	} else if (NM_IN_STRSET (type, NM_SETTING_GSM_SETTING_NAME, NM_SETTING_CDMA_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  modems:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  modems:\n    %s:\n", id);
 		if (!write_modem_setting (connection, netplan, error, type))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  wifis:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  wifis:\n    %s:\n", id);
 		if (!write_wireless_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_INFINIBAND_SETTING_NAME)) {
 #if 0
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  ethernets:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  ethernets:\n    %s:\n", id);
 		if (!write_infiniband_setting (connection, netplan, error))
 #endif
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_BOND_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  bonds:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  bonds:\n    %s:\n", id);
 		if (!write_bond_setting (connection, netplan, error))
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_TEAM_SETTING_NAME)) {
 #if 0
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  ethernets:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  ethernets:\n    %s:\n", id);
 		if (!write_team_setting (connection, netplan, error))
 #endif
 			return FALSE;
 	} else if (!strcmp (type, NM_SETTING_BRIDGE_SETTING_NAME)) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "  bridges:\n    %s:\n",
-		                        nm_connection_get_interface_name (connection));
+		                        "  bridges:\n    %s:\n", id);
 		if (!write_bridge_setting (connection, netplan, error))
 			return FALSE;
 	} else {
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index fd39bee6fa6cc5af25b7a02fffda98126ee59043..40b4b717f0b126b0d52ef166fb194c8197894d15 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -620,7 +620,6 @@ test_write_wifi_band_a (void)
 	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Band A",
 	              NM_SETTING_CONNECTION_UUID, "eda52185-2feb-41d7-a34d-cf7ad470a590",
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
 	              NULL);
 
 	/* Wifi setting */
@@ -667,7 +666,6 @@ test_write_wifi_band_bg (void)
 	              NM_SETTING_CONNECTION_ID, "Test Write Wi-Fi Band BG",
 	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
 	              NULL);
 
 	/* Wifi setting */
@@ -713,7 +711,6 @@ test_wifi_wowlan_mac_randomization (void)
 	              NM_SETTING_CONNECTION_ID, "wowlan-macrandom",
 	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
 	              NULL);
 
 	/* Wireless setting */
@@ -969,7 +966,6 @@ test_example_field_wifi (void)
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
 	              //NM_SETTING_CONNECTION_PERMISSIONS, "",
 	              //NM_SETTING_CONNECTION_SECONDARIES, "",
-	              NM_SETTING_CONNECTION_INTERFACE_NAME, "wlan0", // XXX: how to handle unknown iface in netplan?
 	              NULL);
 
 	/* Wireless setting */
diff --git a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
index 9574d388ada7a0fd5b0c9d0a77d3b7c91ae67bdd..53ae75f1f20b1ab1eb3b0296ccd67e4844896477 100644
--- a/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/wifi-band-a.yaml
@@ -2,7 +2,7 @@ network:
   version: 2
   renderer: NetworkManager
   wifis:
-    wlan0:
+    NM-eda52185-2feb-41d7-a34d-cf7ad470a590:
       access-points:
         Test SSID:
           mode: infrastructure
@@ -15,4 +15,3 @@ network:
       networkmanager:
         name: Test Write Wi-Fi Band A
         uuid: eda52185-2feb-41d7-a34d-cf7ad470a590
-        device: wlan0
-- 
2.25.1


From 2761532bec269fda41cbf599b6ece9704a4df215 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 20 Apr 2020 16:57:20 +0200
Subject: [PATCH 36/78] netplan: basic IP4 routes

---
 .../plugins/netplan/nms-netplan-reader.c      |  19 +++
 .../plugins/netplan/nms-netplan-writer.c      |  18 ++-
 .../plugins/netplan/tests/test-netplan.c      | 125 ++++++++++++++++++
 3 files changed, 155 insertions(+), 7 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index e8de2db2bd286b7fdb980cc71ef23bb79e5c2388..8c1a9d5935c13c7df1f2a5ed7086bfdfc718ff4b 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -710,6 +710,7 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	gs_free char *gateway = NULL;
 	GError *local = NULL;
 	char *method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+	NMIPRoute *route = NULL;
 
 	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
 
@@ -934,7 +935,25 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
 	              priority,
 	              NULL);
+#endif
+
+	if (nd->routes != NULL) {
+		for (unsigned i = 0; i < nd->routes->len; ++i) {
+			NetplanIPRoute *r = g_array_index(nd->routes, NetplanIPRoute*, i);
+			if (r->family != AF_INET)
+				continue;
+			gchar** ipmask = g_strsplit (r->to, "/", 2);
+			route = nm_ip_route_new (r->family, ipmask[0], atoi(ipmask[1]), r->via, r->metric, &local);
+			// TODO: implement route attributes
+			//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
+			//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean(r.onlink));
+			g_assert_no_error (local);
+			nm_setting_ip_config_add_route (s_ip4, route);
+			nm_ip_route_unref (route);
+		}
+	}
 
+#if 0
 	/* Static routes  - route-<name> file */
 	route_path = utils_get_route_path (svFileGetName (netplan));
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 263745e2d632c47aa6ff17e6d923b88aa400e90d..37c39b8ea325c8650a9c218f4b364803e40634ed 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2110,7 +2110,6 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 #endif
 }
 
-#if 0 /* goes with routes!!! */
 static char *
 get_route_attributes_string (NMIPRoute *route, int family)
 {
@@ -2180,9 +2179,7 @@ get_route_attributes_string (NMIPRoute *route, int family)
 
 	return g_string_free (str, FALSE);
 }
-#endif
 
-#if 0 /* temp disable : routes: */
 static GString *
 write_route_settings (NMSettingIPConfig *s_ip)
 {
@@ -2209,13 +2206,13 @@ write_route_settings (NMSettingIPConfig *s_ip)
 		metric = nm_ip_route_get_metric (route);
 		options = get_route_attributes_string (route, addr_family);
 
-		g_string_append_printf (contents, "      - to: %s/%u\n",
+		g_string_append_printf (contents, "        - to: %s/%u\n",
 		                        nm_ip_route_get_dest (route),
 		                        nm_ip_route_get_prefix (route));
 		if (next_hop)
-			g_string_append_printf (contents, "        via: %s\n", next_hop);
+			g_string_append_printf (contents, "          via: %s\n", next_hop);
 		if (metric >= 0)
-			g_string_append_printf (contents, "        metric: %u\n", (guint) metric);
+			g_string_append_printf (contents, "          metric: %u\n", (guint) metric);
 #if 0  // TODO: implementing route options
 		if (options) {
 			g_string_append_c (contents, ' ');
@@ -2226,7 +2223,6 @@ write_route_settings (NMSettingIPConfig *s_ip)
 
 	return contents;
 }
-#endif
 
 #if 0  // TODO: implement proxy support.
 static gboolean
@@ -2587,6 +2583,14 @@ write_ip4_setting (NMConnection *connection,
 	                      timeout);
 #endif
 
+	// TODO: write combined IP4/IP6 routes, by storing them in a hashtable before
+	GString *route_str = write_route_settings (s_ip4);
+	if (route_str) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+	                        "      routes:\n%s", route_str->str);
+		g_string_free (route_str, TRUE);
+	}
+
 #if 0  // TODO: Implement route settings here for ipv4
 	svSetValueBoolean (netplan, "IPV4_FAILURE_FATAL", !nm_setting_ip_config_get_may_fail (s_ip4));
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 40b4b717f0b126b0d52ef166fb194c8197894d15..f0b36635294e9a93181b7ad4c4cd46c95c4f9556 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -555,6 +555,130 @@ test_write_wired_static (void)
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
 
+static void
+test_write_wired_static_routes (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *routefile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMIPAddress *addr;
+	NMIPRoute *route;
+	GError *error = NULL;
+	gboolean reread_same = FALSE;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static Routes",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, "31:33:33:37:be:cd",
+	              NM_SETTING_WIRED_MTU, (guint32) 1492,
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              // TODO: implement NM_SETTING_IP4_CONFIG_METHOD_IGNORE
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              //NM_SETTING_IP_CONFIG_DAD_TIMEOUT, 400,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.5", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* Write out routes */
+	route = nm_ip_route_new (AF_INET, "1.2.3.0", 24, "222.173.190.239", 0, &error);
+	/* XXX: Needs to be implemented in netplan */
+	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
+	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (TRUE));
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip4, route);
+	nm_ip_route_unref (route);
+
+	route = nm_ip_route_new (AF_INET, "3.2.1.0", 24, "202.254.186.190", 77, &error);
+	/* XXX: Needs to be implemented in netplan */
+	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (30000));
+	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip4, route);
+	nm_ip_route_unref (route);
+
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.1");
+	nm_setting_ip_config_add_dns (s_ip4, "4.2.2.2");
+
+	nm_setting_ip_config_add_dns_search (s_ip4, "foobar.com");
+	nm_setting_ip_config_add_dns_search (s_ip4, "lab.foobar.com");
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+	/* XXX: improve test
+	_writer_new_connection_reread (connection,
+	                               TEST_SCRATCH_DIR,
+	                               &testfile,
+	                               NULL,//TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Static_Routes.cexpected",
+	                               &reread,
+	                               &reread_same);
+								   */
+	/* ifcfg does not support setting onlink=0. It gets lost during write+re-read.
+	 * Assert that it's missing, and patch it to check whether the rest of the
+	 * connection equals. */
+	/*
+	g_assert (!reread_same);
+	nmtst_assert_connection_verifies_without_normalization (reread);
+	s_ip4 = nm_connection_get_setting_ip4_config (reread);
+	g_assert (s_ip4);
+	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 2);
+	route = nm_setting_ip_config_get_route (s_ip4, 1);
+	g_assert (route);
+	g_assert (!nm_ip_route_get_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK));
+	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
+	*/
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	//routefile = utils_get_route_path (testfile);
+}
+
+
 static void
 test_read_write_wired_dhcp_send_hostname (void)
 {
@@ -1109,6 +1233,7 @@ int main (int argc, char **argv)
 
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
+	g_test_add_func (TPATH "wired/write/routes", test_write_wired_static_routes);
 
 	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
-- 
2.25.1


From a4fa025af47b6bf7ee13a1a99537d35a154c323d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 20 Apr 2020 17:05:28 +0200
Subject: [PATCH 37/78] netplan: fix ip6 'disabled' method

---
 src/settings/plugins/netplan/nms-netplan-reader.c        | 9 +++++++++
 src/settings/plugins/netplan/tests/test-netplan.c        | 7 ++-----
 src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml  | 6 +++++-
 .../plugins/netplan/tests/yaml/wired-default.yaml        | 6 ------
 4 files changed, 16 insertions(+), 12 deletions(-)
 delete mode 100644 src/settings/plugins/netplan/tests/yaml/wired-default.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 8c1a9d5935c13c7df1f2a5ed7086bfdfc718ff4b..77bd9cffae40b6801c3f15f7b3cbd69092172a2e 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1155,6 +1155,15 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		route_table = 0;
 	}
 #endif  /* ipv6 methods and settings */
+
+	/* Skip if we have neither static nor dynamic IP6 config */
+	if (!nd->ip6_addresses && !nd->dhcp6) {
+		g_object_set (s_ip6,
+		              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+		              NULL);
+		return NM_SETTING (g_steal_pointer (&s_ip6));
+	}
+
 	if (nd->ip6_addresses)
 		method = NM_SETTING_IP6_CONFIG_METHOD_MANUAL;
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index f0b36635294e9a93181b7ad4c4cd46c95c4f9556..fcc4f9923c3376a10de139a5539fe3cfba989f13 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -307,10 +307,8 @@ test_read_basic_dhcp (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	// XXX: is wired-default.yaml still needed?
 	connection = _connection_from_file (TEST_NETPLAN_DIR"/basic-dhcp.yaml",
-	                                    TEST_NETPLAN_DIR"/wired-default.yaml",
-										NULL, NULL);
+	                                    NULL, NULL, NULL);
 
 	/* ===== CONNECTION SETTING ===== */
 	s_con = nm_connection_get_setting_connection (connection);
@@ -599,7 +597,6 @@ test_write_wired_static_routes (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
 
 	g_object_set (s_ip4,
-	              // TODO: implement NM_SETTING_IP4_CONFIG_METHOD_IGNORE
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
 	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
 	              //NM_SETTING_IP_CONFIG_DAD_TIMEOUT, 400,
@@ -643,7 +640,7 @@ test_write_wired_static_routes (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
 
 	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
 	              NULL);
 
 	nmtst_assert_connection_verifies (connection);
diff --git a/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml b/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml
index 1d2a7f8a4b5796f0ea0c2f47f7af7ecfd44aa7da..0972e6e74378924c6daa13fa36b226467736206f 100644
--- a/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/basic-dhcp.yaml
@@ -1,3 +1,7 @@
 network:
   version: 2
-  renderer: NetworkManager
\ No newline at end of file
+  renderer: NetworkManager
+  ethernets:
+    wired-default:
+      dhcp4: true
+      dhcp6: true
diff --git a/src/settings/plugins/netplan/tests/yaml/wired-default.yaml b/src/settings/plugins/netplan/tests/yaml/wired-default.yaml
deleted file mode 100644
index ee887ceb4f57fa0035fd9eb36229e38b94fe9e15..0000000000000000000000000000000000000000
--- a/src/settings/plugins/netplan/tests/yaml/wired-default.yaml
+++ /dev/null
@@ -1,6 +0,0 @@
-network:
-  version: 2
-  renderer: NetworkManager
-  ethernets:
-    wired-default:
-      renderer: NetworkManager
-- 
2.25.1


From 1c9a3d2061f67c7914929cc4be260745d45b82c5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 21 Apr 2020 09:07:59 +0200
Subject: [PATCH 38/78] netplan: basic IP6 routes

---
 .../plugins/netplan/nms-netplan-reader.c      | 106 +++++-------------
 .../plugins/netplan/nms-netplan-writer.c      |   9 ++
 .../plugins/netplan/tests/test-netplan.c      |  18 +++
 3 files changed, 54 insertions(+), 79 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 77bd9cffae40b6801c3f15f7b3cbd69092172a2e..940a9537432573ed0ae9d8e0abcf9e2fe2f66696 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -699,6 +699,27 @@ make_proxy_setting (NetplanNetDefinition *nd)
 }
 #endif  /* proxy support */
 
+static void
+make_routes (NetplanNetDefinition *nd, NMSettingIPConfig *s_ip, guint family)
+{
+	NMIPRoute *route = NULL;
+	GError *local = NULL;
+
+	for (unsigned i = 0; i < nd->routes->len; ++i) {
+		NetplanIPRoute *r = g_array_index(nd->routes, NetplanIPRoute*, i);
+		if (r->family != family)
+			continue;
+		gchar** ipmask = g_strsplit (r->to, "/", 2);
+		route = nm_ip_route_new (r->family, ipmask[0], atoi(ipmask[1]), r->via, r->metric, &local);
+		// TODO: implement route attributes
+		//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
+		//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean(r.onlink));
+		g_assert_no_error (local);
+		nm_setting_ip_config_add_route (s_ip, route);
+		nm_ip_route_unref (route);
+	}
+}
+
 static NMSetting *
 make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 {
@@ -710,7 +731,6 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	gs_free char *gateway = NULL;
 	GError *local = NULL;
 	char *method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
-	NMIPRoute *route = NULL;
 
 	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
 
@@ -928,7 +948,7 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	parse_dns_options (s_ip4, dns_options);
 #endif /* shared */
 
-#if 0  /* TODO: DNS priority, routes */
+#if 0  /* TODO: DNS priority */
 	/* DNS priority */
 	priority = svGetValueInt64 (netplan, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
 	g_object_set (s_ip4,
@@ -937,72 +957,10 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	              NULL);
 #endif
 
-	if (nd->routes != NULL) {
-		for (unsigned i = 0; i < nd->routes->len; ++i) {
-			NetplanIPRoute *r = g_array_index(nd->routes, NetplanIPRoute*, i);
-			if (r->family != AF_INET)
-				continue;
-			gchar** ipmask = g_strsplit (r->to, "/", 2);
-			route = nm_ip_route_new (r->family, ipmask[0], atoi(ipmask[1]), r->via, r->metric, &local);
-			// TODO: implement route attributes
-			//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
-			//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean(r.onlink));
-			g_assert_no_error (local);
-			nm_setting_ip_config_add_route (s_ip4, route);
-			nm_ip_route_unref (route);
-		}
-	}
-
-#if 0
-	/* Static routes  - route-<name> file */
-	route_path = utils_get_route_path (svFileGetName (netplan));
-
-	if (!routes_read) {
-		/* NOP */
-	} else if (utils_has_route_file_new_syntax (route_path)) {
-		/* Parse route file in new syntax */
-		route_netplan = utils_get_route_netplan (svFileGetName (netplan), FALSE);
-		if (route_netplan) {
-			for (i = 0;; i++) {
-				NMIPRoute *route = NULL;
-
-				if (!read_one_ip4_route (route_netplan, i, &route, error)) {
-					svCloseFile (route_netplan);
-					return NULL;
-				}
-
-				if (!route)
-					break;
-
-				if (!nm_setting_ip_config_add_route (s_ip4, route))
-					PARSE_WARNING ("duplicate IP4 route");
-				nm_ip_route_unref (route);
-			}
-			svCloseFile (route_netplan);
-		}
-	} else {
-		if (!read_route_file (AF_INET, route_path, s_ip4, error))
-			return NULL;
-	}
-
-	/* Legacy value NM used for a while but is incorrect (rh #459370) */
-	if (   !nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED)
-	    && !nm_setting_ip_config_get_num_dns_searches (s_ip4)) {
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "SEARCH", &value);
-		if (v) {
-			gs_free const char **searches = NULL;
-
-			searches = nm_utils_strsplit_set (v, " ");
-			if (searches) {
-				for (item = searches; *item; item++) {
-					if (!nm_setting_ip_config_add_dns_search (s_ip4, *item))
-						PARSE_WARNING ("duplicate DNS search '%s'", *item);
-				}
-			}
-		}
-	}
+	if (nd->routes)
+		make_routes(nd, s_ip4, AF_INET);
 
+#if 0 /* TODO: dad-timeout */
 	timeout = svGetValueInt64 (netplan, "ACD_TIMEOUT", 10, -1, NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX, -2);
 	if (timeout == -2) {
 		timeout = svGetValueInt64 (netplan, "ARPING_WAIT", 10, -1,
@@ -1327,18 +1285,8 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	}
 #endif
 
-#if 0  /* TODO: ipv6 routes */
-	if (!routes_read) {
-		/* NOP */
-	} else {
-		gs_free char *route6_path = NULL;
-
-		/* Read static routes from route6-<interface> file */
-		route6_path = utils_get_route6_path (svFileGetName (netplan));
-		if (!read_route_file (AF_INET6, route6_path, s_ip6, error))
-			return NULL;
-	}
-#endif  /* ipv6 routes */
+	if (nd->routes)
+		make_routes(nd, s_ip6, AF_INET6);
 
 #if 0  /* TODO: IPv6 DNS searches */
 	/* DNS searches */
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 37c39b8ea325c8650a9c218f4b364803e40634ed..7a3b22b3bc7c9e3fae54afbe0a9b57069e7af26f 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2783,6 +2783,15 @@ write_ip6_setting (NMConnection *connection,
 		                        "      metric: %ld\n", route_metric);
 #endif
 
+	// TODO: write combined IP4/IP6 routes, by storing them in a hashtable before
+	GString *route_str = write_route_settings (s_ip6);
+	if (route_str) {
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+	                        "      routes:\n%s", route_str->str);
+		g_string_free (route_str, TRUE);
+	}
+
+
 #if 0
     // TODO: Implement this route as a formal route (rather than gatewayN) to set route table
     // TODO: Implement RouteTable= (networkd)  for DHCP.
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index fcc4f9923c3376a10de139a5539fe3cfba989f13..a21a7b1058503023acf7c6a48711820a3f5aea59 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -532,6 +532,24 @@ test_write_wired_static (void)
 	nm_setting_ip_config_add_address (s_ip6, addr6);
 	nm_ip_address_unref (addr6);
 
+	/* Add routes */
+	route6 = nm_ip_route_new (AF_INET6,
+	                          "2222:aaaa:bbbb:cccc::", 64,
+	                          "2222:aaaa:bbbb:cccc:dddd:eeee:5555:6666", 99, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_route (s_ip6, route6);
+	nm_ip_route_unref (route6);
+
+	route6 = nm_ip_route_new (AF_INET6, "::", 128, "2222:aaaa::9999", 1, &error);
+	g_assert_no_error (error);
+	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_CWND, g_variant_new_uint32 (100));
+	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_MTU, g_variant_new_uint32 (1280));
+	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND, g_variant_new_boolean (TRUE));
+	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_FROM, g_variant_new_string ("2222::bbbb/32"));
+	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_SRC, g_variant_new_string ("::42"));
+	//nm_setting_ip_config_add_route (s_ip6, route6);
+	nm_ip_route_unref (route6);
+
 	/* DNS servers */
 	nm_setting_ip_config_add_dns (s_ip6, "fade:0102:0103::face");
 	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
-- 
2.25.1


From 5342126e2a20c8f2c3b2c4d82c37bad1960ef17b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 21 Apr 2020 10:19:42 +0200
Subject: [PATCH 39/78] netplan: combine IP4 & IP6 routes writing

The routes are saved in an array of hashTables.
Each array element contains one route, with its
corresponding key/value pairs as strings, e.g.:

Arr[0]:
        to: 0.0.0.0/0
        via: 10.0.0.1
        metric: 100
Arr[1]:
        to: 0.0.0.0/0
        via: 11.0.0.1
        metric: 100
---
 .../plugins/netplan/nms-netplan-writer.c      | 92 ++++++++++---------
 1 file changed, 48 insertions(+), 44 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 7a3b22b3bc7c9e3fae54afbe0a9b57069e7af26f..9230dac68125648fb119d6b4c4a2c48c7a3e5301 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2180,23 +2180,22 @@ get_route_attributes_string (NMIPRoute *route, int family)
 	return g_string_free (str, FALSE);
 }
 
-static GString *
-write_route_settings (NMSettingIPConfig *s_ip)
+static gboolean
+write_route_settings (NMSettingIPConfig *s_ip, GArray *out_routes)
 {
-	GString *contents;
 	NMIPRoute *route;
 	guint32 i, num;
 	int addr_family;
+	GHashTable *tbl;
 
 	addr_family = nm_setting_ip_config_get_addr_family (s_ip);
 
 	num = nm_setting_ip_config_get_num_routes (s_ip);
 	if (num == 0)
-		return NULL;
-
-	contents = g_string_new ("");
+		return FALSE;
 
 	for (i = 0; i < num; i++) {
+		tbl = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
 		gs_free char *options = NULL;
 		const char *next_hop;
 		gint64 metric;
@@ -2206,13 +2205,16 @@ write_route_settings (NMSettingIPConfig *s_ip)
 		metric = nm_ip_route_get_metric (route);
 		options = get_route_attributes_string (route, addr_family);
 
-		g_string_append_printf (contents, "        - to: %s/%u\n",
-		                        nm_ip_route_get_dest (route),
-		                        nm_ip_route_get_prefix (route));
+		g_hash_table_insert (tbl, "to", g_strdup_printf("%s/%u",
+		                     nm_ip_route_get_dest (route),
+		                     nm_ip_route_get_prefix (route)));
 		if (next_hop)
-			g_string_append_printf (contents, "          via: %s\n", next_hop);
+			g_hash_table_insert (tbl, "via", g_strdup(next_hop));
 		if (metric >= 0)
-			g_string_append_printf (contents, "          metric: %u\n", (guint) metric);
+			g_hash_table_insert (tbl, "metric", g_strdup_printf("%u",
+			                     (guint) metric));
+
+		g_array_append_val (out_routes, tbl);
 #if 0  // TODO: implementing route options
 		if (options) {
 			g_string_append_c (contents, ' ');
@@ -2221,7 +2223,7 @@ write_route_settings (NMSettingIPConfig *s_ip)
 #endif
 	}
 
-	return contents;
+	return TRUE;
 }
 
 #if 0  // TODO: implement proxy support.
@@ -2452,6 +2454,7 @@ write_ip4_setting (NMConnection *connection,
                    GArray *addresses,
                    GArray *nameservers,
                    GArray *searches,
+                   GArray *routes,
                    GHashTable *dhcp_overrides,
                    GError **error)
 {
@@ -2518,18 +2521,6 @@ write_ip4_setting (NMConnection *connection,
 		g_array_append_val (addresses, value);
 	}
 
-#if 0  /* TODO: improve routes handling */
-		routes = g_array_new(...)
-	    // Routes -> split up into routes section
-	    // routes = g_array_new (...)
-	    // ...
-	    // g_hash_table_insert (netplan, "routes", <routes>)
-	    // 
-		g_hash_table_insert (route,
-		                     "to",
-		                     nm_ip_address_get_address (addr));
-#endif
-
 	gateway = nm_setting_ip_config_get_gateway (s_ip4);
 	if (gateway)
 		g_output_stream_printf(netplan, 0, NULL, NULL,
@@ -2583,13 +2574,7 @@ write_ip4_setting (NMConnection *connection,
 	                      timeout);
 #endif
 
-	// TODO: write combined IP4/IP6 routes, by storing them in a hashtable before
-	GString *route_str = write_route_settings (s_ip4);
-	if (route_str) {
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-	                        "      routes:\n%s", route_str->str);
-		g_string_free (route_str, TRUE);
-	}
+	write_route_settings (s_ip4, routes);
 
 #if 0  // TODO: Implement route settings here for ipv4
 	svSetValueBoolean (netplan, "IPV4_FAILURE_FATAL", !nm_setting_ip_config_get_may_fail (s_ip4));
@@ -2684,10 +2669,11 @@ write_ip6_setting_dhcp_hostname (NMSettingIPConfig *s_ip6,
 static gboolean
 write_ip6_setting (NMConnection *connection,
                    GOutputStream *netplan,
-		   GArray *addresses,
-		   GArray *nameservers,
-		   GArray *searches,
-		   GHashTable *dhcp_overrides,
+                   GArray *addresses,
+                   GArray *nameservers,
+                   GArray *searches,
+                   GArray *routes,
+                   GHashTable *dhcp_overrides,
                    GError **error)
 {
 	NMSettingIPConfig *s_ip6;
@@ -2783,14 +2769,7 @@ write_ip6_setting (NMConnection *connection,
 		                        "      metric: %ld\n", route_metric);
 #endif
 
-	// TODO: write combined IP4/IP6 routes, by storing them in a hashtable before
-	GString *route_str = write_route_settings (s_ip6);
-	if (route_str) {
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-	                        "      routes:\n%s", route_str->str);
-		g_string_free (route_str, TRUE);
-	}
-
+	write_route_settings (s_ip6, routes);
 
 #if 0
     // TODO: Implement this route as a formal route (rather than gatewayN) to set route table
@@ -2901,7 +2880,7 @@ do_write_construct (NMConnection *connection,
 	//NMSettingIPConfig *s_ip6;
 	const gchar *type = NULL, *id = NULL;
 	GString *id_str = NULL;
-	GArray *addresses, *nameservers, *searches;
+	GArray *addresses, *nameservers, *searches, *routes;
 	GHashTable *dhcp4_overrides, *dhcp6_overrides;
 
 	nm_assert (NM_IS_CONNECTION (connection));
@@ -2910,6 +2889,7 @@ do_write_construct (NMConnection *connection,
 	addresses = g_array_new (TRUE, FALSE, sizeof(char *));
 	nameservers = g_array_new (TRUE, FALSE, sizeof(char *));
 	searches = g_array_new (TRUE, FALSE, sizeof(char *));
+	routes = g_array_new (TRUE, FALSE, sizeof(GHashTable *));
 	dhcp6_overrides = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
 	dhcp4_overrides = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
 
@@ -3028,6 +3008,7 @@ do_write_construct (NMConnection *connection,
 	                        addresses,
 	                        nameservers,
 	                        searches,
+	                        routes,
 	                        dhcp4_overrides,
 	                        error))
 		return FALSE;
@@ -3037,6 +3018,7 @@ do_write_construct (NMConnection *connection,
 	                        addresses,
 	                        nameservers,
 	                        searches,
+	                        routes,
 	                        dhcp6_overrides,
 	                        error))
 		return FALSE;
@@ -3057,6 +3039,28 @@ do_write_construct (NMConnection *connection,
 	if (searches->len > 0)
 		write_array_to_sequence(searches, netplan, "        search:");
 
+	/**
+	 * Write pre-filled IP4 & IP6 routes mapping
+	 */
+	if (routes->len > 0) {
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      routes:\n");
+		GHashTable *tbl = NULL;
+		for (unsigned i = 0; i < routes->len; ++i) {
+			tbl = g_array_index(routes, GHashTable*, i);
+			size_t len = 3;
+			gchar* keys[3] = { "to", "via", "metric" };
+			gchar* indent = NULL;
+			gchar* v = NULL;
+			for (unsigned j = 0; j < len; ++j) {
+				indent = (!j) ? "      - " : "        ";
+				v = (gchar*) g_hash_table_lookup(tbl, keys[j]);
+				if (v)
+					g_output_stream_printf (netplan, 0, NULL, NULL,
+					                        "%s%s: %s\n", indent, keys[j], v);
+			}
+		}
+	}
+
 	/**
 	 * Write dhcp6-overrides
 	 */
-- 
2.25.1


From 9266f074bf6399a13ffc68e17d44310152c0786e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 21 Apr 2020 12:42:08 +0200
Subject: [PATCH 40/78] netplan: fix compiler warning with GSM/CDMA settings

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 940a9537432573ed0ae9d8e0abcf9e2fe2f66696..6536b9f51e27c94d102c02f72d53dc8dcc9618c5 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1958,13 +1958,13 @@ make_modem_setting (NetplanNetDefinition *nd,
                     GError **error,
                     gboolean is_gsm)
 {
-	void *s_modem;
+	NMSetting *s_modem;
 	const char *tmp;
 	const char *field;
 
-	s_modem = is_gsm ?
-	          NM_SETTING_GSM (nm_setting_gsm_new ()) :
-	          NM_SETTING_CDMA (nm_setting_cdma_new());
+	s_modem = is_gsm
+	          ? NM_SETTING (nm_setting_gsm_new ())
+	          : NM_SETTING (nm_setting_cdma_new());
 
 	/* Make GSM only settings */
 	if (is_gsm) {
-- 
2.25.1


From d299afa1a59445f296fbfcfaeff1b4a9916034db Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 21 Apr 2020 12:58:06 +0200
Subject: [PATCH 41/78] netplan: ip routing rules (routing-policy)

---
 .../plugins/netplan/nms-netplan-reader.c      |  64 +++++------
 .../plugins/netplan/nms-netplan-writer.c      | 105 ++++++++++++------
 .../plugins/netplan/tests/test-netplan.c      |  94 ++++++++++++++++
 3 files changed, 196 insertions(+), 67 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 6536b9f51e27c94d102c02f72d53dc8dcc9618c5..5382d55471a829cdf3e89ed7862c9c309db868d3 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2076,30 +2076,42 @@ modem_connection_from_netplan (const char *file,
 
 /* TODO: Support ethtool settings */
 
-#if 0  /* TODO: Read routing rules (routing-policy) */
 static void
 read_routing_rules (NetplanNetDefinition *nd,
-                    gboolean routes_read,
                     NMSettingIPConfig *s_ip4,
                     NMSettingIPConfig *s_ip6)
 {
-	gs_unref_ptrarray GPtrArray *routing_rules = NULL;
-	guint i;
+	NMIPRoutingRule *rule;
 
-	routing_rules = read_routing_rules_parse (netplan, routes_read);
-	if (!routing_rules)
-		return;
-
-	for (i = 0; i < routing_rules->len; i++) {
-		NMIPRoutingRule *rule = routing_rules->pdata[i];
+	for (unsigned i = 0; i < nd->ip_rules->len; ++i) {
+		NetplanIPRule *r = g_array_index(nd->ip_rules, NetplanIPRule*, i);
+		gboolean is_ipv4 = r->family == AF_INET;
 
-		nm_setting_ip_config_add_routing_rule (  (nm_ip_routing_rule_get_addr_family (rule) == AF_INET)
-		                                       ? s_ip4
-		                                       : s_ip6,
-		                                       rule);
+		rule = nm_ip_routing_rule_new (r->family);
+		if (r->from) {
+			gchar** ipmask = g_strsplit (r->from, "/", 2);
+			guint8 len = atoi(ipmask[1]);
+			nm_ip_routing_rule_set_to (rule, len ? ipmask[0] : NULL, len);
+		}
+		if (r->to) {
+			gchar** ipmask = g_strsplit (r->to, "/", 2);
+			guint8 len = atoi(ipmask[1]);
+			nm_ip_routing_rule_set_to (rule, len ? ipmask[0] : NULL, len);
+		}
+		if (r->table != NETPLAN_ROUTE_TABLE_UNSPEC)
+			nm_ip_routing_rule_set_table (rule, r->table);
+		if (r->priority != NETPLAN_IP_RULE_PRIO_UNSPEC)
+			nm_ip_routing_rule_set_priority (rule, r->priority);
+		/* XXX: Fix/implement fwmask, which is missing in NetplanNetDefinition. */
+		if (r->fwmark != NETPLAN_IP_RULE_FW_MARK_UNSPEC)
+			nm_ip_routing_rule_set_fwmark (rule, r->fwmark, 0);
+		if (r->tos != NETPLAN_IP_RULE_TOS_UNSPEC)
+			nm_ip_routing_rule_set_tos (rule, r->tos);
+
+		nm_setting_ip_config_add_routing_rule (is_ipv4 ? s_ip4 : s_ip6, rule);
+		nm_ip_routing_rule_unref (rule);
 	}
 }
-#endif  /* routing rules */
 
 static NMSetting *
 make_wired_setting (NetplanNetDefinition *nd,
@@ -2928,18 +2940,6 @@ connection_from_file_full (const char *filename,
 
 #if 0
 	parse_ethtool_options (main_netplan, connection);
-
-	has_complex_routes_v4 = utils_has_complex_routes (filename, AF_INET);
-	has_complex_routes_v6 = utils_has_complex_routes (filename, AF_INET6);
-
-	if (has_complex_routes_v4 || has_complex_routes_v6) {
-		if (has_complex_routes_v4 && !has_complex_routes_v6)
-			PARSE_WARNING ("'rule-' file is present; you will need to use a dispatcher script to apply these routes");
-		else if (has_complex_routes_v6 && !has_complex_routes_v4)
-			PARSE_WARNING ("'rule6-' file is present; you will need to use a dispatcher script to apply these routes");
-		else
-			PARSE_WARNING ("'rule-' and 'rule6-' files are present; you will need to use a dispatcher script to apply these routes");
-	}
 #endif
 
 	s_ip6 = make_ip6_setting (netdef, error);
@@ -2960,12 +2960,12 @@ connection_from_file_full (const char *filename,
 		nm_connection_add_setting (connection, s_match);
 	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
 
-#if 0  /* TODO: routing rules, sriov, tc, etc. */
-	read_routing_rules (main_netplan,
-	                    !has_complex_routes_v4 && !has_complex_routes_v6,
-	                    NM_SETTING_IP_CONFIG (s_ip4),
-	                    NM_SETTING_IP_CONFIG (s_ip6));
+	if (netdef->ip_rules)
+		read_routing_rules (netdef,
+		                    NM_SETTING_IP_CONFIG (s_ip4),
+		                    NM_SETTING_IP_CONFIG (s_ip6));
 
+#if 0  /* TODO: sriov, tc, etc. */
 	s_sriov = make_sriov_setting (main_netplan);
 	if (s_sriov)
 		nm_connection_add_setting (connection, s_sriov);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 9230dac68125648fb119d6b4c4a2c48c7a3e5301..c22a9f903dc64cff029e449c8e2872994d19dc72 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2828,7 +2828,8 @@ write_ip_routing_rules (NMConnection *connection,
                         GOutputStream *netplan)
 {
 	//gsize idx = 0;
-	int is_ipv4;
+	int is_ipv4, tmp;
+	long int li;
 	GString *routing_policy;
 
 	routing_policy = g_string_sized_new (200);
@@ -2837,6 +2838,8 @@ write_ip_routing_rules (NMConnection *connection,
 		const int addr_family = is_ipv4 ? AF_INET : AF_INET6;
 		NMSettingIPConfig *s_ip;
 		guint i, num;
+		guint8 to_len, from_len;
+		const char *to = NULL, *from = NULL;
 
 		s_ip = nm_connection_get_setting_ip_config (connection, addr_family);
 		if (!s_ip)
@@ -2847,19 +2850,48 @@ write_ip_routing_rules (NMConnection *connection,
 			NMIPRoutingRule *rule = nm_setting_ip_config_get_routing_rule (s_ip, i);
 			gs_free const char *s = NULL;
 			//char key[64];
+			to = nm_ip_routing_rule_get_to (rule);
+			to_len = nm_ip_routing_rule_get_to_len (rule);
+			from = nm_ip_routing_rule_get_from (rule);
+			from_len = nm_ip_routing_rule_get_from_len (rule);
+
+			/* Fallback to from=ALL, iff neither "to" nor "from" are set.
+			 * As done in nm_ip_routing_rule_to_string() */
+			if (!to && !from) {
+				from = is_ipv4 ? "0.0.0.0" : "::";
+				from_len = 0;
+			}
+
+			/* Netplan expects either "to" or "from" to be set. */
+			if (to)
+				g_string_append_printf (routing_policy,
+				                        "        - to: %s/%u\n", to, to_len);
+			else if (from)
+				g_string_append_printf (routing_policy,
+			                            "        - from: %s/%u\n", from, from_len);
+			else
+				nm_assert_not_reached ();
+
+			if (to && from)
+				g_string_append_printf (routing_policy,
+				                        "          from: %s/%u\n", from, from_len);
+
+			tmp = nm_ip_routing_rule_get_table (rule);
+			if (tmp)
+				g_string_append_printf (routing_policy, "          table: %d\n", tmp);
+
+			tmp = nm_ip_routing_rule_get_fwmark (rule);
+			if (tmp)
+				g_string_append_printf (routing_policy, "          mark: %d\n", tmp);
+
+			tmp = nm_ip_routing_rule_get_tos (rule);
+			printf("TOS %d\n", tmp);
+			if (tmp)
+				g_string_append_printf (routing_policy, "          type-of-service: %d\n", tmp);
 
-			g_string_append_printf(routing_policy, "        - to: %s\n",
-			                       nm_ip_routing_rule_get_to(rule));
-			g_string_append_printf(routing_policy, "          from: %s\n",
-			                       nm_ip_routing_rule_get_from(rule));
-			g_string_append_printf(routing_policy, "          table: %d\n",
-			                       nm_ip_routing_rule_get_table(rule));
-			g_string_append_printf(routing_policy, "          mark: %d\n",
-			                       nm_ip_routing_rule_get_fwmark(rule));
-			g_string_append_printf(routing_policy, "          type-of-service: %d\n",
-			                       nm_ip_routing_rule_get_tos(rule));
-			g_string_append_printf(routing_policy, "          priority: %ld\n",
-			                       nm_ip_routing_rule_get_priority(rule));
+			li = nm_ip_routing_rule_get_priority (rule);
+			if (li)
+				g_string_append_printf (routing_policy, "          priority: %ld\n", li);
 		}
 	}
 
@@ -3039,28 +3071,6 @@ do_write_construct (NMConnection *connection,
 	if (searches->len > 0)
 		write_array_to_sequence(searches, netplan, "        search:");
 
-	/**
-	 * Write pre-filled IP4 & IP6 routes mapping
-	 */
-	if (routes->len > 0) {
-		g_output_stream_printf (netplan, 0, NULL, NULL, "      routes:\n");
-		GHashTable *tbl = NULL;
-		for (unsigned i = 0; i < routes->len; ++i) {
-			tbl = g_array_index(routes, GHashTable*, i);
-			size_t len = 3;
-			gchar* keys[3] = { "to", "via", "metric" };
-			gchar* indent = NULL;
-			gchar* v = NULL;
-			for (unsigned j = 0; j < len; ++j) {
-				indent = (!j) ? "      - " : "        ";
-				v = (gchar*) g_hash_table_lookup(tbl, keys[j]);
-				if (v)
-					g_output_stream_printf (netplan, 0, NULL, NULL,
-					                        "%s%s: %s\n", indent, keys[j], v);
-			}
-		}
-	}
-
 	/**
 	 * Write dhcp6-overrides
 	 */
@@ -3085,6 +3095,31 @@ do_write_construct (NMConnection *connection,
 		g_free(htd.indent);
 	}
 
+	/**
+	 * Write pre-filled IP4 & IP6 routes mapping
+	 */
+	if (routes->len > 0) {
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      routes:\n");
+		GHashTable *tbl = NULL;
+		for (unsigned i = 0; i < routes->len; ++i) {
+			tbl = g_array_index(routes, GHashTable*, i);
+			size_t len = 3;
+			gchar* keys[3] = { "to", "via", "metric" };
+			gchar* indent = NULL;
+			gchar* v = NULL;
+			for (unsigned j = 0; j < len; ++j) {
+				indent = (!j) ? "      - " : "        ";
+				v = (gchar*) g_hash_table_lookup(tbl, keys[j]);
+				if (v)
+					g_output_stream_printf (netplan, 0, NULL, NULL,
+					                        "%s%s: %s\n", indent, keys[j], v);
+			}
+		}
+	}
+
+	/**
+	 * Write routing rules (routing-policy)
+	 */
 	write_ip_routing_rules (connection, netplan);
 
 	write_connection_setting (s_con, netplan);
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index a21a7b1058503023acf7c6a48711820a3f5aea59..c6f62977daef9dfea45d495ef8714473aa77370d 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -693,6 +693,99 @@ test_write_wired_static_routes (void)
 	//routefile = utils_get_route_path (testfile);
 }
 
+static NMIPRoutingRule *
+_ip_routing_rule_new (int addr_family,
+                      const char *str)
+{
+	NMIPRoutingRuleAsStringFlags flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE;
+	gs_free_error GError *local = NULL;
+	NMIPRoutingRule *rule;
+
+	if (addr_family != AF_UNSPEC) {
+		if (addr_family == AF_INET)
+			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET;
+		else {
+			g_assert (addr_family == AF_INET6);
+			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6;
+		}
+	}
+
+	rule = nm_ip_routing_rule_from_string (str,
+	                                       NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
+	                                       | flags,
+	                                       NULL,
+	                                       nmtst_get_rand_bool () ? &local : NULL);
+	nmtst_assert_success (rule, local);
+
+	if (addr_family != AF_UNSPEC)
+		g_assert_cmpint (nm_ip_routing_rule_get_addr_family (rule), ==, addr_family);
+	return rule;
+}
+
+static void
+_ip_routing_rule_add_to_setting (NMSettingIPConfig *s_ip,
+                                 const char *str)
+{
+	nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
+
+	rule = _ip_routing_rule_new (nm_setting_ip_config_get_addr_family (s_ip), str);
+	nm_setting_ip_config_add_routing_rule (s_ip, rule);
+}
+
+static void
+test_write_routing_rules (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Routing Rules",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NULL);
+
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	_ip_routing_rule_add_to_setting (s_ip4, "pref 10 from 0.0.0.0/0 table 1");
+	_ip_routing_rule_add_to_setting (s_ip4, "priority 10 to 192.167.8.0/24 table 2");
+	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 table 10");
+	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 to 1:2:3::5/24 table 22");
+	_ip_routing_rule_add_to_setting (s_ip6, "pref 10 from ::/0 to 1:3:3::5/128 table 55");
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
 
 static void
 test_read_write_wired_dhcp_send_hostname (void)
@@ -1249,6 +1342,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/basic", test_write_wired_basic);
 	g_test_add_func (TPATH "wired/write/static", test_write_wired_static);
 	g_test_add_func (TPATH "wired/write/routes", test_write_wired_static_routes);
+	g_test_add_func (TPATH "wired/write/routing-policy", test_write_routing_rules);
 
 	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
-- 
2.25.1


From f4fcff6da867545b402eb6169985e77d2203ce24 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 21 Apr 2020 15:03:15 +0200
Subject: [PATCH 42/78] netplan: add wake-on-lan, test mac-address +
 cloned-mac-address

---
 .../plugins/netplan/nms-netplan-reader.c      | 11 +++++++
 .../plugins/netplan/nms-netplan-writer.c      |  5 +++
 .../plugins/netplan/tests/test-netplan.c      | 33 ++++++++++++++-----
 .../netplan/tests/yaml/exp-wired-basic.yaml   | 14 ++++++++
 .../netplan/tests/yaml/exp-wired-static.yaml  | 25 ++++++++++++++
 5 files changed, 80 insertions(+), 8 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-wired-basic.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-wired-static.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 5382d55471a829cdf3e89ed7862c9c309db868d3..eef4eaa77225e282c273a8bff6fea83f5c7de630 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2129,6 +2129,17 @@ make_wired_setting (NetplanNetDefinition *nd,
 	if (nd->mtubytes > 0)
 		g_object_set (s_wired, NM_SETTING_WIRED_MTU, nd->mtubytes, NULL);
 
+	/* TODO: Implement all the different wake-on-lan flags in netplan.
+	 *   Right now we can only enable the default (0x1) or ignore. */
+	if (nd->wake_on_lan)
+		g_object_set (s_wired,
+		              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT,
+		              NULL);
+	else
+		g_object_set (s_wired,
+		              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE,
+		              NULL);
+
 	value = nd->match.mac;
 	if (value)
 		g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, value, NULL);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index c22a9f903dc64cff029e449c8e2872994d19dc72..25fa5f59ddb616e5c556baa5195101f71daac790 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1203,6 +1203,11 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 				        "      mtu: %d\n", mtu);
 
+	/* TODO: Implement all the different WoLAN flags in netplan. */
+	if (nm_setting_wired_get_wake_on_lan (s_wired) != NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE) {
+		g_output_stream_printf (netplan, 0, NULL, NULL, "      wakeonlan: true\n");
+	}
+
 #if 0 // TODO: implement s390 subchannels 
 	s390_subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index c6f62977daef9dfea45d495ef8714473aa77370d..2786a0d1ecba5b2da59f4e8734503110fc578f28 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -394,9 +394,9 @@ test_write_wired_basic (void)
 
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_ID, "write-test",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-				  NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test",
-				  NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
+	              NM_SETTING_CONNECTION_UUID, "dc6604ee-8924-4439-b9a3-ffda82e53427",
+	              NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test",
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
 	              NULL);
 
@@ -406,6 +406,7 @@ test_write_wired_basic (void)
 
 	g_object_set (s_wired,
 	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
+	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE,
 	              NULL);
 
 	/* IP4 setting */
@@ -427,12 +428,18 @@ test_write_wired_basic (void)
 
 	nmtst_assert_connection_verifies (connection);
 
-	_writer_new_connection (connection,
+	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR,
+	                        TEST_NETPLAN_DIR"/exp-wired-basic.yaml",
 	                        &testfile);
 
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
+	/* Verify Wake-on-LAN */
+	s_wired = nm_connection_get_setting_wired (reread);
+	g_assert_true (s_wired);
+	g_assert_true (nm_setting_wired_get_wake_on_lan (s_wired) == NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE);
+
 	nm_connection_add_setting (connection, nm_setting_proxy_new ());
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
@@ -463,9 +470,9 @@ test_write_wired_static (void)
 
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_ID, "write-test-static",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
-				  NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test-static",
-				  NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
+	              NM_SETTING_CONNECTION_UUID, "3f5705e4-bb5b-4e4d-a2f9-e8f44d508ee5",
+	              NM_SETTING_CONNECTION_STABLE_ID, "stable-id-test-static",
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "eth42",
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
 	              NULL);
 
@@ -475,6 +482,9 @@ test_write_wired_static (void)
 
 	g_object_set (s_wired,
 	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
+	              NM_SETTING_WIRED_CLONED_MAC_ADDRESS, "00:11:22:33:44:55",
+	              // XXX: Netplan will change any flag to DEFAULT, except IGNORE
+	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT,
 	              NM_SETTING_WIRED_MTU, mtu,
 	              NULL);
 
@@ -561,12 +571,19 @@ test_write_wired_static (void)
 
 	nmtst_assert_connection_verifies (connection);
 
-	_writer_new_connection (connection,
+	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR,
+	                        TEST_NETPLAN_DIR"/exp-wired-static.yaml",
 	                        &testfile);
 
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
+	/* Verify Wake-on-LAN */
+	s_wired = nm_connection_get_setting_wired (reread);
+	g_assert_true (s_wired);
+	// XXX: netplan can only set DEFAULT (wake-on-lan = true) or IGNORE (wake-on-lan = false)
+	g_assert_true (nm_setting_wired_get_wake_on_lan (s_wired) == NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT);
+
 	nm_connection_add_setting (connection, nm_setting_proxy_new ());
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wired-basic.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wired-basic.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..73b8190c73c3a8aa36bf338e23471da4d9560494
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wired-basic.yaml
@@ -0,0 +1,14 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    eth42:
+      match: { macaddress: DE:AD:BE:EF:CA:FE }
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: write-test
+        uuid: dc6604ee-8924-4439-b9a3-ffda82e53427
+        stable-id: stable-id-test
+        device: eth42
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wired-static.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wired-static.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..cfb07f70c3d00dd419e8bbd1cec86055acdaa7ff
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wired-static.yaml
@@ -0,0 +1,25 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    eth42:
+      match: { macaddress: DE:AD:BE:EF:CA:FE }
+      macaddress: 00:11:22:33:44:55
+      mtu: 1492
+      wakeonlan: true
+      gateway4: 1.1.1.1
+      gateway6: 2001:dead:beef::1
+      ipv6-address-generation: stable-privacy
+      addresses: [1.1.1.3/24, 1.1.1.5/24, 1003:1234:abcd::1/11, 2003:1234:abcd::2/22, 3003:1234:abcd::3/33]
+      nameservers:
+        addresses: [4.2.2.1, 4.2.2.2, fade:102:103::face, cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed]
+        search: [foobar.com, lab.foobar.com]
+      routes:
+      - to: 2222:aaaa:bbbb:cccc::/64
+        via: 2222:aaaa:bbbb:cccc:dddd:eeee:5555:6666
+        metric: 99
+      networkmanager:
+        name: write-test-static
+        uuid: 3f5705e4-bb5b-4e4d-a2f9-e8f44d508ee5
+        stable-id: stable-id-test-static
+        device: eth42
-- 
2.25.1


From 3b8a7a9c960463818a77f805ed1ac7a0fba84295 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 21 Apr 2020 16:41:42 +0200
Subject: [PATCH 43/78] netplan: fix wake-on-lan, apply certain wired settings
 only to physical devices

---
 .../plugins/netplan/nms-netplan-reader.c      | 40 +++++++++----------
 .../plugins/netplan/nms-netplan-writer.c      |  8 ++--
 .../plugins/netplan/tests/test-netplan.c      |  4 +-
 3 files changed, 26 insertions(+), 26 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index eef4eaa77225e282c273a8bff6fea83f5c7de630..74836ccd576af85a2d2eb9e4fad80172f8ca9997 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2126,27 +2126,27 @@ make_wired_setting (NetplanNetDefinition *nd,
 
 	s_wired = NM_SETTING_WIRED (nm_setting_wired_new ());
 
-	if (nd->mtubytes > 0)
-		g_object_set (s_wired, NM_SETTING_WIRED_MTU, nd->mtubytes, NULL);
-
-	/* TODO: Implement all the different wake-on-lan flags in netplan.
-	 *   Right now we can only enable the default (0x1) or ignore. */
-	if (nd->wake_on_lan)
-		g_object_set (s_wired,
-		              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT,
-		              NULL);
-	else
-		g_object_set (s_wired,
-		              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE,
-		              NULL);
-
-	value = nd->match.mac;
-	if (value)
-		g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, value, NULL);
+	/* Only for physical devices */
+	if (nd->type < NETPLAN_DEF_TYPE_VIRTUAL) {
+		if (nd->mtubytes > 0)
+			g_object_set (s_wired, NM_SETTING_WIRED_MTU, nd->mtubytes, NULL);
+
+		value = nd->match.mac;
+		if (value)
+			g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, value, NULL);
+
+		value = nd->set_mac;
+		if (value)
+			g_object_set (s_wired, NM_SETTING_WIRED_CLONED_MAC_ADDRESS, value, NULL);
+
+		/* TODO: Implement all the different wake-on-lan flags in netplan.
+		 *   Right now we can only enable the DEFAULT (0x1) or NONE (0x0). */
+		if (!nd->wake_on_lan)
+			g_object_set (s_wired,
+			              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_NONE,
+			              NULL);
+	}
 
-	value = nd->set_mac;
-	if (value)
-		g_object_set (s_wired, NM_SETTING_WIRED_CLONED_MAC_ADDRESS, value, NULL);
 
 	/* TODO: Add subchannels and other s390 options */
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 25fa5f59ddb616e5c556baa5195101f71daac790..b444444c212724f59492c4a6babc9d2216869099 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1159,7 +1159,7 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 {
 	NMSettingWired *s_wired;
 	//const char *const*s390_subchannels;
-	guint32 mtu; // i, num_opts;
+	guint32 mtu, wolan; // i, num_opts;
 	//const char *const*macaddr_blacklist;
 	const char *mac;
 
@@ -1204,9 +1204,10 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 				        "      mtu: %d\n", mtu);
 
 	/* TODO: Implement all the different WoLAN flags in netplan. */
-	if (nm_setting_wired_get_wake_on_lan (s_wired) != NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE) {
+	wolan = nm_setting_wired_get_wake_on_lan (s_wired);
+	if (wolan > NM_SETTING_WIRED_WAKE_ON_LAN_NONE &&
+	    wolan < NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE)
 		g_output_stream_printf (netplan, 0, NULL, NULL, "      wakeonlan: true\n");
-	}
 
 #if 0 // TODO: implement s390 subchannels 
 	s390_subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
@@ -2890,7 +2891,6 @@ write_ip_routing_rules (NMConnection *connection,
 				g_string_append_printf (routing_policy, "          mark: %d\n", tmp);
 
 			tmp = nm_ip_routing_rule_get_tos (rule);
-			printf("TOS %d\n", tmp);
 			if (tmp)
 				g_string_append_printf (routing_policy, "          type-of-service: %d\n", tmp);
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 2786a0d1ecba5b2da59f4e8734503110fc578f28..a9e16766cce9db974a7057423eae6597ac6acf79 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -406,7 +406,7 @@ test_write_wired_basic (void)
 
 	g_object_set (s_wired,
 	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
-	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE,
+	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_NONE,
 	              NULL);
 
 	/* IP4 setting */
@@ -438,7 +438,7 @@ test_write_wired_basic (void)
 	/* Verify Wake-on-LAN */
 	s_wired = nm_connection_get_setting_wired (reread);
 	g_assert_true (s_wired);
-	g_assert_true (nm_setting_wired_get_wake_on_lan (s_wired) == NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE);
+	g_assert_true (nm_setting_wired_get_wake_on_lan (s_wired) == NM_SETTING_WIRED_WAKE_ON_LAN_NONE);
 
 	nm_connection_add_setting (connection, nm_setting_proxy_new ());
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
-- 
2.25.1


From 57d9200b8d4d57bd7af615f0b69d7f622fffaae1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 12:29:34 +0200
Subject: [PATCH 44/78] netplan: bond options, test framework improvement

---
 .../plugins/netplan/nms-netplan-reader.c      |  73 +++++----
 .../plugins/netplan/nms-netplan-writer.c      |  51 ++++---
 .../plugins/netplan/tests/test-netplan.c      | 139 +++++++++++++++++-
 .../netplan/tests/yaml/add-slaves.yaml        |   6 +
 .../netplan/tests/yaml/exp-bond-main.yaml     |  27 ++++
 5 files changed, 244 insertions(+), 52 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/add-slaves.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 74836ccd576af85a2d2eb9e4fad80172f8ca9997..780599610a5dcb38ae4990493fa1d77820deb727 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2238,32 +2238,34 @@ make_bond_setting (NetplanNetDefinition *nd,
 
 	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
 
-	/* TODO: map the other bond_params fields to NM_SETTING_BOND fields */
-#if 0
-   struct {
-        char* lacp_rate;
-        guint min_links;
-        char* transmit_hash_policy;
-        char* selection_logic;
-        gboolean all_slaves_active;
-        char* arp_validate;
-        char* arp_all_targets;
-        char* fail_over_mac_policy;
-        guint gratuitous_arp;
-        /* TODO: unsolicited_na */
-        guint packets_per_slave;
-        char* primary_reselect_policy;
-        guint resend_igmp;
-        char* learn_interval;
-    } bond_params;
-#endif
-
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, nd->bond_params.mode);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, nd->bond_params.primary_slave);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, nd->bond_params.lacp_rate);
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, nd->bond_params.monitor_interval);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, nd->bond_params.down_delay);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, nd->bond_params.up_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIN_LINKS, g_strdup_printf("%u", nd->bond_params.min_links));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, nd->bond_params.transmit_hash_policy);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_AD_SELECT, nd->bond_params.selection_logic);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE, nd->bond_params.all_slaves_active ? "1" : "0");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_INTERVAL, nd->bond_params.arp_interval);
+	//NM_SETTING_BOND_OPTION_ARP_IP_TARGET handled below
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_VALIDATE, nd->bond_params.arp_validate);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS, nd->bond_params.arp_all_targets);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, nd->bond_params.up_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, nd->bond_params.down_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, nd->bond_params.fail_over_mac_policy);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_NUM_GRAT_ARP, g_strdup_printf("%u", nd->bond_params.gratuitous_arp));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, g_strdup_printf("%u", nd->bond_params.packets_per_slave));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, nd->bond_params.primary_reselect_policy);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_RESEND_IGMP, g_strdup_printf("%u", nd->bond_params.resend_igmp));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL, nd->bond_params.learn_interval);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, nd->bond_params.primary_slave);
+	// XXX: Needs to be implemented in netplan
+	//#define NM_SETTING_BOND_OPTION_ACTIVE_SLAVE      "active_slave"
+	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO "ad_actor_sys_prio"
+	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM   "ad_actor_system"
+	//#define NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY  "ad_user_port_key"
+	//#define NM_SETTING_BOND_OPTION_NUM_UNSOL_NA      "num_unsol_na"
+	//#define NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB    "tlb_dynamic_lb"
+	//#define NM_SETTING_BOND_OPTION_USE_CARRIER       "use_carrier"
 
 	if (nd->bond_params.arp_ip_targets) {
 		char *ip_target;
@@ -2279,7 +2281,6 @@ make_bond_setting (NetplanNetDefinition *nd,
 		nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_IP_TARGET, ip_targets->str);
 		g_string_free (ip_targets, TRUE);
 	}
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, nd->bond_params.lacp_rate);
 
 	return (NMSetting *) s_bond;
 }
@@ -2757,7 +2758,7 @@ netplan_ht_debug (gpointer key,
 static NMConnection *
 connection_from_file_full (const char *filename,
                            const char *network_file,  /* for unit tests only */
-                           const char *test_type,     /* for unit tests only */
+                           const char *netdef_id,     /* for unit tests only */
                            char **out_unhandled,
                            GError **error,
                            gboolean *out_ignore_error)
@@ -2791,9 +2792,10 @@ connection_from_file_full (const char *filename,
 		return NULL;
 	}
 
-	ret = netplan_parse_yaml (filename, error);
-	if (ret && network_file)
+	if (network_file)
 		ret = netplan_parse_yaml (network_file, error);
+	ret = netplan_parse_yaml (filename, error);
+
 	if (ret) {
 		_LOGT ("commit: parse successful");
 		netdefs = netplan_finish_parse (error);
@@ -2897,13 +2899,20 @@ connection_from_file_full (const char *filename,
 		}
 	}
 #endif
-	g_hash_table_iter_init (&iter, netdefs);
-	g_hash_table_iter_next (&iter, &key, (gpointer) &netdef);
+	if (netdef_id) {
+		/* Select netdef specified by ID. */
+		netdef = g_hash_table_lookup (netdefs, netdef_id);
+	} else {
+		/* Select the first netdef from the HashTable,
+		 * if ID is not explicitly asked for. */
+		g_hash_table_iter_init (&iter, netdefs);
+		g_hash_table_iter_next (&iter, &key, (gpointer) &netdef);
+	}
 	if (!netdef) {
 		_LOGE ("invalid netdef");
 		return NULL;
 	}
-	_LOGT ("netplan netdef %s : %d", (char *) key, netdef->type);
+	_LOGT ("Selected netdef %s : %d", netdef_id ? netdef_id : (char *) key, netdef->type);
 
 
 	switch (netdef->type) {
@@ -3030,13 +3039,13 @@ connection_from_file (const char *filename,
 NMConnection *
 nmtst_connection_from_file (const char *filename,
                             const char *network_file,
-                            const char *test_type,
+                            const char *netdef_id,
                             char **out_unhandled,
                             GError **error)
 {
 	return connection_from_file_full (filename,
 	                                  network_file,
-	                                  test_type,
+	                                  netdef_id,
 	                                  out_unhandled,
 	                                  error,
 	                                  NULL);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index b444444c212724f59492c4a6babc9d2216869099..b3fe11bfc64344fddca40359aa483945a340d7d7 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1496,42 +1496,59 @@ static const struct {
 	const char *option;
 	const char *netplan_name;
 } bond_options_mapping[] = {
+	{ NM_SETTING_BOND_OPTION_MODE, "mode" },
+	{ NM_SETTING_BOND_OPTION_LACP_RATE, "lacp-rate" },
 	{ NM_SETTING_BOND_OPTION_MIIMON, "mii-monitor-interval" },
-	{ NM_SETTING_BOND_OPTION_UPDELAY, "up-delay" },
-	{ NM_SETTING_BOND_OPTION_DOWNDELAY, "down-delay" },
+	{ NM_SETTING_BOND_OPTION_MIN_LINKS, "min-links" },
+	{ NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, "transmit-hash-policy" },
+	{ NM_SETTING_BOND_OPTION_AD_SELECT, "ad-select" },
+	{ NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE, "all-slaves-active" },
 	{ NM_SETTING_BOND_OPTION_ARP_INTERVAL, "arp-interval" },
 	{ NM_SETTING_BOND_OPTION_ARP_IP_TARGET, "arp-ip-targets" },
 	{ NM_SETTING_BOND_OPTION_ARP_VALIDATE, "arp-validate" },
-	{ NM_SETTING_BOND_OPTION_PRIMARY, "primary-slave" },
-	{ NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, "primary-reselect-policy" },
-	{ NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, "fail-over-mac-policy" },
-//#define NM_SETTING_BOND_OPTION_USE_CARRIER       "use_carrier"
-	{ NM_SETTING_BOND_OPTION_AD_SELECT, "ad-select" },
-	{ NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, "transmit-hash-policy" },
-	{ NM_SETTING_BOND_OPTION_RESEND_IGMP, "resend-igmp" },
-	{ NM_SETTING_BOND_OPTION_LACP_RATE, "lacp-rate" },
-	{ NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE, "all-slaves-active" },
 	{ NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS, "arp-all-targets" },
-	{ NM_SETTING_BOND_OPTION_MIN_LINKS, "min-links" },
+	{ NM_SETTING_BOND_OPTION_UPDELAY, "up-delay" },
+	{ NM_SETTING_BOND_OPTION_DOWNDELAY, "down-delay" },
+	{ NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, "fail-over-mac-policy" },
 	{ NM_SETTING_BOND_OPTION_NUM_GRAT_ARP, "gratuitous-arp" },
-//#define NM_SETTING_BOND_OPTION_NUM_UNSOL_NA      "num_unsol_na"
 	{ NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "packets-per-slave" },
-//#define NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB    "tlb_dynamic_lb"
+	{ NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, "primary-reselect-policy" },
+	{ NM_SETTING_BOND_OPTION_RESEND_IGMP, "resend-igmp" },
 	{ NM_SETTING_BOND_OPTION_LP_INTERVAL, "learn-packet-interval" },
+	{ NM_SETTING_BOND_OPTION_PRIMARY, "primary" },
+	// XXX: Needs to be implemented in netplan
+	//#define NM_SETTING_BOND_OPTION_ACTIVE_SLAVE      "active_slave"
+	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO "ad_actor_sys_prio"
+	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM   "ad_actor_system"
+	//#define NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY  "ad_user_port_key"
+	//#define NM_SETTING_BOND_OPTION_NUM_UNSOL_NA      "num_unsol_na"
+	//#define NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB    "tlb_dynamic_lb"
+	//#define NM_SETTING_BOND_OPTION_USE_CARRIER       "use_carrier"
 };
 
 static void
 _match_bond_option_to_netplan (GString *bond_options, const char *option, const char *value)
 {
 	guint i;
-	const char *name = option;
+	const char *name = NULL;
 
 	for (i = 0; i < G_N_ELEMENTS (bond_options_mapping); i++) {
-		if (nm_streq (option, bond_options_mapping[i].option))
+		if (nm_streq (option, bond_options_mapping[i].option)) {
 			name = bond_options_mapping[i].netplan_name;
+			break;
+		}
 	}
 
-	g_string_append_printf (bond_options, "        %s: %s\n", name, value);
+	/* Special handling for non-string/non-uint types. */
+	if (nm_streq (option, NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE))
+		value = nm_streq (value, "1") ? "true" : NULL; //default is false
+	else if (nm_streq (option, NM_SETTING_BOND_OPTION_ARP_IP_TARGET))
+		value = (strlen (value) > 0) ? g_strdup_printf ("[%s]", value) : NULL;
+
+	if (!name)
+		_LOGW("Bond option needs implementation: %s (%s)", option, value);
+	else if (value)
+		g_string_append_printf (bond_options, "        %s: %s\n", name, value);
 }
 
 static gboolean
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index a9e16766cce9db974a7057423eae6597ac6acf79..8aab92199c740586732c03dee068a3baaa04c074 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -93,7 +93,7 @@ _clear_all_netdefs (void)
 static NMConnection *
 _connection_from_file (const char *filename,
                        const char *network_file,
-                       const char *test_type,
+                       const char *netdef_id,
                        char **out_unhandled)
 {
 	NMConnection *connection;
@@ -104,7 +104,7 @@ _connection_from_file (const char *filename,
 
 	/* Clear netdefs before reading new data from file */
 	_clear_all_netdefs ();
-	connection = nmtst_connection_from_file (filename, network_file, test_type,
+	connection = nmtst_connection_from_file (filename, network_file, netdef_id,
 	                                         out_unhandled ?: &unhandled_fallback, &error);
 	g_assert_no_error (error);
 	g_assert (!unhandled_fallback);
@@ -117,7 +117,7 @@ _connection_from_file (const char *filename,
 }
 
 /* dummy path for an "expected" file, meaning: don't check for expected
- * written ifcfg file. */
+ * written netplan file. */
 static const char NO_EXPECTED[1];
 
 static void
@@ -228,6 +228,45 @@ _assert_reread_same (NMConnection *connection, NMConnection *reread)
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
+static void
+_writer_new_connection_no_reread (NMConnection *connection,
+                                  const char *netplan_dir,
+                                  char **out_filename,
+                                  const char *expected)
+{
+	gboolean success;
+	GError *error = NULL;
+	char *filename = NULL;
+	gs_unref_object NMConnection *con_verified = NULL;
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (netplan_dir);
+
+	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
+	con_verified = nmtst_connection_duplicate_and_normalize (connection);
+	_clear_all_netdefs();
+
+	success = nms_netplan_writer_write_connection (con_verified,
+	                                               netplan_dir,
+	                                               NULL,
+	                                               NULL,
+	                                               NULL,
+	                                               &filename,
+	                                               NULL,
+	                                               NULL,
+	                                               &error);
+	nmtst_assert_success (success, error);
+	g_assert (filename && filename[0]);
+
+	_assert_expected_content (con_verified, filename, expected);
+
+	if (out_filename)
+		*out_filename = filename;
+	else
+		g_free (filename);
+
+}
+
 static void
 _writer_new_connection_reread (NMConnection *connection,
                                const char *netplan_dir,
@@ -1005,6 +1044,98 @@ test_wifi_wowlan_mac_randomization (void)
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
 
+static void
+test_write_bond_main (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSettingWired *s_wired;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond Main",
+	              NM_SETTING_CONNECTION_UUID, "005688e7-ee1d-4ed4-9bfd-a088ba6e80a9",
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "bond0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* bond setting */
+	s_bond = (NMSettingBond *) nm_setting_bond_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_bond));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, "active-backup");
+	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, "fast");
+	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, "80");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIN_LINKS, "1");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, "layer2+3");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_AD_SELECT, "count");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE, "1");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_INTERVAL, "1");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_IP_TARGET, "192.168.0.1,192.168.0.2");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_VALIDATE, "all");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS, "all");
+	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, "10");
+	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, "5");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, "active");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_NUM_GRAT_ARP, "2");
+	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "2");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, "better");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_RESEND_IGMP, "2");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL, "2");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, "slave0");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	// cannot re-read because of missing slave0 definition
+	_writer_new_connection_no_reread (connection,
+	                                  TEST_SCRATCH_DIR_TMP,
+	                                  &testfile,
+	                                  TEST_NETPLAN_DIR"/exp-bond-main.yaml");
+	/* Manually re-read with added slave (dummy) interfaces, to make the
+	 * netplan parser happy. Explicitly choose the "bond0" netdef. */
+	reread = _connection_from_file (testfile,
+	                                TEST_NETPLAN_DIR"/add-slaves.yaml",
+									"bond0",
+	                                NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_write_modem_gsm_auto_eui64 (void)
 {
@@ -1365,6 +1496,8 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
 
+	g_test_add_func (TPATH "bond/write/main" , test_write_bond_main);
+
 	g_test_add_func (TPATH "modem/write/gsm-auto-eui64", test_write_modem_gsm_auto_eui64);
 	g_test_add_func (TPATH "modem/write/gsm", test_write_modem_gsm);
 	g_test_add_func (TPATH "modem/write/cdma", test_write_modem_cdma);
diff --git a/src/settings/plugins/netplan/tests/yaml/add-slaves.yaml b/src/settings/plugins/netplan/tests/yaml/add-slaves.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..60c7249179743526d57a5afc8c706d49993576b0
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/add-slaves.yaml
@@ -0,0 +1,6 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    slave0: {dhcp4:true}
+    slave1: {dhcp4:true}
\ No newline at end of file
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..e366e8d43e34b3e80875bf7b9e58ec854d55a0d5
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
@@ -0,0 +1,27 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  bonds:
+    bond0:
+      parameters:
+        ad-select: count
+        all-slaves-active: true
+        arp-all-targets: all
+        arp-interval: 1
+        arp-ip-targets: [192.168.0.1,192.168.0.2]
+        arp-validate: all
+        fail-over-mac-policy: active
+        learn-packet-interval: 2
+        min-links: 1
+        mode: active-backup
+        gratuitous-arp: 2
+        primary: slave0
+        primary-reselect-policy: better
+        resend-igmp: 2
+        transmit-hash-policy: layer2+3
+      gateway4: 1.1.1.1
+      addresses: [1.1.1.3/24]
+      networkmanager:
+        name: Test Write Bond Main
+        uuid: 005688e7-ee1d-4ed4-9bfd-a088ba6e80a9
+        device: bond0
-- 
2.25.1


From 3779a237c61b468429e77306d54c70d5296d0bd4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 13:09:46 +0200
Subject: [PATCH 45/78] netplan: improve bond option defaults & testing

---
 .../plugins/netplan/nms-netplan-reader.c      |  65 +++++---
 .../plugins/netplan/tests/test-netplan.c      | 145 +++++++++++++++++-
 .../netplan/tests/yaml/exp-bond-lacp.yaml     |  14 ++
 .../netplan/tests/yaml/exp-bond-rr.yaml       |  17 ++
 4 files changed, 217 insertions(+), 24 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 780599610a5dcb38ae4990493fa1d77820deb727..0afb04e64d8b16c79ef502b481e1fea173a6dfd4 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2238,26 +2238,53 @@ make_bond_setting (NetplanNetDefinition *nd,
 
 	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
 
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, nd->bond_params.mode);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, nd->bond_params.lacp_rate);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, nd->bond_params.monitor_interval);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIN_LINKS, g_strdup_printf("%u", nd->bond_params.min_links));
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, nd->bond_params.transmit_hash_policy);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_AD_SELECT, nd->bond_params.selection_logic);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE, nd->bond_params.all_slaves_active ? "1" : "0");
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_INTERVAL, nd->bond_params.arp_interval);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE,
+	                            nd->bond_params.mode);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE,
+	                            nd->bond_params.lacp_rate);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON,
+	                            nd->bond_params.monitor_interval);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIN_LINKS,
+	                            nd->bond_params.min_links
+	                            ? g_strdup_printf("%u", nd->bond_params.min_links)
+	                            : NULL);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY,
+	                            nd->bond_params.transmit_hash_policy);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_AD_SELECT,
+	                            nd->bond_params.selection_logic);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE,
+	                            nd->bond_params.all_slaves_active ? "1" : NULL);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_INTERVAL,
+	                            nd->bond_params.arp_interval);
 	//NM_SETTING_BOND_OPTION_ARP_IP_TARGET handled below
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_VALIDATE, nd->bond_params.arp_validate);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS, nd->bond_params.arp_all_targets);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, nd->bond_params.up_delay);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, nd->bond_params.down_delay);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, nd->bond_params.fail_over_mac_policy);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_NUM_GRAT_ARP, g_strdup_printf("%u", nd->bond_params.gratuitous_arp));
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, g_strdup_printf("%u", nd->bond_params.packets_per_slave));
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, nd->bond_params.primary_reselect_policy);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_RESEND_IGMP, g_strdup_printf("%u", nd->bond_params.resend_igmp));
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL, nd->bond_params.learn_interval);
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, nd->bond_params.primary_slave);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_VALIDATE,
+	                            nd->bond_params.arp_validate);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS,
+	                            nd->bond_params.arp_all_targets);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY,
+	                            nd->bond_params.up_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY,
+                                nd->bond_params.down_delay);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_FAIL_OVER_MAC,
+                                nd->bond_params.fail_over_mac_policy);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_NUM_GRAT_ARP,
+	                            nd->bond_params.gratuitous_arp > 1 // 1 is default
+	                            ? g_strdup_printf("%u", nd->bond_params.gratuitous_arp)
+	                            : NULL);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE,
+	                            nd->bond_params.packets_per_slave != 1 // 1 is default. 0 is random
+	                            ? g_strdup_printf("%u", nd->bond_params.packets_per_slave)
+	                            : NULL);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY_RESELECT,
+	                            nd->bond_params.primary_reselect_policy);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_RESEND_IGMP,
+	                            nd->bond_params.resend_igmp > 1 // 1 is default
+	                            ? g_strdup_printf("%u", nd->bond_params.resend_igmp)
+	                            : NULL);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL,
+                                nd->bond_params.learn_interval);
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY,
+                                nd->bond_params.primary_slave);
 	// XXX: Needs to be implemented in netplan
 	//#define NM_SETTING_BOND_OPTION_ACTIVE_SLAVE      "active_slave"
 	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO "ad_actor_sys_prio"
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 8aab92199c740586732c03dee068a3baaa04c074..7b103434eec61cc81c3d2d054cd731a91ff2d5ed 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -1080,8 +1080,6 @@ test_write_bond_main (void)
 	s_bond = (NMSettingBond *) nm_setting_bond_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_bond));
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, "active-backup");
-	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, "fast");
-	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, "80");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIN_LINKS, "1");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY, "layer2+3");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_AD_SELECT, "count");
@@ -1090,11 +1088,8 @@ test_write_bond_main (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_IP_TARGET, "192.168.0.1,192.168.0.2");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_VALIDATE, "all");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS, "all");
-	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, "10");
-	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, "5");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_FAIL_OVER_MAC, "active");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_NUM_GRAT_ARP, "2");
-	//nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "2");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, "better");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_RESEND_IGMP, "2");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL, "2");
@@ -1136,6 +1131,144 @@ test_write_bond_main (void)
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
+static void
+test_write_bond_rr (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSettingWired *s_wired;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond RR",
+	              NM_SETTING_CONNECTION_UUID, "005688e7-ee1d-4ed4-9bfd-a088ba6e80a9",
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "bond-rr",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* bond setting */
+	s_bond = (NMSettingBond *) nm_setting_bond_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_bond));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, "balance-rr");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MIIMON, "80");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_UPDELAY, "10");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, "5");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "2");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_NETPLAN_DIR"/exp-bond-rr.yaml",
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_bond_lacp (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSettingWired *s_wired;
+	NMIPAddress *addr;
+	GError *error = NULL;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond LACP",
+	              NM_SETTING_CONNECTION_UUID, "005688e7-ee1d-4ed4-9bfd-a088ba6e80a9",
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "bond-lacp",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* bond setting */
+	s_bond = (NMSettingBond *) nm_setting_bond_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_bond));
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, "802.3ad");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, "fast");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
+	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
+	g_assert_no_error (error);
+	nm_setting_ip_config_add_address (s_ip4, addr);
+	nm_ip_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_NETPLAN_DIR"/exp-bond-lacp.yaml",
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+
 static void
 test_write_modem_gsm_auto_eui64 (void)
 {
@@ -1497,6 +1630,8 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
 
 	g_test_add_func (TPATH "bond/write/main" , test_write_bond_main);
+	g_test_add_func (TPATH "bond/write/rr" , test_write_bond_rr);
+	g_test_add_func (TPATH "bond/write/lacp" , test_write_bond_lacp);
 
 	g_test_add_func (TPATH "modem/write/gsm-auto-eui64", test_write_modem_gsm_auto_eui64);
 	g_test_add_func (TPATH "modem/write/gsm", test_write_modem_gsm);
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..33b92420c695e8a8fdde117fee445f6b16de2bda
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml
@@ -0,0 +1,14 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  bonds:
+    bond-lacp:
+      parameters:
+        lacp-rate: fast
+        mode: 802.3ad
+      gateway4: 1.1.1.1
+      addresses: [1.1.1.3/24]
+      networkmanager:
+        name: Test Write Bond LACP
+        uuid: 005688e7-ee1d-4ed4-9bfd-a088ba6e80a9
+        device: bond-lacp
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..6cd256306b54835eee8b99a93b2497c9d0a51669
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml
@@ -0,0 +1,17 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  bonds:
+    bond-rr:
+      parameters:
+        down-delay: 5
+        mii-monitor-interval: 80
+        mode: balance-rr
+        packets-per-slave: 2
+        up-delay: 10
+      gateway4: 1.1.1.1
+      addresses: [1.1.1.3/24]
+      networkmanager:
+        name: Test Write Bond RR
+        uuid: 005688e7-ee1d-4ed4-9bfd-a088ba6e80a9
+        device: bond-rr
-- 
2.25.1


From f5cbc45de127c090323ffd29accf4e69fb9f9d68 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 15:08:09 +0200
Subject: [PATCH 46/78] netplan: update (C)

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 3 ++-
 src/settings/plugins/netplan/nms-netplan-writer.c | 3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 0afb04e64d8b16c79ef502b481e1fea173a6dfd4..5af236c9e6f711cde2c7ce7ee379c00585b4999d 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2,8 +2,9 @@
 /* NetworkManager system settings service
  *
  * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ * Lukas MÃ¤rdian <lukas.maerdian@canonical.com>
  *
- * Copyright (C) 2019 Canonical Ltd..
+ * Copyright (C) 2019-2020 Canonical Ltd..
  */
 
 #include "nm-default.h"
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index b3fe11bfc64344fddca40359aa483945a340d7d7..c2a9503143f3dea594c94cfd96c072c677008cff 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2,8 +2,9 @@
 /* NetworkManager system settings service
  *
  * Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+ * Lukas MÃ¤rdian <lukas.maerdian@canonical.com>
  *
- * Copyright (C) 2019 Canonical Ltd..
+ * Copyright (C) 2019-2020 Canonical Ltd..
  */
 
 #include "nm-default.h"
-- 
2.25.1


From 46c0cbd9724cb55482db03dc83005edfa47c9ef4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 15:30:53 +0200
Subject: [PATCH 47/78] netplan: cleanup tests

---
 Makefile.am                                   |   1 +
 .../netplan/tests/netplan-test-utils.h        | 341 ++++++++++++++++++
 .../plugins/netplan/tests/test-netplan.c      | 335 +----------------
 3 files changed, 346 insertions(+), 331 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/netplan-test-utils.h

diff --git a/Makefile.am b/Makefile.am
index 22bb8ef443098d474641646f6d7d112714639f8a..9eff56324a145d991ca1876de6a9876239bfbb8f 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2919,6 +2919,7 @@ check_local += check-local-symbols-settings-netplan
 check_programs += src/settings/plugins/netplan/tests/test-netplan
 
 src_settings_plugins_netplan_tests_test_netplan_SOURCES = \
+	src/settings/plugins/netplan/tests/netplan-test-utils.h \
 	src/settings/plugins/netplan/tests/test-netplan.c
 
 src_settings_plugins_netplan_tests_test_netplan_CPPFLAGS = \
diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
new file mode 100644
index 0000000000000000000000000000000000000000..119d54dc21c469bf31cfe4214dccde9c5439af51
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -0,0 +1,341 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* NetworkManager settings service - netplan plugin
+ *
+ * Lukas MÃ¤rdian <lukas.maerdian@canoncial.com>
+ * 
+ * Copyright (C) 2020 Canonical, Ltd..
+ */
+
+#ifndef __NETPLAN_TEST_UTILS_H__
+#define __NETPLAN_TEST_UTILS_H__
+
+#include "nm-default.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <linux/pkt_sched.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <netplan/parse.h>
+
+#include "nm-utils.h"
+#include "nm-setting-connection.h"
+#include "nm-setting-wired.h"
+#include "nm-setting-user.h"
+#include "nm-setting-wireless.h"
+#include "nm-setting-wireless-security.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-ip6-config.h"
+#include "nm-setting-8021x.h"
+#include "nm-setting-pppoe.h"
+#include "nm-setting-ppp.h"
+#include "nm-setting-vpn.h"
+#include "nm-setting-ethtool.h"
+#include "nm-setting-gsm.h"
+#include "nm-setting-cdma.h"
+#include "nm-setting-serial.h"
+#include "nm-setting-vlan.h"
+#include "nm-setting-dcb.h"
+#include "nm-core-internal.h"
+#include "nm-libnm-core-intern/nm-ethtool-utils.h"
+
+#include "NetworkManagerUtils.h"
+#include "settings/plugins/netplan/nms-netplan-reader.h"
+#include "settings/plugins/netplan/nms-netplan-writer.h"
+#include "settings/plugins/netplan/nms-netplan-utils.h"
+
+#include "nm-test-utils-core.h"
+
+#define TEST_NETPLAN_DIR        NM_BUILD_SRCDIR"/src/settings/plugins/netplan/tests/yaml"
+#define TEST_SCRATCH_DIR        NM_BUILD_BUILDDIR"/src/settings/plugins/netplan/tests/yaml"
+#define TEST_SCRATCH_DIR_TMP    TEST_SCRATCH_DIR"/tmp"
+
+/*****************************************************************************/
+
+#define _NMLOG_DOMAIN      LOGD_SETTINGS
+#define _NMLOG_PREFIX_NAME "test-netplan"
+#define _NMLOG(level, ...) \
+    G_STMT_START { \
+        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
+                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
+                _NMLOG_PREFIX_NAME": " \
+                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
+    } G_STMT_END
+
+#define PARSE_WARNING(...) _LOGW ("%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), "    " _NM_UTILS_MACRO_REST(__VA_ARGS__))
+
+/*****************************************************************************/
+
+static void
+_log_keyfile (NMConnection *con)
+{
+	gs_unref_keyfile GKeyFile *kf = NULL;
+	gs_free char *str = NULL;
+	kf = nm_keyfile_write (con, NULL, NULL, NULL);
+	str = g_key_file_to_data (kf, NULL, NULL);
+	printf("===== Keyfile =====\n%s\n===== Keyfile End =====\n", str);
+}
+
+static void
+_clear_all_netdefs (void)
+{
+	// Clear all netdefs before each test, so we only access the connection under test.
+	if(netdefs) {
+		guint n = g_hash_table_size (netdefs);
+		// TODO: make sure that any dynamically allocated netdef data is freed
+		g_hash_table_remove_all (netdefs);
+		_LOGT ("cleared %u prior netdefs", n);
+	}
+}
+
+static NMConnection *
+_connection_from_file (const char *filename,
+                       const char *network_file,
+                       const char *netdef_id,
+                       char **out_unhandled)
+{
+	NMConnection *connection;
+	GError *error = NULL;
+	char *unhandled_fallback = NULL;
+
+	g_assert (!out_unhandled || !*out_unhandled);
+
+	/* Clear netdefs before reading new data from file */
+	_clear_all_netdefs ();
+	connection = nmtst_connection_from_file (filename, network_file, netdef_id,
+	                                         out_unhandled ?: &unhandled_fallback, &error);
+	g_assert_no_error (error);
+	g_assert (!unhandled_fallback);
+
+	if (out_unhandled && *out_unhandled)
+		nmtst_assert_connection_verifies (connection);
+	else
+		nmtst_assert_connection_verifies_without_normalization (connection);
+	return connection;
+}
+
+/* dummy path for an "expected" file, meaning: don't check for expected
+ * written netplan file. */
+static const char NO_EXPECTED[1];
+
+static void
+_assert_expected_content (NMConnection *connection, const char *filename, const char *expected)
+{
+	gs_free char *content_expectd = NULL;
+	gs_free char *content_written = NULL;
+	GError *error = NULL;
+	gsize len_expectd = 0;
+	gsize len_written = 0;
+	gboolean success;
+	const char *uuid = NULL;
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (filename);
+	g_assert (g_file_test (filename, G_FILE_TEST_EXISTS));
+
+	g_assert (expected);
+	if (expected == NO_EXPECTED)
+		return;
+
+	success = g_file_get_contents (filename, &content_written, &len_written, &error);
+	nmtst_assert_success (success, error);
+
+	success = g_file_get_contents (expected, &content_expectd, &len_expectd, &error);
+	nmtst_assert_success (success, error);
+
+	{
+		gsize i, j;
+
+		for (i = 0; i < len_expectd; ) {
+			if (content_expectd[i] != '$') {
+				i++;
+				continue;
+			}
+			if (g_str_has_prefix (&content_expectd[i], "${UUID}")) {
+				GString *str;
+
+				if (!uuid) {
+					uuid = nm_connection_get_uuid (connection);
+					g_assert (uuid);
+				}
+
+				j = strlen (uuid);
+
+				str = g_string_new_len (content_expectd, len_expectd);
+				g_string_erase (str, i, NM_STRLEN ("${UUID}"));
+				g_string_insert_len (str, i, uuid, j);
+
+				g_free (content_expectd);
+				len_expectd = str->len;
+				content_expectd = g_string_free (str, FALSE);
+				i += j;
+				continue;
+			}
+
+			/* other '$' is not supported. If need be, support escaping of
+			 * '$' via '$$'. */
+			g_assert_not_reached ();
+		}
+	}
+
+	if (   len_expectd != len_written
+	    || memcmp (content_expectd, content_written, len_expectd) != 0) {
+		if (   g_getenv ("NMTST_NETPLAN_UPDATE_EXPECTED")
+		    || nm_streq0 (g_getenv ("NM_TEST_REGENERATE"), "1")) {
+			if (uuid) {
+				gs_free char *search = g_strdup_printf ("UUID=%s\n", uuid);
+				const char *s;
+				gsize i;
+				GString *str;
+
+				s = content_written;
+				while (TRUE) {
+					s = strstr (s, search);
+					g_assert (s);
+					if (   s == content_written
+					    || s[-1] == '\n')
+						break;
+					s += strlen (search);
+				}
+
+				i = s - content_written;
+
+				str = g_string_new_len (content_written, len_written);
+				g_string_erase (str, i, strlen (search));
+				g_string_insert (str, i, "UUID=${UUID}\n");
+
+				len_written = str->len;
+				content_written = g_string_free (str, FALSE);
+			}
+			success = g_file_set_contents (expected, content_written, len_written, &error);
+			nmtst_assert_success (success, error);
+		} else {
+			g_error ("The content of \"%s\" (%zu) differs from \"%s\" (%zu). Set NMTST_NETPLAN_UPDATE_EXPECTED=yes to update the files inplace\n\n>>>%s<<<\n\n>>>%s<<<\n",
+			         filename, len_written,
+			         expected, len_expectd,
+			         content_written,
+			         content_expectd);
+		}
+	}
+}
+
+static void
+_assert_reread_same (NMConnection *connection, NMConnection *reread)
+{
+	nmtst_assert_connection_verifies_without_normalization (reread);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+_writer_new_connection_no_reread (NMConnection *connection,
+                                  const char *netplan_dir,
+                                  char **out_filename,
+                                  const char *expected)
+{
+	gboolean success;
+	GError *error = NULL;
+	char *filename = NULL;
+	gs_unref_object NMConnection *con_verified = NULL;
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (netplan_dir);
+
+	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
+	con_verified = nmtst_connection_duplicate_and_normalize (connection);
+	_clear_all_netdefs();
+
+	success = nms_netplan_writer_write_connection (con_verified,
+	                                               netplan_dir,
+	                                               NULL,
+	                                               NULL,
+	                                               NULL,
+	                                               &filename,
+	                                               NULL,
+	                                               NULL,
+	                                               &error);
+	nmtst_assert_success (success, error);
+	g_assert (filename && filename[0]);
+
+	_assert_expected_content (con_verified, filename, expected);
+
+	if (out_filename)
+		*out_filename = filename;
+	else
+		g_free (filename);
+
+}
+
+static void
+_writer_new_connection_reread (NMConnection *connection,
+                               const char *netplan_dir,
+                               char **out_filename,
+                               const char *expected,
+                               NMConnection **out_reread,
+                               gboolean *out_reread_same)
+{
+	gboolean success;
+	GError *error = NULL;
+	char *filename = NULL;
+	gs_unref_object NMConnection *con_verified = NULL;
+	gs_unref_object NMConnection *reread_copy = NULL;
+	NMConnection **reread = out_reread ?: ((nmtst_get_rand_uint32 () % 2) ? &reread_copy : NULL);
+
+	g_assert (NM_IS_CONNECTION (connection));
+	g_assert (netplan_dir);
+
+	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
+	con_verified = nmtst_connection_duplicate_and_normalize (connection);
+	_clear_all_netdefs();
+
+	success = nms_netplan_writer_write_connection (con_verified,
+	                                               netplan_dir,
+	                                               NULL,
+	                                               NULL,
+	                                               NULL,
+	                                               &filename,
+	                                               reread,
+	                                               out_reread_same,
+	                                               &error);
+	nmtst_assert_success (success, error);
+	g_assert (filename && filename[0]);
+
+	if (reread)
+		nmtst_assert_connection_verifies_without_normalization (*reread);
+
+	_assert_expected_content (con_verified, filename, expected);
+
+	if (out_filename)
+		*out_filename = filename;
+	else
+		g_free (filename);
+
+}
+
+static void
+_writer_new_connec_exp (NMConnection *connection,
+                        const char *netplan_dir,
+                        const char *expected,
+                        char **out_filename)
+{
+	gs_unref_object NMConnection *reread = NULL;
+	gboolean reread_same = FALSE;
+
+	_writer_new_connection_reread (connection, netplan_dir, out_filename, expected, &reread, &reread_same);
+	_assert_reread_same (connection, reread);
+	g_assert (reread_same);
+}
+
+static void
+_writer_new_connection (NMConnection *connection,
+                        const char *netplan_dir,
+                        char **out_filename)
+{
+	_writer_new_connec_exp (connection, netplan_dir, NO_EXPECTED, out_filename);
+}
+
+#endif /* __NETPLAN_TEST_UTILS_H__ */
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 7b103434eec61cc81c3d2d054cd731a91ff2d5ed..fb59b5a6097fddc62e014118e1faca8bfb7d5b24 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -1,339 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0+
 /* NetworkManager settings service - netplan plugin
  *
- * Copyright (C) 2020 Canonical, Ltd.
- * Author: Lukas MÃ¤rdian <lukas.maerdian@canoncial.com>
+ * Lukas MÃ¤rdian <lukas.maerdian@canoncial.com>
+ *
+ * Copyright (C) 2020 Canonical, Ltd..
  */
 
-#include "nm-default.h"
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <unistd.h>
-#include <linux/pkt_sched.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <netplan/parse.h>
-
-#include "nm-utils.h"
-#include "nm-setting-connection.h"
-#include "nm-setting-wired.h"
-#include "nm-setting-user.h"
-#include "nm-setting-wireless.h"
-#include "nm-setting-wireless-security.h"
-#include "nm-setting-ip4-config.h"
-#include "nm-setting-ip6-config.h"
-#include "nm-setting-8021x.h"
-#include "nm-setting-pppoe.h"
-#include "nm-setting-ppp.h"
-#include "nm-setting-vpn.h"
-#include "nm-setting-ethtool.h"
-#include "nm-setting-gsm.h"
-#include "nm-setting-cdma.h"
-#include "nm-setting-serial.h"
-#include "nm-setting-vlan.h"
-#include "nm-setting-dcb.h"
-#include "nm-core-internal.h"
-#include "nm-libnm-core-intern/nm-ethtool-utils.h"
-
-#include "NetworkManagerUtils.h"
-
-#include "settings/plugins/netplan/nms-netplan-reader.h"
-#include "settings/plugins/netplan/nms-netplan-writer.h"
-#include "settings/plugins/netplan/nms-netplan-utils.h"
-
-#include "nm-test-utils-core.h"
-
-#define TEST_NETPLAN_DIR        NM_BUILD_SRCDIR"/src/settings/plugins/netplan/tests/yaml"
-#define TEST_SCRATCH_DIR        NM_BUILD_BUILDDIR"/src/settings/plugins/netplan/tests/yaml"
-#define TEST_SCRATCH_DIR_TMP    TEST_SCRATCH_DIR"/tmp"
-
-/*****************************************************************************/
-
-#define _NMLOG_DOMAIN      LOGD_SETTINGS
-#define _NMLOG_PREFIX_NAME "test-netplan"
-#define _NMLOG(level, ...) \
-    G_STMT_START { \
-        nm_log ((level), (_NMLOG_DOMAIN), NULL, NULL, \
-                "%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), \
-                _NMLOG_PREFIX_NAME": " \
-                _NM_UTILS_MACRO_REST(__VA_ARGS__)); \
-    } G_STMT_END
-
-#define PARSE_WARNING(...) _LOGW ("%s" _NM_UTILS_MACRO_FIRST(__VA_ARGS__), "    " _NM_UTILS_MACRO_REST(__VA_ARGS__))
-
-/*****************************************************************************/
-
-static void
-_log_keyfile (NMConnection *con)
-{
-	gs_unref_keyfile GKeyFile *kf = NULL;
-	gs_free char *str = NULL;
-	kf = nm_keyfile_write (con, NULL, NULL, NULL);
-	str = g_key_file_to_data (kf, NULL, NULL);
-	printf("===== Keyfile =====\n%s\n===== Keyfile End =====\n", str);
-}
-
-static void
-_clear_all_netdefs (void)
-{
-	// Clear all netdefs before each test, so we only access the connection under test.
-	if(netdefs) {
-		guint n = g_hash_table_size (netdefs);
-		// TODO: make sure that any dynamically allocated netdef data is freed
-		g_hash_table_remove_all (netdefs);
-		_LOGT ("cleared %u prior netdefs", n);
-	}
-}
-
-static NMConnection *
-_connection_from_file (const char *filename,
-                       const char *network_file,
-                       const char *netdef_id,
-                       char **out_unhandled)
-{
-	NMConnection *connection;
-	GError *error = NULL;
-	char *unhandled_fallback = NULL;
-
-	g_assert (!out_unhandled || !*out_unhandled);
-
-	/* Clear netdefs before reading new data from file */
-	_clear_all_netdefs ();
-	connection = nmtst_connection_from_file (filename, network_file, netdef_id,
-	                                         out_unhandled ?: &unhandled_fallback, &error);
-	g_assert_no_error (error);
-	g_assert (!unhandled_fallback);
-
-	if (out_unhandled && *out_unhandled)
-		nmtst_assert_connection_verifies (connection);
-	else
-		nmtst_assert_connection_verifies_without_normalization (connection);
-	return connection;
-}
-
-/* dummy path for an "expected" file, meaning: don't check for expected
- * written netplan file. */
-static const char NO_EXPECTED[1];
-
-static void
-_assert_expected_content (NMConnection *connection, const char *filename, const char *expected)
-{
-	gs_free char *content_expectd = NULL;
-	gs_free char *content_written = NULL;
-	GError *error = NULL;
-	gsize len_expectd = 0;
-	gsize len_written = 0;
-	gboolean success;
-	const char *uuid = NULL;
-
-	g_assert (NM_IS_CONNECTION (connection));
-	g_assert (filename);
-	g_assert (g_file_test (filename, G_FILE_TEST_EXISTS));
-
-	g_assert (expected);
-	if (expected == NO_EXPECTED)
-		return;
-
-	success = g_file_get_contents (filename, &content_written, &len_written, &error);
-	nmtst_assert_success (success, error);
-
-	success = g_file_get_contents (expected, &content_expectd, &len_expectd, &error);
-	nmtst_assert_success (success, error);
-
-	{
-		gsize i, j;
-
-		for (i = 0; i < len_expectd; ) {
-			if (content_expectd[i] != '$') {
-				i++;
-				continue;
-			}
-			if (g_str_has_prefix (&content_expectd[i], "${UUID}")) {
-				GString *str;
-
-				if (!uuid) {
-					uuid = nm_connection_get_uuid (connection);
-					g_assert (uuid);
-				}
-
-				j = strlen (uuid);
-
-				str = g_string_new_len (content_expectd, len_expectd);
-				g_string_erase (str, i, NM_STRLEN ("${UUID}"));
-				g_string_insert_len (str, i, uuid, j);
-
-				g_free (content_expectd);
-				len_expectd = str->len;
-				content_expectd = g_string_free (str, FALSE);
-				i += j;
-				continue;
-			}
-
-			/* other '$' is not supported. If need be, support escaping of
-			 * '$' via '$$'. */
-			g_assert_not_reached ();
-		}
-	}
-
-	if (   len_expectd != len_written
-	    || memcmp (content_expectd, content_written, len_expectd) != 0) {
-		if (   g_getenv ("NMTST_NETPLAN_UPDATE_EXPECTED")
-		    || nm_streq0 (g_getenv ("NM_TEST_REGENERATE"), "1")) {
-			if (uuid) {
-				gs_free char *search = g_strdup_printf ("UUID=%s\n", uuid);
-				const char *s;
-				gsize i;
-				GString *str;
-
-				s = content_written;
-				while (TRUE) {
-					s = strstr (s, search);
-					g_assert (s);
-					if (   s == content_written
-					    || s[-1] == '\n')
-						break;
-					s += strlen (search);
-				}
-
-				i = s - content_written;
-
-				str = g_string_new_len (content_written, len_written);
-				g_string_erase (str, i, strlen (search));
-				g_string_insert (str, i, "UUID=${UUID}\n");
-
-				len_written = str->len;
-				content_written = g_string_free (str, FALSE);
-			}
-			success = g_file_set_contents (expected, content_written, len_written, &error);
-			nmtst_assert_success (success, error);
-		} else {
-			g_error ("The content of \"%s\" (%zu) differs from \"%s\" (%zu). Set NMTST_NETPLAN_UPDATE_EXPECTED=yes to update the files inplace\n\n>>>%s<<<\n\n>>>%s<<<\n",
-			         filename, len_written,
-			         expected, len_expectd,
-			         content_written,
-			         content_expectd);
-		}
-	}
-}
-
-static void
-_assert_reread_same (NMConnection *connection, NMConnection *reread)
-{
-	nmtst_assert_connection_verifies_without_normalization (reread);
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-}
-
-static void
-_writer_new_connection_no_reread (NMConnection *connection,
-                                  const char *netplan_dir,
-                                  char **out_filename,
-                                  const char *expected)
-{
-	gboolean success;
-	GError *error = NULL;
-	char *filename = NULL;
-	gs_unref_object NMConnection *con_verified = NULL;
-
-	g_assert (NM_IS_CONNECTION (connection));
-	g_assert (netplan_dir);
-
-	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
-	con_verified = nmtst_connection_duplicate_and_normalize (connection);
-	_clear_all_netdefs();
-
-	success = nms_netplan_writer_write_connection (con_verified,
-	                                               netplan_dir,
-	                                               NULL,
-	                                               NULL,
-	                                               NULL,
-	                                               &filename,
-	                                               NULL,
-	                                               NULL,
-	                                               &error);
-	nmtst_assert_success (success, error);
-	g_assert (filename && filename[0]);
-
-	_assert_expected_content (con_verified, filename, expected);
-
-	if (out_filename)
-		*out_filename = filename;
-	else
-		g_free (filename);
-
-}
-
-static void
-_writer_new_connection_reread (NMConnection *connection,
-                               const char *netplan_dir,
-                               char **out_filename,
-                               const char *expected,
-                               NMConnection **out_reread,
-                               gboolean *out_reread_same)
-{
-	gboolean success;
-	GError *error = NULL;
-	char *filename = NULL;
-	gs_unref_object NMConnection *con_verified = NULL;
-	gs_unref_object NMConnection *reread_copy = NULL;
-	NMConnection **reread = out_reread ?: ((nmtst_get_rand_uint32 () % 2) ? &reread_copy : NULL);
-
-	g_assert (NM_IS_CONNECTION (connection));
-	g_assert (netplan_dir);
-
-	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
-	con_verified = nmtst_connection_duplicate_and_normalize (connection);
-	_clear_all_netdefs();
-
-	success = nms_netplan_writer_write_connection (con_verified,
-	                                               netplan_dir,
-	                                               NULL,
-	                                               NULL,
-	                                               NULL,
-	                                               &filename,
-	                                               reread,
-	                                               out_reread_same,
-	                                               &error);
-	nmtst_assert_success (success, error);
-	g_assert (filename && filename[0]);
-
-	if (reread)
-		nmtst_assert_connection_verifies_without_normalization (*reread);
-
-	_assert_expected_content (con_verified, filename, expected);
-
-	if (out_filename)
-		*out_filename = filename;
-	else
-		g_free (filename);
-
-}
-
-static void
-_writer_new_connec_exp (NMConnection *connection,
-                        const char *netplan_dir,
-                        const char *expected,
-                        char **out_filename)
-{
-	gs_unref_object NMConnection *reread = NULL;
-	gboolean reread_same = FALSE;
-
-	_writer_new_connection_reread (connection, netplan_dir, out_filename, expected, &reread, &reread_same);
-	_assert_reread_same (connection, reread);
-	g_assert (reread_same);
-}
-
-static void
-_writer_new_connection (NMConnection *connection,
-                        const char *netplan_dir,
-                        char **out_filename)
-{
-	_writer_new_connec_exp (connection, netplan_dir, NO_EXPECTED, out_filename);
-}
+#include "netplan-test-utils.h"
 
 /*****************************************************************************/
 
-- 
2.25.1


From 626c6cd4d42bc1ce4519a4de895fdf0961297e69 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 15:55:17 +0200
Subject: [PATCH 48/78] netplan: cleanup test-suite a bit

---
 .../netplan/tests/netplan-test-utils.h        |  63 ++++++
 .../plugins/netplan/tests/test-netplan.c      | 200 ++----------------
 .../netplan/tests/yaml/exp-bond-lacp.yaml     |   5 +-
 .../netplan/tests/yaml/exp-bond-main.yaml     |   5 +-
 .../netplan/tests/yaml/exp-bond-rr.yaml       |   5 +-
 5 files changed, 87 insertions(+), 191 deletions(-)

diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
index 119d54dc21c469bf31cfe4214dccde9c5439af51..63fa632048e09850134b9cd3fb4b1947d546e6c2 100644
--- a/src/settings/plugins/netplan/tests/netplan-test-utils.h
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -338,4 +338,67 @@ _writer_new_connection (NMConnection *connection,
 	_writer_new_connec_exp (connection, netplan_dir, NO_EXPECTED, out_filename);
 }
 
+/*****************************************************************************/
+
+static NMIPRoutingRule *
+_ip_routing_rule_new (int addr_family,
+                      const char *str)
+{
+	NMIPRoutingRuleAsStringFlags flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE;
+	gs_free_error GError *local = NULL;
+	NMIPRoutingRule *rule;
+
+	if (addr_family != AF_UNSPEC) {
+		if (addr_family == AF_INET)
+			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET;
+		else {
+			g_assert (addr_family == AF_INET6);
+			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6;
+		}
+	}
+
+	rule = nm_ip_routing_rule_from_string (str,
+	                                       NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
+	                                       | flags,
+	                                       NULL,
+	                                       nmtst_get_rand_bool () ? &local : NULL);
+	nmtst_assert_success (rule, local);
+
+	if (addr_family != AF_UNSPEC)
+		g_assert_cmpint (nm_ip_routing_rule_get_addr_family (rule), ==, addr_family);
+	return rule;
+}
+
+static void
+_ip_routing_rule_add_to_setting (NMSettingIPConfig *s_ip,
+                                 const char *str)
+{
+	nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
+
+	rule = _ip_routing_rule_new (nm_setting_ip_config_get_addr_family (s_ip), str);
+	nm_setting_ip_config_add_routing_rule (s_ip, rule);
+}
+
+/*****************************************************************************/
+
+static void
+_add_ip_auto_settings (NMConnection *connection,
+                       NMSettingIPConfig *s_ip4,
+                       NMSettingIPConfig *s_ip6)
+{
+	/* IP4 setting */
+	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6,
+	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
+	              NULL);
+}
+
 #endif /* __NETPLAN_TEST_UTILS_H__ */
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index fb59b5a6097fddc62e014118e1faca8bfb7d5b24..8184be455b1f7baec5119c16394bd0e3803365ad 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -103,7 +103,6 @@ test_write_wired_basic (void)
 	/* Connection setting */
 	s_con = (NMSettingConnection *) nm_setting_connection_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_ID, "write-test",
 	              NM_SETTING_CONNECTION_UUID, "dc6604ee-8924-4439-b9a3-ffda82e53427",
@@ -115,36 +114,19 @@ test_write_wired_basic (void)
 	/* Wired setting */
 	s_wired = (NMSettingWired *) nm_setting_wired_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_wired));
-
 	g_object_set (s_wired,
 	              NM_SETTING_WIRED_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
 	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_NONE,
 	              NULL);
 
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NULL);
-
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR,
 	                        TEST_NETPLAN_DIR"/exp-wired-basic.yaml",
 	                        &testfile);
-
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
 	/* Verify Wake-on-LAN */
@@ -395,70 +377,8 @@ test_write_wired_static_routes (void)
 	                        TEST_SCRATCH_DIR,
 	                        &testfile);
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
-	/* XXX: improve test
-	_writer_new_connection_reread (connection,
-	                               TEST_SCRATCH_DIR,
-	                               &testfile,
-	                               NULL,//TEST_IFCFG_DIR"/ifcfg-Test_Write_Wired_Static_Routes.cexpected",
-	                               &reread,
-	                               &reread_same);
-								   */
-	/* ifcfg does not support setting onlink=0. It gets lost during write+re-read.
-	 * Assert that it's missing, and patch it to check whether the rest of the
-	 * connection equals. */
-	/*
-	g_assert (!reread_same);
-	nmtst_assert_connection_verifies_without_normalization (reread);
-	s_ip4 = nm_connection_get_setting_ip4_config (reread);
-	g_assert (s_ip4);
-	g_assert_cmpint (nm_setting_ip_config_get_num_routes (s_ip4), ==, 2);
-	route = nm_setting_ip_config_get_route (s_ip4, 1);
-	g_assert (route);
-	g_assert (!nm_ip_route_get_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK));
-	nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
-	*/
-	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 
-	//routefile = utils_get_route_path (testfile);
-}
-
-static NMIPRoutingRule *
-_ip_routing_rule_new (int addr_family,
-                      const char *str)
-{
-	NMIPRoutingRuleAsStringFlags flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE;
-	gs_free_error GError *local = NULL;
-	NMIPRoutingRule *rule;
-
-	if (addr_family != AF_UNSPEC) {
-		if (addr_family == AF_INET)
-			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET;
-		else {
-			g_assert (addr_family == AF_INET6);
-			flags = NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6;
-		}
-	}
-
-	rule = nm_ip_routing_rule_from_string (str,
-	                                       NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE
-	                                       | flags,
-	                                       NULL,
-	                                       nmtst_get_rand_bool () ? &local : NULL);
-	nmtst_assert_success (rule, local);
-
-	if (addr_family != AF_UNSPEC)
-		g_assert_cmpint (nm_ip_routing_rule_get_addr_family (rule), ==, addr_family);
-	return rule;
-}
-
-static void
-_ip_routing_rule_add_to_setting (NMSettingIPConfig *s_ip,
-                                 const char *str)
-{
-	nm_auto_unref_ip_routing_rule NMIPRoutingRule *rule = NULL;
-
-	rule = _ip_routing_rule_new (nm_setting_ip_config_get_addr_family (s_ip), str);
-	nm_setting_ip_config_add_routing_rule (s_ip, rule);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 static void
@@ -488,19 +408,8 @@ test_write_routing_rules (void)
 	s_wired = (NMSettingWired *) nm_setting_wired_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_wired));
 
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NULL);
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 
 	_ip_routing_rule_add_to_setting (s_ip4, "pref 10 from 0.0.0.0/0 table 1");
 	_ip_routing_rule_add_to_setting (s_ip4, "priority 10 to 192.167.8.0/24 table 2");
@@ -685,26 +594,13 @@ test_wifi_wowlan_mac_randomization (void)
 				  NM_SETTING_WIRELESS_WAKE_ON_WLAN, NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL,
 	              NULL);
 
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NULL);
-
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connection (connection,
 	                        TEST_SCRATCH_DIR,
 	                        &testfile);
-
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
 	/* Verify WoWLan & MAC address randomization */
@@ -768,26 +664,8 @@ test_write_bond_main (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL, "2");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, "slave0");
 
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 
 	// cannot re-read because of missing slave0 definition
 	_writer_new_connection_no_reread (connection,
@@ -844,26 +722,8 @@ test_write_bond_rr (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_DOWNDELAY, "5");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "2");
 
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 
 	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR_TMP,
@@ -911,26 +771,8 @@ test_write_bond_lacp (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_MODE, "802.3ad");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, "fast");
 
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
-	              NM_SETTING_IP_CONFIG_GATEWAY, "1.1.1.1",
-	              NM_SETTING_IP_CONFIG_MAY_FAIL, TRUE,
-	              NULL);
-
-	addr = nm_ip_address_new (AF_INET, "1.1.1.3", 24, &error);
-	g_assert_no_error (error);
-	nm_setting_ip_config_add_address (s_ip4, addr);
-	nm_ip_address_unref (addr);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
-	              NULL);
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 
 	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR_TMP,
@@ -1104,20 +946,8 @@ test_write_modem_cdma (void)
 	              NM_SETTING_GSM_MTU, 1600,
 	              NULL);
 
-	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
-	              NULL);
-
-	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
-	              NULL);
-
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, s_ip4, s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml
index 33b92420c695e8a8fdde117fee445f6b16de2bda..8002d87ca5151efe2139e08d61897a42d60e3f3e 100644
--- a/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-lacp.yaml
@@ -6,8 +6,9 @@ network:
       parameters:
         lacp-rate: fast
         mode: 802.3ad
-      gateway4: 1.1.1.1
-      addresses: [1.1.1.3/24]
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
       networkmanager:
         name: Test Write Bond LACP
         uuid: 005688e7-ee1d-4ed4-9bfd-a088ba6e80a9
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
index e366e8d43e34b3e80875bf7b9e58ec854d55a0d5..9efed19da491dc958642c6d08ecd460bbad755c2 100644
--- a/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
@@ -19,8 +19,9 @@ network:
         primary-reselect-policy: better
         resend-igmp: 2
         transmit-hash-policy: layer2+3
-      gateway4: 1.1.1.1
-      addresses: [1.1.1.3/24]
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
       networkmanager:
         name: Test Write Bond Main
         uuid: 005688e7-ee1d-4ed4-9bfd-a088ba6e80a9
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml
index 6cd256306b54835eee8b99a93b2497c9d0a51669..3716a8cfe473881aca00fb1b1db75bc1dffe838c 100644
--- a/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-rr.yaml
@@ -9,8 +9,9 @@ network:
         mode: balance-rr
         packets-per-slave: 2
         up-delay: 10
-      gateway4: 1.1.1.1
-      addresses: [1.1.1.3/24]
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
       networkmanager:
         name: Test Write Bond RR
         uuid: 005688e7-ee1d-4ed4-9bfd-a088ba6e80a9
-- 
2.25.1


From 36c4b2ca03457de81403b4299efb31acf49d4971 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 17:31:13 +0200
Subject: [PATCH 49/78] netplan: test: improve utils

---
 .../plugins/netplan/tests/netplan-test-utils.h   | 16 ++++++++--------
 .../plugins/netplan/tests/test-netplan.c         | 14 +++++++-------
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
index 63fa632048e09850134b9cd3fb4b1947d546e6c2..2245d69cecabe210a8c787d5c63ee83f92dff410 100644
--- a/src/settings/plugins/netplan/tests/netplan-test-utils.h
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -383,20 +383,20 @@ _ip_routing_rule_add_to_setting (NMSettingIPConfig *s_ip,
 
 static void
 _add_ip_auto_settings (NMConnection *connection,
-                       NMSettingIPConfig *s_ip4,
-                       NMSettingIPConfig *s_ip6)
+                       NMSettingIPConfig **s_ip4,
+                       NMSettingIPConfig **s_ip6)
 {
 	/* IP4 setting */
-	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
-	g_object_set (s_ip4,
+	*s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (*s_ip4));
+	g_object_set (*s_ip4,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO,
 	              NULL);
 
 	/* IP6 setting */
-	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
-	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
-	g_object_set (s_ip6,
+	*s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
+	nm_connection_add_setting (connection, NM_SETTING (*s_ip6));
+	g_object_set (*s_ip6,
 	              NM_SETTING_IP_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO,
 	              NULL);
 }
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 8184be455b1f7baec5119c16394bd0e3803365ad..bd170183e331a0db3a01d37862ac90639206f784 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -120,7 +120,7 @@ test_write_wired_basic (void)
 	              NULL);
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connec_exp (connection,
@@ -409,7 +409,7 @@ test_write_routing_rules (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_wired));
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 
 	_ip_routing_rule_add_to_setting (s_ip4, "pref 10 from 0.0.0.0/0 table 1");
 	_ip_routing_rule_add_to_setting (s_ip4, "priority 10 to 192.167.8.0/24 table 2");
@@ -595,7 +595,7 @@ test_wifi_wowlan_mac_randomization (void)
 	              NULL);
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connection (connection,
@@ -665,7 +665,7 @@ test_write_bond_main (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, "slave0");
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 
 	// cannot re-read because of missing slave0 definition
 	_writer_new_connection_no_reread (connection,
@@ -723,7 +723,7 @@ test_write_bond_rr (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE, "2");
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 
 	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR_TMP,
@@ -772,7 +772,7 @@ test_write_bond_lacp (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LACP_RATE, "fast");
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 
 	_writer_new_connec_exp (connection,
 	                        TEST_SCRATCH_DIR_TMP,
@@ -947,7 +947,7 @@ test_write_modem_cdma (void)
 	              NULL);
 
 	/* Add generic IP4/6 DHCP settings. */
-	_add_ip_auto_settings (connection, s_ip4, s_ip6);
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
 	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
-- 
2.25.1


From 956b8ff3a2924ac9e779b6a7c269cf9ae594b647 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 22 Apr 2020 17:32:43 +0200
Subject: [PATCH 50/78] netplan: basic VLAN support

---
 .../plugins/netplan/nms-netplan-reader.c      | 119 ++----------------
 .../plugins/netplan/tests/test-netplan.c      |  63 +++++++++-
 .../{add-slaves.yaml => add-base-iface.yaml}  |   3 +-
 .../netplan/tests/yaml/exp-bond-main.yaml     |   2 +-
 .../netplan/tests/yaml/exp-vlan-write.yaml    |  14 +++
 5 files changed, 90 insertions(+), 111 deletions(-)
 rename src/settings/plugins/netplan/tests/yaml/{add-slaves.yaml => add-base-iface.yaml} (55%)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-vlan-write.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 5af236c9e6f711cde2c7ce7ee379c00585b4999d..3aba9a2e6258bd0354546bf025c454552a4bfa76 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -2521,8 +2521,7 @@ make_team_port_setting (NetplanNetDefinition *nd)
 }
 #endif
 
-
-#if 0   /* TODO: VLAN Support */
+#if 0   /* TODO: Advanced VLAN */
 static void
 parse_prio_map_list (NMSettingVlan *s_vlan,
                      NetplanNetDefinition *nd,
@@ -2546,6 +2545,7 @@ parse_prio_map_list (NMSettingVlan *s_vlan,
 			PARSE_WARNING ("invalid %s priority map item '%s'", key, *iter);
 	}
 }
+#endif
 
 static NMSetting *
 make_vlan_setting (NetplanNetDefinition *nd,
@@ -2553,118 +2553,28 @@ make_vlan_setting (NetplanNetDefinition *nd,
                    GError **error)
 {
 	gs_unref_object NMSettingVlan *s_vlan = NULL;
-	gs_free char *parent = NULL;
-	gs_free char *iface_name = NULL;
-	gs_free char *value = NULL;
-	const char *v = NULL;
-	int vlan_id = -1;
-	guint32 vlan_flags = 0;
-	int gvrp, reorder_hdr;
-
-	v = svGetValueStr (netplan, "VLAN_ID", &value);
-	if (v) {
-		vlan_id = _nm_utils_ascii_str_to_int64 (v, 10, 0, 4095, -1);
-		if (vlan_id == -1) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid VLAN_ID '%s'", v);
-			return NULL;
-		}
-	}
-
-	/* Need DEVICE if we don't have a separate VLAN_ID property */
-	iface_name = svGetValueStr_cp (netplan, "DEVICE");
-	if (!iface_name && vlan_id < 0) {
-		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "Missing DEVICE property; cannot determine VLAN ID.");
-		return NULL;
-	}
-
+	//guint32 vlan_flags = 0;
 	s_vlan = NM_SETTING_VLAN (nm_setting_vlan_new ());
 
-	/* Parent interface from PHYSDEV takes precedence if it exists */
-	parent = svGetValueStr_cp (netplan, "PHYSDEV");
-
-	if (iface_name) {
-		v = strchr (iface_name, '.');
-		if (v) {
-			/* eth0.43; PHYSDEV is assumed from it if unknown */
-			if (!parent) {
-				parent = g_strndup (iface_name, v - iface_name);
-				if (g_str_has_prefix (parent, "vlan")) {
-					/* Like initscripts, if no PHYSDEV and we get an obviously
-					 * invalid parent interface from DEVICE, fail.
-					 */
-					nm_clear_g_free (&parent);
-				}
-			}
-			v++;
-		} else {
-			/* format like vlan43; PHYSDEV must be set */
-			if (g_str_has_prefix (iface_name, "vlan"))
-				v = iface_name + 4;
-		}
-
-		if (v) {
-			int device_vlan_id;
-
-			/* Grab VLAN ID from interface name; this takes precedence over the
-			 * separate VLAN_ID property for backwards compat.
-			 */
-			device_vlan_id = _nm_utils_ascii_str_to_int64 (v, 10, 0, 4095, -1);
-			if (device_vlan_id != -1)
-				vlan_id = device_vlan_id;
-		}
-	}
-
-	if (vlan_id < 0) {
+	/* Netplan initializes the ID to G_MAXUINT, as 0 is a valid VLAN ID */
+	if (nd->vlan_id > 4094) {
 		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "Failed to determine VLAN ID from DEVICE or VLAN_ID.");
+		                     "Failed to determine VLAN ID (id) from netplan");
 		return NULL;
 	}
-	g_object_set (s_vlan, NM_SETTING_VLAN_ID, vlan_id, NULL);
+	g_object_set (s_vlan, NM_SETTING_VLAN_ID, nd->vlan_id, NULL);
 
-	if (parent == NULL) {
+	if (!nd->vlan_link) {
 		g_set_error_literal (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		                     "Failed to determine VLAN parent from DEVICE or PHYSDEV");
+		                     "Failed to determine VLAN parent (link) from netplan");
 		return NULL;
 	}
-	g_object_set (s_vlan, NM_SETTING_VLAN_PARENT, parent, NULL);
+	g_object_set (s_vlan, NM_SETTING_VLAN_PARENT, nd->vlan_link->id, NULL);
 
+	/* TODO: VLAN flags need to be implemented in netplan
 	vlan_flags |= NM_VLAN_FLAG_REORDER_HEADERS;
-
-	gvrp = svGetValueBoolean (netplan, "GVRP", -1);
-	if (gvrp > 0)
-		vlan_flags |= NM_VLAN_FLAG_GVRP;
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "VLAN_FLAGS", &value);
-	if (v) {
-		gs_free const char **strv = NULL;
-		const char *const *ptr;
-
-		strv = nm_utils_strsplit_set (v, ", ");
-		for (ptr = strv; ptr && *ptr; ptr++) {
-			if (nm_streq (*ptr, "GVRP") && gvrp == -1)
-				vlan_flags |= NM_VLAN_FLAG_GVRP;
-			if (nm_streq (*ptr, "LOOSE_BINDING"))
-				vlan_flags |=  NM_VLAN_FLAG_LOOSE_BINDING;
-			if (nm_streq (*ptr, "NO_REORDER_HDR"))
-				vlan_flags &= ~NM_VLAN_FLAG_REORDER_HEADERS;
-		}
-	}
-
-	reorder_hdr = svGetValueBoolean (netplan, "REORDER_HDR", -1);
-	if (   reorder_hdr != -1
-	    && reorder_hdr != NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS))
-		PARSE_WARNING ("REORDER_HDR key is deprecated, use VLAN_FLAGS");
-
-	if (svGetValueBoolean (netplan, "MVRP", FALSE))
-		vlan_flags |= NM_VLAN_FLAG_MVRP;
-
 	g_object_set (s_vlan, NM_SETTING_VLAN_FLAGS, vlan_flags, NULL);
-
-	parse_prio_map_list (s_vlan, netplan, "VLAN_INGRESS_PRIORITY_MAP", NM_VLAN_INGRESS_MAP);
-	parse_prio_map_list (s_vlan, netplan, "VLAN_EGRESS_PRIORITY_MAP", NM_VLAN_EGRESS_MAP);
+	*/
 
 	return NM_SETTING (g_steal_pointer (&s_vlan));
 }
@@ -2682,7 +2592,7 @@ vlan_connection_from_netplan (const char *file,
 	GError *local = NULL;
 
 	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (netplan != NULL, NULL);
+	g_return_val_if_fail (nd != NULL, NULL);
 
 	connection = nm_simple_connection_new ();
 
@@ -2718,7 +2628,6 @@ vlan_connection_from_netplan (const char *file,
 
 	return connection;
 }
-#endif
 
 static NMConnection *
 create_unhandled_connection (const char *filename, NetplanNetDefinition *nd,
@@ -2959,11 +2868,9 @@ connection_from_file_full (const char *filename,
 	case NETPLAN_DEF_TYPE_BOND:
 		connection = bond_connection_from_netplan (filename, netdef, error);
 		break;
-#if 0  /* skip for now... */
 	case NETPLAN_DEF_TYPE_VLAN:
 		connection = vlan_connection_from_netplan (filename, netdef, error);
 		break;
-#endif
 #if 0  /* not yet implemented */
 	case NETPLAN_DEF_TYPE_INFINIBAND:
 		connection = infiniband_connection_from_netplan (filename, netdef, error);
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index bd170183e331a0db3a01d37862ac90639206f784..e459573eb5554ff76e7c87cf7c885efe190b79fa 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -613,6 +613,63 @@ test_wifi_wowlan_mac_randomization (void)
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
 
+static void
+test_write_vlan (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingVlan *s_vlan;
+	NMSettingWired *s_wired;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write VLAN",
+	              NM_SETTING_CONNECTION_UUID, "0f9f128b-3f77-4ff3-806d-bc1e85621c99",
+	              //NM_SETTING_CONNECTION_AUTOCONNECT, FALSE, // Not implemented by netplan
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_VLAN_SETTING_NAME,
+				  NM_SETTING_CONNECTION_INTERFACE_NAME, "enred",
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* VLAN setting */
+	s_vlan = (NMSettingVlan *) nm_setting_vlan_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_vlan));
+	g_object_set (s_vlan,
+	              NM_SETTING_VLAN_PARENT, "eno1",
+	              NM_SETTING_VLAN_ID, 42,
+	              //NM_SETTING_VLAN_FLAGS, 1, // XXX: Needs to be implemented in netplan
+	              NULL);
+
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
+
+	// cannot re-read because of missing eno1 definition
+	_writer_new_connection_no_reread (connection,
+	                                  TEST_SCRATCH_DIR_TMP,
+	                                  &testfile,
+	                                  TEST_NETPLAN_DIR"/exp-vlan-write.yaml");
+	/* Manually re-read with added base (dummy) interfaces, to make the
+	 * netplan parser happy. Explicitly choose the "enred" netdef. */
+	reread = _connection_from_file (testfile,
+	                                TEST_NETPLAN_DIR"/add-base-iface.yaml",
+									"enred",
+	                                NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_write_bond_main (void)
 {
@@ -662,7 +719,7 @@ test_write_bond_main (void)
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY_RESELECT, "better");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_RESEND_IGMP, "2");
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_LP_INTERVAL, "2");
-	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, "slave0");
+	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY, "eno1");
 
 	/* Add generic IP4/6 DHCP settings. */
 	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
@@ -675,7 +732,7 @@ test_write_bond_main (void)
 	/* Manually re-read with added slave (dummy) interfaces, to make the
 	 * netplan parser happy. Explicitly choose the "bond0" netdef. */
 	reread = _connection_from_file (testfile,
-	                                TEST_NETPLAN_DIR"/add-slaves.yaml",
+	                                TEST_NETPLAN_DIR"/add-base-iface.yaml",
 									"bond0",
 	                                NULL);
 
@@ -1132,6 +1189,8 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
 
+	g_test_add_func (TPATH "vlan/write/main" , test_write_vlan);
+
 	g_test_add_func (TPATH "bond/write/main" , test_write_bond_main);
 	g_test_add_func (TPATH "bond/write/rr" , test_write_bond_rr);
 	g_test_add_func (TPATH "bond/write/lacp" , test_write_bond_lacp);
diff --git a/src/settings/plugins/netplan/tests/yaml/add-slaves.yaml b/src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml
similarity index 55%
rename from src/settings/plugins/netplan/tests/yaml/add-slaves.yaml
rename to src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml
index 60c7249179743526d57a5afc8c706d49993576b0..cb5f2a2303c4753f7eff5e53a8d1aa98db59b215 100644
--- a/src/settings/plugins/netplan/tests/yaml/add-slaves.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml
@@ -2,5 +2,4 @@ network:
   version: 2
   renderer: NetworkManager
   ethernets:
-    slave0: {dhcp4:true}
-    slave1: {dhcp4:true}
\ No newline at end of file
+    eno1: {dhcp4:true, dhcp6:true}
\ No newline at end of file
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
index 9efed19da491dc958642c6d08ecd460bbad755c2..6207e992db188e9e617ba6c96d0176a215e88233 100644
--- a/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bond-main.yaml
@@ -15,7 +15,7 @@ network:
         min-links: 1
         mode: active-backup
         gratuitous-arp: 2
-        primary: slave0
+        primary: eno1
         primary-reselect-policy: better
         resend-igmp: 2
         transmit-hash-policy: layer2+3
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-vlan-write.yaml b/src/settings/plugins/netplan/tests/yaml/exp-vlan-write.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..0bce45c0e91b9b2e47c1e0fde1b2c98da8bf56d0
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-vlan-write.yaml
@@ -0,0 +1,14 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  vlans:
+    enred:
+      id: 42
+      link: eno1
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write VLAN
+        uuid: 0f9f128b-3f77-4ff3-806d-bc1e85621c99
+        device: enred
-- 
2.25.1


From 02dece8b6dcbb801b2e96f1de309609b3afefd50 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 24 Apr 2020 16:15:03 +0200
Subject: [PATCH 51/78] netplan: allow empty IP config

---
 src/settings/plugins/netplan/nms-netplan-writer.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index c2a9503143f3dea594c94cfd96c072c677008cff..399550574610c343c105f44143f9b5b1dca9dbbc 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2497,6 +2497,9 @@ write_ip4_setting (NMConnection *connection,
 	//gboolean has_netmask;
 
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (!s_ip4)
+		return TRUE;
+
 	method = nm_setting_ip_config_get_method (s_ip4);
 
 	/* Missing IP4 setting is assumed to be DHCP */
@@ -2713,9 +2716,8 @@ write_ip6_setting (NMConnection *connection,
 	NMSettingIP6ConfigAddrGenMode addr_gen_mode;
 
 	s_ip6 = nm_connection_get_setting_ip6_config (connection);
-	if (!s_ip6) {
+	if (!s_ip6)
 		return TRUE;
-	}
 
 	gateway = nm_setting_ip_config_get_gateway (s_ip6);
 	if (gateway)
@@ -3055,9 +3057,6 @@ do_write_construct (NMConnection *connection,
 	//if (!write_tc_setting (connection, netplan, error))
 	//	return FALSE;
 
-	//s_ip4 = nm_connection_get_setting_ip4_config (connection);
-	//s_ip6 = nm_connection_get_setting_ip6_config (connection);
-
 	if (!write_ip4_setting (connection,
 	                        netplan,
 	                        addresses,
-- 
2.25.1


From 1e4441a3ec3eda8c65952188ac696eed79afbc20 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 24 Apr 2020 16:16:05 +0200
Subject: [PATCH 52/78] netplan: basic bridge[-port] support

---
 .../plugins/netplan/nms-netplan-reader.c      | 100 +++++------
 .../plugins/netplan/nms-netplan-writer.c      |  43 +++--
 .../plugins/netplan/tests/test-netplan.c      | 170 +++++++++++++++++-
 .../netplan/tests/yaml/add-bridge.yaml        |   5 +
 .../netplan/tests/yaml/exp-bridge-main.yaml   |  20 +++
 .../netplan/tests/yaml/exp-bridge-port.yaml   |  17 ++
 6 files changed, 283 insertions(+), 72 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/add-bridge.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-bridge-main.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-bridge-port.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 3aba9a2e6258bd0354546bf025c454552a4bfa76..40edf6febbc4632d4bba540a8abb4dffda4208a4 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -137,23 +137,18 @@ _cert_set_from_netplan (gpointer setting,
 
 /*****************************************************************************/
 
-#if 0
 static void
 check_if_bond_slave (NetplanNetDefinition *nd,
                      NMSettingConnection *s_con)
 {
-	gs_free char *value = NULL;
 	const char *v;
 	const char *master;
 
-	v = svGetValueStr (netplan, "MASTER_UUID", &value);
-	if (!v)
-		v = svGetValueStr (netplan, "MASTER", &value);
-
+	v = nd->bond;
 	if (v) {
 		master = nm_setting_connection_get_master (s_con);
 		if (master) {
-			PARSE_WARNING ("Already configured as slave of %s. Ignoring MASTER{_UUID}=\"%s\"",
+			PARSE_WARNING ("Already configured as slave of %s. Ignoring master \"%s\"",
 			               master, v);
 			return;
 		}
@@ -163,12 +158,7 @@ check_if_bond_slave (NetplanNetDefinition *nd,
 		              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
 		              NULL);
 	}
-
-	/* We should be checking for SLAVE=yes as well, but NM used to not set that,
-	 * so for backward-compatibility, we don't check.
-	 */
 }
-#endif
 
 #if 0  /* TODO: Implement (read) Team support  */
 static void
@@ -352,28 +342,23 @@ make_connection_setting (const char *file,
 	nm_clear_g_free (&value);
 #endif
 
-#if 0  /* TODO: Bridge UUIDs??? */
-	v = svGetValueStr (netplan, "BRIDGE_UUID", &value);
-	if (!v)
-		v = svGetValueStr (netplan, "BRIDGE", &value);
+	v = nd->bridge;
 	if (v) {
 		const char *old_value;
 
 		if ((old_value = nm_setting_connection_get_master (s_con))) {
-			PARSE_WARNING ("Already configured as slave of %s. Ignoring BRIDGE=\"%s\"",
+			PARSE_WARNING ("Already configured as slave of %s. Ignoring master \"%s\"",
 			               old_value, v);
 		} else {
-			g_object_set (s_con, NM_SETTING_CONNECTION_MASTER, v, NULL);
-			g_object_set (s_con, NM_SETTING_CONNECTION_SLAVE_TYPE,
-			              NM_SETTING_BRIDGE_SETTING_NAME, NULL);
+			g_object_set (s_con,
+			              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+			              NM_SETTING_CONNECTION_MASTER, v,
+			              NULL);
 		}
 	}
 
-	check_if_bond_slave (netplan, s_con);
-	check_if_team_slave (netplan, s_con);
-
-	nm_clear_g_free (&value);
-#endif
+	check_if_bond_slave (nd, s_con);
+	//check_if_team_slave (nd, s_con);
 
 #if 0  /* TODO: OVS support */
 	v = svGetValueStr (netplan, "OVS_PORT_UUID", &value);
@@ -2396,19 +2381,19 @@ make_bridge_setting (NetplanNetDefinition *nd,
 			g_object_set (s_bridge, NM_SETTING_BRIDGE_MAX_AGE,
 			              _nm_utils_ascii_str_to_int64 (nd->bridge_params.max_age, 10, 0, G_MAXUINT, -1),
 			              NULL);
-	}
 
-	//g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_PRIORITY, nd->bridge_params.port_priority, NULL);
-	//g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_PATH_COST, nd->bridge_params.path_cost, NULL);
+		if (nd->bridge_params.ageing_time)
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_AGEING_TIME,
+			              _nm_utils_ascii_str_to_int64 (nd->bridge_params.ageing_time, 10, 0, G_MAXUINT, -1),
+			              NULL);
+	}
 	
 #if 0  /* TODO: add the other bridge params */
-	g_object_set (s_bridge, NM_SETTING_BRIDGE_AGEING_TIME, nd->bridge_params.stp, NULL);
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_MULTICAST_SNOOPING, nd->bridge_params.stp, NULL);
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_FILTERING, nd->bridge_params.stp, NULL);
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, nd->bridge_params.stp, NULL);
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, nd->bridge_params.stp, NULL);
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, nd->bridge_params.stp, NULL);
-	g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, nd->bridge_params.stp, NULL);
 #endif
 
 	return (NMSetting *) g_steal_pointer (&s_bridge);
@@ -2468,38 +2453,37 @@ bridge_connection_from_netplan (const char *file,
 	return connection;
 }
 
-#if 0  /* TODO: bridge-port settings */
 static NMSetting *
 make_bridge_port_setting (NetplanNetDefinition *nd)
 {
 	NMSetting *s_port = NULL;
-	gs_free char *value_to_free = NULL;
-	const char *value;
+	g_return_val_if_fail (nd != NULL, FALSE);
 
-	g_return_val_if_fail (netplan != NULL, FALSE);
+	if (!nd->bridge)
+		return NULL;
 
-	value = svGetValueStr (netplan, "BRIDGE_UUID", &value_to_free);
-	if (!value)
-		value = svGetValueStr (netplan, "BRIDGE", &value_to_free);
-	if (value) {
-		nm_clear_g_free (&value_to_free);
+	s_port = nm_setting_bridge_port_new ();
 
-		s_port = nm_setting_bridge_port_new ();
-		value = svGetValueStr (netplan, "BRIDGING_OPTS", &value_to_free);
-		if (value) {
-			handle_bridging_opts (s_port, FALSE, value, handle_bridge_option, BRIDGE_OPT_TYPE_PORT_OPTION);
-			nm_clear_g_free (&value_to_free);
-		}
+	if (nd->bridge_params.path_cost)
+		g_object_set (s_port, NM_SETTING_BRIDGE_PORT_PATH_COST,
+		              nd->bridge_params.path_cost, NULL);
 
-		read_bridge_vlans (netplan,
-		                   "BRIDGE_PORT_VLANS",
-		                   s_port,
-		                   NM_SETTING_BRIDGE_PORT_VLANS);
-	}
+	if (nd->bridge_params.port_priority)
+		g_object_set (s_port, NM_SETTING_BRIDGE_PORT_PRIORITY,
+		              nd->bridge_params.port_priority, NULL);
+
+#if 0 /* TODO: bridge-port vlans need to be implemented in netplan */
+	read_bridge_vlans (netplan,
+	                   "BRIDGE_PORT_VLANS",
+	                   s_port,
+	                   NM_SETTING_BRIDGE_PORT_VLANS);
+
+	/* TODO: additional bridge-port settings */
+	//g_object_set (s_bridge, NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, nd->bridge_params.stp, NULL);
+#endif
 
 	return s_port;
 }
-#endif
 
 #if 0  /* TODO: Team device support */
 static NMSetting *
@@ -2705,8 +2689,8 @@ connection_from_file_full (const char *filename,
 	gs_free char *type = NULL;
 	//char *devtype, *bootproto;
 	NMSetting *s_ip4, *s_ip6;
-	//NMSetting *s_tc, *s_proxy, *s_port, *s_dcb = NULL, *s_user, *s_sriov;
-	NMSetting *s_match;
+	//NMSetting *s_tc, *s_proxy, *s_dcb = NULL, *s_user, *s_sriov;
+	NMSetting *s_match, *s_port;
 	const char *netplan_name = NULL;
 	gboolean ret;
 	GHashTableIter iter;
@@ -2906,7 +2890,6 @@ connection_from_file_full (const char *filename,
 	s_ip4 = make_ip4_setting (netdef, error);
 	if (!s_ip4)
 		return NULL;
-
 	nm_connection_add_setting (connection, s_ip4);
 	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
 
@@ -2915,6 +2898,11 @@ connection_from_file_full (const char *filename,
 		nm_connection_add_setting (connection, s_match);
 	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
 
+	s_port = make_bridge_port_setting (netdef);
+	if (s_port)
+		nm_connection_add_setting (connection, s_port);
+	_LOGT ("netplan conn %p : %s", connection, nm_connection_get_uuid(connection));
+
 	if (netdef->ip_rules)
 		read_routing_rules (netdef,
 		                    NM_SETTING_IP_CONFIG (s_ip4),
@@ -2937,10 +2925,6 @@ connection_from_file_full (const char *filename,
 	if (s_user)
 		nm_connection_add_setting (connection, s_user);
 
-	s_port = make_bridge_port_setting (main_netplan);
-	if (s_port)
-		nm_connection_add_setting (connection, s_port);
-
 	s_port = make_team_port_setting (main_netplan);
 	if (s_port)
 		nm_connection_add_setting (connection, s_port);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 399550574610c343c105f44143f9b5b1dca9dbbc..b6817f33ec692bd0b551e72b1df2d2e27e2b4647 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1788,25 +1788,33 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 {
 	// TODO: Probably needs reorg in netplan to support in member device bond/bridge params.
 	NMSettingBridgePort *s_port;
+	NMSettingConnection *s_con;
 	guint32 i;
 	GString *string;
+	const char *master, *iface;
 
+	s_con = nm_connection_get_setting_connection (connection);
 	s_port = nm_connection_get_setting_bridge_port (connection);
 	if (!s_port)
 		return TRUE;
 
+	iface = nm_setting_connection_get_interface_name (s_con);
+	if (!iface) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_CONNECTION_INTERFACE_NAME);
+		return FALSE;
+	}
+
 	/* Bridge options */
 	string = g_string_sized_new (32);
 
 	i = nm_setting_bridge_port_get_priority (s_port);
 	if (i != get_setting_default_uint (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PRIORITY))
-		g_string_append_printf (string, "        priority: %u", i);
+		g_string_append_printf (string, "        port-priority:\n          %s: %u\n", iface, i);
 
 	i = nm_setting_bridge_port_get_path_cost (s_port);
 	if (i != get_setting_default_uint (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PATH_COST)) {
-		if (string->len)
-			g_string_append_c (string, ' ');
-		g_string_append_printf (string, "        path-cost: %u", i);
+		g_string_append_printf (string, "        path-cost:\n          %s: %u\n", iface, i);
 	}
 
 #if 0 // TODO: need hairpin mode support in networkd/netplan
@@ -1817,9 +1825,18 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 	}
 #endif
 
-	if (string->len)
+	master = nm_setting_connection_get_master (s_con);
+	if (!master) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Missing '%s' setting", NM_SETTING_CONNECTION_MASTER);
+		return FALSE;
+	}
+
+	if (string->len) {
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-				        "      parameters:\n%s", string->str);
+		                        "  bridges:\n    %s:\n      interfaces: [%s]\n      parameters:\n%s",
+		                        master, iface, string->str);
+	}
 	g_string_free (string, TRUE);
 
 	if (!write_bridge_vlans ((NMSetting *) s_port,
@@ -3031,9 +3048,6 @@ do_write_construct (NMConnection *connection,
 		return FALSE;
 	}
 
-	if (!write_bridge_port_setting (connection, netplan, error))
-		return FALSE;
-
 	//if (!write_team_port_setting (connection, netplan, error))
 	//	return FALSE;
 
@@ -3146,6 +3160,15 @@ do_write_construct (NMConnection *connection,
 
 	write_connection_setting (s_con, netplan);
 
+	/**
+	 * Write bridge-port settings, by adding the master bridge interface
+	 * to the YAML. It will be merged with its own YAML definition, when
+	 * the YAML files are read and combined/merged.
+	 * This adds a new "bridges:" section to the YAML, so this code needs
+	 * to run after all settings for the current netdef have been written. */
+	if (!write_bridge_port_setting (connection, netplan, error))
+		return FALSE;
+
 	//NM_SET_OUT (out_netplan, g_steal_pointer (&netplan));
 	return TRUE;
 }
@@ -3310,7 +3333,7 @@ nms_netplan_writer_can_write_connection (NMConnection *connection, GError **erro
 	                  NM_SETTING_GSM_SETTING_NAME,
 	                  NM_SETTING_CDMA_SETTING_NAME,
 	                  NM_SETTING_BOND_SETTING_NAME,
-	                  NM_SETTING_TEAM_SETTING_NAME,
+	                  //NM_SETTING_TEAM_SETTING_NAME,
 	                  NM_SETTING_BRIDGE_SETTING_NAME))
 		return TRUE;
 	if (nm_streq0 (type, NM_SETTING_WIRED_SETTING_NAME)
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index e459573eb5554ff76e7c87cf7c885efe190b79fa..9420faf3f93900ae0411bf6d6e5d2001afc4b2c5 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -613,6 +613,165 @@ test_wifi_wowlan_mac_randomization (void)
 	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
 }
 
+static void
+test_write_bridge_main (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingBridge *s_bridge;
+	NMSettingIPConfig *s_ip4, *s_ip6;
+	NMSettingWired *s_wired;
+	NMIPAddress *addr;
+	static const char *mac = "31:33:33:37:be:cd";
+	GError *error = NULL;
+	gs_unref_ptrarray GPtrArray *vlans = NULL;
+	NMBridgeVlan *vlan;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Main",
+	              NM_SETTING_CONNECTION_UUID, "965e4838-253f-4291-9eda-6bb46cd4b6c8",
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "br0",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+
+	/* bridge setting */
+	s_bridge = (NMSettingBridge *) nm_setting_bridge_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_bridge));
+
+	/* XXX: Needs to be implemented in netplan
+	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+	vlan = nm_bridge_vlan_new (10, 16);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (22, 22);
+	nm_bridge_vlan_set_pvid (vlan, TRUE);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (44, 0);
+	g_ptr_array_add (vlans, vlan);
+	*/
+
+	g_object_set (s_bridge,
+	              NM_SETTING_BRIDGE_MAC_ADDRESS, mac,
+	              NM_SETTING_BRIDGE_AGEING_TIME, 100,
+	              NM_SETTING_BRIDGE_PRIORITY, 1024,
+	              //NM_SETTING_BRIDGE_PORT_PRIORITY, 1,
+	              NM_SETTING_BRIDGE_FORWARD_DELAY, 10,
+	              NM_SETTING_BRIDGE_HELLO_TIME, 5,
+	              NM_SETTING_BRIDGE_MAX_AGE, 10,
+	              //NM_SETTING_BRIDGE_PORT_PATH_COST, 1,
+	              NM_SETTING_BRIDGE_STP, TRUE,
+	              /* XXX: Needs to be implemented in netplan
+	              NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, 19008,
+	              NM_SETTING_BRIDGE_VLAN_FILTERING, TRUE,
+	              NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, 4000,
+	              NM_SETTING_BRIDGE_VLANS, vlans,
+	              */
+	              NULL);
+
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_verifies_without_normalization (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+							TEST_NETPLAN_DIR"/exp-bridge-main.yaml",
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_bridge_port (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSetting *s_port;
+	static const char *mac = "de:ad:be:ef:ca:fe";
+	//gs_unref_ptrarray GPtrArray *vlans = NULL;
+	//NMBridgeVlan *vlan;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Port",
+	              NM_SETTING_CONNECTION_UUID, "d146971d-c5f4-4452-95f7-b8e9b9e4e310",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "br0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NM_SETTING_CONNECTION_INTERFACE_NAME, "slave0",
+	              NULL);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+	g_object_set (s_wired,
+	              //NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_NONE,
+	              NULL);
+
+	/* TODO: Needs to be implemented in netplan
+	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+	vlan = nm_bridge_vlan_new (1, 0);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (4, 4094);
+	nm_bridge_vlan_set_untagged (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	vlan = nm_bridge_vlan_new (2, 2);
+	nm_bridge_vlan_set_pvid (vlan, TRUE);
+	g_ptr_array_add (vlans, vlan);
+	*/
+
+	/* Bridge port */
+	s_port = nm_setting_bridge_port_new ();
+	nm_connection_add_setting (connection, s_port);
+	g_object_set (s_port,
+	              NM_SETTING_BRIDGE_PORT_PRIORITY, 50,
+	              NM_SETTING_BRIDGE_PORT_PATH_COST, 33,
+	              //NM_SETTING_BRIDGE_PORT_VLANS, vlans, // XXX: Not implemented in netplan
+	              NULL);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection_no_reread (connection,
+	                                  TEST_SCRATCH_DIR_TMP,
+	                                  &testfile,
+	                                  TEST_NETPLAN_DIR"/exp-bridge-port.yaml");
+	/* Manually re-read with added (dummy) bridge iface, to make the
+	 * netplan parser happy. Explicitly choose the "slave0" netdef. */
+	reread = _connection_from_file (testfile,
+	                                TEST_NETPLAN_DIR"/add-bridge.yaml",
+									"slave0",
+	                                NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_write_vlan (void)
 {
@@ -1189,11 +1348,14 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
 
-	g_test_add_func (TPATH "vlan/write/main" , test_write_vlan);
+	g_test_add_func (TPATH "bridge/write/main", test_write_bridge_main);
+	g_test_add_func (TPATH "bridge/write/port", test_write_bridge_port);
+
+	g_test_add_func (TPATH "vlan/write/main", test_write_vlan);
 
-	g_test_add_func (TPATH "bond/write/main" , test_write_bond_main);
-	g_test_add_func (TPATH "bond/write/rr" , test_write_bond_rr);
-	g_test_add_func (TPATH "bond/write/lacp" , test_write_bond_lacp);
+	g_test_add_func (TPATH "bond/write/main", test_write_bond_main);
+	g_test_add_func (TPATH "bond/write/rr", test_write_bond_rr);
+	g_test_add_func (TPATH "bond/write/lacp", test_write_bond_lacp);
 
 	g_test_add_func (TPATH "modem/write/gsm-auto-eui64", test_write_modem_gsm_auto_eui64);
 	g_test_add_func (TPATH "modem/write/gsm", test_write_modem_gsm);
diff --git a/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml b/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..652900b3edcac19891f5a6d404ce63920f495acf
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml
@@ -0,0 +1,5 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  bridges:
+    br0: {dhcp4:true, dhcp6:true}
\ No newline at end of file
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bridge-main.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bridge-main.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..61451d11b808c42c01b6e1650b5ef61ceae60742
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bridge-main.yaml
@@ -0,0 +1,20 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  bridges:
+    br0:
+      macaddress: 31:33:33:37:BE:CD
+      parameters:
+        stp: yes
+        forward-delay: 10
+        priority: 1024
+        hello-time: 5
+        max-age: 10
+        ageing-time: 100
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write Bridge Main
+        uuid: 965e4838-253f-4291-9eda-6bb46cd4b6c8
+        device: br0
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-bridge-port.yaml b/src/settings/plugins/netplan/tests/yaml/exp-bridge-port.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..47552045fd1f473860862a4cab7d5f4c1fb4427f
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-bridge-port.yaml
@@ -0,0 +1,17 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  ethernets:
+    slave0:
+      networkmanager:
+        name: Test Write Bridge Port
+        uuid: d146971d-c5f4-4452-95f7-b8e9b9e4e310
+        device: slave0
+  bridges:
+    br0:
+      interfaces: [slave0]
+      parameters:
+        port-priority:
+          slave0: 50
+        path-cost:
+          slave0: 33
-- 
2.25.1


From 06d17c879e586e26d3a9009f31671d89e2154dc6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 24 Apr 2020 17:24:32 +0200
Subject: [PATCH 53/78] netplan: improve bridge-port test

---
 src/settings/plugins/netplan/nms-netplan-writer.c |  4 +++-
 src/settings/plugins/netplan/tests/test-netplan.c | 15 ++++++++++++---
 .../netplan/tests/yaml/add-base-iface.yaml        |  2 +-
 .../plugins/netplan/tests/yaml/add-bridge.yaml    | 11 ++++++++++-
 4 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index b6817f33ec692bd0b551e72b1df2d2e27e2b4647..1bbedf9448ae910cc32473b2805fe909bbcc79a9 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -1786,7 +1786,9 @@ write_bridge_setting (NMConnection *connection, GOutputStream *netplan, GError *
 static gboolean
 write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
-	// TODO: Probably needs reorg in netplan to support in member device bond/bridge params.
+	/* XXX: Might need reorg in netplan to support in member device bond/bridge params.
+	 *   We need to make sure bridge-port params do not get overwritten in netplan, when
+	 *   multiple YAML files are read, which define the same bridge master ID. */
 	NMSettingBridgePort *s_port;
 	NMSettingConnection *s_con;
 	guint32 i;
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 9420faf3f93900ae0411bf6d6e5d2001afc4b2c5..48c0e3d2b2ed160531fa008fcf75807625212ef7 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -706,7 +706,7 @@ test_write_bridge_port (void)
 	NMSettingConnection *s_con;
 	NMSettingWired *s_wired;
 	NMSetting *s_port;
-	static const char *mac = "de:ad:be:ef:ca:fe";
+	guint32 i;
 	//gs_unref_ptrarray GPtrArray *vlans = NULL;
 	//NMBridgeVlan *vlan;
 
@@ -730,7 +730,6 @@ test_write_bridge_port (void)
 	s_wired = (NMSettingWired *) nm_setting_wired_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_wired));
 	g_object_set (s_wired,
-	              //NM_SETTING_WIRED_MAC_ADDRESS, mac,
 	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_NONE,
 	              NULL);
 
@@ -768,8 +767,18 @@ test_write_bridge_port (void)
 	                                TEST_NETPLAN_DIR"/add-bridge.yaml",
 									"slave0",
 	                                NULL);
-
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+
+	/* Re-read again, to verify the bridge-port parameters of "slave1"
+	 * (from "add-bridge.yaml") still exist and were not overwritten. */
+	reread = _connection_from_file (testfile,
+	                                TEST_NETPLAN_DIR"/add-bridge.yaml",
+									"slave1",
+	                                NULL);
+	s_port = NM_SETTING (nm_connection_get_setting_bridge_port (reread));
+	g_assert_true (s_port);
+	i = nm_setting_bridge_port_get_priority (NM_SETTING_BRIDGE_PORT(s_port));
+	g_assert_cmpint (i, ==, 44);
 }
 
 static void
diff --git a/src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml b/src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml
index cb5f2a2303c4753f7eff5e53a8d1aa98db59b215..bb53d2ab68f1362f7b3efe7473de7cea201ab888 100644
--- a/src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/add-base-iface.yaml
@@ -2,4 +2,4 @@ network:
   version: 2
   renderer: NetworkManager
   ethernets:
-    eno1: {dhcp4:true, dhcp6:true}
\ No newline at end of file
+    eno1: {dhcp4: true, dhcp6: true}
diff --git a/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml b/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml
index 652900b3edcac19891f5a6d404ce63920f495acf..f2c32745dcc647f81b586e9166170319c53dd6ff 100644
--- a/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/add-bridge.yaml
@@ -1,5 +1,14 @@
 network:
   version: 2
   renderer: NetworkManager
+  ethernets:
+    slave1: {dhcp4: no}
   bridges:
-    br0: {dhcp4:true, dhcp6:true}
\ No newline at end of file
+    br0:
+      dhcp4: true
+      dhcp6: true
+      interfaces:
+      - slave1
+      parameters:
+        port-priority:
+          slave1: 44
-- 
2.25.1


From d98958e3dfe7988097ddb0d5ef621e13bf6a4745 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 27 Apr 2020 17:40:49 +0200
Subject: [PATCH 54/78] netplan: more WiFi testing

---
 .../plugins/netplan/tests/test-netplan.c      | 52 +++++++++++++++++++
 .../netplan/tests/yaml/exp-wifi-main.yaml     | 17 ++++++
 2 files changed, 69 insertions(+)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml

diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 48c0e3d2b2ed160531fa008fcf75807625212ef7..363586ec5553012c6d490ee1ccda2168ecd2cdb3 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -469,6 +469,57 @@ test_read_write_wired_dhcp_send_hostname (void)
 	g_assert_cmpstr (nm_setting_ip_config_get_dhcp_hostname (s_ip6), ==, dhcp_hostname);
 }
 
+static void
+test_write_wifi_main (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	GBytes *ssid;
+	guint32 mtu = 1492;
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write WiFi Main",
+	              NM_SETTING_CONNECTION_UUID, "d5515a99-c7f1-4fd3-bc49-ecfd5ba01c93",
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wireless setting */
+	s_wireless = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wireless));
+	ssid = g_bytes_new ("open-net", 8);
+	g_object_set (s_wireless,
+	              NM_SETTING_WIRELESS_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
+	              NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS, "00:11:22:33:44:55",
+	              NM_SETTING_WIRELESS_MTU, mtu,
+	              NM_SETTING_WIRELESS_MODE, NM_SETTING_WIRELESS_MODE_AP,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NULL);
+
+	/* Add generic IP4/6 DHCP settings. */
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_NETPLAN_DIR"/exp-wifi-main.yaml",
+	                        &testfile);
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	//nm_connection_add_setting (connection, nm_setting_proxy_new ());
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_write_wifi_band_a (void)
 {
@@ -1353,6 +1404,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/routes", test_write_wired_static_routes);
 	g_test_add_func (TPATH "wired/write/routing-policy", test_write_routing_rules);
 
+	g_test_add_func (TPATH "wifi/write/main", test_write_wifi_main);
 	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..2e76727d347155e4ea4c9a21d2a3136781d6f54d
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml
@@ -0,0 +1,17 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  wifis:
+    NM-d5515a99-c7f1-4fd3-bc49-ecfd5ba01c93:
+      match: { macaddress: DE:AD:BE:EF:CA:FE }
+      macaddress: 00:11:22:33:44:55
+      mtu: 1492
+      access-points:
+        open-net:
+          mode: ap
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write WiFi Main
+        uuid: d5515a99-c7f1-4fd3-bc49-ecfd5ba01c93
-- 
2.25.1


From 5a0d832081f1041d5fac2a8de9324f05be3c608d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 28 Apr 2020 16:14:13 +0200
Subject: [PATCH 55/78] netplan: WiFi auth mode wpa-eap / tls

---
 .../plugins/netplan/nms-netplan-reader.c      |  92 ++++++++++++--
 .../plugins/netplan/nms-netplan-writer.c      |  86 +++++++++----
 .../netplan/tests/netplan-test-utils.h        |   4 +
 .../plugins/netplan/tests/test-netplan.c      | 120 +++++++++++++++++-
 .../netplan/tests/yaml/exp-wifi-main.yaml     |   5 +-
 .../netplan/tests/yaml/test1_key_and_cert.pem | 118 +++++++++++++++++
 .../netplan/tests/yaml/test_ca_cert.pem       |  27 ++++
 .../netplan/tests/yaml/test_client.p12        | Bin 0 -> 2848 bytes
 8 files changed, 413 insertions(+), 39 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
 create mode 100644 src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem
 create mode 100644 src/settings/plugins/netplan/tests/yaml/test_client.p12

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 40edf6febbc4632d4bba540a8abb4dffda4208a4..c121cb610b027cf5851bd8efb9c195bb64b70066 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1532,16 +1532,78 @@ parse_wpa_psk (NetplanWifiAccessPoint *ap,
 
 static NMSetting8021x *
 fill_8021x (NetplanNetDefinition *nd,
+            NetplanWifiAccessPoint *ap,
             const char *file,
             const char *key_mgmt,
             gboolean wifi,
             GError **error)
 {
 	gs_unref_object NMSetting8021x *s_8021x = NULL;
+	NetplanAuthEAPMethod method = NETPLAN_AUTH_EAP_NONE;
+	const char *value = NULL, *pass = NULL;
+	NetplanAuthenticationSettings auth = nd->auth;
 
 	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
 
+	if (wifi && ap) {
+		auth = ap->auth;
+	}
+
 	// TODO: read 802.1x settings from hashtable keys (just mapping values already in netplan structures)
+	method = auth.eap_method;
+	switch (method) {
+		case NETPLAN_AUTH_EAP_TLS:
+			nm_setting_802_1x_add_eap_method (s_8021x, "tls");
+			break;
+		case NETPLAN_AUTH_EAP_PEAP:
+			nm_setting_802_1x_add_eap_method (s_8021x, "peap");
+			break;
+		case NETPLAN_AUTH_EAP_TTLS:
+			nm_setting_802_1x_add_eap_method (s_8021x, "ttls");
+			break;
+		default:
+			// TODO: set a corresponding error/warning
+			return NULL;
+	}
+
+	value = auth.identity;
+	if (value)
+		g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, value, NULL);
+
+	value = auth.anonymous_identity;
+	if (value)
+		g_object_set (s_8021x, NM_SETTING_802_1X_ANONYMOUS_IDENTITY, value, NULL);
+
+	value = auth.password;
+	if (value)
+		g_object_set (s_8021x, NM_SETTING_802_1X_PASSWORD, value, NULL);
+
+
+	value = auth.ca_certificate;
+	if (value)
+		nm_setting_802_1x_set_ca_cert (s_8021x,
+		                               value,
+		                               NM_SETTING_802_1X_CK_SCHEME_PATH,
+		                               NULL,
+		                               error);
+
+	value = auth.client_certificate;
+	if (value)
+		nm_setting_802_1x_set_client_cert (s_8021x,
+		                                   value,
+		                                   NM_SETTING_802_1X_CK_SCHEME_PATH,
+		                                   NULL,
+		                                   error);
+
+	value = auth.client_key;
+	pass = auth.client_key_password;
+	if (value && pass)
+		nm_setting_802_1x_set_private_key (s_8021x,
+	                                       value,
+	                                       pass,
+	                                       NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                       NULL,
+	                                       error);
 
 	return g_steal_pointer (&s_8021x);
 }
@@ -1598,24 +1660,28 @@ make_wpa_setting (NetplanNetDefinition *nd,
 			nm_setting_wireless_security_add_proto (wsec, "rsn");
 		/* Else: Stay with the default, i.e.: wpa;rsn; */
 
-		if (ap->auth.password) {
-			gs_free char *psk = NULL;
-			psk = parse_wpa_psk (val, file, ssid, &local);
-			if (psk)
-				g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
-			else if (local) {
+		if (ap->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK) {
+			if (ap->auth.password) {
+				gs_free char *psk = NULL;
+				psk = parse_wpa_psk (val, file, ssid, &local);
+				if (psk)
+					g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_PSK, psk, NULL);
+				else if (local) {
+					g_propagate_error (error, local);
+					return NULL;
+				}
+			}
+			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
+		} else {
+			*s_8021x = fill_8021x (nd, ap, file, v, TRUE, &local);
+			if (!*s_8021x) {
 				g_propagate_error (error, local);
 				return NULL;
 			}
-		}
-
-		if (ap->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK)
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk", NULL);
-		else {
 			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
 		}
 	} else {
-		*s_8021x = fill_8021x (nd, file, v, TRUE, error);
+		*s_8021x = fill_8021x (nd, NULL, file, v, TRUE, error);
 		if (!*s_8021x)
 			return NULL;
 	}
@@ -2156,7 +2222,7 @@ make_wired_setting (NetplanNetDefinition *nd,
 		found = TRUE;
 	if (cvalue && cvalue[0] != '\0') {
 		if (!strcmp (cvalue, "IEEE8021X")) {
-			*s_8021x = fill_8021x (netplan, file, cvalue, FALSE, error);
+			*s_8021x = fill_8021x (netplan, NULL, file, cvalue, FALSE, error);
 			if (!*s_8021x)
 				return NULL;
 		} else {
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 1bbedf9448ae910cc32473b2805fe909bbcc79a9..6e7e392657e70227f630b8d4247d4ad3a59b2321 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -395,7 +395,6 @@ write_8021x_certs (NMSetting8021x *s_8021x,
 }
 #endif  /* GCC magic */
 
-#if 0  /* temp disable: unused?? */
 static gboolean
 write_8021x_setting (NMConnection *connection,
                      GOutputStream *netplan,
@@ -423,7 +422,7 @@ write_8021x_setting (NMConnection *connection,
 	/* If wired, write KEY_MGMT */
 	if (wired)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
-				        "        key-management: %s\n", "802.1x");
+		                        "            key-management: %s\n", "802.1x");
 
 	/* EAP method */
 	if (nm_setting_802_1x_get_num_eap_methods (s_8021x)) {
@@ -432,25 +431,27 @@ write_8021x_setting (NMConnection *connection,
 		// See eap_methods_table  in libnm-core/nm-setting-8021x.c
 		if (!g_strcmp0(value, "peap") || !g_strcmp0(value, "tls") || !g_strcmp0(value, "ttls")) {
 			g_output_stream_printf (netplan, 0, NULL, NULL,
-					        "        method: %s\n", value);
+			                        "            method: %s\n", value);
 		} else {
 			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
 			             "Unsupported '%s' method in netplan", value);
+			return FALSE;
 		}
-		return FALSE;
 	}
 
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        identity: %s\n",
-	                        nm_setting_802_1x_get_identity (s_8021x));
-
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        anonymous-identity: %s\n",
-	                        nm_setting_802_1x_get_anonymous_identity (s_8021x));
+	value = nm_setting_802_1x_get_identity (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            identity: %s\n", value);
+	value = nm_setting_802_1x_get_anonymous_identity (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            anonymous-identity: %s\n", value);
 
-	g_output_stream_printf (netplan, 0, NULL, NULL,
-			        "        password: %s\n",
-			        nm_setting_802_1x_get_password(s_8021x));
+	value = nm_setting_802_1x_get_password (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            password: %s\n", value);
 
 #if 0 // TODO: 802.1x use set_secret instead of g_output_stream_printf()...
 	set_secret (netplan,
@@ -591,9 +592,27 @@ write_8021x_setting (NMConnection *connection,
 		return FALSE;
 #endif
 
+	value = nm_setting_802_1x_get_ca_cert_path (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            ca-certificate: %s\n", value);
+
+	value = nm_setting_802_1x_get_client_cert_path (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            client-certificate: %s\n", value);
+
+	value = nm_setting_802_1x_get_private_key_path (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            client-key: %s\n", value);
+
+	value = nm_setting_802_1x_get_private_key_password (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            client-key-password: %s\n", value);
 	return TRUE;
 }
-#endif
 
 static gboolean
 write_wireless_security_setting (NMConnection *connection,
@@ -605,7 +624,7 @@ write_wireless_security_setting (NMConnection *connection,
 	NMSettingWirelessSecurity *s_wsec;
 	const char *key_mgmt, *key; //, *auth_alg, *proto, *cipher;
 	const char *psk = NULL;
-	gboolean wep = FALSE, wpa = FALSE; //, dynamic_wep = FALSE;
+	gboolean wep = FALSE, wpa = FALSE, wpa_psk = FALSE; //, dynamic_wep = FALSE;
 	//NMSettingWirelessSecurityWpsMethod wps_method;
 	guint32 i;  //, num;
 	//GString *str;
@@ -630,16 +649,23 @@ write_wireless_security_setting (NMConnection *connection,
 	} else if (!strcmp (key_mgmt, "wpa-psk")) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: psk\n");
 		wpa = TRUE;
+		wpa_psk = TRUE;
+	/* TODO: Implement wireless auth SAE mode in netplan
 	} else if (!strcmp (key_mgmt, "sae")) {
-		// TODO: Implement wireless auth SAE mode in netplan
 		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: sae\n");
 		wpa = TRUE;
+	*/
 	} else if (!strcmp (key_mgmt, "ieee8021x")) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: 802.1x\n");
 		//dynamic_wep = TRUE;
 	} else if (!strcmp (key_mgmt, "wpa-eap")) {
 		g_output_stream_printf(netplan, 0, NULL, NULL, "            key-management: eap\n");
 		wpa = TRUE;
+	} else if (key_mgmt != NULL) {
+		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+		             "Invalid key_mgmt '%s' in '%s' setting",
+		             key_mgmt, NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+		return FALSE;
 	}
 
 #if 0 // TODO: Unravel this SECURITYMODE story: restricted | open | leap ???
@@ -776,14 +802,26 @@ write_wireless_security_setting (NMConnection *connection,
 	g_string_free (str, TRUE);
 #endif
 
-	if (wpa)
+	if (wpa_psk) {
 		psk = nm_setting_wireless_security_get_psk (s_wsec);
-
-	// XXX: Should be using set_secret() here?
-	// FIXME: Add quotes IFF type=WPA-PSK AND length=8-63, otherwise 64 HEX chars
-	//        see: https://github.com/CanonicalLtd/netplan/commit/2427ab267b24daa3504345be4ee6be7f286056a3
-	g_output_stream_printf(netplan, 0, NULL, NULL,
-			       "          password: %s\n", psk);
+		if (!nm_utils_wpa_psk_valid (psk)) {
+			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
+			             "Invalid psk '%s' in '%s' setting",
+			             key_mgmt, NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+			return FALSE;
+		}
+		// XXX: Should be using set_secret() here?
+		g_output_stream_printf(netplan, 0, NULL, NULL,
+		                       "          password: \"%s\"\n", psk);
+	} else if (wpa) {
+		if (!write_8021x_setting (connection,
+		                          netplan,
+		                          secrets,
+		                          NULL, //GHashTable *blobs,
+		                          FALSE,
+		                          error))
+			return FALSE;
+	}
 
 #if 0 // TODO: wireless security: implement PMF and FILS support
 	if (nm_setting_wireless_security_get_pmf (s_wsec) == NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT)
diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
index 2245d69cecabe210a8c787d5c63ee83f92dff410..1f44ceacca07296daa91ce141d44ed13db29367a 100644
--- a/src/settings/plugins/netplan/tests/netplan-test-utils.h
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -55,6 +55,10 @@
 #define TEST_SCRATCH_DIR        NM_BUILD_BUILDDIR"/src/settings/plugins/netplan/tests/yaml"
 #define TEST_SCRATCH_DIR_TMP    TEST_SCRATCH_DIR"/tmp"
 
+#define TEST_NETPLAN_WIFI_WPA_EAP_TLS_CA_CERT TEST_NETPLAN_DIR"/test_ca_cert.pem"
+#define TEST_NETPLAN_WIFI_WPA_EAP_TLS_CLIENT_CERT TEST_NETPLAN_DIR"/test1_key_and_cert.pem"
+#define TEST_NETPLAN_WIFI_WPA_EAP_TLS_PRIVATE_KEY TEST_NETPLAN_DIR"/test1_key_and_cert.pem"
+
 /*****************************************************************************/
 
 #define _NMLOG_DOMAIN      LOGD_SETTINGS
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 363586ec5553012c6d490ee1ccda2168ecd2cdb3..787ebd91572044f2d0492aa8468f9987ab705bd7 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -477,6 +477,7 @@ test_write_wifi_main (void)
 	gs_unref_object NMConnection *reread = NULL;
 	NMSettingConnection *s_con;
 	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 	GBytes *ssid;
@@ -497,7 +498,7 @@ test_write_wifi_main (void)
 	/* Wireless setting */
 	s_wireless = (NMSettingWireless *) nm_setting_wireless_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_wireless));
-	ssid = g_bytes_new ("open-net", 8);
+	ssid = g_bytes_new ("my-net", 6);
 	g_object_set (s_wireless,
 	              NM_SETTING_WIRELESS_MAC_ADDRESS, "de:ad:be:ef:ca:fe",
 	              NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS, "00:11:22:33:44:55",
@@ -506,6 +507,13 @@ test_write_wifi_main (void)
 	              NM_SETTING_WIRELESS_SSID, ssid,
 	              NULL);
 
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
+	              NM_SETTING_WIRELESS_SECURITY_PSK, "s0s3cr3t",
+	              NULL);
+
 	/* Add generic IP4/6 DHCP settings. */
 	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 	nmtst_assert_connection_verifies (connection);
@@ -520,6 +528,115 @@ test_write_wifi_main (void)
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
+static void
+test_write_wifi_wpa_eap_tls (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	gboolean success;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TLS",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap",
+	              /* XXX: Needs to be implemented in netplan
+	              NM_SETTING_WIRELESS_SECURITY_FILS, (int) NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,*/
+	              NULL);
+
+	/* XXX: Needs to be implemented in netplan
+	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	nm_setting_wireless_security_add_group (s_wsec, "tkip");
+	*/
+
+	/* Wireless security setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, "Bill Smith", NULL);
+	/* XXX: Needs to be implemented in netplan
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_PHASE1_AUTH_FLAGS,
+	              (guint) (NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE |
+	                       NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE),
+	              NULL);
+	*/
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "tls");
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_NETPLAN_WIFI_WPA_EAP_TLS_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	success = nm_setting_802_1x_set_client_cert (s_8021x,
+	                                             TEST_NETPLAN_WIFI_WPA_EAP_TLS_CLIENT_CERT,
+	                                             NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                             NULL,
+	                                             &error);
+	nmtst_assert_success (success, error);
+
+	success = nm_setting_802_1x_set_private_key (s_8021x,
+	                                             TEST_NETPLAN_WIFI_WPA_EAP_TLS_PRIVATE_KEY,
+	                                             "test1",
+	                                             NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                             NULL,
+	                                             &error);
+	nmtst_assert_success (success, error);
+
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_write_wifi_band_a (void)
 {
@@ -1405,6 +1522,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wired/write/routing-policy", test_write_routing_rules);
 
 	g_test_add_func (TPATH "wifi/write/main", test_write_wifi_main);
+	g_test_add_func (TPATH "wifi/write/eap-tls", test_write_wifi_wpa_eap_tls);
 	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml
index 2e76727d347155e4ea4c9a21d2a3136781d6f54d..8320780e9b29d031a16c2242ff37c4d6dd027c6e 100644
--- a/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wifi-main.yaml
@@ -7,8 +7,11 @@ network:
       macaddress: 00:11:22:33:44:55
       mtu: 1492
       access-points:
-        open-net:
+        my-net:
           mode: ap
+          auth:
+            key-management: psk
+          password: "s0s3cr3t"
       dhcp4: yes
       dhcp6: yes
       ipv6-address-generation: stable-privacy
diff --git a/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem b/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
new file mode 100644
index 0000000000000000000000000000000000000000..dec9aa1b8fd7eb3a369f1cb6033e8e79bdbd297c
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
@@ -0,0 +1,118 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: DES-EDE3-CBC,4DE0615F23D82107
+
+QPNCO5Dobvz9dDhN32KkZRoEifW+HDm2PCbRQhKDiscGwB6LgypvVjHNsZiFKwzz
+L4R51UqgQeJx7GSGJqE626e9z9J+UNBhop02aOO2X0eSPdvBzr/uJ6Umiyr1xqD7
+zWf7u9l5kXElDJRhK+87GMBewp4Ie9NeXDjhF8hzC5Kiulen4AH3AYnfH3S7DimU
+h8GFMg8inrudrTbcjBhCdPeHG2jCygOxw3InRFz7uaN6LIhOaPQvmvpP4Cc1WRnW
+ZPq9o+eU3fPWPD5t+Op/VzYLvKwgBy/yK1rQXUm6ZMO7MhhRJ94ZCsJv+nVWpJlv
+QyBlxDKxwfkfYbDELdnnDQdHdMbKatLqa0KhSkgpp8LywBtanPz731tyT0r7b3na
+eLdra59lRU7ZQLPEdS3lPZd2O/KQvWf8wbg7MjXS9LxQ7R5HOPu6DNJlwXVZBmmo
+cAfu2q8ubU2IePvWLD1GOrBi6hE9TiGvFJkw+wBK+t72sz3njv9Xm/zlxruaEk5m
+RW/kybU3FP4PtjriBbskz3/VZaaxuRN7OoOYTkmyHmG1ADgcRUV6fea19qqsBlN8
+xb+SRtoH28oT/JVWU5neE2dbNzk5LeVO+w70NNdR5s5xqkBhbGGaJxvXwNP4ltFr
+T06SMh8znOLKwWB00aRtwfU7jOwR3mOleQO4ugIHmau3zp1TqzAHW8XtpuV7qVeI
+ESZOZuf0vW43BtNzgLXt1+r+bmsMsRwhnyomL9M0TUyyBdVYY9GkzTG9pOESheRo
+RSvAZ8qKGUliTpgBcbt2v1+NqkszcHa6FxuvS8YU4uo5/GqsgTxHTNIB232hIrrZ
+EIm6QL9TC5oFXMjy6UNqoCm5Nb8DBJ6aErt7pt7aoktqUW3O3QIzQT3IbZ4nAcTt
+lVF4d7j29I9t7bcC8GOVU1neilguZUss4ghJg9x4zI5UZdR7hZ8fbFT47TyxB+j5
+r0YdmjbjVTaSyaN2JGh1wvb4TzawGNVx/U2EJE16HigOtPfsfQRJ3x+FROKBdVa4
+aIFYXkRBeIPxX6n9pcw0lBCsnXo6/5iTjQSk2VqO3rHO/wyWiEjNczhL33dY2A8W
+GG5ECMO5SqXZHQQzpABqK94dxe3UC8aEESO5NhEqDuV7qQGol0qPKrUA3wb0jb2e
+DrejJ9HS2m1SUDmjpvvmEGy6GN7CRibbKt5rNZdJNNvWArOF5d0F6wkixQLl73oE
+lq5gLQQk9n7ClleKLhlQpBCorxilBbzmSUekkJLi0eaZiBBFWBX9udqnUZloXTgO
+8qwuO8K/GPR9Jy1/UH2Vh1H+wivaqKTVgEb0NotzgzECgTEFKJafl7rUNs1OZRZ3
+VBjevi6+iDpxVFgF71kXfdUC4ph0E1XDl0ja2rrKQGivMkUhWJ57+4EV5+hBkAnt
+G0RV45NwHXLrK2bd8F9PlRk2XHW6mIcFRXsW1DjeBhk/sQjvlO9R01GRSgcXtekJ
+tmX17FWrMrzXHpvy1IC3fk4RVnSjpzQ8O+17YE8/la9wVaeZZzHyYFmMT7VXjIhW
+QozJQ0vJ2jxJRh5GYn3tpJzdaeRfvTBik0pChNdUTnWP+BJ35xoCTs8iwJbmgVZ1
+-----END RSA PRIVATE KEY-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 1 (0x1)
+        Signature Algorithm: md5WithRSAEncryption
+        Issuer: C=US, ST=Berkshire, L=Newbury, O=My Company Ltd, OU=Testing, CN=test/emailAddress=test@test.com
+        Validity
+            Not Before: Mar 10 15:13:16 2009 GMT
+            Not After : Mar  8 15:13:16 2019 GMT
+        Subject: C=US, ST=Berkshire, O=My Company Ltd, OU=Testing, CN=test1/emailAddress=test@test.com
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+            RSA Public Key: (2048 bit)
+                Modulus (2048 bit):
+                    00:cd:34:b1:2e:b0:04:c6:f4:2b:a2:c0:a0:39:7a:
+                    82:ed:96:c4:f7:19:83:91:5c:b4:e7:9c:de:ec:48:
+                    ec:2d:e4:51:08:26:42:ac:d3:98:26:7a:72:f7:49:
+                    c2:9e:66:05:c6:47:29:fe:3b:ac:6b:af:6f:5e:a8:
+                    03:5a:73:33:ba:19:03:00:35:f5:00:bc:a8:be:14:
+                    ce:46:69:e3:6d:ed:34:37:85:55:87:62:b3:b7:c9:
+                    c0:cc:9a:aa:61:05:5b:cd:a2:17:42:d3:e5:6f:1c:
+                    60:8d:c2:15:41:46:f8:12:54:d0:38:57:e1:fd:8d:
+                    44:c8:fb:56:b3:b9:6c:e9:f8:9e:21:11:57:1b:8b:
+                    f9:cf:e3:17:e7:d8:fd:ac:d1:01:c6:92:30:f3:2d:
+                    c9:d6:c1:f0:3d:fd:ca:30:dd:75:74:e7:d1:6b:75:
+                    d8:c5:4d:43:61:fe:f6:ad:7e:4c:63:7c:03:17:a2:
+                    06:8f:d0:8b:69:d3:7a:07:0f:0b:a2:cf:0c:70:38:
+                    ba:cc:55:35:60:84:58:d8:d2:be:1f:ef:76:a9:ba:
+                    ae:6a:dc:08:97:80:de:42:00:b7:d4:ce:9a:b0:36:
+                    2a:c7:6f:45:04:7c:ea:41:19:d8:b9:19:04:1f:11:
+                    a9:22:80:bd:69:08:15:0d:3c:de:cd:7e:88:6c:0f:
+                    a3:43
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            Netscape Comment: 
+                OpenSSL Generated Certificate
+            X509v3 Subject Key Identifier: 
+                CE:03:7E:EF:E7:DE:C9:87:BF:DE:56:F4:C8:A3:40:F6:C8:6F:05:8C
+            X509v3 Authority Key Identifier: 
+                keyid:B8:35:37:32:BE:CF:4F:79:F5:7B:74:B2:F2:10:5A:BA:80:C5:6A:10
+                DirName:/C=US/ST=Berkshire/L=Newbury/O=My Company Ltd/OU=Testing/CN=test/emailAddress=test@test.com
+                serial:EB:E7:64:FB:79:F7:22:19
+
+    Signature Algorithm: md5WithRSAEncryption
+        7a:20:93:63:40:73:7d:33:01:2e:c0:13:52:a4:a7:e1:4d:82:
+        f4:fb:b2:7b:d0:2b:5a:3f:0e:3c:28:61:71:ab:01:4d:fe:89:
+        b5:cd:2f:97:59:93:53:9d:51:86:48:dd:b9:e4:73:5e:22:0b:
+        12:0d:25:39:76:16:44:06:0c:40:45:21:6b:a6:b1:e0:bf:76:
+        1b:36:f3:1e:41:82:57:d9:59:b7:60:40:43:1c:1d:79:f6:48:
+        32:5c:4e:e2:06:89:96:41:d2:54:1f:4a:6f:f6:78:a5:3c:02:
+        85:21:e2:65:e1:8a:6d:24:19:95:f8:c0:35:ab:bd:ff:3d:f1:
+        fb:50:2d:30:1e:67:a6:7c:50:f9:d5:77:66:77:5a:14:0f:5c:
+        cd:21:09:9b:a3:92:57:19:dd:01:a4:18:c5:f9:70:e4:17:43:
+        8d:b1:e6:61:e9:50:89:83:4f:ce:a4:57:68:58:40:70:ae:71:
+        1c:47:66:d2:30:54:50:ea:3a:87:32:64:3b:18:42:fe:5a:19:
+        07:64:f7:f1:b1:10:07:fd:a7:d2:a7:a8:05:79:5b:25:ba:69:
+        7b:1a:3e:b1:3e:e4:17:17:01:ba:eb:54:ae:83:00:ed:66:62:
+        8d:c0:3e:8a:b4:27:5f:e9:01:ce:20:c3:34:a9:28:c0:6f:c7:
+        3b:65:fe:f9
+-----BEGIN CERTIFICATE-----
+MIIEojCCA4qgAwIBAgIBATANBgkqhkiG9w0BAQQFADCBizELMAkGA1UEBhMCVVMx
+EjAQBgNVBAgTCUJlcmtzaGlyZTEQMA4GA1UEBxMHTmV3YnVyeTEXMBUGA1UEChMO
+TXkgQ29tcGFueSBMdGQxEDAOBgNVBAsTB1Rlc3RpbmcxDTALBgNVBAMTBHRlc3Qx
+HDAaBgkqhkiG9w0BCQEWDXRlc3RAdGVzdC5jb20wHhcNMDkwMzEwMTUxMzE2WhcN
+MTkwMzA4MTUxMzE2WjB6MQswCQYDVQQGEwJVUzESMBAGA1UECBMJQmVya3NoaXJl
+MRcwFQYDVQQKEw5NeSBDb21wYW55IEx0ZDEQMA4GA1UECxMHVGVzdGluZzEOMAwG
+A1UEAxMFdGVzdDExHDAaBgkqhkiG9w0BCQEWDXRlc3RAdGVzdC5jb20wggEiMA0G
+CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDNNLEusATG9CuiwKA5eoLtlsT3GYOR
+XLTnnN7sSOwt5FEIJkKs05gmenL3ScKeZgXGRyn+O6xrr29eqANaczO6GQMANfUA
+vKi+FM5GaeNt7TQ3hVWHYrO3ycDMmqphBVvNohdC0+VvHGCNwhVBRvgSVNA4V+H9
+jUTI+1azuWzp+J4hEVcbi/nP4xfn2P2s0QHGkjDzLcnWwfA9/cow3XV059FrddjF
+TUNh/vatfkxjfAMXogaP0Itp03oHDwuizwxwOLrMVTVghFjY0r4f73apuq5q3AiX
+gN5CALfUzpqwNirHb0UEfOpBGdi5GQQfEakigL1pCBUNPN7NfohsD6NDAgMBAAGj
+ggEfMIIBGzAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVy
+YXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUzgN+7+feyYe/3lb0yKNA9shvBYww
+gcAGA1UdIwSBuDCBtYAUuDU3Mr7PT3n1e3Sy8hBauoDFahChgZGkgY4wgYsxCzAJ
+BgNVBAYTAlVTMRIwEAYDVQQIEwlCZXJrc2hpcmUxEDAOBgNVBAcTB05ld2J1cnkx
+FzAVBgNVBAoTDk15IENvbXBhbnkgTHRkMRAwDgYDVQQLEwdUZXN0aW5nMQ0wCwYD
+VQQDEwR0ZXN0MRwwGgYJKoZIhvcNAQkBFg10ZXN0QHRlc3QuY29tggkA6+dk+3n3
+IhkwDQYJKoZIhvcNAQEEBQADggEBAHogk2NAc30zAS7AE1Kkp+FNgvT7snvQK1o/
+DjwoYXGrAU3+ibXNL5dZk1OdUYZI3bnkc14iCxINJTl2FkQGDEBFIWumseC/dhs2
+8x5BglfZWbdgQEMcHXn2SDJcTuIGiZZB0lQfSm/2eKU8AoUh4mXhim0kGZX4wDWr
+vf898ftQLTAeZ6Z8UPnVd2Z3WhQPXM0hCZujklcZ3QGkGMX5cOQXQ42x5mHpUImD
+T86kV2hYQHCucRxHZtIwVFDqOocyZDsYQv5aGQdk9/GxEAf9p9KnqAV5WyW6aXsa
+PrE+5BcXAbrrVK6DAO1mYo3APoq0J1/pAc4gwzSpKMBvxztl/vk=
+-----END CERTIFICATE-----
diff --git a/src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem b/src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem
new file mode 100644
index 0000000000000000000000000000000000000000..ef1be20d2be37b79a49cc8e27cc9656a1379d96e
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem
@@ -0,0 +1,27 @@
+-----BEGIN CERTIFICATE-----
+MIIEjzCCA3egAwIBAgIJAOvnZPt59yIZMA0GCSqGSIb3DQEBBQUAMIGLMQswCQYD
+VQQGEwJVUzESMBAGA1UECBMJQmVya3NoaXJlMRAwDgYDVQQHEwdOZXdidXJ5MRcw
+FQYDVQQKEw5NeSBDb21wYW55IEx0ZDEQMA4GA1UECxMHVGVzdGluZzENMAsGA1UE
+AxMEdGVzdDEcMBoGCSqGSIb3DQEJARYNdGVzdEB0ZXN0LmNvbTAeFw0wOTAzMTAx
+NTEyMTRaFw0xOTAzMDgxNTEyMTRaMIGLMQswCQYDVQQGEwJVUzESMBAGA1UECBMJ
+QmVya3NoaXJlMRAwDgYDVQQHEwdOZXdidXJ5MRcwFQYDVQQKEw5NeSBDb21wYW55
+IEx0ZDEQMA4GA1UECxMHVGVzdGluZzENMAsGA1UEAxMEdGVzdDEcMBoGCSqGSIb3
+DQEJARYNdGVzdEB0ZXN0LmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
+ggEBAKot9j+/+CX1/gZLgJHIXCRgCItKLGnf7qGbgqB9T2ACBqR0jllKWwDKrcWU
+xjXNIc+GF9Wnv+lX6G0Okn4Zt3/uRNobL+2b/yOF7M3Td3/9W873zdkQQX930YZc
+Rr8uxdRPP5bxiCgtcw632y21sSEbG9mjccAUnV/0jdvfmMNj0i8gN6E0fMBiJ9S3
+FkxX/KFvt9JWE9CtoyL7ki7UIDq+6vj7Gd5N0B3dOa1y+rRHZzKlJPcSXQSEYUS4
+HmKDwiKSVahft8c4tDn7KPi0vex91hlgZVd3usL2E/Vq7o5D9FAZ5kZY0AdFXwdm
+J4lO4Mj7ac7GE4vNERNcXVIX59sCAwEAAaOB8zCB8DAdBgNVHQ4EFgQUuDU3Mr7P
+T3n1e3Sy8hBauoDFahAwgcAGA1UdIwSBuDCBtYAUuDU3Mr7PT3n1e3Sy8hBauoDF
+ahChgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRIwEAYDVQQIEwlCZXJrc2hpcmUxEDAO
+BgNVBAcTB05ld2J1cnkxFzAVBgNVBAoTDk15IENvbXBhbnkgTHRkMRAwDgYDVQQL
+EwdUZXN0aW5nMQ0wCwYDVQQDEwR0ZXN0MRwwGgYJKoZIhvcNAQkBFg10ZXN0QHRl
+c3QuY29tggkA6+dk+3n3IhkwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOC
+AQEAVRG4aALIvCXCiKfe7K+iJxjBVRDFPEf7JWA9LGgbFOn6pNvbxonrR+0BETdc
+JV1ET4ct2xsE7QNFIkp9GKRC+6J32zCo8qtLCD5+v436r8TUG2/t2JRMkb9I2XVT
+p7RJoot6M0Ltf8KNQUPYh756xmKZ4USfQUwc58MOSDGY8VWEXJOYij9Pf0e0c52t
+qiCEjXH7uXiS8Pgq9TYm7AkWSOrglYhSa83x0f8mtT8Q15nBESIHZ6o8FAS2bBgn
+B0BkrKRjtBUkuJG3vTox+bYINh2Gxi1JZHWSV1tN5z3hd4VFcKqanW5OgQwToBqp
+3nniskIjbH0xjgZf/nVMyLnjxg==
+-----END CERTIFICATE-----
diff --git a/src/settings/plugins/netplan/tests/yaml/test_client.p12 b/src/settings/plugins/netplan/tests/yaml/test_client.p12
new file mode 100644
index 0000000000000000000000000000000000000000..edc2af75ca6beabf5b4997ebcdf637e0408a296a
GIT binary patch
literal 2848
zcmY+^c{CJ^8U}E~%oq$a2HBT{EX6R%zKg-A>`eAO>t}0Fwn;<Cl6`4H)=IYQOEUCj
z%OJ`&sFdu)6l1w{&b{}$_mB6y=RD6j&!0aeo<)Ejz<|Uve*!Z}6VQa8tN=zpF`jt>
zh-V)C9S<S#Ag_Naa4{Za`#Z9v2hja~rvEemqyU)t-wRLx7|8~NR8X%<dJ1!p=;<MJ
zv3QWkP+07?aiMErBxbE6A-AF>#dnA``v4_%cfC9ztz5?>A0~<^-RhTr&yl=40G9ar
zx^zB;$gUT=CA$2EyV`E}PX7_oTe~u+N{3`>LCEsa3liw<hdV!wLs(IpWES5%<9=Yn
zkx=$6m>|sB+2jhdvA_A<r9O+610PnXNr1OQ8B4qkD9bwY+>?TfB05ptYZWa#FPT<s
zN17d$9yqQS$){TnSn9#W)9Pd^ANDLUvUQeNUkVoHn7wt>XF7mg(quA$RB7|(G=8!(
z<0IiD?dFgT<M0hH{MQngtumiUV&rDrr%ndn0rTAiB`oB=sRW|mr4PZ-4x5C?<_?!g
z?L2&AJV?}2qeaX0c=w$MtqCpVIR~EmB{3f@j@~7;j<1YqU_mE&{vHP%b|l_YC;_GL
zc=GOnLdMOYDak{Ur5mMi&A6v^BZW_B;w7-HQ=XA&w#9xifqSl!X&u(OpQE7I=rvpE
zgiAH{tc@ckG4VO{sz_xfXH{$7g%yBzmb}T)kUcY3E8S+j9qM0%7amu%TbUP@0Gip4
zcK&WJgi=+iBGSL+ddA-CM%=TjQ=h~Xh3LOn7`46G8X92ieZM`7kt;rZA)O^e|9%r%
zj#FX!2i!wV?creH-k}QoK1l1mvVc%64e`)cwXn4hKFa}3c!kFlp)hozNA!XwT>8c?
zF(EYVvMe0BLQrs}R=Wq;%BuPe+2MlC{Rx>)WGo`Rrq-oC0tU&?r=#JT%^0^cN_Qsl
zpXQp0o~2K%9`AO8LiuzIg43yGOsvE3ceBO*KZUZ~78$Io#R=?9`fsZ>hhNTIb?anR
zwtA@`2sD2tv(&|l#H4#$Z?fEOOe*+pl*}z`z+&BTEU+(4EU<@7?|eTH0fG5gPJeui
zjy7V$vc*7yq0$b{+FE34QFb}uSCVaJ5>3wXhi?yi+bhFM<%!2*<leOK+nwCOC6K>x
z?nAC;2?g4Vpmb{P5|2qiAvWrn<G%Fg(ii?PqSp^Fm$RI>GUIeD$h_cvfLm2J*6gEW
zn`4d~C)R=uRHZU&sAU}R{E_Rg^MV%Bu9`4z!x3?NoAa!)VcUbQ;{aWkdyV{`yKL&8
zAj}U?lUK?=^uZ>oNdm-cE>w+*#u&+6q5K5)OcCohJMFNx<DfWrEn$vL&^c$E!7qU5
z5w~?g@lq(e|Du^rIhMiQb2xM0g%IXRzcRZV!IxFq+q0^Tq~@h}XVg9M6ZfcsH-4(I
z#XLXMhqQ?3Emo}aACdTs^l*A=!f{oiLDkCX)Jl-n2ATF(PM*>;v7C9Sb%pny`g}oP
zUD~ydGatk?kD`|8+_O+VevN^pFIy`cdovAQ+~uj#mh6Ighv+!h9)~GvlCHa1M^A!v
zBj10$8~E(DpK=5&J_=xr$7PTAUKkv<5Dr79MEZWl)X%MJql?IoBuo=?-pSS0&|g<F
z@=Jx@oE05f^pIZbyVlgu?_Cy2zE+dkjxgWZ{(ziRrYO^?&Zt18E=|Uw`;z^1jI?%o
zLrX3;wa(QR{GEgn#j&6=g2HRFC-q&hI}6(W!hC!yPOoXhuj#QN*E#5o^7EVw60G;!
zV6=3=*=y1j;d42XygeeP3q-9dLseOIR+P1xh^XYb15baN;VmnNmN)Sew*%i|CS_W^
z#_9bAVLm*9`z80-k!LyC*hpBB$L~4#ANU(zEGovuC-Rk(EmwDUn4h;_q9A5=sx+7)
z)H~6!HuX2yF5I*=_zkN4|A6|NT2mk%Wb`|}^80kaEdSw^89-l*2W}$qz}5d#m*J1P
z*@EYW$&P-df7Auyfp5h+Bu0|nF$QgfL#x%E#B*wSL9R$CYB*v0cLE<H%#NYWV+X}$
zl(t}Vpi$1lS#`%GM}gG#FhloY<1K%)9P@rBSz(4No6&kAHF9c?aKTOAeXJtlFb<jg
zBINsCk6(>GdUO3m|3lWMFtX9$OxVmN)s-RJJc`t<hVE@$nC#DUuP42DS5ujWaq>f1
zPaTj!5#efM>SEC~U)T*oUe&+P*V=YhX?`{es!Uxx{JGANF}`+ib#_Z^X)uG*bpu!g
zOW;d9_&U{odC<s}PTP+&N}%S(*f7z7X3>~1vN1GJb8MSvhAaVXyK7OOFK1MgXaOdo
zZBD)C1y2PC;z8eXm?eEkuS(G&cC4k9@4tW-UX34mP2D*_FbF+7qqpv&DJFcLTjrAS
z{?gX9_({3jUmU^*>(aKp)r!Cb7Y^<KvGm>`W>AbYjWQ`IZfu&T(cutqlol)#&$FZ;
z)=sMQ@WJZ_(!2`Gh*I$>C{m~HkKD*W1qZX?0LUFOjbr)pNs$EM{C=aYp8Bf$K%=L4
zUGkx+Qd6Fr;iz7xB6|(}Mt_i+EEKkRa-#a&@irOUC4J=N6BaT1;oJy!<Q7`w^uiO0
zLOpgsUwSrNkR`u1TTDI<1JwF{zs~hq>*rFm0Pus}>jAkdx-N?0?t6I~!o$*0@aT7J
zJxC0n0~Zf_23;w>TxmTQ6($i`9I+xC>(9Hox?;coJ-^{N4xQycq4eWuKPID5g*hXg
zt1NNV#y2N5m)sXBp=-Eot4^$ymq#8Rt9<8X=pbAGFiNnNnOyyX!%7Lo7F+X=G&pz~
ztzf${=ZsuWJYGM@<wE7#Vf?W`e%9x{`*E%TL`gxnFAq~iEV0vC$7Renop#4GgK#TG
zx{A^V@tgD1XWaW|ah~}ECmrXK%e4()Hd(0{z|WoY0n>xNijP@g->#<V)uGi_u8tf>
z{ECnEGHJ|c)v;A+eXEf<vX!G5bXcT$Ir5u>5pS^&oL9<aori4Sl0LHBeB7U5!;&PF
zVvPdYi<54}p}K9S;eA*oGm%ptn#TievT7z3B9jug6jke!7*kCfGos8d@R!AI+<~G^
zM>bW-!c{6WeTenSgB!QRGq{l9OAH4)_;B3*-I)sNm#rx<{yK^hz4sNcu=GMefp?7J
z8vSBr!=~uOVinfh-d&CO>UR-!E0;Bakd#Q<{yF|jRp;orrK^=@`w{hxx_NjC?JcBZ
zRb0PC1-CMi`=pNL<nfaLH9z1llNt@#(B?y>DS>H;FKqDb!b9W^=Hn(cxklpSnM|U+
zY=RDSw?!rkF>x+-Cc<RoqZ`xSfO9f?crthEL?*O5+sKwq_KwbFzHMfk7|Hc&vB3r|
zPhQc<;J2ZHPgg5b<Jz>nWVR^`qA29{(}0`0XcI>Mj_E)Xg>I^fB>5=AeZh_1rZE3}
zi^EgMuS&kVTRrXeh~Um;QDn`Uecjm&j(rL`5oiw`w68Xdti>YSdm(;ddn*D->2MxZ
zJ6|lnnA@jh+-WdlZ-q#+w+4&Fjdrx9ghe%_UV2vfOhM)e)3>#@-B+Wgr4dZh);~bH
zJt5By_TJ`M6q1MCE_%e8tIyZ`y`-6j<muY#3*PpBM@D)0aCJ>l<h7B!|J9L+QywbB
zOy@@DK^IIHN+*vz_fN$oe+I~zl|!VH@&y}2w^~O<DW_?l@2)RJ$|KJrnZO_!HU@e=
o5FL<{lf%8FtqF{XNy1I|hiu-eRV8--A!@}+0gj<2ihlt87rKciAOHXW

literal 0
HcmV?d00001

-- 
2.25.1


From 1c4fdc531de9c6632f0208ef76fddd87e800d205 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 28 Apr 2020 17:00:51 +0200
Subject: [PATCH 56/78] netplan: Wifi auth method wpa-eap: ttls/mschapv2

---
 .../plugins/netplan/nms-netplan-reader.c      |  5 +
 .../plugins/netplan/nms-netplan-writer.c      | 36 ++++---
 .../plugins/netplan/tests/test-netplan.c      | 93 +++++++++++++++++++
 3 files changed, 122 insertions(+), 12 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index c121cb610b027cf5851bd8efb9c195bb64b70066..372ea09e1805287ee31194e86d48903b79c80898 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1566,6 +1566,11 @@ fill_8021x (NetplanNetDefinition *nd,
 			return NULL;
 	}
 
+	/* XXX: Verify ...PHASE2_AUTHEAP VS ...PHASE2_AUTH */
+	value = auth.phase2_auth;
+	if (value)
+		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, value, NULL);
+
 	value = auth.identity;
 	if (value)
 		g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, value, NULL);
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 6e7e392657e70227f630b8d4247d4ad3a59b2321..8444fa1024ef2c1975ca25aa99a716759f6e55ea 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -439,6 +439,12 @@ write_8021x_setting (NMConnection *connection,
 		}
 	}
 
+	/* XXX: Verify ...phase2_autheap VS ...phase2_auth */
+	value = nm_setting_802_1x_get_phase2_autheap (s_8021x);
+	if (value)
+		g_output_stream_printf (netplan, 0, NULL, NULL,
+		                        "            phase2-auth: %s\n", value);
+
 	value = nm_setting_802_1x_get_identity (s_8021x);
 	if (value)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
@@ -592,20 +598,26 @@ write_8021x_setting (NMConnection *connection,
 		return FALSE;
 #endif
 
-	value = nm_setting_802_1x_get_ca_cert_path (s_8021x);
-	if (value)
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "            ca-certificate: %s\n", value);
+	if (nm_setting_802_1x_get_ca_cert_scheme (s_8021x) == NM_SETTING_802_1X_CK_SCHEME_PATH) {
+		value = nm_setting_802_1x_get_ca_cert_path (s_8021x);
+		if (value)
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "            ca-certificate: %s\n", value);
+	}
 
-	value = nm_setting_802_1x_get_client_cert_path (s_8021x);
-	if (value)
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "            client-certificate: %s\n", value);
+	if (nm_setting_802_1x_get_client_cert_scheme (s_8021x) == NM_SETTING_802_1X_CK_SCHEME_PATH) {
+		value = nm_setting_802_1x_get_client_cert_path (s_8021x);
+		if (value)
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "            client-certificate: %s\n", value);
+	}
 
-	value = nm_setting_802_1x_get_private_key_path (s_8021x);
-	if (value)
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "            client-key: %s\n", value);
+	if (nm_setting_802_1x_get_private_key_scheme (s_8021x) == NM_SETTING_802_1X_CK_SCHEME_PATH) {
+		value = nm_setting_802_1x_get_private_key_path (s_8021x);
+		if (value)
+			g_output_stream_printf (netplan, 0, NULL, NULL,
+			                        "            client-key: %s\n", value);
+	}
 
 	value = nm_setting_802_1x_get_private_key_password (s_8021x);
 	if (value)
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 787ebd91572044f2d0492aa8468f9987ab705bd7..cdca2ce81e2c48b6db8b88f622eb1f9474ea6bef 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -637,6 +637,98 @@ test_write_wifi_wpa_eap_tls (void)
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
+static void
+test_write_wifi_wpa_eap_ttls_mschapv2 (void)
+{
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSetting8021x *s_8021x;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	gboolean success;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TTLS (MSCHAPv2)",
+	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
+	/* XXX: Needs to be implemented in netplan
+	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	nm_setting_wireless_security_add_group (s_wsec, "tkip");
+	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
+	*/
+
+	/* Wireless security setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "ttls");
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
+	              NM_SETTING_802_1X_PASSWORD, ";alkdfja;dslkfjsad;lkfjsadf",
+	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "foobar22",
+	              NM_SETTING_802_1X_PHASE2_AUTHEAP, "mschapv2",
+	              NULL);
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_NETPLAN_WIFI_WPA_EAP_TLS_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connection (connection,
+	                        TEST_SCRATCH_DIR,
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
 static void
 test_write_wifi_band_a (void)
 {
@@ -1523,6 +1615,7 @@ int main (int argc, char **argv)
 
 	g_test_add_func (TPATH "wifi/write/main", test_write_wifi_main);
 	g_test_add_func (TPATH "wifi/write/eap-tls", test_write_wifi_wpa_eap_tls);
+	g_test_add_func (TPATH "wifi/write/eap-ttls", test_write_wifi_wpa_eap_ttls_mschapv2);
 	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
-- 
2.25.1


From 95c4a8cba210af03ab69d9d6c17ace344af068a2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 29 Apr 2020 10:58:06 +0200
Subject: [PATCH 57/78] netplan: wifi wpa method eap-peap; improve wpa-eap
 tests

---
 .../plugins/netplan/nms-netplan-reader.c      |   3 +-
 .../plugins/netplan/nms-netplan-writer.c      |   3 +-
 .../netplan/tests/netplan-test-utils.h        |   1 +
 .../plugins/netplan/tests/test-netplan.c      | 105 ++++++++++++++++--
 .../netplan/tests/yaml/exp-wifi-eap-peap.yaml |  22 ++++
 .../netplan/tests/yaml/exp-wifi-eap-tls.yaml  |  22 ++++
 .../netplan/tests/yaml/exp-wifi-eap-ttls.yaml |  22 ++++
 7 files changed, 167 insertions(+), 11 deletions(-)
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-peap.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-tls.yaml
 create mode 100644 src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-ttls.yaml

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 372ea09e1805287ee31194e86d48903b79c80898..a3c5dbcdee0c5e3c52e30fb733a14e1ed3f81d56 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1566,10 +1566,9 @@ fill_8021x (NetplanNetDefinition *nd,
 			return NULL;
 	}
 
-	/* XXX: Verify ...PHASE2_AUTHEAP VS ...PHASE2_AUTH */
 	value = auth.phase2_auth;
 	if (value)
-		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTHEAP, value, NULL);
+		g_object_set (s_8021x, NM_SETTING_802_1X_PHASE2_AUTH, value, NULL);
 
 	value = auth.identity;
 	if (value)
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 8444fa1024ef2c1975ca25aa99a716759f6e55ea..686e412875ed2ee70e6db663ec337596b765ebba 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -439,8 +439,7 @@ write_8021x_setting (NMConnection *connection,
 		}
 	}
 
-	/* XXX: Verify ...phase2_autheap VS ...phase2_auth */
-	value = nm_setting_802_1x_get_phase2_autheap (s_8021x);
+	value = nm_setting_802_1x_get_phase2_auth (s_8021x);
 	if (value)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "            phase2-auth: %s\n", value);
diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
index 1f44ceacca07296daa91ce141d44ed13db29367a..26f2b941a90762c7624d5433d68bce93b8bc563b 100644
--- a/src/settings/plugins/netplan/tests/netplan-test-utils.h
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -58,6 +58,7 @@
 #define TEST_NETPLAN_WIFI_WPA_EAP_TLS_CA_CERT TEST_NETPLAN_DIR"/test_ca_cert.pem"
 #define TEST_NETPLAN_WIFI_WPA_EAP_TLS_CLIENT_CERT TEST_NETPLAN_DIR"/test1_key_and_cert.pem"
 #define TEST_NETPLAN_WIFI_WPA_EAP_TLS_PRIVATE_KEY TEST_NETPLAN_DIR"/test1_key_and_cert.pem"
+#define TEST_NETPLAN_WIFI_WPA_EAP_PEAP_CA_CERT TEST_NETPLAN_DIR"/test_ca_cert.pem"
 
 /*****************************************************************************/
 
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index cdca2ce81e2c48b6db8b88f622eb1f9474ea6bef..08d281678178f01af5f6431d300d2aabce2660cc 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -555,7 +555,7 @@ test_write_wifi_wpa_eap_tls (void)
 
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TLS",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_UUID, "aeb01292-957c-4f84-8f74-4a94d15b47b2",
 	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
 	              NULL);
@@ -628,8 +628,9 @@ test_write_wifi_wpa_eap_tls (void)
 	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 	nmtst_assert_connection_verifies (connection);
 
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_NETPLAN_DIR"/exp-wifi-eap-tls.yaml",
 	                        &testfile);
 
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
@@ -664,7 +665,7 @@ test_write_wifi_wpa_eap_ttls_mschapv2 (void)
 
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-TTLS (MSCHAPv2)",
-	              NM_SETTING_CONNECTION_UUID, nm_utils_uuid_generate_a (),
+	              NM_SETTING_CONNECTION_UUID, "2ac5e61f-990a-48b5-97a1-8c3e9e155fb4",
 	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
 	              NULL);
@@ -706,7 +707,7 @@ test_write_wifi_wpa_eap_ttls_mschapv2 (void)
 	              NM_SETTING_802_1X_IDENTITY, "Bill Smith",
 	              NM_SETTING_802_1X_PASSWORD, ";alkdfja;dslkfjsad;lkfjsadf",
 	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "foobar22",
-	              NM_SETTING_802_1X_PHASE2_AUTHEAP, "mschapv2",
+	              NM_SETTING_802_1X_PHASE2_AUTH, "mschapv2",
 	              NULL);
 
 	success = nm_setting_802_1x_set_ca_cert (s_8021x,
@@ -720,8 +721,97 @@ test_write_wifi_wpa_eap_ttls_mschapv2 (void)
 
 	nmtst_assert_connection_verifies (connection);
 
-	_writer_new_connection (connection,
-	                        TEST_SCRATCH_DIR,
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_NETPLAN_DIR"/exp-wifi-eap-ttls.yaml",
+	                        &testfile);
+
+	reread = _connection_from_file (testfile, NULL, NULL, NULL);
+
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
+}
+
+static void
+test_write_wifi_wpa_eap_peap (void)
+{
+	nmtst_auto_unlinkfile char *keyfile = NULL;
+	nmtst_auto_unlinkfile char *testfile = NULL;
+	gs_unref_object NMConnection *connection = NULL;
+	gs_unref_object NMConnection *reread = NULL;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIPConfig *s_ip4;
+	NMSettingIPConfig *s_ip6;
+	NMSetting8021x *s_8021x;
+	gboolean success;
+	GError *error = NULL;
+	GBytes *ssid;
+	const char *ssid_data = "blahblah";
+
+	_clear_all_netdefs ();
+	connection = nm_simple_connection_new ();
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WPA EAP-PEAP (MSCHAPv2)",
+	              NM_SETTING_CONNECTION_UUID, "24c60a6a-dfcd-4992-a454-2c7fab53cebc",
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_bytes_new (ssid_data, strlen (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NULL);
+
+	g_bytes_unref (ssid);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
+
+	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
+
+	/* 802.1x setting */
+	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
+	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	g_object_set (s_8021x,
+	              NM_SETTING_802_1X_IDENTITY, "Bob Saget",
+	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "barney",
+	              NM_SETTING_802_1X_PASSWORD, "Kids, it was back in October 2008...",
+				  /* XXX: Needs to be implemented in netplan
+	              NM_SETTING_802_1X_PHASE1_PEAPVER, "1",
+	              NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1", */
+	              NM_SETTING_802_1X_PHASE2_AUTH, "mschapv2",
+	              NULL);
+
+	nm_setting_802_1x_add_eap_method (s_8021x, "peap");
+
+	success = nm_setting_802_1x_set_ca_cert (s_8021x,
+	                                         TEST_NETPLAN_WIFI_WPA_EAP_PEAP_CA_CERT,
+	                                         NM_SETTING_802_1X_CK_SCHEME_PATH,
+	                                         NULL,
+	                                         &error);
+	nmtst_assert_success (success, error);
+
+	nmtst_assert_connection_verifies (connection);
+
+	_writer_new_connec_exp (connection,
+	                        TEST_SCRATCH_DIR_TMP,
+	                        TEST_NETPLAN_DIR"/exp-wifi-eap-peap.yaml",
 	                        &testfile);
 
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
@@ -1616,6 +1706,7 @@ int main (int argc, char **argv)
 	g_test_add_func (TPATH "wifi/write/main", test_write_wifi_main);
 	g_test_add_func (TPATH "wifi/write/eap-tls", test_write_wifi_wpa_eap_tls);
 	g_test_add_func (TPATH "wifi/write/eap-ttls", test_write_wifi_wpa_eap_ttls_mschapv2);
+	g_test_add_func (TPATH "wifi/write/eap-peap", test_write_wifi_wpa_eap_peap);
 	g_test_add_func (TPATH "wifi/write/band-a", test_write_wifi_band_a);
 	g_test_add_func (TPATH "wifi/write/band-bg", test_write_wifi_band_bg);
 	g_test_add_func (TPATH "wifi/write/wowlan-macrandom", test_wifi_wowlan_mac_randomization);
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-peap.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-peap.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..a4efbf1b81d88ee18e154b79dd0e81e75f45b77b
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-peap.yaml
@@ -0,0 +1,22 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  wifis:
+    NM-24c60a6a-dfcd-4992-a454-2c7fab53cebc:
+      access-points:
+        blahblah:
+          mode: infrastructure
+          auth:
+            key-management: eap
+            method: peap
+            phase2-auth: mschapv2
+            identity: Bob Saget
+            anonymous-identity: barney
+            password: Kids, it was back in October 2008...
+            ca-certificate: /x/src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write Wifi WPA EAP-PEAP (MSCHAPv2)
+        uuid: 24c60a6a-dfcd-4992-a454-2c7fab53cebc
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-tls.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-tls.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..2388d46344ce76ac400025252f93b21dec9f8667
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-tls.yaml
@@ -0,0 +1,22 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  wifis:
+    NM-aeb01292-957c-4f84-8f74-4a94d15b47b2:
+      access-points:
+        blahblah:
+          mode: infrastructure
+          auth:
+            key-management: eap
+            method: tls
+            identity: Bill Smith
+            ca-certificate: /x/src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem
+            client-certificate: /x/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
+            client-key: /x/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
+            client-key-password: test1
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write Wifi WPA EAP-TLS
+        uuid: aeb01292-957c-4f84-8f74-4a94d15b47b2
diff --git a/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-ttls.yaml b/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-ttls.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..aafbb84273a886e7d0196cac5fc1a9eaf5d6da99
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/yaml/exp-wifi-eap-ttls.yaml
@@ -0,0 +1,22 @@
+network:
+  version: 2
+  renderer: NetworkManager
+  wifis:
+    NM-2ac5e61f-990a-48b5-97a1-8c3e9e155fb4:
+      access-points:
+        blahblah:
+          mode: infrastructure
+          auth:
+            key-management: eap
+            method: ttls
+            phase2-auth: mschapv2
+            identity: Bill Smith
+            anonymous-identity: foobar22
+            password: ;alkdfja;dslkfjsad;lkfjsadf
+            ca-certificate: /x/src/settings/plugins/netplan/tests/yaml/test_ca_cert.pem
+      dhcp4: yes
+      dhcp6: yes
+      ipv6-address-generation: stable-privacy
+      networkmanager:
+        name: Test Write Wifi WPA EAP-TTLS (MSCHAPv2)
+        uuid: 2ac5e61f-990a-48b5-97a1-8c3e9e155fb4
-- 
2.25.1


From 33fe96d9df1ec880a316f56e9685bad2d63422e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 29 Apr 2020 12:59:31 +0200
Subject: [PATCH 58/78] netplan: cleanup tests

---
 .../plugins/netplan/tests/test-netplan.c      | 154 +++++++++---------
 1 file changed, 73 insertions(+), 81 deletions(-)

diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 08d281678178f01af5f6431d300d2aabce2660cc..c6d021d491a6a35e848168b9e06f61d12d3d5cbe 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -134,8 +134,7 @@ test_write_wired_basic (void)
 	g_assert_true (s_wired);
 	g_assert_true (nm_setting_wired_get_wake_on_lan (s_wired) == NM_SETTING_WIRED_WAKE_ON_LAN_NONE);
 
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 static void
@@ -246,6 +245,7 @@ test_write_wired_static (void)
 
 	route6 = nm_ip_route_new (AF_INET6, "::", 128, "2222:aaaa::9999", 1, &error);
 	g_assert_no_error (error);
+	/* TODO: Needs to be implemented in netplan. */
 	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_CWND, g_variant_new_uint32 (100));
 	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_MTU, g_variant_new_uint32 (1280));
 	//nm_ip_route_set_attribute (route6, NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND, g_variant_new_boolean (TRUE));
@@ -259,7 +259,7 @@ test_write_wired_static (void)
 	nm_setting_ip_config_add_dns (s_ip6, "cafe:ffff:eeee:dddd:cccc:bbbb:aaaa:feed");
 
 	/* DNS domains */
-	// FIXME: How to differentiate ip4/ip6 search domains??
+	/* FIXME: How to differentiate ip4/ip6 search domains in netplan? */
 	//nm_setting_ip_config_add_dns_search (s_ip6, "foobar6.com");
 	//nm_setting_ip_config_add_dns_search (s_ip6, "lab6.foobar.com");
 
@@ -278,8 +278,7 @@ test_write_wired_static (void)
 	// XXX: netplan can only set DEFAULT (wake-on-lan = true) or IGNORE (wake-on-lan = false)
 	g_assert_true (nm_setting_wired_get_wake_on_lan (s_wired) == NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT);
 
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 static void
@@ -343,7 +342,7 @@ test_write_wired_static_routes (void)
 
 	/* Write out routes */
 	route = nm_ip_route_new (AF_INET, "1.2.3.0", 24, "222.173.190.239", 0, &error);
-	/* XXX: Needs to be implemented in netplan */
+	/* TODO: Needs to be implemented in netplan. */
 	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (3455));
 	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (TRUE));
 	g_assert_no_error (error);
@@ -351,7 +350,7 @@ test_write_wired_static_routes (void)
 	nm_ip_route_unref (route);
 
 	route = nm_ip_route_new (AF_INET, "3.2.1.0", 24, "202.254.186.190", 77, &error);
-	/* XXX: Needs to be implemented in netplan */
+	/* TODO: Needs to be implemented in netplan. */
 	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_WINDOW, g_variant_new_uint32 (30000));
 	//nm_ip_route_set_attribute (route, NM_IP_ROUTE_ATTRIBUTE_ONLINK, g_variant_new_boolean (FALSE));
 	g_assert_no_error (error);
@@ -524,7 +523,6 @@ test_write_wifi_main (void)
 	                        &testfile);
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
-	//nm_connection_add_setting (connection, nm_setting_proxy_new ());
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
@@ -578,28 +576,26 @@ test_write_wifi_wpa_eap_tls (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
 
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap",
-	              /* XXX: Needs to be implemented in netplan
-	              NM_SETTING_WIRELESS_SECURITY_FILS, (int) NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,*/
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_WIRELESS_SECURITY_FILS, (int) NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,
 	              NULL);
 
-	/* XXX: Needs to be implemented in netplan
-	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-	nm_setting_wireless_security_add_group (s_wsec, "tkip");
-	*/
+	/* TODO: Needs to be implemented in netplan. */
+	//nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	//nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	//nm_setting_wireless_security_add_group (s_wsec, "tkip");
 
 	/* Wireless security setting */
 	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_8021x));
 
 	g_object_set (s_8021x, NM_SETTING_802_1X_IDENTITY, "Bill Smith", NULL);
-	/* XXX: Needs to be implemented in netplan
-	g_object_set (s_8021x,
-	              NM_SETTING_802_1X_PHASE1_AUTH_FLAGS,
-	              (guint) (NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE |
-	                       NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE),
-	              NULL);
-	*/
+	/* TODO: Needs to be implemented in netplan. */
+	//g_object_set (s_8021x,
+	//              NM_SETTING_802_1X_PHASE1_AUTH_FLAGS,
+	//              (guint) (NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE |
+	//                       NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE),
+	//              NULL);
 
 	nm_setting_802_1x_add_eap_method (s_8021x, "tls");
 
@@ -688,14 +684,13 @@ test_write_wifi_wpa_eap_ttls_mschapv2 (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
 
 	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-eap", NULL);
-	/* XXX: Needs to be implemented in netplan
-	nm_setting_wireless_security_add_proto (s_wsec, "wpa");
-	nm_setting_wireless_security_add_proto (s_wsec, "rsn");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
-	nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
-	nm_setting_wireless_security_add_group (s_wsec, "tkip");
-	nm_setting_wireless_security_add_group (s_wsec, "ccmp");
-	*/
+	/* TODO: Needs to be implemented in netplan. */
+	//nm_setting_wireless_security_add_proto (s_wsec, "wpa");
+	//nm_setting_wireless_security_add_proto (s_wsec, "rsn");
+	//nm_setting_wireless_security_add_pairwise (s_wsec, "tkip");
+	//nm_setting_wireless_security_add_pairwise (s_wsec, "ccmp");
+	//nm_setting_wireless_security_add_group (s_wsec, "tkip");
+	//nm_setting_wireless_security_add_group (s_wsec, "ccmp");
 
 	/* Wireless security setting */
 	s_8021x = (NMSetting8021x *) nm_setting_802_1x_new ();
@@ -792,9 +787,9 @@ test_write_wifi_wpa_eap_peap (void)
 	              NM_SETTING_802_1X_IDENTITY, "Bob Saget",
 	              NM_SETTING_802_1X_ANONYMOUS_IDENTITY, "barney",
 	              NM_SETTING_802_1X_PASSWORD, "Kids, it was back in October 2008...",
-				  /* XXX: Needs to be implemented in netplan
-	              NM_SETTING_802_1X_PHASE1_PEAPVER, "1",
-	              NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1", */
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_802_1X_PHASE1_PEAPVER, "1",
+	              //NM_SETTING_802_1X_PHASE1_PEAPLABEL, "1",
 	              NM_SETTING_802_1X_PHASE2_AUTH, "mschapv2",
 	              NULL);
 
@@ -938,7 +933,8 @@ test_wifi_wowlan_mac_randomization (void)
 	nm_connection_add_setting (connection, NM_SETTING (s_wireless));
 	ssid = g_bytes_new ("open-net", 8);
 	g_object_set (s_wireless,
-	              //NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, NM_SETTING_MAC_RANDOMIZATION_ALWAYS, // TODO: needs to be implemented in netplan
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION, NM_SETTING_MAC_RANDOMIZATION_ALWAYS,
 	              NM_SETTING_WIRELESS_MODE, NM_SETTING_WIRELESS_MODE_INFRA,
 	              NM_SETTING_WIRELESS_SSID, ssid,
 				  NM_SETTING_WIRELESS_WAKE_ON_WLAN, NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL,
@@ -957,10 +953,10 @@ test_wifi_wowlan_mac_randomization (void)
 	s_wireless = nm_connection_get_setting_wireless (reread);
 	g_assert_true (s_wireless);
 	g_assert_true (nm_setting_wireless_get_wake_on_wlan (s_wireless) == NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL);
+	/* TODO: Needs to be implemented in netplan. */
 	//g_assert_true (nm_setting_wireless_get_mac_address_randomization (s_wireless) == NM_SETTING_MAC_RANDOMIZATION_ALWAYS);
 
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 static void
@@ -998,35 +994,31 @@ test_write_bridge_main (void)
 	s_bridge = (NMSettingBridge *) nm_setting_bridge_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_bridge));
 
-	/* XXX: Needs to be implemented in netplan
-	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
-	vlan = nm_bridge_vlan_new (10, 16);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (22, 22);
-	nm_bridge_vlan_set_pvid (vlan, TRUE);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (44, 0);
-	g_ptr_array_add (vlans, vlan);
-	*/
+	/* TODO: Needs to be implemented in netplan. */
+	//vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+	//vlan = nm_bridge_vlan_new (10, 16);
+	//nm_bridge_vlan_set_untagged (vlan, TRUE);
+	//g_ptr_array_add (vlans, vlan);
+	//vlan = nm_bridge_vlan_new (22, 22);
+	//nm_bridge_vlan_set_pvid (vlan, TRUE);
+	//nm_bridge_vlan_set_untagged (vlan, TRUE);
+	//g_ptr_array_add (vlans, vlan);
+	//vlan = nm_bridge_vlan_new (44, 0);
+	//g_ptr_array_add (vlans, vlan);
 
 	g_object_set (s_bridge,
 	              NM_SETTING_BRIDGE_MAC_ADDRESS, mac,
 	              NM_SETTING_BRIDGE_AGEING_TIME, 100,
 	              NM_SETTING_BRIDGE_PRIORITY, 1024,
-	              //NM_SETTING_BRIDGE_PORT_PRIORITY, 1,
 	              NM_SETTING_BRIDGE_FORWARD_DELAY, 10,
 	              NM_SETTING_BRIDGE_HELLO_TIME, 5,
 	              NM_SETTING_BRIDGE_MAX_AGE, 10,
-	              //NM_SETTING_BRIDGE_PORT_PATH_COST, 1,
 	              NM_SETTING_BRIDGE_STP, TRUE,
-	              /* XXX: Needs to be implemented in netplan
-	              NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, 19008,
-	              NM_SETTING_BRIDGE_VLAN_FILTERING, TRUE,
-	              NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, 4000,
-	              NM_SETTING_BRIDGE_VLANS, vlans,
-	              */
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_BRIDGE_VLANS, vlans,
+	              //NM_SETTING_BRIDGE_VLAN_FILTERING, TRUE,
+	              //NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID, 4000,
+	              //NM_SETTING_BRIDGE_GROUP_FORWARD_MASK, 19008,
 	              NULL);
 
 	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
@@ -1083,18 +1075,17 @@ test_write_bridge_port (void)
 	              NM_SETTING_WIRED_WAKE_ON_LAN, NM_SETTING_WIRED_WAKE_ON_LAN_NONE,
 	              NULL);
 
-	/* TODO: Needs to be implemented in netplan
-	vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
-	vlan = nm_bridge_vlan_new (1, 0);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (4, 4094);
-	nm_bridge_vlan_set_untagged (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	vlan = nm_bridge_vlan_new (2, 2);
-	nm_bridge_vlan_set_pvid (vlan, TRUE);
-	g_ptr_array_add (vlans, vlan);
-	*/
+	/* TODO: Needs to be implemented in netplan. */
+	//vlans = g_ptr_array_new_with_free_func ((GDestroyNotify) nm_bridge_vlan_unref);
+	//vlan = nm_bridge_vlan_new (1, 0);
+	//nm_bridge_vlan_set_untagged (vlan, TRUE);
+	//g_ptr_array_add (vlans, vlan);
+	//vlan = nm_bridge_vlan_new (4, 4094);
+	//nm_bridge_vlan_set_untagged (vlan, TRUE);
+	//g_ptr_array_add (vlans, vlan);
+	//vlan = nm_bridge_vlan_new (2, 2);
+	//nm_bridge_vlan_set_pvid (vlan, TRUE);
+	//g_ptr_array_add (vlans, vlan);
 
 	/* Bridge port */
 	s_port = nm_setting_bridge_port_new ();
@@ -1102,7 +1093,8 @@ test_write_bridge_port (void)
 	g_object_set (s_port,
 	              NM_SETTING_BRIDGE_PORT_PRIORITY, 50,
 	              NM_SETTING_BRIDGE_PORT_PATH_COST, 33,
-	              //NM_SETTING_BRIDGE_PORT_VLANS, vlans, // XXX: Not implemented in netplan
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_BRIDGE_PORT_VLANS, vlans,
 	              NULL);
 
 	nmtst_assert_connection_verifies (connection);
@@ -1152,7 +1144,8 @@ test_write_vlan (void)
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_ID, "Test Write VLAN",
 	              NM_SETTING_CONNECTION_UUID, "0f9f128b-3f77-4ff3-806d-bc1e85621c99",
-	              //NM_SETTING_CONNECTION_AUTOCONNECT, FALSE, // Not implemented by netplan
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
 	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_VLAN_SETTING_NAME,
 				  NM_SETTING_CONNECTION_INTERFACE_NAME, "enred",
 	              NULL);
@@ -1167,13 +1160,14 @@ test_write_vlan (void)
 	g_object_set (s_vlan,
 	              NM_SETTING_VLAN_PARENT, "eno1",
 	              NM_SETTING_VLAN_ID, 42,
-	              //NM_SETTING_VLAN_FLAGS, 1, // XXX: Needs to be implemented in netplan
+	              /* TODO: Needs to be implemented in netplan. */
+	              //NM_SETTING_VLAN_FLAGS, 1,
 	              NULL);
 
 	/* Add generic IP4/6 DHCP settings. */
 	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 
-	// cannot re-read because of missing eno1 definition
+	/* Cannot re-read because of missing eno1 definition. */
 	_writer_new_connection_no_reread (connection,
 	                                  TEST_SCRATCH_DIR_TMP,
 	                                  &testfile,
@@ -1242,12 +1236,12 @@ test_write_bond_main (void)
 	/* Add generic IP4/6 DHCP settings. */
 	_add_ip_auto_settings (connection, &s_ip4, &s_ip6);
 
-	// cannot re-read because of missing slave0 definition
+	/* Cannot re-read because of missing eno1 definition. */
 	_writer_new_connection_no_reread (connection,
 	                                  TEST_SCRATCH_DIR_TMP,
 	                                  &testfile,
 	                                  TEST_NETPLAN_DIR"/exp-bond-main.yaml");
-	/* Manually re-read with added slave (dummy) interfaces, to make the
+	/* Manually re-read with added base (dummy) interfaces, to make the
 	 * netplan parser happy. Explicitly choose the "bond0" netdef. */
 	reread = _connection_from_file (testfile,
 	                                TEST_NETPLAN_DIR"/add-base-iface.yaml",
@@ -1528,8 +1522,7 @@ test_write_modem_cdma (void)
 	_writer_new_connection (connection, TEST_SCRATCH_DIR, &testfile);
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 static void
@@ -1575,7 +1568,8 @@ test_example_field_wifi (void)
 	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
 	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
 	g_object_set (s_wsec,
-	              //NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", // XXX: This seems to be invalid: Only valid for WEP, not WPA-PSK
+	              /* XXX: AUTH_ALG=open seems to be invalid for WPA-PSK. */
+	              //NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open",
 	              //NM_SETTING_WIRELESS_SECURITY_GROUP, "",
 	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "wpa-psk",
 	              //NM_SETTING_WIRELESS_SECURITY_PAIRWISE, ""
@@ -1609,8 +1603,7 @@ test_example_field_wifi (void)
 
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 static void
@@ -1673,8 +1666,7 @@ test_example_field_lte (void)
 
 	reread = _connection_from_file (testfile, NULL, NULL, NULL);
 
-	nm_connection_add_setting (connection, nm_setting_proxy_new ());
-	nmtst_assert_connection_equals (connection, FALSE, reread, FALSE);
+	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
 }
 
 /*****************************************************************************/
-- 
2.25.1


From b1fd8cb803ceabcaefe63191394dc55abbbb3d97 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 29 Apr 2020 15:49:28 +0200
Subject: [PATCH 59/78] netplan: cleanup reader

Get rid of all the ifcfg-rh boilerplate code.
Keep only the NM setting names/function calls and IFCFG-RH setting names
for reference, at its corresponding place. We can always look up the
logic in the ifcfg-rh plugin.
---
 .../plugins/netplan/nms-netplan-reader.c      | 1363 +++--------------
 1 file changed, 194 insertions(+), 1169 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index a3c5dbcdee0c5e3c52e30fb733a14e1ed3f81d56..1aedb6ea661ecf609656717151804167e23b0250 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -67,79 +67,8 @@
 
 /*****************************************************************************/
 
-#if 0   /* TODO: Support certs for reading from netplan files. */
-static gboolean
-_cert_get_cert (NetplanNetDefinition *nd,
-                const char *netplan_key,
-                GBytes **out_cert,
-                NMSetting8021xCKScheme *out_scheme,
-                GError **error)
-{
-	nm_auto_free_secret char *val_free = NULL;
-	const char *val;
-	gs_unref_bytes GBytes *cert = NULL;
-	GError *local = NULL;
-	NMSetting8021xCKScheme scheme;
-
-	val = svGetValueStr (netplan, netplan_key, &val_free);
-	if (!val) {
-		NM_SET_OUT (out_cert, NULL);
-		NM_SET_OUT (out_scheme, NM_SETTING_802_1X_CK_SCHEME_UNKNOWN);
-		return TRUE;
-	}
-
-	cert = _cert_get_cert_bytes (svFileGetName (netplan), val, &local);
-	if (!cert)
-		goto err;
-
-	scheme = _nm_setting_802_1x_cert_get_scheme (cert, &local);
-	if (scheme == NM_SETTING_802_1X_CK_SCHEME_UNKNOWN)
-		goto err;
-
-	NM_SET_OUT (out_cert, g_steal_pointer (&cert));
-	NM_SET_OUT (out_scheme, scheme);
-	return TRUE;
-
-err:
-	g_set_error (error,
-	             NM_SETTINGS_ERROR,
-	             NM_SETTINGS_ERROR_INVALID_CONNECTION,
-	             "invalid certificate %s: %s",
-	             netplan_key,
-	             local->message);
-	g_error_free (local);
-	return FALSE;
-}
-
-static gboolean
-_cert_set_from_netplan (gpointer setting,
-                        NetplanNetDefinition *nd,
-                        const char *netplan_key,
-                        const char *property_name,
-                        GBytes **out_cert,
-                        GError **error)
-{
-	gs_unref_bytes GBytes *cert = NULL;
-
-	if (!_cert_get_cert (netplan,
-	                     netplan_key,
-	                     &cert,
-	                     NULL,
-	                     error))
-		return FALSE;
-
-	g_object_set (setting, property_name, cert, NULL);
-
-	NM_SET_OUT (out_cert, g_steal_pointer (&cert));
-	return TRUE;
-}
-#endif /* cert support */
-
-/*****************************************************************************/
-
 static void
-check_if_bond_slave (NetplanNetDefinition *nd,
-                     NMSettingConnection *s_con)
+check_if_bond_slave (NetplanNetDefinition *nd, NMSettingConnection *s_con)
 {
 	const char *v;
 	const char *master;
@@ -161,33 +90,11 @@ check_if_bond_slave (NetplanNetDefinition *nd,
 }
 
 #if 0  /* TODO: Implement (read) Team support  */
+NM_SETTING_CONNECTION_MASTER
+NM_SETTING_CONNECTION_SLAVE_TYPE (NM_SETTING_TEAM_SETTING_NAME)
 static void
-check_if_team_slave (NetplanNetDefinition *nd,
-                     NMSettingConnection *s_con)
-{
-	gs_free char *value = NULL;
-	const char *v;
-	const char *master;
-
-	v = svGetValueStr (netplan, "TEAM_MASTER_UUID", &value);
-	if (!v)
-		v = svGetValueStr (netplan, "TEAM_MASTER", &value);
-	if (!v)
-		return;
-
-	master = nm_setting_connection_get_master (s_con);
-	if (master) {
-		PARSE_WARNING ("Already configured as slave of %s. Ignoring TEAM_MASTER{_UUID}=\"%s\"",
-		               master, v);
-		return;
-	}
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_MASTER, v,
-	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_TEAM_SETTING_NAME,
-	              NULL);
-}
-#endif /* team support */
+check_if_team_slave (NetplanNetDefinition *nd, NMSettingConnection *s_con)
+#endif
 
 static char *
 make_connection_name (NetplanNetDefinition *nd,
@@ -254,8 +161,7 @@ make_connection_setting (const char *file,
 		uuid = uuid_free;
 	}
 
-	/* XXX: Can the stable-id be unset, or do we need to create one? E.g. via g_strdup(new_id)? */
-	stable_id = nd->backend_settings.nm.stable_id ? nd->backend_settings.nm.stable_id : NULL;
+	stable_id = nd->backend_settings.nm.stable_id ?: NULL;
 	g_object_set (s_con,
 	              NM_SETTING_CONNECTION_TYPE, type,
 	              NM_SETTING_CONNECTION_UUID, uuid,
@@ -280,66 +186,21 @@ make_connection_setting (const char *file,
 	}
 
 #if 0  /* TODO: handle LLDP, ONBOOT (autoconnect) settings for NM */
-	v = svGetValueStr (netplan, "LLDP", &value);
-	if (nm_streq0 (v, "rx"))
-		lldp = NM_SETTING_CONNECTION_LLDP_ENABLE_RX;
-	else
-		lldp = svParseBoolean (v, NM_SETTING_CONNECTION_LLDP_DEFAULT);
-
-	/* Missing ONBOOT is treated as "ONBOOT=true" by the old network service */
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_AUTOCONNECT,
-	              svGetValueBoolean (netplan, "ONBOOT", TRUE),
-	              NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY,
-	              (int) svGetValueInt64 (netplan, "AUTOCONNECT_PRIORITY", 10,
-	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN,
-	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX,
-	                                      NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT),
-	              NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES,
-	              (int) svGetValueInt64 (netplan, "AUTOCONNECT_RETRIES", 10,
-	                                      -1, G_MAXINT32, -1),
-	              NM_SETTING_CONNECTION_MULTI_CONNECT,
-	              (gint) svGetValueInt64 (netplan, "MULTI_CONNECT", 10,
-	                                      G_MININT32, G_MAXINT32, NM_CONNECTION_MULTI_CONNECT_DEFAULT),
-	              NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES,
-	              svGetValueBoolean (netplan, "AUTOCONNECT_SLAVES", NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT),
-	              NM_SETTING_CONNECTION_LLDP, lldp,
-	              NULL);
-	nm_clear_g_free (&value);
+NM_SETTING_CONNECTION_AUTOCONNECT
+NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY
+NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES
+NM_SETTING_CONNECTION_MULTI_CONNECT
+NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES
+NM_SETTING_CONNECTION_LLDP
 #endif
 
 #if 0  /* TODO: User permissions handling in netplan syntax */
-	v = svGetValueStr (netplan, "USERS", &value);
-	if (v) {
-		gs_free const char **items = NULL;
-
-		items = nm_utils_strsplit_set (v, " ");
-		for (iter = items; iter && *iter; iter++) {
-			if (!nm_setting_connection_add_permission (s_con, "user", *iter, NULL))
-				PARSE_WARNING ("invalid USERS item '%s'", *iter);
-		}
-	}
-
-	nm_clear_g_free (&value);
+nm_setting_connection_add_permission (s_con, "user", *iter, NULL);
 #endif
 
 #if 0  /* TODO: Support ZONE (firewall), Secondary UUIDs, etc. */
-	v = svGetValueStr (netplan, "ZONE", &value);
-	g_object_set (s_con, NM_SETTING_CONNECTION_ZONE, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "SECONDARY_UUIDS", &value);
-	if (v) {
-		gs_free const char **items = NULL;
-
-		items = nm_utils_strsplit_set (v, " \t");
-		for (iter = items; iter && *iter; iter++) {
-			if (!nm_setting_connection_add_secondary (s_con, *iter))
-				PARSE_WARNING ("secondary connection UUID '%s' already added", *iter);
-		}
-	}
-
-	nm_clear_g_free (&value);
+NM_SETTING_CONNECTION_ZONE
+nm_setting_connection_add_secondary (s_con, *iter);
 #endif
 
 	v = nd->bridge;
@@ -361,152 +222,30 @@ make_connection_setting (const char *file,
 	//check_if_team_slave (nd, s_con);
 
 #if 0  /* TODO: OVS support */
-	v = svGetValueStr (netplan, "OVS_PORT_UUID", &value);
-	if (!v)
-		v = svGetValueStr (netplan, "OVS_PORT", &value);
-	if (v) {
-		const char *old_value;
-
-		if ((old_value = nm_setting_connection_get_master (s_con))) {
-			PARSE_WARNING ("Already configured as slave of %s. Ignoring OVS_PORT=\"%s\"",
-			               old_value, v);
-		} else {
-			g_object_set (s_con, NM_SETTING_CONNECTION_MASTER, v, NULL);
-			g_object_set (s_con, NM_SETTING_CONNECTION_SLAVE_TYPE,
-			              NM_SETTING_OVS_PORT_SETTING_NAME, NULL);
-		}
-	}
-
-	nm_clear_g_free (&value);
-#endif  /* OVS support */
+NM_SETTING_CONNECTION_MASTER
+NM_SETTING_CONNECTION_SLAVE_TYPE (NM_SETTING_OVS_PORT_SETTING_NAME)
+#endif
 
 #if 0  /* TODO: more random settings that are NM-specific */
-	v = svGetValueStr (netplan, "GATEWAY_PING_TIMEOUT", &value);
-	if (v) {
-		gint64 tmp;
-
-		tmp = _nm_utils_ascii_str_to_int64 (v, 10, 0, G_MAXINT32 - 1, -1);
-		if (tmp >= 0) {
-			if (tmp > 600) {
-				tmp = 600;
-				PARSE_WARNING ("invalid GATEWAY_PING_TIMEOUT time");
-			}
-			g_object_set (s_con, NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT, (guint) tmp, NULL);
-		} else
-			PARSE_WARNING ("invalid GATEWAY_PING_TIMEOUT time");
-	}
-
-	switch (svGetValueBoolean (netplan, "CONNECTION_METERED", -1)) {
-	case TRUE:
-		g_object_set (s_con, NM_SETTING_CONNECTION_METERED, NM_METERED_YES, NULL);
-		break;
-	case FALSE:
-		g_object_set (s_con, NM_SETTING_CONNECTION_METERED, NM_METERED_NO, NULL);
-		break;
-	}
-
-	vint64 = svGetValueInt64 (netplan, "AUTH_RETRIES", 10, -1, G_MAXINT32, -1);
-	g_object_set (s_con, NM_SETTING_CONNECTION_AUTH_RETRIES, (int) vint64, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DEVTIMEOUT", &value);
-	if (v) {
-		vint64 = _nm_utils_ascii_str_to_int64 (v, 10, 0, ((gint64) G_MAXINT32) / 1000, -1);
-		if (vint64 != -1)
-			vint64 *= 1000;
-		else {
-			char *endptr;
-			double d;
-
-			d = g_ascii_strtod (v, &endptr);
-			if (   errno == 0
-			    && endptr[0] == '\0'
-			    && d >= 0.0) {
-				d *= 1000.0;
-
-				/* We round. Yes, this is not correct to round IEEE 754 floats in general,
-				 * but sufficient for our case where we know that NetworkManager wrote the
-				 * setting with up to 3 digits for the milliseconds. */
-				d += 0.5;
-				if (   d >= 0.0
-				    && d <= (double) G_MAXINT32)
-					vint64 = (gint64) d;
-			}
-		}
-		if (vint64 == -1)
-			PARSE_WARNING ("invalid DEVTIMEOUT setting");
-		else
-			g_object_set (s_con, NM_SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT, (int) vint64, NULL);
-	}
-
-	i_val = NM_SETTING_CONNECTION_MDNS_DEFAULT;
-	if (!svGetValueEnum (netplan, "MDNS",
-	                     nm_setting_connection_mdns_get_type (),
-	                     &i_val, NULL))
-		PARSE_WARNING ("invalid MDNS setting");
-	g_object_set (s_con, NM_SETTING_CONNECTION_MDNS, i_val, NULL);
+NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT
+NM_SETTING_CONNECTION_METERED
+NM_SETTING_CONNECTION_AUTH_RETRIES
+NM_SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT
+NM_SETTING_CONNECTION_MDNS
 #endif
 
 #if 0  /* TODO: LLMNR settings support */
-	i_val = NM_SETTING_CONNECTION_LLMNR_DEFAULT;
-	if (!svGetValueEnum (netplan, "LLMNR",
-	                     nm_setting_connection_llmnr_get_type (),
-	                     &i_val, NULL))
-		PARSE_WARNING ("invalid LLMNR setting");
-	g_object_set (s_con, NM_SETTING_CONNECTION_LLMNR, i_val, NULL);
+NM_SETTING_CONNECTION_LLMNR
 #endif
 
 	return NM_SETTING (s_con);
 }
 
-#if 0
+#if 0  /* TODO: Parse through the GArray of addresses and pick just the ipv4 (static addresses) */
 static gboolean
-read_ip4_address (NetplanNetDefinition *nd,
-                  const char *tag,
-                  gboolean *out_has_key,
-                  guint32 *out_addr,
-                  GError **error)
-{
-	//const char *value;
-	//in_addr_t a;
-
-	nm_assert (nd);
-	nm_assert (tag);
-	nm_assert (!error || !*error);
-
-	// TODO: Parse through the GArray of addresses and pick just the ipv4 (static addresses)
-
-	return TRUE;
-}
-
+read_ip4_address (NetplanNetDefinition *nd, const char *tag, gboolean *out_has_key, guint32 *out_addr, GError **error)
 static gboolean
 is_any_ip4_address_defined (NetplanNetDefinition *nd, int *idx)
-{
-	int i, ignore, *ret_idx;
-
-	ret_idx = idx ?: &ignore;
-
-	for (i = -1; i <= 2; i++) {
-		gs_free char *value = NULL;
-		char tag[256];
-
-		if (svGetValueStr (netplan, numbered_tag (tag, "IPADDR", i), &value)) {
-			*ret_idx = i;
-			return TRUE;
-		}
-
-		if (svGetValueStr (netplan, numbered_tag (tag, "PREFIX", i), &value)) {
-			*ret_idx = i;
-			return TRUE;
-		}
-
-		if (svGetValueStr (netplan, numbered_tag (tag, "NETMASK", i), &value)) {
-			*ret_idx = i;
-			return TRUE;
-		}
-	}
-	return FALSE;
-}
 #endif
 
 /*****************************************************************************/
@@ -577,44 +316,10 @@ parse_full_ip6_address (NetplanNetDefinition *nd,
 #if 0   /* TODO: Support user settings in netplan schema */
 static NMSetting *
 make_user_setting (NetplanNetDefinition *nd)
-{
-	gboolean has_user_data = FALSE;
-	gs_unref_object NMSettingUser *s_user = NULL;
-	gs_unref_hashtable GHashTable *keys = NULL;
-	GHashTableIter iter;
-	const char *key;
-	nm_auto_free_gstring GString *str = NULL;
 
-	g_hash_table_iter_init (&iter, keys);
-	while (g_hash_table_iter_next (&iter, (gpointer *) &key, NULL)) {
-		const char *value;
-		gs_free char *value_to_free = NULL;
-
-		value = svGetValue (netplan, key, &value_to_free);
-
-		if (!value)
-			continue;
-
-		if (!str)
-			str = g_string_sized_new (100);
-		else
-			g_string_set_size (str, 0);
-
-		if (!nms_netplan_utils_user_key_decode (key + NM_STRLEN ("NM_USER_"), str))
-			continue;
-
-		if (!s_user)
-			s_user = NM_SETTING_USER (nm_setting_user_new ());
-
-		if (nm_setting_user_set_data (s_user, str->str,
-		                              value, NULL))
-			has_user_data = TRUE;
-	}
-
-	return   has_user_data
-	       ? NM_SETTING (g_steal_pointer (&s_user))
-	       : NULL;
-}
+nms_netplan_utils_user_key_decode (key + NM_STRLEN ("NM_USER_"), str)
+s_user = NM_SETTING_USER (nm_setting_user_new ());
+nm_setting_user_set_data (s_user, str->str, value, NULL))
 #endif /* user settings */
 
 static NMSetting *
@@ -637,53 +342,13 @@ make_match_setting (NetplanNetDefinition *nd)
 #if 0  /* TODO: proxy support */
 static NMSetting *
 make_proxy_setting (NetplanNetDefinition *nd)
-{
-	NMSettingProxy *s_proxy = NULL;
-	gs_free char *value = NULL;
-	const char *v;
-	NMSettingProxyMethod method;
 
-	v = svGetValueStr (netplan, "PROXY_METHOD", &value);
-	if (!v)
-		return NULL;
-
-	if (!g_ascii_strcasecmp (v, "auto"))
-		method = NM_SETTING_PROXY_METHOD_AUTO;
-	else
-		method = NM_SETTING_PROXY_METHOD_NONE;
-
-	s_proxy = (NMSettingProxy *) nm_setting_proxy_new ();
-
-	switch (method) {
-	case NM_SETTING_PROXY_METHOD_AUTO:
-		g_object_set (s_proxy,
-		              NM_SETTING_PROXY_METHOD, (int) NM_SETTING_PROXY_METHOD_AUTO,
-		              NULL);
-
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "PAC_URL", &value);
-		if (v)
-			g_object_set (s_proxy, NM_SETTING_PROXY_PAC_URL, v, NULL);
-
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "PAC_SCRIPT", &value);
-		if (v)
-			g_object_set (s_proxy, NM_SETTING_PROXY_PAC_SCRIPT, v, NULL);
-
-		break;
-	case NM_SETTING_PROXY_METHOD_NONE:
-		g_object_set (s_proxy,
-		              NM_SETTING_PROXY_METHOD, (int) NM_SETTING_PROXY_METHOD_NONE,
-		              NULL);
-		break;
-	}
-
-	if (svGetValueBoolean (netplan, "BROWSER_ONLY", FALSE))
-		g_object_set (s_proxy, NM_SETTING_PROXY_BROWSER_ONLY, TRUE, NULL);
-
-	return NM_SETTING (s_proxy);
-}
-#endif  /* proxy support */
+s_proxy = (NMSettingProxy *) nm_setting_proxy_new ();
+NM_SETTING_PROXY_METHOD
+NM_SETTING_PROXY_PAC_URL
+NM_SETTING_PROXY_PAC_SCRIPT
+NM_SETTING_PROXY_BROWSER_ONLY
+#endif
 
 static void
 make_routes (NetplanNetDefinition *nd, NMSettingIPConfig *s_ip, guint family)
@@ -721,83 +386,14 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	s_ip4 = (NMSettingIPConfig *) nm_setting_ip4_config_new ();
 
 #if 0  /* TODO: Review defroute magic for never-default */
-	const char *v;
-	const char *dns_options = NULL;
-	int i;
-	guint32 a;
-	gboolean has_key;
-	gboolean never_default;
-	gint64 timeout;
-	int priority;
-	const char *const *item;
-	guint32 route_table;
-
-	nm_assert (out_has_defroute && !*out_has_defroute);
-
-	/* First check if DEFROUTE is set for this device; DEFROUTE has the
-	 * opposite meaning from never-default. The default if DEFROUTE is not
-	 * specified is DEFROUTE=yes which means that this connection can be used
-	 * as a default route
-	 */
-	i = svGetValueBoolean (netplan, "DEFROUTE", -1);
-	if (i == -1)
-		never_default = FALSE;
-	else {
-		never_default = !i;
-		*out_has_defroute = TRUE;
-	}
-
-	/* Then check if GATEWAYDEV; it's global and overrides DEFROUTE */
-	if (network_netplan) {
-		gs_free char *gatewaydev_value = NULL;
-		const char *gatewaydev;
-
-		/* Get the connection netplan device name and the global gateway device */
-		v = svGetValueStr (netplan, "DEVICE", &value);
-		gatewaydev = svGetValueStr (network_netplan, "GATEWAYDEV", &gatewaydev_value);
-		dns_options = svGetValue (network_netplan, "RES_OPTIONS", &dns_options_free);
-
-		/* If there was a global gateway device specified, then only connections
-		 * for that device can be the default connection.
-		 */
-		if (gatewaydev && v)
-			never_default = !!strcmp (v, gatewaydev);
-
-		nm_clear_g_free (&value);
-	}
-
-	v = svGetValueStr (netplan, "BOOTPROTO", &value);
-
-	if (!v || !*v || !g_ascii_strcasecmp (v, "none")) {
-		if (is_any_ip4_address_defined (netplan, NULL))
-			method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
-		else
-			method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
-	} else if (!g_ascii_strcasecmp (v, "bootp") || !g_ascii_strcasecmp (v, "dhcp")) {
-		method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
-	} else if (!g_ascii_strcasecmp (v, "static")) {
-		if (is_any_ip4_address_defined (netplan, NULL))
-			method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
-		else
-			method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
-	} else if (!g_ascii_strcasecmp (v, "autoip")) {
-		method = NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL;
-	} else if (!g_ascii_strcasecmp (v, "shared")) {
-		method = NM_SETTING_IP4_CONFIG_METHOD_SHARED;
-	} else {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Unknown BOOTPROTO '%s'", v);
-		return NULL;
-	}
-
-	/* the route table (policy routing) is ignored if we don't handle routes. */
-	route_table = svGetValueInt64 (netplan, "IPV4_ROUTE_TABLE", 10,
-	                               0, G_MAXUINT32, 0);
-	if (   route_table != 0
-	    && !routes_read) {
-		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing (IPV4_ROUTE_TABLE) is ignored");
-		route_table = 0;
-	}
+NM_SETTING_IP4_CONFIG_METHOD_*
+ifcfg-rh:
+DEFROUTE
+DEVICE
+GATEWAYDEV
+RES_OPTIONS
+BOOTPROTO
+IPV4_ROUTE_TABLE
 #endif
 
 	if (nd->ip4_addresses)
@@ -826,29 +422,9 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	if (nd->dhcp4 && !nd->dhcp4_overrides.send_hostname)
 		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
 #if 0
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DHCP_HOSTNAME", &value);
-	if (v)
-		g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DHCP_FQDN", &value);
-	if (v) {
-		g_object_set (s_ip4,
-		              NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, NULL,
-		              NM_SETTING_IP4_CONFIG_DHCP_FQDN, v,
-		              NULL);
-	}
-
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, svGetValueBoolean (netplan, "DHCP_SEND_HOSTNAME", TRUE),
-	              NM_SETTING_IP_CONFIG_DHCP_TIMEOUT, svGetValueInt64 (netplan, "IPV4_DHCP_TIMEOUT", 10, 0, G_MAXINT32, 0),
-	              NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DHCP_CLIENT_ID", &value);
-	if (v)
-		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID, v, NULL);
+NM_SETTING_IP_CONFIG_DHCP_TIMEOUT
+NM_SETTING_IP4_CONFIG_DHCP_FQDN
+NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID
 #endif
 
 	/* Read static IP addresses.
@@ -867,7 +443,6 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 	}
 
 #if 0
-
 	if (gateway && never_default)
 		PARSE_WARNING ("GATEWAY will be ignored when DEFROUTE is disabled");
 #endif
@@ -883,79 +458,25 @@ make_ip4_setting (NetplanNetDefinition *nd, GError **error)
 												 g_array_index(nd->search_domains, char*, i));
 
 #if 0  /* TODO: Implement read for connection sharing. */
-	/* We used to skip saving a lot of unused properties for the ipv4 shared method.
-	 * We want now to persist them but... unfortunately loading DNS or DOMAIN options
-	 * would cause a fail in the ipv4 verify() function. As we don't want any regression
-	 * in the unlikely event that someone has a working netplan file for an IPv4 shared ip
-	 * connection with a crafted "DNS" entry... don't load it. So we will avoid failing
-	 * the connection) */
-	if (!nm_streq (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED)) {
-		/* DNS servers
-		 * Pick up just IPv4 addresses (IPv6 addresses are taken by make_ip6_setting())
-		 */
-		for (i = 1; i <= 10; i++) {
-			char tag[256];
-
-			numbered_tag (tag, "DNS", i);
-			nm_clear_g_free (&value);
-			v = svGetValueStr (netplan, tag, &value);
-			if (v) {
-				if (nm_utils_ipaddr_valid (AF_INET, v)) {
-					if (!nm_setting_ip_config_add_dns (s_ip4, v))
-						PARSE_WARNING ("duplicate DNS server %s", tag);
-				} else if (nm_utils_ipaddr_valid (AF_INET6, v)) {
-					/* Ignore IPv6 addresses */
-				} else {
-					PARSE_WARNING ("invalid DNS server address %s", v);
-					return NULL;
-				}
-			}
-		}
-
-		/* DNS searches */
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "DOMAIN", &value);
-		if (v) {
-			gs_free const char **searches = NULL;
-
-			searches = nm_utils_strsplit_set (v, " ");
-			if (searches) {
-				for (item = searches; *item; item++) {
-					if (!nm_setting_ip_config_add_dns_search (s_ip4, *item))
-						PARSE_WARNING ("duplicate DNS domain '%s'", *item);
-				}
-			}
-		}
-	}
-
-	/* DNS options */
-	nm_clear_g_free (&value);
-	parse_dns_options (s_ip4, svGetValue (netplan, "RES_OPTIONS", &value));
-	parse_dns_options (s_ip4, dns_options);
-#endif /* shared */
+NM_SETTING_IP4_CONFIG_METHOD_SHARED
+nm_setting_ip_config_add_dns (s_ip4, v)
+nm_setting_ip_config_add_dns_search (s_ip4, *item)
+ifcfg-rh:
+DNS
+DOMAIN
+RES_OPTIONS
+#endif
 
 #if 0  /* TODO: DNS priority */
-	/* DNS priority */
-	priority = svGetValueInt64 (netplan, "IPV4_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
-	g_object_set (s_ip4,
-	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
-	              priority,
-	              NULL);
+NM_SETTING_IP_CONFIG_DNS_PRIORITY
 #endif
 
 	if (nd->routes)
 		make_routes(nd, s_ip4, AF_INET);
 
 #if 0 /* TODO: dad-timeout */
-	timeout = svGetValueInt64 (netplan, "ACD_TIMEOUT", 10, -1, NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX, -2);
-	if (timeout == -2) {
-		timeout = svGetValueInt64 (netplan, "ARPING_WAIT", 10, -1,
-		                           NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX / 1000, -1);
-		if (timeout > 0)
-			timeout *= 1000;
-	}
-	g_object_set (s_ip4, NM_SETTING_IP_CONFIG_DAD_TIMEOUT, (int) timeout, NULL);
-#endif  /* DNS prio, routes */
+NM_SETTING_IP_CONFIG_DAD_TIMEOUT
+#endif
 
 	return NM_SETTING (g_steal_pointer (&s_ip4));
 }
@@ -991,114 +512,32 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	s_ip6 = (NMSettingIPConfig *) nm_setting_ip6_config_new ();
 
 #if 0  /* TODO: never-default for ipv6 */
-	/* First check if IPV6_DEFROUTE is set for this device; IPV6_DEFROUTE has the
-	 * opposite meaning from never-default. The default if IPV6_DEFROUTE is not
-	 * specified is IPV6_DEFROUTE=yes which means that this connection can be used
-	 * as a default route
-	 */
-	never_default = !svGetValueBoolean (netplan, "IPV6_DEFROUTE", TRUE);
+ifcfg-rh:
+IPV6_DEFROUTE
 #endif
 
 #if 0  /* TODO: ipv6 gateway and all */
-	/* Then check if IPV6_DEFAULTGW or IPV6_DEFAULTDEV is specified;
-	 * they are global and override IPV6_DEFROUTE
-	 * When both are set, the device specified in IPV6_DEFAULTGW takes preference.
-	 */
-	if (network_netplan) {
-		const char *ipv6_defaultgw, *ipv6_defaultdev;
-		gs_free char *ipv6_defaultgw_to_free = NULL;
-		gs_free char *ipv6_defaultdev_to_free = NULL;
-		const char *default_dev = NULL;
-
-		/* Get the connection netplan device name and the global default route device */
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "DEVICE", &value);
-		ipv6_defaultgw = svGetValueStr (network_netplan, "IPV6_DEFAULTGW", &ipv6_defaultgw_to_free);
-		ipv6_defaultdev = svGetValueStr (network_netplan, "IPV6_DEFAULTDEV", &ipv6_defaultdev_to_free);
-
-		if (ipv6_defaultgw) {
-			default_dev = strchr (ipv6_defaultgw, '%');
-			if (default_dev)
-				default_dev++;
-		}
-		if (!default_dev)
-			default_dev = ipv6_defaultdev;
-
-		/* If there was a global default route device specified, then only connections
-		 * for that device can be the default connection.
-		 */
-		if (default_dev && v)
-			never_default = !!strcmp (v, default_dev);
-	}
-
-	/* Find out method property */
-	/* Is IPV6 enabled? Set method to "ignored", when not enabled */
-	disabled = svGetValueBoolean(netplan, "IPV6_DISABLED", FALSE);
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IPV6INIT", &value);
-	ipv6init = svGetValueBoolean (netplan, "IPV6INIT", FALSE);
-	if (!v) {
-		if (network_netplan)
-			ipv6init = svGetValueBoolean (network_netplan, "IPV6INIT", FALSE);
-	}
-#endif  /* defaults ipv6 */
+ifcfg-rh:
+DEVICE
+IPV6_DEFAULTGW
+IPV6_DEFAULTDEV
+IPV6_DISABLED
+IPV6INIT
+#endif
 
 #if 0  /* TODO: ipv6 config methods */
-	if (disabled)
-		method = NM_SETTING_IP6_CONFIG_METHOD_DISABLED;
-	else if (!ipv6init)
-		method = NM_SETTING_IP6_CONFIG_METHOD_IGNORE;
-	else {
-		ipv6forwarding = svGetValueBoolean (netplan, "IPV6FORWARDING", FALSE);
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "IPV6_AUTOCONF", &value);
-		dhcp6 = svGetValueBoolean (netplan, "DHCPV6C", FALSE);
-
-		if (!g_strcmp0 (v, "shared"))
-			method = NM_SETTING_IP6_CONFIG_METHOD_SHARED;
-		else if (svParseBoolean (v, !ipv6forwarding))
-			method = NM_SETTING_IP6_CONFIG_METHOD_AUTO;
-		else if (dhcp6)
-			method = NM_SETTING_IP6_CONFIG_METHOD_DHCP;
-		else {
-			/* IPV6_AUTOCONF=no and no IPv6 address -> method 'link-local' */
-			nm_clear_g_free (&value);
-			v = svGetValueStr (netplan, "IPV6ADDR", &value);
-			if (!v) {
-				nm_clear_g_free (&value);
-				v = svGetValueStr (netplan, "IPV6ADDR_SECONDARIES", &value);
-			}
-
-			if (!v)
-				method = NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL;
-		}
-	}
-
-	/* Read IPv6 Privacy Extensions configuration */
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IPV6_PRIVACY", &value);
-	if (v) {
-		ip6_privacy = svParseBoolean (v, FALSE);
-		if (!ip6_privacy)
-			ip6_privacy = (g_strcmp0 (v, "rfc4941") == 0) ||
-			              (g_strcmp0 (v, "rfc3041") == 0);
-	}
-	ip6_privacy_prefer_public_ip = svGetValueBoolean (netplan, "IPV6_PRIVACY_PREFER_PUBLIC_IP", FALSE);
-	ip6_privacy_val = v ?
-	                      (ip6_privacy ?
-	                          (ip6_privacy_prefer_public_ip ? NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR : NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR) :
-	                          NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED) :
-	                      NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN;
-
-	/* the route table (policy routing) is ignored if we don't handle routes. */
-	route_table = svGetValueInt64 (netplan, "IPV6_ROUTE_TABLE", 10,
-	                               0, G_MAXUINT32, 0);
-	if (   route_table != 0
-	    && !routes_read) {
-		PARSE_WARNING ("'rule-' or 'rule6-' files are present; Policy routing (IPV6_ROUTE_TABLE) is ignored");
-		route_table = 0;
-	}
-#endif  /* ipv6 methods and settings */
+NM_SETTING_IP6_CONFIG_METHOD_*
+NM_SETTING_IP6_CONFIG_PRIVACY_*
+ifcfg-rh:
+IPV6FORWARDING
+DHCPV6C
+IPV6_AUTOCONF
+IPV6ADDR
+IPV6ADDR_SECONDARIES
+IPV6_PRIVACY
+IPV6_PRIVACY_PREFER_PUBLIC_IP
+IPV6_ROUTE_TABLE
+#endif
 
 	/* Skip if we have neither static nor dynamic IP6 config */
 	if (!nd->ip6_addresses && !nd->dhcp6) {
@@ -1126,8 +565,7 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 	              NM_SETTING_IP6_CONFIG_IP6_PRIVACY, NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
 	              NULL);
 
-#if 0
-	/* Don't bother to read IP, DNS and routes when IPv6 is disabled */
+#if 0  /* TODO: Don't bother to read IP, DNS and routes when IPv6 is disabled */
 	if (NM_IN_STRSET (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
 	                          NM_SETTING_IP6_CONFIG_METHOD_DISABLED))
 		return NM_SETTING (g_steal_pointer (&s_ip6));
@@ -1140,29 +578,16 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME, FALSE, NULL);
 
 #if 0  /* TODO: Implement IPv6 DUID, hostname and special DHCP options */
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DHCPV6_DUID", &value);
-	if (v)
-		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_DHCP_DUID, v, NULL);
-
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "DHCPV6_HOSTNAME", &value);
-	/* Use DHCP_HOSTNAME as fallback if it is in FQDN format and ipv6.method is
-	 * auto or dhcp: this is required to support old netplan files
-	 */
-	if (!v && (   !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
-		       || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_DHCP))) {
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "DHCP_HOSTNAME", &value);
-		if (v && !strchr (v, '.'))
-			v = NULL;
-	}
-	if (v)
-		g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_HOSTNAME, v, NULL);
-
-	g_object_set (s_ip6, NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME,
-	              svGetValueBoolean (netplan, "DHCPV6_SEND_HOSTNAME", TRUE), NULL);
-#endif  /* IPv6 DUID, hostname and special DHCP options */
+NM_SETTING_IP6_CONFIG_DHCP_DUID
+NM_SETTING_IP6_CONFIG_METHOD_*
+NM_SETTING_IP_CONFIG_DHCP_HOSTNAME
+NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME
+ifcfg-rh:
+DHCPV6_DUID
+DHCPV6_HOSTNAME
+DHCP_HOSTNAME
+DHCPV6_SEND_HOSTNAME
+#endif
 
 	/* Read static IP addresses. */
 	if (nd->ip6_addresses) {
@@ -1181,59 +606,20 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 										  g_array_index(nd->ip6_nameservers, char*, i));
 
 #if 0  /* TODO: IPv6: read static addresses. */
-	ipv6addr = svGetValueStr (netplan, "IPV6ADDR", &ipv6addr_to_free);
-	ipv6addr_secondaries = svGetValueStr (netplan, "IPV6ADDR_SECONDARIES", &ipv6addr_secondaries_to_free);
-
-	nm_clear_g_free (&value);
-	value = g_strjoin (ipv6addr && ipv6addr_secondaries ? " " : NULL,
-	                   ipv6addr ?: "",
-	                   ipv6addr_secondaries ?: "",
-	                   NULL);
-
-	list = nm_utils_strsplit_set (value, " ");
-	for (iter = list, i = 0; iter && *iter; iter++, i++) {
-		NMIPAddress *addr = NULL;
-
-		if (!parse_full_ip6_address (netplan, *iter, i, &addr, error))
-			return NULL;
-
-		if (!nm_setting_ip_config_add_address (s_ip6, addr))
-			PARSE_WARNING ("duplicate IP6 address");
-		nm_ip_address_unref (addr);
-	}
-#endif  /* IPv6: read static addresses. */
+parse_full_ip6_address (netplan, *iter, i, &addr, error)
+nm_setting_ip_config_add_address (s_ip6, addr)
+ifcfg-rh:
+IPV6ADDR
+IPV6ADDR_SECONDARIES
+#endif
 
 #if 0  /* IPv6: read gateway. */
-	/* Gateway */
-	if (nm_setting_ip_config_get_num_addresses (s_ip6)) {
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, "IPV6_DEFAULTGW", &value);
-		if (!v) {
-			/* If no gateway in the netplan, try global /etc/sysconfig/network instead */
-			if (network_netplan) {
-				nm_clear_g_free (&value);
-				v = svGetValueStr (network_netplan, "IPV6_DEFAULTGW", &value);
-			}
-		}
-		if (v) {
-			char *ptr;
-			if ((ptr = strchr (v, '%')) != NULL)
-				*ptr = '\0';  /* remove %interface prefix if present */
-			if (!nm_utils_ipaddr_valid (AF_INET6, v)) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Invalid IP6 address '%s'", v);
-				return NULL;
-			}
-
-			g_object_set (s_ip6, NM_SETTING_IP_CONFIG_GATEWAY, v, NULL);
-		}
-	}
-
-	/* IPv6 tokenized interface identifier */
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IPV6_TOKEN", &value);
-	if (v)
-		g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_TOKEN, v, NULL);
+nm_setting_ip_config_get_num_addresses (s_ip6)
+NM_SETTING_IP_CONFIG_GATEWAY
+NM_SETTING_IP6_CONFIG_TOKEN
+ifcfg-rh:
+IPV6_DEFAULTGW
+IPV6_TOKEN
 #endif
 
 	/* IPv6 Address generation mode */
@@ -1245,61 +631,21 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 		              NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64, NULL);
 
 #if 0  /* TODO: set dns servers */
-	/* DNS servers
-	 * Pick up just IPv6 addresses (IPv4 addresses are taken by make_ip4_setting())
-	 */
-	for (i = 1; i <= 10; i++) {
-		char tag[256];
-
-		numbered_tag (tag, "DNS", i);
-		nm_clear_g_free (&value);
-		v = svGetValueStr (netplan, tag, &value);
-		if (!v) {
-			/* all done */
-			break;
-		}
-
-		if (nm_utils_ipaddr_valid (AF_INET6, v)) {
-			if (!nm_setting_ip_config_add_dns (s_ip6, v))
-				PARSE_WARNING ("duplicate DNS server %s", tag);
-		} else if (nm_utils_ipaddr_valid (AF_INET, v)) {
-			/* Ignore IPv4 addresses */
-		} else {
-			PARSE_WARNING ("invalid DNS server address %s", v);
-			return NULL;
-		}
-	}
+nm_setting_ip_config_add_dns (s_ip6, v)
+ifcfg-rh:
+DNS
 #endif
 
 	if (nd->routes)
 		make_routes(nd, s_ip6, AF_INET6);
 
 #if 0  /* TODO: IPv6 DNS searches */
-	/* DNS searches */
-	nm_clear_g_free (&value);
-	v = svGetValueStr (netplan, "IPV6_DOMAIN", &value);
-	if (v) {
-		gs_free const char **searches = NULL;
-
-		searches = nm_utils_strsplit_set (v, " ");
-		if (searches) {
-			for (iter = searches; *iter; iter++) {
-				if (!nm_setting_ip_config_add_dns_search (s_ip6, *iter))
-					PARSE_WARNING ("duplicate DNS domain '%s'", *iter);
-			}
-		}
-	}
-
-	/* DNS options */
-	nm_clear_g_free (&value);
-	parse_dns_options (s_ip6, svGetValue (netplan, "IPV6_RES_OPTIONS", &value));
-
-	/* DNS priority */
-	priority = svGetValueInt64 (netplan, "IPV6_DNS_PRIORITY", 10, G_MININT32, G_MAXINT32, 0);
-	g_object_set (s_ip6,
-	              NM_SETTING_IP_CONFIG_DNS_PRIORITY,
-	              priority,
-	              NULL);
+nm_setting_ip_config_add_dns_search (s_ip6, *iter)
+NM_SETTING_IP_CONFIG_DNS_PRIORITY
+ifcfg-rh:
+IPV6_DOMAIN
+IPV6_RES_OPTIONS
+IPV6_DNS_PRIORITY
 #endif
 
 	return NM_SETTING (g_steal_pointer (&s_ip6));
@@ -1310,139 +656,33 @@ make_ip6_setting (NetplanNetDefinition *nd, GError **error)
 /* TODO: Implement DCB support */
 /* There is useful code to look at in ifcfg-rh plugin ~cyphermox */
 
-#if 0 /* TODO: It looks like we don't really support WEP right now */
+#if 0 /* TODO: Netplan doesn't really support WEP right now */
 static gboolean
-add_one_wep_key (NetplanNetDefinition *nd,
-                 const char *shvar_key,
-                 guint8 key_idx,
-                 gboolean passphrase,
-                 NMSettingWirelessSecurity *s_wsec,
-                 GError **error)
-{
-	gs_free char *value_free = NULL;
-	const char *value;
-	const char *key = NULL;
-
-	g_return_val_if_fail (nd != NULL, FALSE);
-	g_return_val_if_fail (shvar_key != NULL, FALSE);
-	g_return_val_if_fail (key_idx <= 3, FALSE);
-	g_return_val_if_fail (s_wsec != NULL, FALSE);
-
-	value = svGetValueStr (ifcfg, shvar_key, &value_free);
-	if (!value)
-		return TRUE;
+add_one_wep_key (NetplanNetDefinition *nd, const char *shvar_key, guint8 key_idx, gboolean passphrase, NMSettingWirelessSecurity *s_wsec, GError **error)
 
-	/* Validate keys */
-	if (passphrase) {
-		if (value[0] && strlen (value) < 64)
-			key = value;
-	} else {
-		if (NM_IN_SET (strlen (value), 10, 26)) {
-			/* Hexadecimal WEP key */
-			if (NM_STRCHAR_ANY (value, ch, !g_ascii_isxdigit (ch))) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Invalid hexadecimal WEP key.");
-				return FALSE;
-			}
-			key = value;
-		} else if (   !strncmp (value, "s:", 2)
-		           && NM_IN_SET (strlen (value), 7, 15)) {
-			/* ASCII key */
-			if (NM_STRCHAR_ANY (value + 2, ch, !g_ascii_isprint (ch))) {
-				g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-				             "Invalid ASCII WEP key.");
-				return FALSE;
-			}
+nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
 
-			/* Remove 's:' prefix.
-			 * Don't convert to hex string. wpa_supplicant takes 'wep_key0' option over D-Bus as byte array
-			 * and converts it to hex string itself. Even though we convert hex string keys into a bin string
-			 * before passing to wpa_supplicant, this prevents two unnecessary conversions. And mainly,
-			 * ASCII WEP key doesn't change to HEX WEP key in UI, which could confuse users.
-			 */
-			key = value + 2;
-		}
-	}
-
-	if (!key) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Invalid WEP key length.");
-		return FALSE;
-	}
-
-	nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
-	return TRUE;
-}
 
 static gboolean
-read_wep_keys (NetplanNetDefinition *nd,
-               NMWepKeyType key_type,
-               guint8 def_idx,
-               NMSettingWirelessSecurity *s_wsec,
-               GError **error)
-{
-	if (key_type != NM_WEP_KEY_TYPE_PASSPHRASE) {
-		if (!add_one_wep_key (nd, "KEY1", 0, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY2", 1, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY3", 2, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY4", 3, FALSE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY", def_idx, FALSE, s_wsec, error))
-			return FALSE;
-	}
-
-	if (key_type != NM_WEP_KEY_TYPE_KEY) {
-		if (!add_one_wep_key (nd, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
-			return FALSE;
-		if (!add_one_wep_key (nd, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
-			return FALSE;
-	}
+read_wep_keys (NetplanNetDefinition *nd, NMWepKeyType key_type, guint8 def_idx, NMSettingWirelessSecurity *s_wsec, GError **error)
 
-	return TRUE;
-}
+NM_WEP_KEY_TYPE_PASSPHRASE
+add_one_wep_key (nd, "KEY1", 0, FALSE, s_wsec, error)
+NM_WEP_KEY_TYPE_KEY
+add_one_wep_key (nd, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error)
 #endif
 
 #if 0 /* TODO: Implement WEP in netplan */
 static NMSetting *
-make_wep_setting (NetplanNetDefinition *nd,
-                  const char *file,
-                  GError **error)
-{
-	gs_unref_object NMSettingWirelessSecurity *s_wsec = NULL;
-	gs_free char *value = NULL;
-	//int default_key_idx = 0;
-	//gboolean has_default_key = FALSE;
-	//NMSettingSecretFlags key_flags;
-
-	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none", NULL);
-
-	/* TODO: support specifying keyidx for WEP */
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0, NULL);
-
-	/* Read WEP key flags */
-	// TODO: read wifi WEP secret flags.
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS, NM_SETTING_SECRET_FLAG_NONE, NULL);
-
-	g_object_set (G_OBJECT (s_wsec),
-	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
-	              NULL);
-
-	g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "open", NULL);
-	/* TODO: Support WEP-only (apparently) "shared" AUTH_ALG... */
-	//g_object_set (s_wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared", NULL);
-
-	nm_setting_wireless_security_set_wep_key (s_wsec, 0, nd->auth.password);
-
-	return NM_SETTING (g_steal_pointer (&s_wsec));
-}
+make_wep_setting (NetplanNetDefinition *nd, const char *file, GError **error)
+
+s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+NM_SETTING_WIRELESS_SECURITY_KEY_MGMT
+NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX
+NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS
+NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE
+NM_SETTING_WIRELESS_SECURITY_AUTH_ALG
+nm_setting_wireless_security_set_wep_key (s_wsec, 0, nd->auth.password);
 #endif
 
 static gboolean
@@ -1452,38 +692,15 @@ fill_wpa_ciphers (NetplanNetDefinition *nd,
                   gboolean adhoc)
 {
 #if 0  /* TODO: WPA ciphers selection (not yet in netplan) */
-	gs_free char *value = NULL;
-	const char *p;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-	int i = 0;
-
-	p = svGetValueStr (netplan, group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE", &value);
-	if (!p)
-		return TRUE;
-
-	list = nm_utils_strsplit_set (p, " ");
-	for (iter = list; iter && *iter; iter++, i++) {
-		if (!strcmp (*iter, "CCMP")) {
-			if (group)
-				nm_setting_wireless_security_add_group (wsec, "ccmp");
-			else
-				nm_setting_wireless_security_add_pairwise (wsec, "ccmp");
-		} else if (!strcmp (*iter, "TKIP")) {
-			if (group)
-				nm_setting_wireless_security_add_group (wsec, "tkip");
-			else
-				nm_setting_wireless_security_add_pairwise (wsec, "tkip");
-		} else if (group && !strcmp (*iter, "WEP104"))
-			nm_setting_wireless_security_add_group (wsec, "wep104");
-		else if (group && !strcmp (*iter, "WEP40"))
-			nm_setting_wireless_security_add_group (wsec, "wep40");
-		else {
-			PARSE_WARNING ("ignoring invalid %s cipher '%s'",
-			               group ? "CIPHER_GROUP" : "CIPHER_PAIRWISE",
-			               *iter);
-		}
-	}
+nm_setting_wireless_security_add_group (wsec, "ccmp");
+nm_setting_wireless_security_add_pairwise (wsec, "ccmp");
+nm_setting_wireless_security_add_group (wsec, "tkip");
+nm_setting_wireless_security_add_pairwise (wsec, "tkip");
+nm_setting_wireless_security_add_group (wsec, "wep104");
+nm_setting_wireless_security_add_group (wsec, "wep40");
+ifcfg-rh:
+CIPHER_GROUP
+CIPHER_PAIRWISE
 #endif
 	return TRUE;
 }
@@ -1640,17 +857,12 @@ make_wpa_setting (NetplanNetDefinition *nd,
 			&& ap->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_8021X)
 			return NULL; /* Not WPA or Dynamic WEP */
 
-	#if 0  /* TODO: support WPS */
-		/* WPS */
-		i_val = NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT;
-		if (!svGetValueEnum (netplan, "WPS_METHOD",
-							nm_setting_wireless_security_wps_method_get_type (),
-							&i_val, error))
-			return NULL;
-		g_object_set (wsec,
-					NM_SETTING_WIRELESS_SECURITY_WPS_METHOD, (guint) i_val,
-					NULL);
-	#endif
+#if 0  /* TODO: support WPS */
+nm_setting_wireless_security_wps_method_get_type ()
+NM_SETTING_WIRELESS_SECURITY_WPS_METHOD
+ifcfg-rh:
+WPS_METHOD
+#endif
 
 		/* Pairwise and Group ciphers (only relevant for WPA/RSN) */
 		if (ap->auth.key_management == NETPLAN_AUTH_KEY_MANAGEMENT_WPA_PSK
@@ -1692,9 +904,9 @@ make_wpa_setting (NetplanNetDefinition *nd,
 	/* TODO: support WPA PMF, FILS */
 
 #if 0
-	v = svGetValueStr (netplan, "SECURITYMODE", &value);
-	if (NM_IN_STRSET (v, NULL, "open"))
-		g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, v, NULL);
+NM_SETTING_WIRELESS_SECURITY_AUTH_ALG
+ifcfg-rh:
+SECURITYMODE
 #endif
 
 	return (NMSetting *) g_steal_pointer (&wsec);
@@ -1702,57 +914,17 @@ make_wpa_setting (NetplanNetDefinition *nd,
 
 #if 0  /* TODO: LEAP not yet supported in netplan yaml */
 static NMSetting *
-make_leap_setting (NetplanNetDefinition *nd,
-                   const char *file,
-                   GError **error)
-{
-	gs_unref_object NMSettingWirelessSecurity *wsec = NULL;
-	gs_free char *value   = NULL;
-	NMSettingSecretFlag  s flags;
-  
-	wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
-
-	if (nd->auth.key_management != NETPLAN_AUTH_KEY_MANAGEMENT_8021X)
-		return NULL;
-
-	if (nd->auth.eap_method != NETPLAN_AUTH_EAP_LEAP)
-		return NULL; /* Not LEAP */
-
-	flags = _secret_read_netplan_flags (netplan, "IEEE_8021X_PASSWORD_FLAGS");
-	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS, flags, NULL);
-
-	/* Read LEAP password if it's system-owned */
-	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
-		value = svGetValueStr_cp (netplan, "IEEE_8021X_PASSWORD");
-		if (!value) {
-			/* Try to get keys from the "shadow" key file */
-			k  eys_netplan = utils_get_keys_netplan (file, FALSE);
-  			if (keys_netpl  an) {
-				  value = svGetV    alueStr_cp (keys_netplan, "IEEE_8021X_PASSWORD");
-  				svCloseFile (k      eys_netplan);
-  		    	}
-	    	}
-		if (value && strle  n (value))
-			g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD, value, NULL);
-		nm_clear_g_free (&value);
-	}
-
-	value = svGetValueStr_cp (netplan, "IEEE_8021X_IDENTITY");
-	if (!value) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Missing LEAP identity");
-		return NULL;
-	}
-	g_object_set (wsec, NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME, value, NULL);
-	nm_clear_g_free (&value);
-
-	g_object_set (wsec,
-	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "ieee8021x",
-	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "leap",
-	              NULL);
-
-	return (NMSetting *) g_steal_pointer (&wsec);
-}
+make_leap_setting (NetplanNetDefinition *nd, const char *file, GError **error)
+
+wsec = NM_SETTING_WIRELESS_SECURITY (nm_setting_wireless_security_new ());
+NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS
+NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD
+NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME
+NM_SETTING_WIRELESS_SECURITY_KEY_MGMT ("ieee8021x")
+NM_SETTING_WIRELESS_SECURITY_AUTH_ALG ("leap")
+ifcfg-rh:
+IEEE_8021X_PASSWORD
+IEEE_8021X_IDENTITY
 #endif
 
 static NMSetting *
@@ -1784,14 +956,14 @@ make_wireless_security_setting (NetplanNetDefinition *nd,
 	else if (*error)
 		return NULL;
 
-	/* XXX: WEP is not supported with netplan.
+#if 0  /* TODO: WEP is not supported with netplan. */
 	 *   Only 'none', 'psk', 'eap' and '802.1x' as handled by make_wpa_setting().
 	wsec = make_wep_setting (nd, file, error);
 	if (wsec)
 		return wsec;
 	else if (*error)
 		return NULL;
-	*/
+#endif
 
 	return NULL; /* unencrypted, open network */
 }
@@ -1908,29 +1080,10 @@ make_wireless_setting (NetplanNetDefinition *nd,
 	              NULL);
 
 #if 0  /* TODO: Add support for MAC address randomization */
-	cvalue = svGetValue (netplan, "MAC_ADDRESS_RANDOMIZATION", &value);
-	if (cvalue) {
-		if (strcmp (cvalue, "default") == 0)
-			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
-		else if (strcmp (cvalue, "never") == 0)
-			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_NEVER;
-		else if (strcmp (cvalue, "always") == 0)
-			mac_randomization = NM_SETTING_MAC_RANDOMIZATION_ALWAYS;
-		else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Invalid MAC_ADDRESS_RANDOMIZATION value '%s'", cvalue);
-			g_free (value);
-			goto error;
-		}
-		g_free (value);
-	} else
-		mac_randomization = NM_SETTING_MAC_RANDOMIZATION_DEFAULT;
-
-	g_object_set (s_wireless,
-	              NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION,
-	              mac_randomization,
-	              NULL);
-#endif  /* MAC address randomization */
+NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION
+ifcfg-rh:
+MAC_ADDRESS_RANDOMIZATION
+#endif
 
 	return NM_SETTING (s_wireless);
 
@@ -2158,7 +1311,7 @@ read_routing_rules (NetplanNetDefinition *nd,
 			nm_ip_routing_rule_set_table (rule, r->table);
 		if (r->priority != NETPLAN_IP_RULE_PRIO_UNSPEC)
 			nm_ip_routing_rule_set_priority (rule, r->priority);
-		/* XXX: Fix/implement fwmask, which is missing in NetplanNetDefinition. */
+		/* TODO: Implement fwmask, which is missing in NetplanNetDefinition. */
 		if (r->fwmark != NETPLAN_IP_RULE_FW_MARK_UNSPEC)
 			nm_ip_routing_rule_set_fwmark (rule, r->fwmark, 0);
 		if (r->tos != NETPLAN_IP_RULE_TOS_UNSPEC)
@@ -2207,35 +1360,15 @@ make_wired_setting (NetplanNetDefinition *nd,
 	/* TODO: Add subchannels and other s390 options */
 
 #if 0  /* TODO: wired: generate mac address */
-	cvalue = svGetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK", &value);
-	if (cvalue) {
-		if (cvalue[0] != '\0') {
-			g_object_set (s_wired,
-			              NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK,
-			              cvalue,
-			              NULL);
-		}
-		nm_clear_g_free (&value);
-		found = TRUE;
-	}
-#endif  /* generate mac address */
+NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK
+ifcfg-rh:
+GENERATE_MAC_ADDRESS_MASK
+#endif
 
 #if 0  /* TODO: 802.1x wired settings */
-	cvalue = svGetValue (netplan, "KEY_MGMT", &value);
-	if (cvalue)
-		found = TRUE;
-	if (cvalue && cvalue[0] != '\0') {
-		if (!strcmp (cvalue, "IEEE8021X")) {
-			*s_8021x = fill_8021x (netplan, NULL, file, cvalue, FALSE, error);
-			if (!*s_8021x)
-				return NULL;
-		} else {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Unknown wired KEY_MGMT type '%s'", cvalue);
-			return NULL;
-		}
-	}
-	nm_clear_g_free (&value);
+*s_8021x = fill_8021x (netplan, NULL, file, cvalue, FALSE, error);
+ifcfg-rh:
+KEY_MGMT
 #endif  /* 802.1x */
 
 	return (NMSetting *) g_steal_pointer (&s_wired);
@@ -2341,7 +1474,7 @@ make_bond_setting (NetplanNetDefinition *nd,
                                 nd->bond_params.learn_interval);
 	nm_setting_bond_add_option (s_bond, NM_SETTING_BOND_OPTION_PRIMARY,
                                 nd->bond_params.primary_slave);
-	// XXX: Needs to be implemented in netplan
+	/* TODO: Needs to be implemented in netplan. */
 	//#define NM_SETTING_BOND_OPTION_ACTIVE_SLAVE      "active_slave"
 	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO "ad_actor_sys_prio"
 	//#define NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM   "ad_actor_system"
@@ -2558,47 +1691,17 @@ make_bridge_port_setting (NetplanNetDefinition *nd)
 #if 0  /* TODO: Team device support */
 static NMSetting *
 make_team_port_setting (NetplanNetDefinition *nd)
-{
-	NMSetting *s_port;
-	gs_free char *value = NULL;
 
-	value = svGetValueStr_cp (netplan, "TEAM_PORT_CONFIG");
-	if (!value)
-		return NULL;
-
-	s_port = nm_setting_team_port_new ();
-	g_object_set (s_port,
-	              NM_SETTING_TEAM_PORT_CONFIG,
-	              value,
-	              NULL);
-	return s_port;
-}
+NM_SETTING_TEAM_PORT_CONFIG
+ifcfg-rh:
+TEAM_PORT_CONFIG
 #endif
 
 #if 0   /* TODO: Advanced VLAN */
 static void
-parse_prio_map_list (NMSettingVlan *s_vlan,
-                     NetplanNetDefinition *nd,
-                     const char *key,
-                     NMVlanPriorityMap map)
-{
-	gs_free char *value = NULL;
-	gs_free const char **list = NULL;
-	const char *const *iter;
-	const char *v;
-
-	v = svGetValueStr (netplan, key, &value);
-	if (!v)
-		return;
-	list = nm_utils_strsplit_set (v, ",");
+parse_prio_map_list (NMSettingVlan *s_vlan, NetplanNetDefinition *nd, const char *key, NMVlanPriorityMap map)
 
-	for (iter = list; iter && *iter; iter++) {
-		if (!strchr (*iter, ':'))
-			continue;
-		if (!nm_setting_vlan_add_priority_str (s_vlan, map, *iter))
-			PARSE_WARNING ("invalid %s priority map item '%s'", key, *iter);
-	}
-}
+!nm_setting_vlan_add_priority_str (s_vlan, map, *iter)
 #endif
 
 static NMSetting *
@@ -2698,8 +1801,7 @@ create_unhandled_connection (const char *filename, NetplanNetDefinition *nd,
 
 	/* Get NAME, UUID, etc. We need to set a connection type (generic) and add
 	 * an empty type-specific setting as well, to make sure it passes
-	 * nm_connection_verify() later.
-	 */
+	 * nm_connection_verify() later. */
 	s_con = make_connection_setting (filename, nd, NM_SETTING_GENERIC_SETTING_NAME,
 	                                 NULL, NULL);
 	nm_connection_add_setting (connection, s_con);
@@ -2716,11 +1818,9 @@ create_unhandled_connection (const char *filename, NetplanNetDefinition *nd,
 	}
 
 #if 0  /* TODO: create unhandled matching for s390 subchannels */
-	v = svGetValueStr (nd, "SUBCHANNELS", &value);
-	if (v) {
-		*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_S390_SUBCHANNELS_TAG"%s", type, v);
-		return connection;
-	}
+*out_spec = g_strdup_printf ("%s:"NM_MATCH_SPEC_S390_SUBCHANNELS_TAG"%s", type, v);
+ifcfg-rh:
+SUBCHANNELS
 #endif
 
 	v = nd->match.original_name;
@@ -2800,96 +1900,21 @@ connection_from_file_full (const char *filename,
 	}
 
 #if 0
-	if (!svGetValueBoolean (main_netplan, "NM_CONTROLLED", TRUE)) {
-		connection = create_unhandled_connection (filename, main_netplan, "unmanaged", out_unhandled);
-		if (!connection) {
-			NM_SET_OUT (out_ignore_error, TRUE);
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			             "NM_CONTROLLED was false but device was not uniquely identified; device will be managed");
-		}
-		return g_steal_pointer (&connection);
-	}
-
-	/* iBFT is handled by nm-initrd-generator during boot. */
-	bootproto = svGetValueStr_cp (main_netplan, "BOOTPROTO");
-	if (bootproto && !g_ascii_strcasecmp (bootproto, "ibft")) {
-		NM_SET_OUT (out_ignore_error, TRUE);
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-		             "Ignoring iBFT configuration");
-		g_free (bootproto);
-		return NULL;
-	}
-	g_free (bootproto);
-
-	devtype = svGetValueStr_cp (main_netplan, "DEVICETYPE");
-	if (devtype) {
-		if (!strcasecmp (devtype, TYPE_TEAM))
-			type = g_strdup (TYPE_TEAM);
-		else if (!strcasecmp (devtype, TYPE_TEAM_PORT)) {
-			gs_free char *device = NULL;
-
-			type = svGetValueStr_cp (main_netplan, "TYPE");
-			device = svGetValueStr_cp (main_netplan, "DEVICE");
-
-			if (type) {
-				/* nothing to do */
-			} else if (device && nd->type == NETPLAN_DEF_TYPE_VLAN)
-				type = g_strdup (TYPE_VLAN);
-			else
-				type = g_strdup (TYPE_ETHERNET);
-		}
-		g_free (devtype);
-	}
-	if (!type) {
-		gs_free char *t = NULL;
-
-		/* Team and TeamPort types are also accepted by the mere
-		 * presence of TEAM_CONFIG/TEAM_MASTER. They don't require
-		 * DEVICETYPE. */
-		t = svGetValueStr_cp (main_netplan, "TEAM_CONFIG");
-		if (t)
-			type = g_strdup (TYPE_TEAM);
-	}
-
-	if (!type)
-		type = svGetValueStr_cp (main_netplan, "TYPE");
-
-	if (!type) {
-		gs_free char *tmp = NULL;
-		char *device;
-
-		if ((tmp = svGetValueStr_cp (main_netplan, "IPV6TUNNELIPV4"))) {
-			NM_SET_OUT (out_ignore_error, TRUE);
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Ignoring unsupported connection due to IPV6TUNNELIPV4");
-			return NULL;
-		}
-
-		device = svGetValueStr_cp (main_netplan, "DEVICE");
-		if (!device) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "File '%s' had neither TYPE nor DEVICE keys.", filename);
-			return NULL;
-		}
-
-		if (!strcmp (device, "lo")) {
-			NM_SET_OUT (out_ignore_error, TRUE);
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
-			             "Ignoring loopback device config.");
-			g_free (device);
-			return NULL;
-		}
+connection = create_unhandled_connection (filename, main_netplan, "unmanaged", out_unhandled);
+ifcfg-rh:
+NM_CONTROLLED
+BOOTPROTO
+DEVICETYPE
+TYPE
+DEVICE
+TEAM_CONFIG
+TEAM_MASTER
+IPV6TUNNELIPV4
+IPV6TUNNELIPV4
 #endif
 
-#if 0
-	} else {
-		/* Check for IBM s390 CTC devices and call them Ethernet */
-		if (g_strcmp0 (type, "CTC") == 0) {
-			g_free (type);
-			type = g_strdup (TYPE_ETHERNET);
-		}
-	}
-#endif
+	/* TODO: Check for IBM s390 CTC devices and call them TYPE_ETHERNET */
+
 	if (netdef_id) {
 		/* Select netdef specified by ID. */
 		netdef = g_hash_table_lookup (netdefs, netdef_id);
@@ -2947,7 +1972,7 @@ connection_from_file_full (const char *filename,
 	if (!connection)
 		return NULL;
 
-#if 0
+#if 0  /* TODO: ethtool options */
 	parse_ethtool_options (main_netplan, connection);
 #endif
 
-- 
2.25.1


From 694708efa88608c22caa4127adc18218d9f5d66d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 30 Apr 2020 09:55:47 +0200
Subject: [PATCH 60/78] netplan: cleanup writer

Get rid of all the ifcfg-rh boilerplate code.
Keep only the NM setting names/function calls and IFCFG-RH setting names
for reference, at its corresponding place. We can always look up the
logic in the ifcfg-rh plugin.
---
 .../plugins/netplan/nms-netplan-writer.c      | 1700 ++++-------------
 1 file changed, 392 insertions(+), 1308 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 686e412875ed2ee70e6db663ec337596b765ebba..b0d428fbc6c6725a67482d8a84e4485966ba74ee 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -89,116 +89,33 @@ write_hashtable_to_dict(gpointer key, gpointer value, gpointer user_data)
 
 #if 0  /* GCC Magic */
 static void
-save_secret_flags (GOutputStream *netplan,
-                   const char *key,
-                   NMSettingSecretFlags flags)
-{
-#if 0 // TODO: we don't do secret_flags yet.
-	GString *str;
-
-	g_return_if_fail (netplan != NULL);
-	g_return_if_fail (key != NULL);
-
-	if (flags == NM_SETTING_SECRET_FLAG_NONE) {
-		svUnsetValue (netplan, key);
-		return;
-	}
+save_secret_flags (GOutputStream *netplan, const char *key, NMSettingSecretFlags flags)
 
-	/* Convert flags bitfield into string representation */
-	str = g_string_sized_new (20);
-	if (flags & NM_SETTING_SECRET_FLAG_AGENT_OWNED)
-		g_string_append (str, SECRET_FLAG_AGENT);
-
-	if (flags & NM_SETTING_SECRET_FLAG_NOT_SAVED) {
-		if (str->len)
-			g_string_append_c (str, ' ');
-		g_string_append (str, SECRET_FLAG_NOT_SAVED);
-	}
-
-	if (flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED) {
-		if (str->len)
-			g_string_append_c (str, ' ');
-		g_string_append (str, SECRET_FLAG_NOT_REQUIRED);
-	}
+NM_SETTING_SECRET_FLAG_*
 
-	svSetValueStr (netplan, key, str->len ? str->str : NULL);
-	g_string_free (str, TRUE);
-#endif
-}
 
 static void
-set_secret (GOutputStream *netplan,
-            GHashTable *secrets,
-            const char *key,
-            const char *value,
-            const char *flags_key,
-            NMSettingSecretFlags flags)
-{
-	// TODO: check how to handle secret flags -- toggles for special behavior of secrets.
-#if 0 // TODO: set_secret(): we write secrets directly to the main YAML file for netplan
-	/* Clear the secret from the netplan and the associated "keys" file */
-	svUnsetValue (netplan, key);
-
-	/* Save secret flags */
-	save_secret_flags (netplan, flags_key, flags);
+set_secret (GOutputStream *netplan, GHashTable *secrets, const char *key, const char *value, const char *flags_key, NMSettingSecretFlags flags)
+// TODO: check how to handle secret flags -- toggles for special behavior of secrets.
+// TODO: set_secret(): we write secrets directly to the main YAML file for netplan
+save_secret_flags (netplan, flags_key, flags);
+g_hash_table_replace (secrets, g_strdup (key), g_strdup (value)
 
-	/* Only write the secret if it's system owned and supposed to be saved */
-	if (flags != NM_SETTING_SECRET_FLAG_NONE)
-		value = NULL;
-
-	g_hash_table_replace (secrets, g_strdup (key), g_strdup (value));
-#endif
-}
 
 static gboolean
-write_secrets (GOutputStream *netplan,
-               GHashTable *secrets,
-               GError **error)
-{
-#if 0  // TODO: write_secrets(): we don't write secrets to a separate file for netplan...
-	nm_auto_shvar_file_close shvarFile *keyfile = NULL;
-	gs_free const char **secrets_keys = NULL;
-	guint i, secrets_keys_n;
-	GError *local = NULL;
-	gboolean any_secrets = FALSE;
-
-	keyfile = utils_get_keys_netplan (svFileGetName (netplan), TRUE);
-	if (!keyfile) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Failure to create secrets file for '%s'", svFileGetName (netplan));
-		return FALSE;
-	}
-
-	/* we purge all existing secrets. */
-	svUnsetAll (keyfile, SV_KEY_TYPE_ANY);
-
-	secrets_keys = nm_utils_strdict_get_keys (secrets, TRUE, &secrets_keys_n);
-	for (i = 0; i < secrets_keys_n; i++) {
-		const char *k = secrets_keys[i];
-		const char *v = g_hash_table_lookup (secrets, k);
-
-		if (v) {
-			svSetValueStr (keyfile, k, v);
-			any_secrets = TRUE;
-		}
-	}
+write_secrets (GOutputStream *netplan, GHashTable *secrets, GError **error)
+// TODO: write_secrets(): we don't write secrets to a separate file for netplan...
+nm_utils_strdict_get_keys (secrets, TRUE, &secrets_keys_n)
+ifcfg-rh:
+SV_KEY_TYPE_ANY
 
-	if (!any_secrets)
-		(void) unlink (svFileGetName (keyfile));
-	else if (!svWriteFile (keyfile, 0600, &local)) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Failure to write secrets to '%s': %s", svFileGetName (keyfile), local->message);
-		return FALSE;
-	}
-#endif
-	return TRUE;
-}
 
 typedef struct {
 	const NMSetting8021xSchemeVtable *vtable;
 	const char *netplan_key;
 } Setting8021xSchemeVtable;
 
+
 // TODO: implement Phase2 auth blobs for 802.1x...
 static const Setting8021xSchemeVtable setting_8021x_scheme_vtable[] = {
 #define _D(_scheme_type, _netplan_key) \
@@ -215,184 +132,33 @@ static const Setting8021xSchemeVtable setting_8021x_scheme_vtable[] = {
 #undef _D
 };
 
-static gboolean
-write_object (NMSetting8021x *s_8021x,
-              GOutputStream *netplan,
-              GHashTable *secrets,
-              GHashTable *blobs,
-              const Setting8021xSchemeVtable *objtype,
-              gboolean force_write,
-              GError **error)
-{
-	NMSetting8021xCKScheme scheme;
-	const char *value = NULL;
-	const char *password = NULL;
-	const char *extension;
-	char *standard_file;
-
-	g_return_val_if_fail (netplan != NULL, FALSE);
-	g_return_val_if_fail (objtype != NULL, FALSE);
-
-	scheme = (*(objtype->vtable->scheme_func))(s_8021x);
-	switch (scheme) {
-	case NM_SETTING_802_1X_CK_SCHEME_UNKNOWN:
-		break;
-	case NM_SETTING_802_1X_CK_SCHEME_BLOB:
-		break;
-	case NM_SETTING_802_1X_CK_SCHEME_PATH:
-		value = (*(objtype->vtable->path_func))(s_8021x);
-		break;
-	case NM_SETTING_802_1X_CK_SCHEME_PKCS11:
-		value = (*(objtype->vtable->uri_func))(s_8021x);
-		break;
-	default:
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Unhandled certificate object scheme");
-		return FALSE;
-	}
-
-	/* Set the password for certificate/private key. */
-	//nm_sprintf_buf (secret_flags, "%s_PASSWORD_FLAGS", objtype->netplan_key);
-	//flags = (*(objtype->vtable->pwflag_func))(s_8021x);
-	//set_secret (netplan, secrets, secret_name, password, secret_flags, flags);
-	password = (*(objtype->vtable->passwd_func))(s_8021x);
-	if (password)
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-		                        "          %s-password: \"%s\"\n",
-			                objtype->netplan_key, password);
-
-	/* If the object path was specified, prefer that over any raw cert data that
-	 * may have been sent.
-	 */
-	if (value) {
-		g_output_stream_printf (netplan, 0, NULL, NULL,
-				        "          %s: %s\n",
-				        objtype->netplan_key, value);
-		return TRUE;
-	}
 
-#if 0 // TODO: netplan does not yet support saving binary certs instead of paths
-	if (!objtype->vtable->format_func)
-		extension = "der";
-	else if (objtype->vtable->format_func (s_8021x) == NM_SETTING_802_1X_CK_FORMAT_PKCS12)
-		extension = "p12";
-	else
-		extension = "pem";
+static gboolean
+write_object (NMSetting8021x *s_8021x, GOutputStream *netplan, GHashTable *secrets, GHashTable *blobs, const Setting8021xSchemeVtable *objtype, gboolean force_write, GError **error)
 
-	/* If it's raw certificate data, write the data out to the standard file */
-	if (blob) {
-		char *new_file;
+NM_SETTING_802_1X_CK_SCHEME_*
+NM_SETTING_802_1X_CK_FORMAT_PKCS12 (der/p12/pem)
+// TODO: netplan does not yet support saving binary certs instead of paths
+g_hash_table_replace (blobs, new_file, g_bytes_ref (blob));
+g_hash_table_replace (blobs, standard_file, NULL);
 
-		new_file = utils_cert_path (svFileGetName (netplan), objtype->vtable->file_suffix, extension);
-		g_hash_table_replace (blobs, new_file, g_bytes_ref (blob));
-		svSetValueStr (netplan, objtype->netplan_key, new_file);
-		return TRUE;
-	}
-
-	/* If certificate/private key wasn't sent, the connection may no longer be
-	 * 802.1x and thus we clear out the paths and certs.
-	 *
-	 * Since no cert/private key is now being used, delete any standard file
-	 * that was created for this connection, but leave other files alone.
-	 * Thus, for example,
-	 * /etc/sysconfig/network-scripts/ca-cert-Test_Write_Wifi_WPA_EAP-TLS.der
-	 * will be deleted, but /etc/pki/tls/cert.pem will not.
-	 */
-	standard_file = utils_cert_path (svFileGetName (netplan), objtype->vtable->file_suffix, extension);
-	g_hash_table_replace (blobs, standard_file, NULL);
-	svSetValue (netplan, objtype->netplan_key, force_write ? "" : NULL);
-#endif
-	return FALSE;
-}
 
 static gboolean
 write_blobs (GHashTable *blobs, GError **error)
-{
-	GHashTableIter iter;
-	const char *filename;
-	GBytes *blob;
-
-#if 0 // TODO: netplan does not yet support saving binary blobs in yaml (802.1x certs)
-	if (!blobs)
-		return TRUE;
-
-	g_hash_table_iter_init (&iter, blobs);
-	while (g_hash_table_iter_next (&iter, (gpointer *) &filename, (gpointer *) &blob)) {
-		GError *write_error = NULL;
 
-		if (!blob) {
-			(void) unlink (filename);
-			continue;
-		}
-
-		/* Write the raw certificate data out to the standard file so that we
-		 * can use paths from now on instead of pushing around the certificate
-		 * data itself.
-		 */
-		if (!nm_utils_file_set_contents (filename,
-		                                 (const char *) g_bytes_get_data (blob, NULL),
-		                                 g_bytes_get_size (blob),
-		                                 0600,
-		                                 NULL,
-		                                 &write_error)) {
-			g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-			             "Could not write certificate to file \"%s\": %s",
-			             filename,
-			             write_error->message);
-			return FALSE;
-		}
-	}
-#endif
+// TODO: netplan does not yet support saving binary blobs in yaml (802.1x certs)
+nm_utils_file_set_contents (filename, (const char *) g_bytes_get_data (blob, NULL), g_bytes_get_size (blob), 0600, NULL, &write_error)
 
-	return TRUE;
-}
 
 static gboolean
-write_8021x_certs (NMSetting8021x *s_8021x,
-                   GHashTable *secrets,
-                   GHashTable *blobs,
-                   gboolean phase2,
-                   GOutputStream *netplan,
-                   GError **error)
-{
-	const Setting8021xSchemeVtable *pk_otype = NULL;
-	gs_free char *value_to_free = NULL;
-
-	/* CA certificate */
-	if (!write_object (s_8021x, netplan, secrets, blobs,
-	                   phase2
-	                       ? &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT]
-	                       : &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT],
-	                   FALSE,
-	                   error))
-		return FALSE;
-
-	/* Private key */
-	if (phase2)
-		pk_otype = &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_PRIVATE_KEY];
-	else
-		pk_otype = &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY];
-
-	/* Save the private key */
-	if (!write_object (s_8021x, netplan, secrets, blobs, pk_otype, FALSE, error))
-		return FALSE;
-
-	/* Save the client certificate.
-	 * If there is a private key, always write a property for the
-	 * client certificate even if it is empty, so that the reader
-	 * doesn't have to read the private key file to determine if it
-	 * is a PKCS #12 one which serves also as client certificate.
-	 */
-	if (!write_object (s_8021x, netplan, secrets, blobs,
-	                   phase2
-	                       ? &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT]
-	                       : &setting_8021x_scheme_vtable[NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT],
-	                   FALSE, // XXX: may need adjustment; ifcfg-rh uses a conditional here.
-	                   error))
-		return FALSE;
-
-	return TRUE;
-}
+write_8021x_certs (NMSetting8021x *s_8021x, GHashTable *secrets, GHashTable *blobs, gboolean phase2, GOutputStream *netplan, GError **error)
+
+NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CA_CERT
+NM_SETTING_802_1X_SCHEME_TYPE_CA_CERT
+NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_PRIVATE_KEY
+NM_SETTING_802_1X_SCHEME_TYPE_PRIVATE_KEY
+NM_SETTING_802_1X_SCHEME_TYPE_PHASE2_CLIENT_CERT
+NM_SETTING_802_1X_SCHEME_TYPE_CLIENT_CERT
 #endif  /* GCC magic */
 
 static gboolean
@@ -459,133 +225,52 @@ write_8021x_setting (NMConnection *connection,
 		                        "            password: %s\n", value);
 
 #if 0 // TODO: 802.1x use set_secret instead of g_output_stream_printf()...
-	set_secret (netplan,
-	            secrets,
-	            "IEEE_8021X_PASSWORD",
-	            nm_setting_802_1x_get_password (s_8021x),
-	            "IEEE_8021X_PASSWORD_FLAGS",
-	            nm_setting_802_1x_get_password_flags (s_8021x));
+nm_setting_802_1x_get_password (s_8021x)
+nm_setting_802_1x_get_password_flags (s_8021x)
+ifcfg-rh:
+set_secret (...)
+IEEE_8021X_PASSWORD
+IEEE_8021X_PASSWORD_FLAGS
 #endif
 
 #if 0 // TODO: 802.1x complex EAP / PEAP and other auth settings
-	tmp = NULL;
-	bytes = nm_setting_802_1x_get_password_raw (s_8021x);
-	if (bytes) {
-		ptr = g_bytes_get_data (bytes, &size);
-		tmp = nm_utils_bin2hexstr (ptr, size, -1);
-	}
-	set_secret (netplan,
-	            secrets,
-	            "IEEE_8021X_PASSWORD_RAW",
-	            tmp,
-	            "IEEE_8021X_PASSWORD_RAW_FLAGS",
-	            nm_setting_802_1x_get_password_raw_flags (s_8021x));
-	g_free (tmp);
-
-	/* PEAP version */
-	value = nm_setting_802_1x_get_phase1_peapver (s_8021x);
-	svUnsetValue (netplan, "IEEE_8021X_PEAP_VERSION");
-	if (value && (!strcmp (value, "0") || !strcmp (value, "1")))
-		svSetValueStr (netplan, "IEEE_8021X_PEAP_VERSION", value);
-
-	/* Force new PEAP label */
-	value = nm_setting_802_1x_get_phase1_peaplabel (s_8021x);
-	svUnsetValue (netplan, "IEEE_8021X_PEAP_FORCE_NEW_LABEL");
-	if (value && !strcmp (value, "1"))
-		svSetValueStr (netplan, "IEEE_8021X_PEAP_FORCE_NEW_LABEL", "yes");
-
-	/* PAC file */
-	value = nm_setting_802_1x_get_pac_file (s_8021x);
-	svUnsetValue (netplan, "IEEE_8021X_PAC_FILE");
-	if (value)
-		svSetValueStr (netplan, "IEEE_8021X_PAC_FILE", value);
-
-	/* FAST PAC provisioning */
-	value = nm_setting_802_1x_get_phase1_fast_provisioning (s_8021x);
-	svUnsetValue (netplan, "IEEE_8021X_FAST_PROVISIONING");
-	if (value) {
-		if (strcmp (value, "1") == 0)
-			svSetValueStr (netplan, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth");
-		else if (strcmp (value, "2") == 0)
-			svSetValueStr (netplan, "IEEE_8021X_FAST_PROVISIONING", "allow-auth");
-		else if (strcmp (value, "3") == 0)
-			svSetValueStr (netplan, "IEEE_8021X_FAST_PROVISIONING", "allow-unauth allow-auth");
-	}
-
-	/* Phase2 auth methods */
-	svUnsetValue (netplan, "IEEE_8021X_INNER_AUTH_METHODS");
-	phase2_auth = g_string_new (NULL);
-
-	value = nm_setting_802_1x_get_phase2_auth (s_8021x);
-	if (value) {
-		tmp = g_ascii_strup (value, -1);
-		g_string_append (phase2_auth, tmp);
-		g_free (tmp);
-	}
-
-	value = nm_setting_802_1x_get_phase2_autheap (s_8021x);
-	if (value) {
-		if (phase2_auth->len)
-			g_string_append_c (phase2_auth, ' ');
-
-		tmp = g_ascii_strup (value, -1);
-		g_string_append_printf (phase2_auth, "EAP-%s", tmp);
-		g_free (tmp);
-	}
-
-	auth_flags = nm_setting_802_1x_get_phase1_auth_flags (s_8021x);
-	if (auth_flags == NM_SETTING_802_1X_AUTH_FLAGS_NONE) {
-		svUnsetValue (netplan, "IEEE_8021X_PHASE1_AUTH_FLAGS");
-	} else {
-		svSetValueEnum (netplan, "IEEE_8021X_PHASE1_AUTH_FLAGS",
-		                nm_setting_802_1x_auth_flags_get_type(),
-		                auth_flags);
-	}
-
-	svSetValueStr (netplan, "IEEE_8021X_INNER_AUTH_METHODS",
-	               phase2_auth->len ? phase2_auth->str : NULL);
-
-	g_string_free (phase2_auth, TRUE);
-
-	svSetValueStr (netplan, "IEEE_8021X_SUBJECT_MATCH",
-	               nm_setting_802_1x_get_subject_match (s_8021x));
-
-	svSetValueStr (netplan, "IEEE_8021X_PHASE2_SUBJECT_MATCH",
-	               nm_setting_802_1x_get_phase2_subject_match (s_8021x));
-
-	svUnsetValue (netplan, "IEEE_8021X_ALTSUBJECT_MATCHES");
-	str = g_string_new (NULL);
-	num = nm_setting_802_1x_get_num_altsubject_matches (s_8021x);
-	for (i = 0; i < num; i++) {
-		if (i > 0)
-			g_string_append_c (str, ' ');
-		match = nm_setting_802_1x_get_altsubject_match (s_8021x, i);
-		g_string_append (str, match);
-	}
-	if (str->len > 0)
-		svSetValueStr (netplan, "IEEE_8021X_ALTSUBJECT_MATCHES", str->str);
-	g_string_free (str, TRUE);
-
-	svUnsetValue (netplan, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES");
-	str = g_string_new (NULL);
-	num = nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x);
-	for (i = 0; i < num; i++) {
-		if (i > 0)
-			g_string_append_c (str, ' ');
-		match = nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, i);
-		g_string_append (str, match);
-	}
-	if (str->len > 0)
-		svSetValueStr (netplan, "IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES", str->str);
-	g_string_free (str, TRUE);
-
-	svSetValueStr (netplan, "IEEE_8021X_DOMAIN_SUFFIX_MATCH",
-	               nm_setting_802_1x_get_domain_suffix_match (s_8021x));
-	svSetValueStr (netplan, "IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH",
-	               nm_setting_802_1x_get_phase2_domain_suffix_match (s_8021x));
-
-	vint = nm_setting_802_1x_get_auth_timeout (s_8021x);
-	svSetValueInt64_cond (netplan, "IEEE_8021X_AUTH_TIMEOUT", vint > 0, vint);
+nm_setting_802_1x_get_password_raw (s_8021x)
+nm_setting_802_1x_get_password_raw_flags (s_8021x)
+nm_setting_802_1x_get_phase1_peapver (s_8021x)
+nm_setting_802_1x_get_phase1_peaplabel (s_8021x)
+nm_setting_802_1x_get_pac_file (s_8021x)
+nm_setting_802_1x_get_phase1_fast_provisioning (s_8021x)
+nm_setting_802_1x_get_phase2_auth (s_8021x)
+nm_setting_802_1x_get_phase2_autheap (s_8021x)
+nm_setting_802_1x_get_phase1_auth_flags (s_8021x)
+nm_setting_802_1x_auth_flags_get_type()
+nm_setting_802_1x_get_subject_match (s_8021x))
+nm_setting_802_1x_get_phase2_subject_match (s_8021x)
+nm_setting_802_1x_get_num_altsubject_matches (s_8021x)
+nm_setting_802_1x_get_altsubject_match (s_8021x, i)
+nm_setting_802_1x_get_num_phase2_altsubject_matches (s_8021x)
+nm_setting_802_1x_get_phase2_altsubject_match (s_8021x, i)
+nm_setting_802_1x_get_domain_suffix_match (s_8021x)
+nm_setting_802_1x_get_phase2_domain_suffix_match (s_8021x)
+nm_setting_802_1x_get_auth_timeout (s_8021x)
+NM_SETTING_802_1X_AUTH_FLAGS_*
+ifcfg-rh:
+set_secret (...)
+IEEE_8021X_PASSWORD_RAW
+IEEE_8021X_PASSWORD_RAW_FLAGS
+IEEE_8021X_PEAP_VERSION
+IEEE_8021X_PEAP_FORCE_NEW_LABEL
+IEEE_8021X_PAC_FILE
+IEEE_8021X_FAST_PROVISIONING
+IEEE_8021X_INNER_AUTH_METHODS
+IEEE_8021X_PHASE1_AUTH_FLAGS
+IEEE_8021X_SUBJECT_MATCH
+IEEE_8021X_PHASE2_SUBJECT_MATCH
+IEEE_8021X_ALTSUBJECT_MATCHES
+IEEE_8021X_PHASE2_ALTSUBJECT_MATCHES
+IEEE_8021X_DOMAIN_SUFFIX_MATCH
+IEEE_8021X_PHASE2_DOMAIN_SUFFIX_MATCH
+IEEE_8021X_AUTH_TIMEOUT
 #endif
 
 #if 0 // TODO: 802.1x certs in binary / path
@@ -680,33 +365,21 @@ write_wireless_security_setting (NMConnection *connection,
 	}
 
 #if 0 // TODO: Unravel this SECURITYMODE story: restricted | open | leap ???
-	svUnsetValue (netplan, "SECURITYMODE");
-	if (auth_alg) {
-		if (!strcmp (auth_alg, "shared"))
-			svSetValueStr (netplan, "SECURITYMODE", "restricted");
-		else if (!strcmp (auth_alg, "open"))
-			svSetValueStr (netplan, "SECURITYMODE", "open");
-		else if (!strcmp (auth_alg, "leap")) {
-			svSetValueStr (netplan, "SECURITYMODE", "leap");
-			svSetValueStr (netplan, "IEEE_8021X_IDENTITY",
-			               nm_setting_wireless_security_get_leap_username (s_wsec));
-			set_secret (netplan,
-			            secrets,
-			            "IEEE_8021X_PASSWORD",
-			            nm_setting_wireless_security_get_leap_password (s_wsec),
-			            "IEEE_8021X_PASSWORD_FLAGS",
-			            nm_setting_wireless_security_get_leap_password_flags (s_wsec));
-		}
-	}
+nm_setting_wireless_security_get_leap_username (s_wsec)
+nm_setting_wireless_security_get_leap_password (s_wsec)
+nm_setting_wireless_security_get_leap_password_flags (s_wsec)
+ifcfg-rh:
+SECURITYMODE (restricted|open|leap)
+IEEE_8021X_IDENTITY
+IEEE_8021X_PASSWORD
+IEEE_8021X_PASSWORD_FLAGS
 #endif
 
 #if 0 // TODO: support enabling WPS in netplan.
-	/* WPS */
-	wps_method = nm_setting_wireless_security_get_wps_method (s_wsec);
-	if (wps_method == NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT)
-		svUnsetValue (netplan, "WPS_METHOD");
-	else
-		svSetValueEnum (netplan, "WPS_METHOD", nm_setting_wireless_security_wps_method_get_type (), wps_method);
+nm_setting_wireless_security_get_wps_method (s_wsec)
+nm_setting_wireless_security_wps_method_get_type ()
+ifcfg-rh:
+WPA_METHOD
 #endif
 
 	/* WEP keys */
@@ -722,19 +395,8 @@ write_wireless_security_setting (NMConnection *connection,
 		// TODO: Fix defaultkey / TX key ID for WEP.
 		//svSetValueInt64 (netplan, "DEFAULTKEY", nm_setting_wireless_security_get_wep_tx_keyidx(s_wsec) + 1);
 
-#if 0 // TODO: differentiate hex key vs. passphrase in netplan for WEP (see below)
-		switch (key_type) {
-		case NM_WEP_KEY_TYPE_KEY:
-			key_type_str = "key";
-			break;
-		case NM_WEP_KEY_TYPE_PASSPHRASE:
-			key_type_str = "passphrase";
-			break;
-		case NM_WEP_KEY_TYPE_UNKNOWN:
-			break;
-		}
-		svSetValue (netplan, "KEY_TYPE", key_type_str);
-#endif
+		// TODO: differentiate hex key vs. passphrase for WEP (see below)
+		// NM_WEP_KEY_TYPE_KEY, NM_WEP_KEY_TYPE_PASSPHRASE, NM_WEP_KEY_TYPE_UNKNOWN
 
 		for (i = 0; i < 4; i++) {
 			key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
@@ -775,42 +437,13 @@ write_wireless_security_setting (NMConnection *connection,
 	}
 
 #if 0 // TODO: implement WPA ciphers
-	/* WPA Pairwise ciphers */
-	str = g_string_new (NULL);
-	num = nm_setting_wireless_security_get_num_pairwise (s_wsec);
-	for (i = 0; i < num; i++) {
-		if (i > 0)
-			g_string_append_c (str, ' ');
-		cipher = nm_setting_wireless_security_get_pairwise (s_wsec, i);
-
-		/* Don't write out WEP40 or WEP104 if for some reason they are set; they
-		 * are not valid pairwise ciphers.
-		 */
-		if (strcmp (cipher, "wep40") && strcmp (cipher, "wep104")) {
-			tmp = g_ascii_strup (cipher, -1);
-			g_string_append (str, tmp);
-			g_free (tmp);
-		}
-	}
-	if (strlen (str->str) && (dynamic_wep == FALSE))
-		svSetValueStr (netplan, "CIPHER_PAIRWISE", str->str);
-	g_string_free (str, TRUE);
-
-	/* WPA Group ciphers */
-	svUnsetValue (netplan, "CIPHER_GROUP");
-	str = g_string_new (NULL);
-	num = nm_setting_wireless_security_get_num_groups (s_wsec);
-	for (i = 0; i < num; i++) {
-		if (i > 0)
-			g_string_append_c (str, ' ');
-		cipher = nm_setting_wireless_security_get_group (s_wsec, i);
-		tmp = g_ascii_strup (cipher, -1);
-		g_string_append (str, tmp);
-		g_free (tmp);
-	}
-	if (strlen (str->str) && (dynamic_wep == FALSE))
-		svSetValueStr (netplan, "CIPHER_GROUP", str->str);
-	g_string_free (str, TRUE);
+nm_setting_wireless_security_get_num_pairwise (s_wsec)
+nm_setting_wireless_security_get_pairwise (s_wsec, i)
+nm_setting_wireless_security_get_num_groups (s_wsec)
+nm_setting_wireless_security_get_group (s_wsec, i)
+ifcfg-rh:
+CIPHER_PAIRWISE
+CIPHER_GROUP
 #endif
 
 	if (wpa_psk) {
@@ -835,19 +468,15 @@ write_wireless_security_setting (NMConnection *connection,
 	}
 
 #if 0 // TODO: wireless security: implement PMF and FILS support
-	if (nm_setting_wireless_security_get_pmf (s_wsec) == NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT)
-		svUnsetValue (netplan, "PMF");
-	else {
-		svSetValueEnum (netplan, "PMF", nm_setting_wireless_security_pmf_get_type (),
-		                nm_setting_wireless_security_get_pmf (s_wsec));
-	}
-
-	if (nm_setting_wireless_security_get_fils (s_wsec) == NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT)
-		svUnsetValue (netplan, "FILS");
-	else {
-		svSetValueEnum (netplan, "FILS", nm_setting_wireless_security_fils_get_type (),
-		                nm_setting_wireless_security_get_fils (s_wsec));
-	}
+nm_setting_wireless_security_get_pmf (s_wsec)
+nm_setting_wireless_security_pmf_get_type ()
+nm_setting_wireless_security_get_fils (s_wsec)
+nm_setting_wireless_security_fils_get_type ()
+NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT
+NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT
+ifcfg-rh:
+PMF
+FILS
 #endif
 
 	return TRUE;
@@ -911,18 +540,11 @@ write_wireless_setting (NMConnection *connection,
 				        "      macaddress: %s\n", cloned_mac);
 
 #if 0	// TODO: fix MAC setting, blacklist for wireless.
-	svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
-	               nm_setting_wireless_get_generate_mac_address_mask (s_wireless));
-
-	svUnsetValue (netplan, "HWADDR_BLACKLIST");
-	macaddr_blacklist = nm_setting_wireless_get_mac_address_blacklist (s_wireless);
-	if (macaddr_blacklist[0]) {
-		char *blacklist_str;
-
-		blacklist_str = g_strjoinv (" ", (char **) macaddr_blacklist);
-		svSetValueStr (netplan, "HWADDR_BLACKLIST", blacklist_str);
-		g_free (blacklist_str);
-	}
+nm_setting_wireless_get_generate_mac_address_mask (s_wireless)
+nm_setting_wireless_get_mac_address_blacklist (s_wireless)
+ifcfg-rh:
+GENERATE_MAC_ADDRESS_MASK
+HWADDR_BLACKLIST
 #endif
 
 	mtu = nm_setting_wireless_get_mtu (s_wireless);
@@ -1052,39 +674,20 @@ write_wireless_setting (NMConnection *connection,
 	}
 
 	// TODO: add support for non-broadcast (hidden) SSID.
-	//svSetValueStr (netplan, "SSID_HIDDEN", nm_setting_wireless_get_hidden (s_wireless) ? "yes" : NULL);
+	// nm_setting_wireless_get_hidden (s_wireless)
 
 #if 0 // TODO: implement wifi powersave mode selection.
-	switch (nm_setting_wireless_get_powersave (s_wireless)) {
-	case NM_SETTING_WIRELESS_POWERSAVE_IGNORE:
-		svSetValueStr (netplan, "POWERSAVE", "ignore");
-		break;
-	case NM_SETTING_WIRELESS_POWERSAVE_DISABLE:
-		svSetValueStr (netplan, "POWERSAVE", "disable");
-		break;
-	case NM_SETTING_WIRELESS_POWERSAVE_ENABLE:
-		svSetValueStr (netplan, "POWERSAVE", "enable");
-		break;
-	default:
-	case NM_SETTING_WIRELESS_POWERSAVE_DEFAULT:
-		svUnsetValue (netplan, "POWERSAVE");
-		break;
-	}
+nm_setting_wireless_get_powersave (s_wireless)
+NM_SETTING_WIRELESS_POWERSAVE_*
+ifcfg-rh:
+POWERSAVE
 #endif
 
 #if 0 // TODO: implement wifi MAC address randomization in netplan
-	switch (nm_setting_wireless_get_mac_address_randomization (s_wireless)) {
-	case NM_SETTING_MAC_RANDOMIZATION_NEVER:
-		svSetValueStr (netplan, "MAC_ADDRESS_RANDOMIZATION", "never");
-		break;
-	case NM_SETTING_MAC_RANDOMIZATION_ALWAYS:
-		svSetValueStr (netplan, "MAC_ADDRESS_RANDOMIZATION", "always");
-		break;
-	case NM_SETTING_MAC_RANDOMIZATION_DEFAULT:
-	default:
-		svSetValueStr (netplan, "MAC_ADDRESS_RANDOMIZATION", "default");
-		break;
-	}
+nm_setting_wireless_get_mac_address_randomization (s_wireless)
+NM_SETTING_MAC_RANDOMIZATION_*
+ifcfg-rh:
+MAC_ADDRESS_RANDOMIZATION
 #endif
 
 	return TRUE;
@@ -1166,42 +769,21 @@ write_modem_setting (NMConnection *connection,
 #if 0 // TODO: implement infiniband!
 static gboolean
 write_infiniband_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-	NMSettingInfiniband *s_infiniband;
-	const char *mac, *transport_mode, *parent;
-	guint32 mtu;
-	int p_key;
-
-	s_infiniband = nm_connection_get_setting_infiniband (connection);
-	if (!s_infiniband) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Missing '%s' setting", NM_SETTING_INFINIBAND_SETTING_NAME);
-		return FALSE;
-	}
-
-	mac = nm_setting_infiniband_get_mac_address (s_infiniband);
-	svSetValueStr (netplan, "HWADDR", mac);
-
-	mtu = nm_setting_infiniband_get_mtu (s_infiniband);
-	svSetValueInt64_cond (netplan, "MTU", mtu != 0, mtu);
 
-	transport_mode = nm_setting_infiniband_get_transport_mode (s_infiniband);
-	svSetValueBoolean (netplan, "CONNECTED_MODE", nm_streq (transport_mode, "connected"));
-
-	p_key = nm_setting_infiniband_get_p_key (s_infiniband);
-	if (p_key != -1) {
-		svSetValueStr (netplan, "PKEY", "yes");
-		svSetValueInt64 (netplan, "PKEY_ID", p_key);
-
-		parent = nm_setting_infiniband_get_parent (s_infiniband);
-		if (parent)
-			svSetValueStr (netplan, "PHYSDEV", parent);
-	}
-
-	svSetValueStr (netplan, "TYPE", TYPE_INFINIBAND);
-
-	return TRUE;
-}
+NM_SETTING_INFINIBAND_SETTING_NAME
+s_infiniband = nm_connection_get_setting_infiniband (connection);
+nm_setting_infiniband_get_mac_address (s_infiniband)
+nm_setting_infiniband_get_mtu (s_infiniband)
+nm_setting_infiniband_get_transport_mode (s_infiniband)
+nm_setting_infiniband_get_p_key (s_infiniband)
+nm_setting_infiniband_get_parent (s_infiniband)
+ifcfg-rh:
+HWADDR
+MTU
+CONNECTED_MODE
+PKEY
+PKEY_ID
+PHYSDEV
 #endif
 
 static gboolean
@@ -1234,18 +816,12 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 				        "      macaddress: %s\n", mac);
 
 	// TODO: dedup fields for mac-address to do MAC setting cleanly.
-	//svSetValueStr (netplan, "GENERATE_MAC_ADDRESS_MASK",
-	//               nm_setting_wired_get_generate_mac_address_mask (s_wired));
+	// nm_setting_wired_get_generate_mac_address_mask (s_wired)
 
 #if 0  // TODO: No MAC match blacklist in netplan. Do we need one?
-	macaddr_blacklist = nm_setting_wired_get_mac_address_blacklist (s_wired);
-	if (macaddr_blacklist[0]) {
-		gs_free char *blacklist_str = NULL;
-
-		blacklist_str = g_strjoinv (" ", (char **) macaddr_blacklist);
-		svSetValueStr (netplan, "HWADDR_BLACKLIST", blacklist_str);
-	} else
-		svUnsetValue (netplan, "HWADDR_BLACKLIST");
+nm_setting_wired_get_mac_address_blacklist (s_wired)
+ifcfg-rh:
+HWADDR_BLACKLIST
 #endif
 
 	mtu = nm_setting_wired_get_mtu (s_wired);
@@ -1260,66 +836,18 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 		g_output_stream_printf (netplan, 0, NULL, NULL, "      wakeonlan: true\n");
 
 #if 0 // TODO: implement s390 subchannels 
-	s390_subchannels = nm_setting_wired_get_s390_subchannels (s_wired);
-
-	{
-		gs_free char *tmp = NULL;
-		gsize len = NM_PTRARRAY_LEN (s390_subchannels);
-
-		if (len == 2) {
-			tmp = g_strdup_printf ("%s,%s",
-			                       s390_subchannels[0],
-			                       s390_subchannels[1]);
-		} else if (len == 3) {
-			tmp = g_strdup_printf ("%s,%s,%s",
-			                       s390_subchannels[0],
-			                       s390_subchannels[1],
-			                       s390_subchannels[2]);
-		}
-
-		svSetValueStr (netplan, "SUBCHANNELS", tmp);
-	}
-
-	svSetValueStr (netplan, "NETTYPE",
-	               nm_setting_wired_get_s390_nettype (s_wired));
-
-	svSetValueStr (netplan, "PORTNAME",
-	               nm_setting_wired_get_s390_option_by_key (s_wired, "portname"));
-
-	svSetValueStr (netplan, "CTCPROT",
-	               nm_setting_wired_get_s390_option_by_key (s_wired, "ctcprot"));
-
-	svUnsetValue (netplan, "OPTIONS");
-	num_opts = nm_setting_wired_get_num_s390_options (s_wired);
-	if (s390_subchannels && num_opts) {
-		nm_auto_free_gstring GString *tmp = NULL;
-
-		for (i = 0; i < num_opts; i++) {
-			const char *s390_key, *s390_val;
-
-			nm_setting_wired_get_s390_option (s_wired, i, &s390_key, &s390_val);
-
-			/* portname is handled separately */
-			if (NM_IN_STRSET (s390_key, "portname", "ctcprot"))
-				continue;
-
-			if (strchr (s390_key, '=')) {
-				/* this key cannot be expressed. But after all, it's not valid anyway
-				 * and the connection shouldn't even verify. */
-				continue;
-			}
-
-			if (!tmp)
-				tmp = g_string_sized_new (30);
-			else
-				g_string_append_c (tmp, ' ');
-			nm_utils_escaped_tokens_escape_gstr (s390_key, NM_ASCII_SPACES, tmp);
-			g_string_append_c (tmp, '=');
-			nm_utils_escaped_tokens_escape_gstr (s390_val, NM_ASCII_SPACES, tmp);
-		}
-		if (tmp)
-			svSetValueStr (netplan, "OPTIONS", tmp->str);
-	}
+nm_setting_wired_get_s390_subchannels (s_wired)
+nm_setting_wired_get_s390_nettype (s_wired)
+nm_setting_wired_get_s390_option_by_key (s_wired, "portname")
+nm_setting_wired_get_s390_option_by_key (s_wired, "ctcprot")
+nm_setting_wired_get_num_s390_options (s_wired)
+nm_setting_wired_get_s390_option (s_wired, i, &s390_key, &s390_val)
+ifcfg-rh:
+SUBCHANNELS
+NETTYPE
+PORTNAME
+CTCPROT
+OPTIONS
 #endif
 
 	return TRUE;
@@ -1328,133 +856,18 @@ write_wired_setting (NMConnection *connection, GOutputStream *netplan, GError **
 #if 0 // TODO: add support for ethtool settings in netplan
 static gboolean
 write_ethtool_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-	NMSettingWired *s_wired;
-	NMSettingEthtool *s_ethtool;
-	const char *duplex;
-	guint32 speed;
-	GString *str = NULL;
-	gboolean auto_negotiate;
-	NMSettingWiredWakeOnLan wol;
-	const char *wol_password;
-
-	s_wired = nm_connection_get_setting_wired (connection);
-	s_ethtool = NM_SETTING_ETHTOOL (nm_connection_get_setting (connection, NM_TYPE_SETTING_ETHTOOL));
-
-	if (!s_wired && !s_ethtool) {
-		svUnsetValue (netplan, "ETHTOOL_WAKE_ON_LAN");
-		svUnsetValue (netplan, "ETHTOOL_OPTS");
-		return TRUE;
-	}
-
-	if (s_wired) {
-		auto_negotiate = nm_setting_wired_get_auto_negotiate (s_wired);
-		speed = nm_setting_wired_get_speed (s_wired);
-		duplex = nm_setting_wired_get_duplex (s_wired);
-
-		/* autoneg off + speed 0 + duplex NULL, means we want NM
-		 * to skip link configuration which is default. So write
-		 * down link config only if we have auto-negotiate true or
-		 * a valid value for one among speed and duplex.
-		 */
-		if (auto_negotiate) {
-			str = g_string_sized_new (64);
-			g_string_printf (str, "autoneg on");
-		} else if (speed || duplex) {
-			str = g_string_sized_new (64);
-			g_string_printf (str, "autoneg off");
-		}
-		if (speed)
-			g_string_append_printf (str, " speed %u", speed);
-		if (duplex)
-			g_string_append_printf (str, " duplex %s", duplex);
-
-		wol = nm_setting_wired_get_wake_on_lan (s_wired);
-		wol_password = nm_setting_wired_get_wake_on_lan_password (s_wired);
-
-		svSetValue (netplan, "ETHTOOL_WAKE_ON_LAN",
-		              wol == NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE
-		            ? "ignore"
-		            : NULL);
-		if (!NM_IN_SET (wol, NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE,
-		                     NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT)) {
-			if (!str)
-				str = g_string_sized_new (30);
-			else
-				g_string_append (str, " ");
-
-			g_string_append (str, "wol ");
-
-			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_PHY))
-				g_string_append (str, "p");
-			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST))
-				g_string_append (str, "u");
-			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST))
-				g_string_append (str, "m");
-			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST))
-				g_string_append (str, "b");
-			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_ARP))
-				g_string_append (str, "a");
-			if (NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC))
-				g_string_append (str, "g");
-
-			if (!NM_FLAGS_ANY (wol, NM_SETTING_WIRED_WAKE_ON_LAN_ALL))
-				g_string_append (str, "d");
-
-			if (wol_password && NM_FLAGS_HAS (wol, NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC))
-				g_string_append_printf (str, "s sopass %s", wol_password);
-		}
-	} else
-		svUnsetValue (netplan, "ETHTOOL_WAKE_ON_LAN");
-
-	if (s_ethtool) {
-		NMEthtoolID ethtool_id;
-		NMSettingConnection *s_con;
-		const char *iface = NULL;
-
-		s_con = nm_connection_get_setting_connection (connection);
-		if (s_con) {
-			iface = nm_setting_connection_get_interface_name (s_con);
-			if (   iface
-			    && (   !iface[0]
-			        || !NM_STRCHAR_ALL (iface, ch,    (ch >= 'a' && ch <= 'z')
-			                                       || (ch >= 'A' && ch <= 'Z')
-			                                       || (ch >= '0' && ch <= '9')
-			                                       || NM_IN_SET (ch, '_'))))
-				iface = NULL;
-		}
-
-		if (!str)
-			str = g_string_sized_new (30);
-		else
-			g_string_append (str, " ; ");
-		g_string_append (str, "-K ");
-		g_string_append (str, iface ?: "net0");
-
-		for (ethtool_id = _NM_ETHTOOL_ID_FEATURE_FIRST; ethtool_id <= _NM_ETHTOOL_ID_FEATURE_LAST; ethtool_id++) {
-			const NMEthtoolData *ed = nm_ethtool_data[ethtool_id];
-			NMTernary val;
-
-			nm_assert (nms_netplan_utils_get_ethtool_name (ethtool_id));
-
-			val = nm_setting_ethtool_get_feature (s_ethtool, ed->optname);
-			if (val == NM_TERNARY_DEFAULT)
-				continue;
-
-			g_string_append_c (str, ' ');
-			g_string_append (str, nms_netplan_utils_get_ethtool_name (ethtool_id));
-			g_string_append (str, val == NM_TERNARY_TRUE ? " on" : " off");
-		}
-	}
-
-	if (str) {
-		svSetValueStr (netplan, "ETHTOOL_OPTS", str->str);
-		g_string_free (str, TRUE);
-	} else
-		svUnsetValue (netplan, "ETHTOOL_OPTS");
 
-	return TRUE;
-}
+s_ethtool = NM_SETTING_ETHTOOL (nm_connection_get_setting (connection, NM_TYPE_SETTING_ETHTOOL));
+nm_setting_wired_get_auto_negotiate (s_wired)
+nm_setting_wired_get_speed (s_wired)
+nm_setting_wired_get_duplex (s_wired)
+nm_setting_wired_get_wake_on_lan_password (s_wired)
+nm_setting_wired_get_wake_on_lan (s_wired)
+nms_netplan_utils_get_ethtool_name (ethtool_id)
+NM_SETTING_WIRED_WAKE_ON_LAN_*
+ifcfg-rh:
+ETHTOOL_WAKE_ON_LAN
+ETHTOOL_OPTS
 #endif
 
 #if 0 /* temp disable: only for team? REUSE */
@@ -1515,28 +928,17 @@ write_vlan_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 			        "      link: %s\n", nm_setting_vlan_get_parent (s_vlan));
 
 #if 0  /* TODO: add support for vlan flags / advanced settings */
-	vlan_flags = nm_setting_vlan_get_flags (s_vlan);
-	svSetValueBoolean (netplan, "REORDER_HDR", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS));
-	svSetValueBoolean (netplan, "GVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_GVRP));
-
-	nm_utils_strbuf_init (s_buf, &s_buf_ptr, &s_buf_len);
-
-	if (NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_LOOSE_BINDING))
-		nm_utils_strbuf_append_str (&s_buf_ptr, &s_buf_len, "LOOSE_BINDING");
-	if (!NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_REORDER_HEADERS))
-		nm_utils_strbuf_append (&s_buf_ptr, &s_buf_len, "%sNO_REORDER_HDR", s_buf[0] ? "," : "");
-
-	svSetValueStr (netplan, "VLAN_FLAGS", s_buf);
-
-	svSetValueBoolean (netplan, "MVRP", NM_FLAGS_HAS (vlan_flags, NM_VLAN_FLAG_MVRP));
-
-	tmp = vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_INGRESS_MAP);
-	svSetValueStr (netplan, "VLAN_INGRESS_PRIORITY_MAP", tmp);
-	g_free (tmp);
-
-	tmp = vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_EGRESS_MAP);
-	svSetValueStr (netplan, "VLAN_EGRESS_PRIORITY_MAP", tmp);
-	g_free (tmp);
+nm_setting_vlan_get_flags (s_vlan)
+NM_VLAN_FLAG_*
+ifcfg-rh:
+vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_INGRESS_MAP)
+vlan_priority_maplist_to_stringlist (s_vlan, NM_VLAN_EGRESS_MAP)
+REORDER_HDR
+GVRP
+VLAN_FLAGS
+MVRP
+VLAN_INGRESS_PRIORITY_MAP
+VLAN_EGRESS_PRIORITY_MAP
 #endif
 
 	return TRUE;
@@ -1635,24 +1037,12 @@ write_bond_setting (NMConnection *connection, GOutputStream *netplan, GError **e
 #if 0 // TODO: implement team devices in netplan
 static gboolean
 write_team_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-	NMSettingTeam *s_team;
-	const char *config;
-
-	s_team = nm_connection_get_setting_team (connection);
-	if (!s_team) {
-		g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_FAILED,
-		             "Missing '%s' setting", NM_SETTING_TEAM_SETTING_NAME);
-		return FALSE;
-	}
 
-	config = nm_setting_team_get_config (s_team);
-	svSetValueStr (netplan, "TEAM_CONFIG", config);
-
-	*wired = write_wired_for_virtual (connection, netplan);
-
-	return TRUE;
-}
+s_team = nm_connection_get_setting_team (connection);
+nm_setting_team_get_config (s_team)
+write_wired_for_virtual (connection, netplan)
+ifcfg-rh:
+TEAM_CONFIG
 #endif
 
 static guint32
@@ -1691,46 +1081,14 @@ get_setting_default_boolean (NMSetting *setting, const char *prop)
 }
 #endif
 
-static gboolean
-write_bridge_vlans (NMSetting *setting,
-                    const char *property_name,
-                    GOutputStream *netplan,
-                    const char *key,
-                    GError **error)
-{
 #if 0 // TODO: Implement bridge VLANs printif settings.
-	gs_unref_ptrarray GPtrArray *vlans = NULL;
-	NMBridgeVlan *vlan;
-	GString *string;
-	guint i;
-
-	g_object_get (setting, property_name, &vlans, NULL);
-
-	if (!vlans || !vlans->len) {
-		svUnsetValue (netplan, key);
-		return TRUE;
-	}
-
-	string = g_string_new ("");
-	for (i = 0; i < vlans->len; i++) {
-		gs_free char *vlan_str = NULL;
-
-		vlan = vlans->pdata[i];
-		vlan_str = nm_bridge_vlan_to_str (vlan, error);
-		if (!vlan_str)
-			return FALSE;
-		if (string->len > 0)
-			g_string_append (string, ",");
-		nm_utils_escaped_tokens_escape_gstr_assert (vlan_str, ",", string);
-	}
+static gboolean
+write_bridge_vlans (NMSetting *setting, const char *property_name, GOutputStream *netplan, const char *key, GError **error)
 
-	svSetValueStr (netplan, key, string->str);
-	g_string_free (string, TRUE);
+vlan_str = nm_bridge_vlan_to_str (vlan, error)
+nm_utils_escaped_tokens_escape_gstr_assert (vlan_str, ",", string)
 #endif
 
-	return TRUE;
-}
-
 static gboolean
 write_bridge_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
 {
@@ -1890,12 +1248,14 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 	}
 	g_string_free (string, TRUE);
 
+#if 0 // TODO: Bridge VLANS
 	if (!write_bridge_vlans ((NMSetting *) s_port,
 	                         NM_SETTING_BRIDGE_PORT_VLANS,
 	                         netplan,
 	                         "BRIDGE_PORT_VLANS",
 	                         error))
 		return FALSE;
+#endif
 
 	return TRUE;
 }
@@ -1903,94 +1263,54 @@ write_bridge_port_setting (NMConnection *connection, GOutputStream *netplan, GEr
 #if 0 // TODO: implement Team port settings.
 static gboolean
 write_team_port_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-	NMSettingTeamPort *s_port;
-	const char *config;
 
-	s_port = nm_connection_get_setting_team_port (connection);
-	if (!s_port)
-		return TRUE;
-
-	config = nm_setting_team_port_get_config (s_port);
-	svSetValueStr (netplan, "TEAM_PORT_CONFIG", config);
-
-	return TRUE;
-}
+s_port = nm_connection_get_setting_team_port (connection)
+nm_setting_team_port_get_config (s_port)
+ifcfg-rh:
+TEAM_PORT_CONFIG
 #endif
 
 #if 0 // TODO: Implement DCB.
 static gboolean
 write_dcb_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-	NMSettingDcb *s_dcb;
-	NMSettingDcbFlags flags;
-
-	s_dcb = nm_connection_get_setting_dcb (connection);
-	if (!s_dcb) {
-		static const char *clear_keys[] = {
-		    "DCB",
-		    KEY_DCB_APP_FCOE_ENABLE,
-		    KEY_DCB_APP_FCOE_ADVERTISE,
-		    KEY_DCB_APP_FCOE_WILLING,
-		    KEY_DCB_APP_FCOE_MODE,
-		    KEY_DCB_APP_ISCSI_ENABLE,
-		    KEY_DCB_APP_ISCSI_ADVERTISE,
-		    KEY_DCB_APP_ISCSI_WILLING,
-		    KEY_DCB_APP_FIP_ENABLE,
-		    KEY_DCB_APP_FIP_ADVERTISE,
-		    KEY_DCB_APP_FIP_WILLING,
-		    KEY_DCB_PFC_ENABLE,
-		    KEY_DCB_PFC_ADVERTISE,
-		    KEY_DCB_PFC_WILLING,
-		    KEY_DCB_PFC_UP,
-		    KEY_DCB_PG_ENABLE,
-		    KEY_DCB_PG_ADVERTISE,
-		    KEY_DCB_PG_WILLING,
-		    KEY_DCB_PG_ID,
-		    KEY_DCB_PG_PCT,
-		    KEY_DCB_PG_UPPCT,
-		    KEY_DCB_PG_STRICT,
-		    KEY_DCB_PG_UP2TC,
-		    NULL };
-		const char **iter;
-
-		for (iter = clear_keys; *iter; iter++)
-			svUnsetValue (netplan, *iter);
-		return TRUE;
-	}
-
-	svSetValueStr (netplan, "DCB", "yes");
-
-	write_dcb_app (netplan, "APP_FCOE",
-	               nm_setting_dcb_get_app_fcoe_flags (s_dcb),
-	               nm_setting_dcb_get_app_fcoe_priority (s_dcb));
-	if (nm_setting_dcb_get_app_fcoe_flags (s_dcb) & NM_SETTING_DCB_FLAG_ENABLE)
-		svSetValueStr (netplan, KEY_DCB_APP_FCOE_MODE, nm_setting_dcb_get_app_fcoe_mode (s_dcb));
-	else
-		svUnsetValue (netplan, KEY_DCB_APP_FCOE_MODE);
-
-	write_dcb_app (netplan, "APP_ISCSI",
-	               nm_setting_dcb_get_app_iscsi_flags (s_dcb),
-	               nm_setting_dcb_get_app_iscsi_priority (s_dcb));
-	write_dcb_app (netplan, "APP_FIP",
-	               nm_setting_dcb_get_app_fip_flags (s_dcb),
-	               nm_setting_dcb_get_app_fip_priority (s_dcb));
-
-	write_dcb_flags (netplan, "PFC", nm_setting_dcb_get_priority_flow_control_flags (s_dcb));
-	write_dcb_bool_array (netplan, KEY_DCB_PFC_UP, s_dcb,
-	                      nm_setting_dcb_get_priority_flow_control_flags (s_dcb),
-	                      nm_setting_dcb_get_priority_flow_control);
-
-	flags = nm_setting_dcb_get_priority_group_flags (s_dcb);
-	write_dcb_flags (netplan, "PG", flags);
-	write_dcb_uint_array (netplan, KEY_DCB_PG_ID, s_dcb, flags, nm_setting_dcb_get_priority_group_id);
-	write_dcb_percent_array (netplan, KEY_DCB_PG_PCT, s_dcb, flags, nm_setting_dcb_get_priority_group_bandwidth);
-	write_dcb_percent_array (netplan, KEY_DCB_PG_UPPCT, s_dcb, flags, nm_setting_dcb_get_priority_bandwidth);
-	write_dcb_bool_array (netplan, KEY_DCB_PG_STRICT, s_dcb, flags, nm_setting_dcb_get_priority_strict_bandwidth);
-	write_dcb_uint_array (netplan, KEY_DCB_PG_UP2TC, s_dcb, flags, nm_setting_dcb_get_priority_traffic_class);
 
-	return TRUE;
-}
+KEY_DCB_[APP|PFC|PG]_*
+s_dcb = nm_connection_get_setting_dcb (connection)
+nm_setting_dcb_get_app_fcoe_flags (s_dcb)
+nm_setting_dcb_get_app_fcoe_priority (s_dcb)
+nm_setting_dcb_get_app_fcoe_mode (s_dcb)
+nm_setting_dcb_get_app_iscsi_flags (s_dcb)
+nm_setting_dcb_get_app_iscsi_priority (s_dcb)
+nm_setting_dcb_get_app_fip_flags (s_dcb)
+nm_setting_dcb_get_app_fip_priority (s_dcb)
+nm_setting_dcb_get_priority_flow_control_flags (s_dcb)
+nm_setting_dcb_get_priority_flow_control)
+nm_setting_dcb_get_priority_group_flags (s_dcb)
+nm_setting_dcb_get_priority_group_id()
+nm_setting_dcb_get_priority_group_bandwidth()
+nm_setting_dcb_get_priority_bandwidth()
+nm_setting_dcb_get_priority_strict_bandwidth()
+nm_setting_dcb_get_priority_traffic_class()
+NM_SETTING_DCB_FLAG_ENABLE
+ifcfg-rh:
+write_dcb_app (...)
+write_dcb_flags (...)
+write_dcb_uint_array (...)
+write_dcb_percent_array (...)
+write_dcb_bool_array (...)
+DCB
+KEY_DCB_APP_FCOE_MODE
+APP_FCOE
+APP_ISCSI
+APP_FIP
+PFC
+KEY_DCB_PFC_UP
+PG
+KEY_DCB_PG_ID
+KEY_DCB_PG_PCT
+KEY_DCB_PG_UPPCT
+KEY_DCB_PG_STRICT
+KEY_DCB_PG_UP2TC
 #endif
 
 static void
@@ -2022,183 +1342,85 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "        device: %s\n", tmp);
 
-	// TODO: hook up autoconnect ???
-	//g_output_stream_printf (netplan, "ONBOOT", nm_setting_connection_get_autoconnect (s_con));
-
-#if 0
-	vint = nm_setting_connection_get_autoconnect_priority (s_con);
-	g_hash_table_insert (netplan, "AUTOCONNECT_PRIORITY",
-	                      vint != NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT ?
-	                      vint : NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT);
-
-	vint = nm_setting_connection_get_autoconnect_retries (s_con);
-	g_hash_table_insert (netplan, "AUTOCONNECT_RETRIES",
-	                      vint != -1 ?
-	                      vint: -1);
-
-	vint = nm_setting_connection_get_multi_connect (s_con);
-	g_hash_table_insert (netplan, "MULTI_CONNECT",
-	                      vint != NM_CONNECTION_MULTI_CONNECT_DEFAULT ?
-	                      vint: NM_CONNECTION_MULTI_CONNECT_DEFAULT);
-
-	/* Only save the value for master connections */
-	type = nm_setting_connection_get_connection_type (s_con);
-	if (_nm_connection_type_is_master (type)) {
-		NMSettingConnectionAutoconnectSlaves autoconnect_slaves;
-		autoconnect_slaves = nm_setting_connection_get_autoconnect_slaves (s_con);
-		g_hash_table_insert (netplan, "AUTOCONNECT_SLAVES",
-		               autoconnect_slaves == NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES ? "yes" :
-		               autoconnect_slaves == NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO ? "no" : NULL);
-	}
-
-	switch (nm_setting_connection_get_lldp (s_con)) {
-	case NM_SETTING_CONNECTION_LLDP_ENABLE_RX:
-		tmp = "rx";
-		break;
-	case NM_SETTING_CONNECTION_LLDP_DISABLE:
-		tmp = "no";
-		break;
-	default:
-		tmp = NULL;
-	}
-	g_hash_table_insert (netplan, "LLDP", tmp);
+#if 0  // TODO: hook up autoconnect ???
+nm_setting_connection_get_autoconnect (s_con)
+nm_setting_connection_get_autoconnect_priority (s_con)
+nm_setting_connection_get_autoconnect_retries (s_con)
+nm_setting_connection_get_multi_connect (s_con)
+nm_setting_connection_get_connection_type (s_con)
+_nm_connection_type_is_master (type)
+nm_setting_connection_get_autoconnect_slaves (s_con)
+nm_setting_connection_get_lldp (s_con)
+NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_*
+NM_CONNECTION_MULTI_CONNECT_*
+NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_*
+NM_SETTING_CONNECTION_LLDP_*
+ifcfg-rh:
+ONBOOT
+AUTOCONNECT_PRIORITY
+AUTOCONNECT_RETRIES
+MULTI_CONNECT
+AUTOCONNECT_SLAVES
+LLDP
 #endif
 
 #if 0 // TODO: handle user permissions for connections
-	/* Permissions */
-	g_hash_table_insert (netplan, "USERS");
-	n = nm_setting_connection_get_num_permissions (s_con);
-	if (n > 0) {
-		str = g_string_sized_new (n * 20);
-
-		for (i = 0; i < n; i++) {
-			const char *puser = NULL;
-
-			/* Items separated by space for consistency with eg
-			 * IPV6ADDR_SECONDARIES and DOMAIN.
-			 */
-			if (str->len)
-				g_string_append_c (str, ' ');
-
-			if (nm_setting_connection_get_permission (s_con, i, NULL, &puser, NULL))
-				g_string_append (str, puser);
-		}
-		g_hash_table_insert (netplan, "USERS", str->str);
-		g_string_free (str, TRUE);
-	}
-
-	g_hash_table_insert (netplan, "ZONE", nm_setting_connection_get_zone (s_con));
+nm_setting_connection_get_num_permissions (s_con)
+nm_setting_connection_get_permission (s_con, i, NULL, &puser, NULL)
+nm_setting_connection_get_zone (s_con)
+ifcfg-rh:
+USERS
+ZONE
 #endif
 
 #if 0
-	master = nm_setting_connection_get_master (s_con);
-	if (master) {
-		/* The reader prefers the *_UUID variants, however we still try to resolve
-		 * it into an interface name, so that legacy tooling is not confused. */
-		if (!nm_utils_get_testing ()) {
-			/* This is conditional for easier testing. */
-			master_iface = nm_manager_iface_for_uuid (nm_manager_get (), master);
-		}
-		if (!master_iface) {
-			master_iface = master;
-			master = NULL;
-
-		}
-
-		if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME)) {
-			g_hash_table_insert (netplan, "MASTER_UUID", master);
-			g_hash_table_insert (netplan, "MASTER", master_iface);
-			g_hash_table_insert (netplan, "SLAVE", "yes");
-		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BRIDGE_SETTING_NAME)) {
-			g_hash_table_insert (netplan, "BRIDGE_UUID", master);
-			g_hash_table_insert (netplan, "BRIDGE", master_iface);
-		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME)) {
-			g_hash_table_insert (netplan, "TEAM_MASTER_UUID", master);
-			g_hash_table_insert (netplan, "TEAM_MASTER", master_iface);
-		} else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_OVS_PORT_SETTING_NAME)) {
-			g_hash_table_insert (netplan, "OVS_PORT_UUID", master);
-			g_hash_table_insert (netplan, "OVS_PORT", master_iface);
-		} else {
-			_LOGW ("don't know how to set master for a %s slave",
-			       nm_setting_connection_get_slave_type (s_con));
-		}
-	}
+nm_setting_connection_get_master (s_con)
+nm_manager_iface_for_uuid (nm_manager_get (), master)
+nm_setting_connection_is_slave_type (s_con, NM_SETTING_*_SETTING_NAME)
+nm_setting_connection_get_slave_type (s_con)
+ifcfg-rh:
+MASTER_UUID
+MASTER
+SLAVE
+BRIDGE_UUID
+BRIDGE
+TEAM_MASTER_UUID
+TEAM_MASTER
+OVS_PORT_UUID
+OVS_PORT
 #endif
 
 #if 0 // TODO: use devicetype code for bridgeport detection
-	if (nm_streq0 (type, NM_SETTING_TEAM_SETTING_NAME))
-		g_hash_table_insert (netplan, "DEVICETYPE", TYPE_TEAM);
-	else if (master_iface && nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME))
-		g_hash_table_insert (netplan, "DEVICETYPE", TYPE_TEAM_PORT);
+nm_setting_connection_is_slave_type (s_con, NM_SETTING_TEAM_SETTING_NAME)
+NM_SETTING_TEAM_SETTING_NAME
+ifcfg-rh:
+DEVICETYPE (TYPE_TEAM|TYPE_TEAM_PORT)
 #endif
 
-#if 0
-	/* secondary connection UUIDs */
-	n = nm_setting_connection_get_num_secondaries (s_con);
-	if (n > 0) {
-		str = g_string_sized_new (n * 37);
-
-		for (i = 0; i < n; i++) {
-			const char *uuid;
-
-			/* Items separated by space for consistency with eg
-			 * IPV6ADDR_SECONDARIES and DOMAIN.
-			 */
-			if (str->len)
-				g_string_append_c (str, ' ');
-
-			if ((uuid = nm_setting_connection_get_secondary (s_con, i)) != NULL)
-				g_string_append (str, uuid);
-		}
-		g_hash_table_insert (netplan, "SECONDARY_UUIDS", str->str);
-		g_string_free (str, TRUE);
-	}
-
-	vuint32 = nm_setting_connection_get_gateway_ping_timeout (s_con);
-	if (vuint32 != 0)
-		g_hash_table_insert (netplan, "GATEWAY_PING_TIMEOUT", vuint32);
-
-	switch (nm_setting_connection_get_metered (s_con)) {
-	case NM_METERED_YES:
-		g_hash_table_insert (netplan, "CONNECTION_METERED", "yes");
-		break;
-	case NM_METERED_NO:
-		g_hash_table_insert (netplan, "CONNECTION_METERED", "no");
-		break;
-	default:
-		break;
-	}
-
-	vint = nm_setting_connection_get_auth_retries (s_con);
-	if (vint >= 0)
-		g_hash_table_insert (netplan, "AUTH_RETRIES", vint);
-
-	vint32 = nm_setting_connection_get_wait_device_timeout (s_con);
-	if (vint32 == -1)
-		// Do nothing
-	else if ((vint32 % 1000) == 0)
-		g_hash_table_insert (netplan, "DEVTIMEOUT", vint32 / 1000);
-	else {
-		char b[100];
-
-		g_hash_table_insert (netplan,
-		                     "DEVTIMEOUT",
-		                     nm_sprintf_buf (b, "%.3f", ((double) vint) / 1000.0));
-	}
+#if 0  // TODO: secondary connection UUIDs
+nm_setting_connection_get_num_secondaries (s_con)
+nm_setting_connection_get_secondary (s_con, i)
+nm_setting_connection_get_gateway_ping_timeout (s_con)
+nm_setting_connection_get_metered (s_con)
+nm_setting_connection_get_auth_retries (s_con)
+nm_setting_connection_get_wait_device_timeout (s_con)
+NM_METERED_*
+ifcfg-rh:
+SECONDARY_UUIDS
+GATEWAY_PING_TIMEOUT
+CONNECTION_METERED
+AUTH_RETRIES
+DEVTIMEOUT
 #endif
 
-#if 0
-	mdns = nm_setting_connection_get_mdns (s_con);
-	if (mdns != NM_SETTING_CONNECTION_MDNS_DEFAULT) {
-		g_hash_table_insert (netplan, "MDNS", //nm_setting_connection_mdns_get_type (),
-		                     mdns);
-	}
-
-	llmnr = nm_setting_connection_get_llmnr (s_con);
-	if (llmnr != NM_SETTING_CONNECTION_LLMNR_DEFAULT) {
-		g_output_stream_printf (netplan, "LLMNR", //nm_setting_connection_llmnr_get_type (),
-		                        llmnr);
-	}
+#if 0  // TODO: mdns & llmnr
+nm_setting_connection_get_mdns (s_con)
+nm_setting_connection_get_llmnr (s_con)
+NM_SETTING_CONNECTION_MDNS_*
+NM_SETTING_CONNECTION_LLMNR_*
+ifcfg-rh:
+MDNS
+LLMNR
 #endif
 }
 
@@ -2321,154 +1543,66 @@ write_route_settings (NMSettingIPConfig *s_ip, GArray *out_routes)
 #if 0  // TODO: implement proxy support.
 static gboolean
 write_proxy_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-	NMSettingProxy *s_proxy;
-	NMSettingProxyMethod method;
-	const char *pac_url, *pac_script;
-
-	s_proxy = nm_connection_get_setting_proxy (connection);
-	if (!s_proxy)
-		return TRUE;
-
-	svUnsetValue (netplan, "BROWSER_ONLY");
-	svUnsetValue (netplan, "PAC_URL");
-	svUnsetValue (netplan, "PAC_SCRIPT");
-
-	method = nm_setting_proxy_get_method (s_proxy);
-	switch (method) {
-	case NM_SETTING_PROXY_METHOD_AUTO:
-		svSetValueStr (netplan, "PROXY_METHOD", "auto");
-
-		pac_url = nm_setting_proxy_get_pac_url (s_proxy);
-		if (pac_url)
-			svSetValueStr (netplan, "PAC_URL", pac_url);
 
-		pac_script = nm_setting_proxy_get_pac_script (s_proxy);
-		if (pac_script)
-			svSetValueStr (netplan, "PAC_SCRIPT", pac_script);
-
-		break;
-	case NM_SETTING_PROXY_METHOD_NONE:
-		svSetValueStr (netplan, "PROXY_METHOD", "none");
-		break;
-	}
-
-	svSetValueBoolean (netplan, "BROWSER_ONLY", nm_setting_proxy_get_browser_only (s_proxy));
-	return TRUE;
-}
+s_proxy = nm_connection_get_setting_proxy (connection)
+nm_setting_proxy_get_method (s_proxy)
+nm_setting_proxy_get_pac_url (s_proxy)
+nm_setting_proxy_get_pac_script (s_proxy)
+nm_setting_proxy_get_browser_only (s_proxy)
+NM_SETTING_PROXY_METHOD_*
+ifcfg-rh:
+BROWSER_ONLY
+PAC_URL
+PAC_SCRIPT
+PROXY_METHOD
 #endif
 
+#if 0  // TODO: implement user permission settings
 static gboolean
 write_user_setting (NMConnection *connection, GOutputStream *netplan, GError **error)
-{
-#if 0  // TODO: implement user permission settings
-	NMSettingUser *s_user;
-	guint i, len;
-	const char *const*keys;
-
-	s_user = NM_SETTING_USER (nm_connection_get_setting (connection, NM_TYPE_SETTING_USER));
-
-	svUnsetAll (netplan, SV_KEY_TYPE_USER);
 
-	if (!s_user)
-		return TRUE;
-
-	keys = nm_setting_user_get_keys (s_user, &len);
-	if (len) {
-		nm_auto_free_gstring GString *str = g_string_sized_new (100);
-
-		for (i = 0; i < len; i++) {
-			const char *key = keys[i];
-
-			g_string_set_size (str, 0);
-			g_string_append (str, "NM_USER_");
-			nms_netplan_utils_user_key_encode (key, str);
-			svSetValue (netplan,
-			            str->str,
-			            nm_setting_user_get_data (s_user, key));
-		}
-	}
+s_user = NM_SETTING_USER (nm_connection_get_setting (connection, NM_TYPE_SETTING_USER))
+nm_setting_user_get_keys (s_user, &len)
+nms_netplan_utils_user_key_encode (key, str)
+nm_setting_user_get_data (s_user, key)
+ifcfg-rh:
+SV_KEY_TYPE_USER
 #endif
-	return TRUE;
-}
 
 #if 0  // TODO: implement SR-IOV settings
 static void
 write_sriov_setting (NMConnection *connection, GHashTable *netplan)
-{
-	NMSettingSriov *s_sriov;
-	guint i, num = 0;
-	NMTernary b;
-	NMSriovVF *vf;
-	char key[32];
-	char *str;
-
-	svUnsetAll (netplan, SV_KEY_TYPE_SRIOV_VF);
-
-	s_sriov = NM_SETTING_SRIOV (nm_connection_get_setting (connection,
-	                                                       NM_TYPE_SETTING_SRIOV));
-	svSetValueInt64 (netplan, "SRIOV_TOTAL_VFS", nm_setting_sriov_get_total_vfs (s_sriov));
-
-	b = nm_setting_sriov_get_autoprobe_drivers (s_sriov);
-	if (b != NM_TERNARY_DEFAULT)
-		svSetValueInt64 (netplan, "SRIOV_AUTOPROBE_DRIVERS", b);
-	else
-		svUnsetValue (netplan, "SRIOV_AUTOPROBE_DRIVERS");
-
-	num = nm_setting_sriov_get_num_vfs (s_sriov);
-	for (i = 0; i < num; i++) {
-		vf = nm_setting_sriov_get_vf (s_sriov, i);
-		nm_sprintf_buf (key, "SRIOV_VF%u", nm_sriov_vf_get_index (vf));
-		str = nm_utils_sriov_vf_to_str (vf, TRUE, NULL);
-		svSetValueStr (netplan, key, str);
-		g_free (str);
-	}
-}
+
+s_sriov = NM_SETTING_SRIOV (nm_connection_get_setting (connection, NM_TYPE_SETTING_SRIOV))
+nm_setting_sriov_get_total_vfs (s_sriov)
+nm_setting_sriov_get_autoprobe_drivers (s_sriov)
+nm_setting_sriov_get_num_vfs (s_sriov)
+nm_setting_sriov_get_vf (s_sriov, i)
+nm_sriov_vf_get_index (vf)
+nm_utils_sriov_vf_to_str (vf, TRUE, NULL)
+NM_TERNARY_DEFAULT
+ifcfg-rh:
+SV_KEY_TYPE_SRIOV_VF
+SRIOV_TOTAL_VFS
+SRIOV_AUTOPROBE_DRIVERS
+SRIOV_VF%u
 #endif
 
 #if 0 // TODO: implement TC settings for netplan
 static gboolean
 write_tc_setting (NMConnection *connection, GHashTable *netplan, GError **error)
-{
-	NMSettingTCConfig *s_tc;
-	guint i, num, n;
-	char tag[64];
-
-	svUnsetAll (netplan, SV_KEY_TYPE_TC);
-
-	s_tc = nm_connection_get_setting_tc_config (connection);
-	if (!s_tc)
-		return TRUE;
-
-	num = nm_setting_tc_config_get_num_qdiscs (s_tc);
-	for (n = 1, i = 0; i < num; i++) {
-		NMTCQdisc *qdisc;
-		gs_free char *str = NULL;
-
-		qdisc = nm_setting_tc_config_get_qdisc (s_tc, i);
-		str = nm_utils_tc_qdisc_to_str (qdisc, error);
-		if (!str)
-			return FALSE;
 
-		svSetValueStr (netplan, numbered_tag (tag, "QDISC", n), str);
-		n++;
-	}
-
-	num = nm_setting_tc_config_get_num_tfilters (s_tc);
-	for (n = 1, i = 0; i < num; i++) {
-		NMTCTfilter *tfilter;
-		gs_free char *str = NULL;
-
-		tfilter = nm_setting_tc_config_get_tfilter (s_tc, i);
-		str = nm_utils_tc_tfilter_to_str (tfilter, error);
-		if (!str)
-			return FALSE;
-
-		svSetValueStr (netplan, numbered_tag (tag, "FILTER", n), str);
-		n++;
-	}
-	return TRUE;
-}
+s_tc = nm_connection_get_setting_tc_config (connection)
+nm_setting_tc_config_get_num_qdiscs (s_tc)
+nm_setting_tc_config_get_qdisc (s_tc, i)
+nm_utils_tc_qdisc_to_str (qdisc, error)
+nm_setting_tc_config_get_num_tfilters (s_tc)
+nm_setting_tc_config_get_tfilter (s_tc, i)
+nm_utils_tc_tfilter_to_str (tfilter, error)
+ifcfg-rh
+SV_KEY_TYPE_TC
+QDISC
+FILTER
 #endif
 
 static gboolean
@@ -2510,20 +1644,9 @@ write_match_setting (NMConnection *connection, GOutputStream *netplan, GError **
 #if 0  // TODO: implement DNS options (edns0, etc.)
 static void
 write_res_options (GHashTable *netplan, NMSettingIPConfig *s_ip, const char *var)
-{
-	nm_auto_free_gstring GString *value = NULL;
-	guint i, num_options;
 
-	value = g_string_new (NULL);
-	num_options = nm_setting_ip_config_get_num_dns_options (s_ip);
-	for (i = 0; i < num_options; i++) {
-		if (i > 0)
-			g_string_append_c (value, ' ');
-		g_string_append (value, nm_setting_ip_config_get_dns_option (s_ip, i));
-	}
-
-	svSetValue (netplan, var, value->str);
-}
+nm_setting_ip_config_get_num_dns_options (s_ip)
+nm_setting_ip_config_get_dns_option (s_ip, i)
 #endif
 
 static void
@@ -2637,78 +1760,44 @@ write_ip4_setting (NMConnection *connection,
 
 	write_ip4_setting_dhcp_hostname (s_ip4, dhcp_overrides);
 #if 0  // TODO: default-route toggles and peer, dhcp settings.
-	/* DEFROUTE; remember that it has the opposite meaning from never-default */
-	svSetValueBoolean (netplan, "DEFROUTE", !nm_setting_ip_config_get_never_default (s_ip4));
-
-	/* Missing PEERDNS means TRUE, so write it only when is FALSE */
-	svSetValueStr (netplan, "PEERDNS",
-	               nm_setting_ip_config_get_ignore_auto_dns (s_ip4) ? "no" : NULL);
-	/* Missing PEERROUTES means TRUE, so write it only when is FALSE */
-	svSetValueStr (netplan, "PEERROUTES",
-	               nm_setting_ip_config_get_ignore_auto_routes (s_ip4) ? "no" : NULL);
-
-	value = nm_setting_ip_config_get_dhcp_hostname (s_ip4);
-	svSetValueStr (netplan, "DHCP_HOSTNAME", value);
-
-	value = nm_setting_ip4_config_get_dhcp_fqdn (NM_SETTING_IP4_CONFIG (s_ip4));
-	svSetValueStr (netplan, "DHCP_FQDN", value);
-
-	/* Missing DHCP_SEND_HOSTNAME means TRUE, and we prefer not write it explicitly
-	 * in that case, because it is NM-specific variable
-	 */
-	svSetValueStr (netplan, "DHCP_SEND_HOSTNAME",
-	               nm_setting_ip_config_get_dhcp_send_hostname (s_ip4) ? NULL : "no");
-
-	value = nm_setting_ip4_config_get_dhcp_client_id (NM_SETTING_IP4_CONFIG (s_ip4));
-	svSetValueStr (netplan, "DHCP_CLIENT_ID", value);
-
-	timeout = nm_setting_ip_config_get_dhcp_timeout (s_ip4);
-	svSetValueInt64_cond (netplan,
-	                      "IPV4_DHCP_TIMEOUT",
-	                      timeout != 0,
-	                      timeout);
+nm_setting_ip_config_get_never_default (s_ip4)
+nm_setting_ip_config_get_ignore_auto_dns (s_ip4)
+nm_setting_ip_config_get_ignore_auto_routes (s_ip4)
+nm_setting_ip_config_get_dhcp_hostname (s_ip4)
+nm_setting_ip4_config_get_dhcp_fqdn (NM_SETTING_IP4_CONFIG (s_ip4))
+nm_setting_ip_config_get_dhcp_send_hostname (s_ip4)
+nm_setting_ip4_config_get_dhcp_client_id (NM_SETTING_IP4_CONFIG (s_ip4))
+nm_setting_ip_config_get_dhcp_timeout (s_ip4)
+ifcfg-rh:
+DEFROUTE
+PEERDNS
+PEERROUTES
+DHCP_HOSTNAME
+DHCP_FQDN
+DHCP_SEND_HOSTNAME
+DHCP_CLIENT_ID
+IPV4_DHCP_TIMEOUT
 #endif
 
 	write_route_settings (s_ip4, routes);
 
 #if 0  // TODO: Implement route settings here for ipv4
-	svSetValueBoolean (netplan, "IPV4_FAILURE_FATAL", !nm_setting_ip_config_get_may_fail (s_ip4));
-
-	route_metric = nm_setting_ip_config_get_route_metric (s_ip4);
-	svSetValueInt64_cond (netplan,
-	                      "IPV4_ROUTE_METRIC",
-	                      route_metric != -1,
-	                      route_metric);
-
-	route_table = nm_setting_ip_config_get_route_table (s_ip4);
-	svSetValueInt64_cond (netplan,
-	                      "IPV4_ROUTE_TABLE",
-	                      route_table != 0,
-	                      route_table);
-
-	//NM_SET_OUT (out_route_content_svformat, write_route_file_svformat (svFileGetName (netplan), s_ip4));
-	NM_SET_OUT (out_route_content, write_route_settings (s_ip4));
-
-	timeout = nm_setting_ip_config_get_dad_timeout (s_ip4);
-	if (timeout < 0) {
-		svUnsetValue (netplan, "ACD_TIMEOUT");
-		svUnsetValue (netplan, "ARPING_WAIT");
-	} else if (timeout == 0) {
-		svSetValueStr (netplan, "ACD_TIMEOUT", "0");
-		svSetValueStr (netplan, "ARPING_WAIT", "0");
-	} else {
-		svSetValueInt64 (netplan, "ACD_TIMEOUT", timeout);
-		/* Round the value up to next integer for initscripts */
-		svSetValueInt64 (netplan, "ARPING_WAIT", (timeout - 1) / 1000 + 1);
-	}
-
-	priority = nm_setting_ip_config_get_dns_priority (s_ip4);
-	if (priority)
-		svSetValueInt64 (netplan, "IPV4_DNS_PRIORITY", priority);
-	else
-		svUnsetValue (netplan, "IPV4_DNS_PRIORITY");
-
-	write_res_options (netplan, s_ip4, "RES_OPTIONS");
+nm_setting_ip_config_get_may_fail (s_ip4)
+nm_setting_ip_config_get_route_metric (s_ip4)
+nm_setting_ip_config_get_route_table (s_ip4)
+nm_setting_ip_config_get_dad_timeout (s_ip4)
+write_route_settings (s_ip4)
+nm_setting_ip_config_get_dns_priority (s_ip4)
+ifcfg-rh:
+write_route_file_svformat (svFileGetName (netplan)
+write_res_options (netplan, s_ip4, "RES_OPTIONS")
+IPV4_FAILURE_FATAL
+IPV4_ROUTE_METRIC
+IPV4_ROUTE_TABLE
+ACD_TIMEOUT
+ARPING_WAIT
+IPV4_DNS_PRIORITY
+RES_OPTIONS
 #endif
 
 	return TRUE;
@@ -2811,9 +1900,11 @@ write_ip6_setting (NMConnection *connection,
 		// TODO: implement sharing
 	}
 
-	// TODO: implement DUID selection in netplan
-	//svSetValueStr (netplan, "DHCPV6_DUID",
-	//               nm_setting_ip6_config_get_dhcp_duid (NM_SETTING_IP6_CONFIG (s_ip6)));
+#if 0  // TODO: implement DUID selection in netplan
+nm_setting_ip6_config_get_dhcp_duid (NM_SETTING_IP6_CONFIG (s_ip6))
+ifcfg-rh:
+DHCPV6_DUID
+#endif
 
 	write_ip6_setting_dhcp_hostname (s_ip6, dhcp_overrides);
 	// TODO: Write out dhcp_overrides to GOutputStream
@@ -2852,11 +1943,13 @@ write_ip6_setting (NMConnection *connection,
 		g_output_stream_printf(netplan, 0, NULL, NULL, "        use-routes: no\n");
 	}
 
-	// TODO: more about "optional" (see above)
-	//svSetValueStr (netplan, "IPV6_FAILURE_FATAL",
-	//               nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes");
+#if 0  // TODO: more about "optional" (see above)
+nm_setting_ip_config_get_may_fail (s_ip6) ? "no" : "yes")
+ifcfg-rh:
+IPV6_FAILURE_FATAL
+#endif
 
-#if 0  /* TODO: Implement proper writing of the metric value to netplan YAML */
+#if 0  // TODO: Implement proper writing of the metric value to netplan YAML
 	route_metric = nm_setting_ip_config_get_route_metric (s_ip6);
 	if (route_metric != -1)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
@@ -2865,15 +1958,11 @@ write_ip6_setting (NMConnection *connection,
 
 	write_route_settings (s_ip6, routes);
 
-#if 0
-    // TODO: Implement this route as a formal route (rather than gatewayN) to set route table
-    // TODO: Implement RouteTable= (networkd)  for DHCP.
-
-	route_table = nm_setting_ip_config_get_route_table (s_ip6);
-	svSetValueInt64_cond (netplan,
-	                      "IPV6_ROUTE_TABLE",
-	                      route_table != 0,
-	                      route_table);
+#if 0  // TODO: Implement this route as a formal route (rather than gatewayN) to set route table
+// TODO: Implement RouteTable= (networkd)  for DHCP.
+route_table = nm_setting_ip_config_get_route_table (s_ip6)
+ifcfg-rh:
+IPV6_ROUTE_TABLE
 #endif
 
 	/* IPv6 Privacy Extensions */
@@ -2896,22 +1985,17 @@ write_ip6_setting (NMConnection *connection,
 		g_output_stream_printf(netplan, 0, NULL, NULL,
 		                       "      ipv6-address-generation: eui64\n");
 
-#if 0
-	// TODO: Support interface identifier. (not in netplan yet)
-	/* IPv6 tokenized interface identifier */
-	value = nm_setting_ip6_config_get_token (NM_SETTING_IP6_CONFIG (s_ip6));
-	svSetValueStr (netplan, "IPV6_TOKEN", value);
+#if 0  // TODO: Support interface identifier. (not in netplan yet)
+nm_setting_ip6_config_get_token (NM_SETTING_IP6_CONFIG (s_ip6))
+ifcfg-rh:
+IPV6_TOKEN
 #endif
 
-    // TODO: Implement priority for connections (probably NM-specific)
-#if 0
-	priority = nm_setting_ip_config_get_dns_priority (s_ip6);
-	if (priority)
-		svSetValueInt64 (netplan, "IPV6_DNS_PRIORITY", priority);
-	else
-		svUnsetValue (netplan, "IPV6_DNS_PRIORITY");
-
-	write_res_options (netplan, s_ip6, "IPV6_RES_OPTIONS");
+#if 0  // TODO: Implement priority for connections (probably NM-specific)
+nm_setting_ip_config_get_dns_priority (s_ip6)
+ifcfg-rh:
+write_res_options (netplan, s_ip6, "IPV6_RES_OPTIONS")
+IPV6_DNS_PRIORITY
 #endif
 
 	return TRUE;
@@ -3111,8 +2195,8 @@ do_write_construct (NMConnection *connection,
 	//if (!write_ethtool_setting (connection, netplan, error))
 	//	return FALSE;
 
-	if (!write_user_setting (connection, netplan, error))
-		return FALSE;
+	//if (!write_user_setting (connection, netplan, error))
+	//	return FALSE;
 
 	if (!write_match_setting (connection, netplan, error))
 		return FALSE;
-- 
2.25.1


From 4a910ae287f993539106cc393d4207c72f08f7c2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 30 Apr 2020 11:24:00 +0200
Subject: [PATCH 61/78] netplan: fix compiler warning in storage

---
 .../plugins/netplan/nms-netplan-storage.c       | 17 +----------------
 1 file changed, 1 insertion(+), 16 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 713dea262c74da038222e37a6c662876864fad17..7af15e83eed9e8fb8458980811c746be57f20b77 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -205,21 +205,6 @@ nms_netplan_storage_new_connection (NMSNetplanPlugin *plugin,
 	return self;
 }
 
-/* FIXME:
-  CC       src/settings/plugins/netplan/libnm_settings_plugin_netplan_la-nms-netplan-storage.lo
-src/settings/plugins/netplan/nms-netplan-storage.c: In function â_storage_clearâ:
-src/settings/plugins/netplan/nms-netplan-storage.c:217:19: warning: passing argument 1 of âg_file_testâ from incompatible pointer type [-Wincompatible-pointer-types]
-  217 |  if (g_file_test (netplan_yaml, G_FILE_TEST_EXISTS)) {
-      |                   ^~~~~~~~~~~~
-      |                   |
-      |                   GFile * {aka struct _GFile *}
-In file included from /usr/include/glib-2.0/glib.h:48,
-                 from ./shared/nm-default.h:191,
-                 from src/settings/plugins/netplan/nms-netplan-storage.c:9:
-/usr/include/glib-2.0/glib/gfileutils.h:82:45: note: expected âconst gchar *â {aka âconst char *â} but argument is of type âGFile *â {aka âstruct _GFile *â}
-   82 | gboolean g_file_test         (const gchar  *filename,
-      |                               ~~~~~~~~~~~~~~^~~~~~~~
-*/
 static void
 _storage_clear (NMSNetplanStorage *self)
 {
@@ -229,7 +214,7 @@ _storage_clear (NMSNetplanStorage *self)
 
 	/* Make sure that the related netplan .yaml config file gets removed. */
 	netplan_yaml_path = nms_netplan_storage_get_filename (self);
-	if (g_file_test (netplan_yaml, G_FILE_TEST_EXISTS)) {
+	if (g_file_test (netplan_yaml_path, G_FILE_TEST_EXISTS)) {
 		netplan_yaml = g_file_new_for_path (netplan_yaml_path);
 		g_file_delete (netplan_yaml, NULL, &error);
 		if (error)
-- 
2.25.1


From c3d10dffe228772b40390136262b332db49280d5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 30 Apr 2020 11:30:46 +0200
Subject: [PATCH 62/78] netplan:plugin: add note about order of loading
 connections (YAML files)

---
 src/settings/plugins/netplan/nms-netplan-plugin.c | 4 ++++
 src/settings/plugins/netplan/nms-netplan-writer.c | 5 +++++
 2 files changed, 9 insertions(+)

diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.c b/src/settings/plugins/netplan/nms-netplan-plugin.c
index 84c05ea777356de61967c2d434ac86eeb3347462..6c4b029a2ed9f7cf729d9598d868f4f8c211f6af 100644
--- a/src/settings/plugins/netplan/nms-netplan-plugin.c
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.c
@@ -241,6 +241,10 @@ _load_dir (NMSNetplanPlugin *self,
 
 	dupl_filenames = g_hash_table_new_full (nm_str_hash, g_str_equal, NULL, NULL);
 
+	/* XXX: Do we need to load virtual connections (bridge, bond, ...) after
+	 *   physical connections, in order to make libnetplan's YAML parser happy?
+	 *   So all the references to physical interfaces are there, before virtual
+	 *   interfaces try to use them... */
 	while ((f_filename = g_dir_read_name (dir))) {
 		gs_free char *full_path = NULL;
 		NMSNetplanStorage *storage;
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index b0d428fbc6c6725a67482d8a84e4485966ba74ee..09f421d1129cad30b31edd74d8c837b808f494db 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2356,6 +2356,11 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 
 	if (!filename) {
 		filename_str = g_string_sized_new (120);
+		/* XXX: Should we mark connections (YAML files) with definitions of
+		 *   physical VS virtual interfaces (e.g. bridge, bond, ...)? To be
+		 *   able to load physical connections prior to virtual connections,
+		 *   which might contain references to those physical ifaces and could
+		 *   thus break libnetplan's YAML parser. */
 		g_string_printf (filename_str, "NM-%s.yaml", nm_connection_get_uuid (connection));
 
 		netplan_yaml_path = g_build_filename (netplan_dir,
-- 
2.25.1


From dd14d635d2b3e43787816b84209963213b724e02 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 30 Apr 2020 17:43:41 +0200
Subject: [PATCH 63/78] meson: avoid line change, keep the plugin add-only

---
 meson_options.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/meson_options.txt b/meson_options.txt
index de95d49804b6120a4c8b20510782214ff56e1097..67830186d875c06bdc53b08af7de7bf1318e46d8 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -45,7 +45,7 @@ option('ebpf', type: 'combo', choices : ['auto', 'true', 'false'], description:
 option('config_plugins_default', type: 'string', value: '', description: 'Default configuration option for main.plugins setting, used as fallback if the configuration option is unset')
 option('ifcfg_rh', type: 'boolean', value: false, description: 'enable ifcfg-rh configuration plugin (Fedora/RHEL)')
 option('netplan', type: 'boolean', value: false, description: 'enable netplan configuration plugin (Ubuntu)')
-option('ifupdown', type: 'boolean', value: false, description: 'enable ifupdown configuration plugin (Debian)')
+option('ifupdown', type: 'boolean', value: false, description: 'enable ifupdown configuration plugin (Debian/Ubuntu)')
 
 # handlers for resolv.conf
 option('resolvconf', type: 'string', value: '', description: 'Enable resolvconf support')
-- 
2.25.1


From 11dc6597425fac7709a8fcb40669127653015b74 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 30 Apr 2020 17:43:56 +0200
Subject: [PATCH 64/78] netplan: whitespace cleanups

---
 src/settings/plugins/netplan/nms-netplan-reader.c       | 6 +++---
 src/settings/plugins/netplan/nms-netplan-writer.c       | 6 +++---
 src/settings/plugins/netplan/tests/netplan-test-utils.h | 2 +-
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 1aedb6ea661ecf609656717151804167e23b0250..d9e5833a6cf75df96906229f6e876fcbea9963ce 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -715,7 +715,7 @@ parse_wpa_psk (NetplanWifiAccessPoint *ap,
 {
 	gs_free char *psk = NULL;
 	size_t plen;
-  
+
 	/* Passphrase must be between 10 and 66 characters in length because WPA
 	 * hex keys are exactly 64 characters (no quoting), and WPA passphrases
 	 * are between 8 and 63 characters (inclusive), plus optional quoting if
@@ -1590,7 +1590,7 @@ make_bridge_setting (NetplanNetDefinition *nd,
 			              _nm_utils_ascii_str_to_int64 (nd->bridge_params.ageing_time, 10, 0, G_MAXUINT, -1),
 			              NULL);
 	}
-	
+
 #if 0  /* TODO: add the other bridge params */
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_MULTICAST_SNOOPING, nd->bridge_params.stp, NULL);
 	g_object_set (s_bridge, NM_SETTING_BRIDGE_VLAN_FILTERING, nd->bridge_params.stp, NULL);
@@ -1842,7 +1842,7 @@ netplan_ht_debug (gpointer key,
 {
 	NetplanNetDefinition *nd = (NetplanNetDefinition *) value;
 	char *key_id = (char *) key;
-	
+
 	_LOGT ("netplan expected id %s : hashtable id %s", key_id, nd->id);
 }
 
diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 09f421d1129cad30b31edd74d8c837b808f494db..2bb409717cd9b464899b1676305ca04ecc8f7318 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -835,7 +835,7 @@ HWADDR_BLACKLIST
 	    wolan < NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE)
 		g_output_stream_printf (netplan, 0, NULL, NULL, "      wakeonlan: true\n");
 
-#if 0 // TODO: implement s390 subchannels 
+#if 0 // TODO: implement s390 subchannels
 nm_setting_wired_get_s390_subchannels (s_wired)
 nm_setting_wired_get_s390_nettype (s_wired)
 nm_setting_wired_get_s390_option_by_key (s_wired, "portname")
@@ -1335,7 +1335,7 @@ write_connection_setting (NMSettingConnection *s_con, GOutputStream *netplan)
 	if (tmp)
 		g_output_stream_printf (netplan, 0, NULL, NULL,
 		                        "        stable-id: %s\n", tmp);
-	
+
 	// TODO: MOVE to header to identify the device / connection it is under
 	tmp = nm_setting_connection_get_interface_name (s_con);
 	if (tmp)
@@ -2372,7 +2372,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 
 	netplan_yaml = g_file_new_for_path (netplan_yaml_path);
 	_LOGT ("write: path %s / %s / %p", netplan_dir, g_file_get_path(netplan_yaml),
-				out_filename);
+	       out_filename);
 
 	if (out_filename && !filename)
 		*out_filename = g_file_get_path(netplan_yaml);
diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
index 26f2b941a90762c7624d5433d68bce93b8bc563b..304495e643901579743bc7057a6d19f53fbedb1f 100644
--- a/src/settings/plugins/netplan/tests/netplan-test-utils.h
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -2,7 +2,7 @@
 /* NetworkManager settings service - netplan plugin
  *
  * Lukas MÃ¤rdian <lukas.maerdian@canoncial.com>
- * 
+ *
  * Copyright (C) 2020 Canonical, Ltd..
  */
 
-- 
2.25.1


From 47e1594a406da8f6d0308e7e93ecfa9f402726a5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Thu, 30 Apr 2020 17:51:12 +0200
Subject: [PATCH 65/78] netplan: more whitespace cleanups

---
 src/settings/plugins/netplan/nms-netplan-writer.c               | 2 +-
 src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 2bb409717cd9b464899b1676305ca04ecc8f7318..8adb17100b459d522071b5f58d268c4876183c21 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2384,7 +2384,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 				                    error);
 	if (error && *error)
 		_LOGT ("netplan: %s", (*error)->message);
-		
+
 	if (!netplan)
 		return FALSE;
 
diff --git a/src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml b/src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml
index 466ca0c4a36805532ac97bcda9bed5b45a7767f0..578ba5da6f9ba59d5063e475e10dac4ea57c93dc 100644
--- a/src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml
+++ b/src/settings/plugins/netplan/tests/yaml/ethernet-match-mac.yaml
@@ -4,4 +4,4 @@ network:
   ethernets:
     eth0:
       match:
-        macaddress: "de:ad:be:ef:ca:fe"
\ No newline at end of file
+        macaddress: "de:ad:be:ef:ca:fe"
-- 
2.25.1


From c6a0ac0d7c7bc3d561c912409ceae77bed178daf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 4 May 2020 15:17:13 +0200
Subject: [PATCH 66/78] netplan: avoid empty connection names

... which might cause segfaults.
---
 src/settings/plugins/netplan/nms-netplan-reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index d9e5833a6cf75df96906229f6e876fcbea9963ce..3eed14db3f854f9cf5e2f68df49aa616a407ecd4 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -106,7 +106,7 @@ make_connection_name (NetplanNetDefinition *nd,
 
 	/* If the NetworkManager backend already has a NAME, use that */
 	name = nd->backend_settings.nm.name;
-	if (name)
+	if (nm_str_not_empty(name))
 		return name;
 
 	/* Otherwise construct a new NAME */
-- 
2.25.1


From 6e67b7cb13d150b82d86ea5c1e4c19fb604c84a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 4 May 2020 15:34:03 +0200
Subject: [PATCH 67/78] netplan: fix double free

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 3eed14db3f854f9cf5e2f68df49aa616a407ecd4..2010c855adb5a9102f6421d39273871763b6643f 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -140,7 +140,7 @@ make_connection_setting (const char *file,
 	const char *uuid;
 	gs_free char *uuid_free = NULL;
 	const char *v;
-	gs_free char *stable_id = NULL;
+	char *stable_id = NULL;
 	//const char *const *iter;
 	//int vint64, i_val;
 
-- 
2.25.1


From e074aaa921ac9871a1079bdaca63247a5a76ab26 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 5 May 2020 09:38:27 +0200
Subject: [PATCH 68/78] netplan:test: whitespace cleanup

---
 .../plugins/netplan/tests/yaml/test1_key_and_cert.pem     | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem b/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
index dec9aa1b8fd7eb3a369f1cb6033e8e79bdbd297c..0da652f206d620aa4b776aef5ddd9df0885f124a 100644
--- a/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
+++ b/src/settings/plugins/netplan/tests/yaml/test1_key_and_cert.pem
@@ -62,13 +62,13 @@ Certificate:
                     a3:43
                 Exponent: 65537 (0x10001)
         X509v3 extensions:
-            X509v3 Basic Constraints: 
+            X509v3 Basic Constraints:
                 CA:FALSE
-            Netscape Comment: 
+            Netscape Comment:
                 OpenSSL Generated Certificate
-            X509v3 Subject Key Identifier: 
+            X509v3 Subject Key Identifier:
                 CE:03:7E:EF:E7:DE:C9:87:BF:DE:56:F4:C8:A3:40:F6:C8:6F:05:8C
-            X509v3 Authority Key Identifier: 
+            X509v3 Authority Key Identifier:
                 keyid:B8:35:37:32:BE:CF:4F:79:F5:7B:74:B2:F2:10:5A:BA:80:C5:6A:10
                 DirName:/C=US/ST=Berkshire/L=Newbury/O=My Company Ltd/OU=Testing/CN=test/emailAddress=test@test.com
                 serial:EB:E7:64:FB:79:F7:22:19
-- 
2.25.1


From 804942ae3c06eeec49a9bf0f9939e6497580b943 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Mon, 18 May 2020 16:01:07 +0200
Subject: [PATCH 69/78] netplan: avoid duplicate connections, by deleting
 netplan's keyfiles

NM was reading the connection profiles from the YAML file directly via
the nms-netplan plugin, as well as via the nms-keyfile plugin from the
/run/NetworkManager/system-connections/netplan-*.nmconnection keyfiles
generated via 'netplan generate'.

We now delete the keyfiles generated by netplan on nms-netplan plugin
init, to only work with the YAML files directly
---
 .../plugins/netplan/nms-netplan-plugin.c      | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.c b/src/settings/plugins/netplan/nms-netplan-plugin.c
index 6c4b029a2ed9f7cf729d9598d868f4f8c211f6af..00ed2a64355af6be1570464cc11aadd95de2fce5 100644
--- a/src/settings/plugins/netplan/nms-netplan-plugin.c
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.c
@@ -13,6 +13,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <glob.h>
 
 #include <netplan/parse.h>
 
@@ -823,6 +824,9 @@ get_unrecognized_specs (NMSettingsPlugin *plugin)
 static void
 nms_netplan_plugin_init (NMSNetplanPlugin *self)
 {
+	glob_t gl;
+	int rc;
+	const char* netplan_keyfiles = NULL;
 	NMSNetplanPluginPrivate *priv = NMS_NETPLAN_PLUGIN_GET_PRIVATE (self);
 
 	priv->config = g_object_ref (nm_config_get ());
@@ -831,6 +835,21 @@ nms_netplan_plugin_init (NMSNetplanPlugin *self)
 	priv->unrecognized_specs = g_hash_table_new_full (nm_str_hash, g_str_equal, g_free, NULL);
 
 	priv->storages = (NMSettUtilStorages) NM_SETT_UTIL_STORAGES_INIT (priv->storages, nms_netplan_storage_destroy);
+
+	/* Delete all 'netplan-*.nmconnection' keyfiles, created by 'netplan generate'. This avoids
+	 * duplicated connections when reading the same profile from the YAML (via this plugin) and
+	 * from the .nmconnection keyfile (generated by netplan itself).
+	 *
+	 * TODO: A cleaner way would be to shadow the .nmconnection keyfile by using the same UUID
+	 *   for the YAML/plugin connection profile, which must be derived from the filename. */
+	netplan_keyfiles = "/run/NetworkManager/system-connections/netplan-*.nmconnection";
+	rc = glob(netplan_keyfiles, 0, NULL, &gl);
+	if (rc != 0 && rc != GLOB_NOMATCH) {
+		_LOGW("failed to glob for %s: %m\n", netplan_keyfiles);
+	} else {
+		for (size_t i = 0; i < gl.gl_pathc; ++i)
+			unlink(gl.gl_pathv[i]);
+	}
 }
 
 static void
-- 
2.25.1


From 014559538545f4b5413d381cf835ddc99f6bced3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Fri, 29 May 2020 14:59:28 +0200
Subject: [PATCH 70/78] netplan: do not create an (empty) file, if we cannot
 write the connection

---
 src/settings/plugins/netplan/nms-netplan-plugin.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/settings/plugins/netplan/nms-netplan-plugin.c b/src/settings/plugins/netplan/nms-netplan-plugin.c
index 00ed2a64355af6be1570464cc11aadd95de2fce5..81bdf30dcbd2bbf30b2b5a5970e422480e28ec35 100644
--- a/src/settings/plugins/netplan/nms-netplan-plugin.c
+++ b/src/settings/plugins/netplan/nms-netplan-plugin.c
@@ -596,6 +596,9 @@ add_connection (NMSettingsPlugin *plugin,
 		       nm_connection_get_id (connection),
 		       local->message);
 		g_propagate_error (error, local);
+		/* FIXME: There must be a cleaner way to do this...
+		 *   Cleanup the (empty) YAML file we created, if we could not write this connection */
+		g_file_delete (g_file_new_for_path(full_filename), NULL, NULL);
 		return FALSE;
 	}
 
-- 
2.25.1


From fde72a35dc86b23cb5a974ba0564bd165af08c77 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Tue, 2 Jun 2020 14:59:04 +0200
Subject: [PATCH 71/78] netplan: fix storage clear/delete segfault

---
 src/settings/plugins/netplan/nms-netplan-storage.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-storage.c b/src/settings/plugins/netplan/nms-netplan-storage.c
index 7af15e83eed9e8fb8458980811c746be57f20b77..36b778e277629ab1d70a193de782ffdb7cbe711d 100644
--- a/src/settings/plugins/netplan/nms-netplan-storage.c
+++ b/src/settings/plugins/netplan/nms-netplan-storage.c
@@ -217,9 +217,10 @@ _storage_clear (NMSNetplanStorage *self)
 	if (g_file_test (netplan_yaml_path, G_FILE_TEST_EXISTS)) {
 		netplan_yaml = g_file_new_for_path (netplan_yaml_path);
 		g_file_delete (netplan_yaml, NULL, &error);
-		if (error)
+		if (error) {
 			_LOGW ("netplan: %s", error->message);
 			g_error_free(error);
+		}
 	}
 
 	c_list_unlink (&self->parent._storage_lst);
-- 
2.25.1


From 225a5e456521031a4cd5121fd310a093c7cd69c8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 08:33:11 +0200
Subject: [PATCH 72/78] netplan: add simple test scripts to check connection
 handling

---
 src/settings/plugins/netplan/tests/add-del.sh | 29 +++++++++++++++++++
 src/settings/plugins/netplan/tests/rename.sh  | 23 +++++++++++++++
 2 files changed, 52 insertions(+)
 create mode 100644 src/settings/plugins/netplan/tests/add-del.sh
 create mode 100644 src/settings/plugins/netplan/tests/rename.sh

diff --git a/src/settings/plugins/netplan/tests/add-del.sh b/src/settings/plugins/netplan/tests/add-del.sh
new file mode 100644
index 0000000000000000000000000000000000000000..254fe415590adbfe6d997ddf7564fc1c800dd492
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/add-del.sh
@@ -0,0 +1,29 @@
+#!/bin/sh
+killall NetworkManager
+rm /etc/netplan/*
+rm /etc/NetworkManager/system-connections/*
+sleep 1
+#NetworkManager -d -n &
+NetworkManager -n &
+
+sleep 2
+nmcli gen log level trace
+echo
+echo "##### 1st add-del round #####"
+nmcli con add type ethernet
+nmcli con show
+nmcli con del ethernet
+
+#add & del again
+echo
+echo "##### 2nd add-del round #####"
+nmcli con add type ethernet
+nmcli con show
+nmcli con del ethernet
+
+#verify NM is still running and results
+echo
+echo "##### END results #####"
+nmcli con show
+ls -la /etc/netplan/
+ls -la /etc/NetworkManager/system-connections/
diff --git a/src/settings/plugins/netplan/tests/rename.sh b/src/settings/plugins/netplan/tests/rename.sh
new file mode 100644
index 0000000000000000000000000000000000000000..4363a7c539c62afbf36d13c7cbd34c3aa4d7df76
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/rename.sh
@@ -0,0 +1,23 @@
+#!/bin/sh
+killall NetworkManager
+rm /etc/netplan/*
+rm /etc/netplan/.goutput*
+rm /etc/NetworkManager/system-connections/*
+sleep 1
+#NetworkManager -d -n &
+NetworkManager -n &
+
+sleep 2
+nmcli gen log level trace
+echo
+echo "##### 1st add-del round #####"
+nmcli con add type ethernet con-name np1 ifname ens3
+nmcli con show
+nmcli con mod np1 con-name np1x
+
+#verify NM is still running and results
+echo
+echo "##### END results #####"
+nmcli con show
+ls -la /etc/netplan/
+ls -la /etc/NetworkManager/system-connections/
-- 
2.25.1


From 3b30f50dec2c1923e1f0b68055bdc8c5be954af8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 08:58:32 +0200
Subject: [PATCH 73/78] netplan:writer: improve handling of YAML filename/path

---
 .../plugins/netplan/nms-netplan-writer.c      | 28 ++++++++-----------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-writer.c b/src/settings/plugins/netplan/nms-netplan-writer.c
index 8adb17100b459d522071b5f58d268c4876183c21..bfd36938f9f14e6d005848d11840299c82bdc3c0 100644
--- a/src/settings/plugins/netplan/nms-netplan-writer.c
+++ b/src/settings/plugins/netplan/nms-netplan-writer.c
@@ -2355,6 +2355,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 
 
 	if (!filename) {
+		/* Create new YAML config file */
 		filename_str = g_string_sized_new (120);
 		/* XXX: Should we mark connections (YAML files) with definitions of
 		 *   physical VS virtual interfaces (e.g. bridge, bond, ...)? To be
@@ -2366,7 +2367,12 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 		netplan_yaml_path = g_build_filename (netplan_dir,
 		                                      filename_str->str,
 		                                      NULL);
+
+		/* Only return the filename if this is a newly written netplan */
+		if (out_filename)
+			*out_filename = g_strdup(netplan_yaml_path);
 	} else {
+		/* Update given YAML config file */
 		netplan_yaml_path = g_strdup(filename);
 	}
 
@@ -2374,14 +2380,10 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 	_LOGT ("write: path %s / %s / %p", netplan_dir, g_file_get_path(netplan_yaml),
 	       out_filename);
 
-	if (out_filename && !filename)
-		*out_filename = g_file_get_path(netplan_yaml);
-
 	netplan = (GOutputStream *) g_file_replace (netplan_yaml,
 	                                            NULL, FALSE,
 	                                            G_FILE_CREATE_REPLACE_DESTINATION,
-				                    NULL,
-				                    error);
+	                                            NULL, error);
 	if (error && *error)
 		_LOGT ("netplan: %s", (*error)->message);
 
@@ -2396,7 +2398,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 	_LOGT ("write: write connection %s (%s) to file \"%s\"",
 	       nm_connection_get_id (connection),
 	       nm_connection_get_uuid (connection),
-	       *out_filename);
+	       netplan_yaml_path);
 
 	if (!do_write_to_disk (connection,
 	                       netplan,
@@ -2422,7 +2424,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 		gs_free_error GError *local = NULL;
 		gs_free char *unhandled = NULL;
 
-		reread = connection_from_file (*out_filename,
+		reread = connection_from_file (netplan_yaml_path,
 		                               &unhandled,
 		                               &local,
 		                               NULL);
@@ -2430,11 +2432,11 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 
 		if (!reread) {
 			_LOGW ("write: failure to re-read connection \"%s\": %s",
-			       *out_filename, local->message);
+			       netplan_yaml_path, local->message);
 		} else if (unhandled) {
 			g_clear_object (&reread);
 			_LOGW ("write: failure to re-read connection \"%s\": %s",
-			       *out_filename, "connection is unhandled");
+			       netplan_yaml_path, "connection is unhandled");
 		} else {
 			if (out_reread_same) {
 				reread_same = nm_connection_compare (reread, connection, NM_SETTING_COMPARE_FLAG_EXACT);
@@ -2442,7 +2444,7 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 					_LOGD ("write: connection %s (%s) was modified by persisting it to \"%s\" ",
 					       nm_connection_get_id (connection),
 					       nm_connection_get_uuid (connection),
-					       *out_filename);
+					       netplan_yaml_path);
 				}
 			}
 		}
@@ -2451,12 +2453,6 @@ nms_netplan_writer_write_connection (NMConnection *connection,
 		NM_SET_OUT (out_reread_same, reread_same);
 	}
 
-#if 0
-	/* Only return the filename if this was a newly written netplan */
-	if (out_filename && !filename)
-		*out_filename = g_strdup (filename);
-#endif
-
 	return TRUE;
 }
 
-- 
2.25.1


From 95fc6cca992ecfabef02375ae035c519ec09d748 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 09:10:52 +0200
Subject: [PATCH 74/78] netplan: fix random memory corruption/segfaults

FIXME: We're accessing libnetplan's internal data structures here...
  We need to find a better way to clear the netplan netdefs, e.g.
  via a proper API function inside libnetplan.
---
 .../plugins/netplan/nms-netplan-reader.c      |  2 ++
 .../plugins/netplan/nms-netplan-utils.h       | 16 ++++++++++++++
 .../netplan/tests/netplan-test-utils.h        | 20 -----------------
 .../plugins/netplan/tests/test-netplan.c      | 22 -------------------
 4 files changed, 18 insertions(+), 42 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 2010c855adb5a9102f6421d39273871763b6643f..7ae8b35df86be7c4b276a4200e23c625454b6b1e 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1883,6 +1883,8 @@ connection_from_file_full (const char *filename,
 		return NULL;
 	}
 
+	/* Clear libnetplan's netdefs data before parsing new YAML file(s) */
+	nms_netplan_utils_clear_netdefs();
 	if (network_file)
 		ret = netplan_parse_yaml (network_file, error);
 	ret = netplan_parse_yaml (filename, error);
diff --git a/src/settings/plugins/netplan/nms-netplan-utils.h b/src/settings/plugins/netplan/nms-netplan-utils.h
index ef100bdd348f8343ced4e106837f60c06bd48afc..f5607ba861521b6edb8ad9fce80d7af1a211f7c5 100644
--- a/src/settings/plugins/netplan/nms-netplan-utils.h
+++ b/src/settings/plugins/netplan/nms-netplan-utils.h
@@ -11,6 +11,7 @@
 
 #include "nm-connection.h"
 #include "nm-libnm-core-intern/nm-ethtool-utils.h"
+#include <netplan/parse.h>
 
 typedef enum {
 	NMS_NETPLAN_STORAGE_TYPE_RUN       = 1, /* read-write, runtime only, e.g. /run */
@@ -73,6 +74,21 @@ nms_netplan_utils_get_ethtool_name (NMEthtoolID ethtool_id)
 	return _nm_ethtool_netplan_names[ethtool_id - _NM_ETHTOOL_ID_FEATURE_FIRST];
 }
 
+static void
+nms_netplan_utils_clear_netdefs()
+{
+	/* Clear netplan's 'netdefs' data structure, to avoid memory corruption, when YAML files are
+	 * parsed multiple times, overwriting previously allocated memory.
+	 * FIXME: This is ugly! It should be a libnetplan API, instead of accessing internal data directly. */
+
+	/* 'netdefs' is a libnetplan global GHashTable* variable, mapping ID â NetplanNetDefinition* */
+	if(netdefs) {
+		guint n = g_hash_table_size (netdefs);
+		// TODO: make sure that any dynamically allocated netdef data is freed
+		g_hash_table_remove_all (netdefs);
+	}
+}
+
 const NMEthtoolData *nms_netplan_utils_get_ethtool_by_name (const char *name);
 
 #endif  /* _UTILS_H_ */
diff --git a/src/settings/plugins/netplan/tests/netplan-test-utils.h b/src/settings/plugins/netplan/tests/netplan-test-utils.h
index 304495e643901579743bc7057a6d19f53fbedb1f..aa7f9b06fc3020e8091e47ed79f93db7a1804cf7 100644
--- a/src/settings/plugins/netplan/tests/netplan-test-utils.h
+++ b/src/settings/plugins/netplan/tests/netplan-test-utils.h
@@ -21,8 +21,6 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include <netplan/parse.h>
-
 #include "nm-utils.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-wired.h"
@@ -86,18 +84,6 @@ _log_keyfile (NMConnection *con)
 	printf("===== Keyfile =====\n%s\n===== Keyfile End =====\n", str);
 }
 
-static void
-_clear_all_netdefs (void)
-{
-	// Clear all netdefs before each test, so we only access the connection under test.
-	if(netdefs) {
-		guint n = g_hash_table_size (netdefs);
-		// TODO: make sure that any dynamically allocated netdef data is freed
-		g_hash_table_remove_all (netdefs);
-		_LOGT ("cleared %u prior netdefs", n);
-	}
-}
-
 static NMConnection *
 _connection_from_file (const char *filename,
                        const char *network_file,
@@ -110,8 +96,6 @@ _connection_from_file (const char *filename,
 
 	g_assert (!out_unhandled || !*out_unhandled);
 
-	/* Clear netdefs before reading new data from file */
-	_clear_all_netdefs ();
 	connection = nmtst_connection_from_file (filename, network_file, netdef_id,
 	                                         out_unhandled ?: &unhandled_fallback, &error);
 	g_assert_no_error (error);
@@ -252,8 +236,6 @@ _writer_new_connection_no_reread (NMConnection *connection,
 
 	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
 	con_verified = nmtst_connection_duplicate_and_normalize (connection);
-	_clear_all_netdefs();
-
 	success = nms_netplan_writer_write_connection (con_verified,
 	                                               netplan_dir,
 	                                               NULL,
@@ -295,8 +277,6 @@ _writer_new_connection_reread (NMConnection *connection,
 
 	/* Duplicate connection and clear current netdefs, to continue testing with a clean state. */
 	con_verified = nmtst_connection_duplicate_and_normalize (connection);
-	_clear_all_netdefs();
-
 	success = nms_netplan_writer_write_connection (con_verified,
 	                                               netplan_dir,
 	                                               NULL,
diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index c6d021d491a6a35e848168b9e06f61d12d3d5cbe..93a3b48b26dc7099581c48536bca24e4516d9dbf 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -97,7 +97,6 @@ test_write_wired_basic (void)
 	NMSettingIPConfig *s_ip6;
 	GError *error = NULL;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -154,7 +153,6 @@ test_write_wired_static (void)
 	NMIPRoute *route6;
 	GError *error = NULL;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -297,7 +295,6 @@ test_write_wired_static_routes (void)
 	GError *error = NULL;
 	gboolean reread_same = FALSE;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -391,7 +388,6 @@ test_write_routing_rules (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	s_con = (NMSettingConnection *) nm_setting_connection_new ();
@@ -482,7 +478,6 @@ test_write_wifi_main (void)
 	GBytes *ssid;
 	guint32 mtu = 1492;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -544,7 +539,6 @@ test_write_wifi_wpa_eap_tls (void)
 	GBytes *ssid;
 	const char *ssid_data = "blahblah";
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -652,7 +646,6 @@ test_write_wifi_wpa_eap_ttls_mschapv2 (void)
 	GBytes *ssid;
 	const char *ssid_data = "blahblah";
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -744,7 +737,6 @@ test_write_wifi_wpa_eap_peap (void)
 	GBytes *ssid;
 	const char *ssid_data = "blahblah";
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -825,7 +817,6 @@ test_write_wifi_band_a (void)
 	GBytes *ssid;
 	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -871,7 +862,6 @@ test_write_wifi_band_bg (void)
 	GBytes *ssid;
 	const unsigned char ssid_data[] = { 0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x53, 0x49, 0x44 };
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -916,7 +906,6 @@ test_wifi_wowlan_mac_randomization (void)
 	NMSettingIPConfig *s_ip6;
 	GBytes *ssid;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -975,7 +964,6 @@ test_write_bridge_main (void)
 	gs_unref_ptrarray GPtrArray *vlans = NULL;
 	NMBridgeVlan *vlan;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 	g_assert (connection);
 
@@ -1052,7 +1040,6 @@ test_write_bridge_port (void)
 	//gs_unref_ptrarray GPtrArray *vlans = NULL;
 	//NMBridgeVlan *vlan;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 	g_assert (connection);
 
@@ -1135,7 +1122,6 @@ test_write_vlan (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1196,7 +1182,6 @@ test_write_bond_main (void)
 	NMIPAddress *addr;
 	GError *error = NULL;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1265,7 +1250,6 @@ test_write_bond_rr (void)
 	NMIPAddress *addr;
 	GError *error = NULL;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1317,7 +1301,6 @@ test_write_bond_lacp (void)
 	NMIPAddress *addr;
 	GError *error = NULL;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1364,7 +1347,6 @@ test_write_modem_gsm_auto_eui64 (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIP6Config *s_ip6;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1427,7 +1409,6 @@ test_write_modem_gsm (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1492,7 +1473,6 @@ test_write_modem_cdma (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1538,7 +1518,6 @@ test_example_field_wifi (void)
 	NMSettingIPConfig *s_ip6;
 	GBytes *ssid;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
@@ -1617,7 +1596,6 @@ test_example_field_lte (void)
 	NMSettingIPConfig *s_ip4;
 	NMSettingIPConfig *s_ip6;
 
-	_clear_all_netdefs ();
 	connection = nm_simple_connection_new ();
 
 	/* Connection setting */
-- 
2.25.1


From 455ad0b67c74c95e315ef497136bad078f758caf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 09:37:24 +0200
Subject: [PATCH 75/78] netplan: add another test script

---
 src/settings/plugins/netplan/tests/loop.sh | 14 ++++++++++++++
 1 file changed, 14 insertions(+)
 create mode 100644 src/settings/plugins/netplan/tests/loop.sh

diff --git a/src/settings/plugins/netplan/tests/loop.sh b/src/settings/plugins/netplan/tests/loop.sh
new file mode 100644
index 0000000000000000000000000000000000000000..31c34a37a475d48d072f54dde9bd388f7581d3a1
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/loop.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+MY_PATH="`dirname \"$0\"`"
+
+# This is an infinite loop... unitl a segfault crashes it
+# Let it run for a minute or so to check if the tests still crash randomly
+until ! $MY_PATH/test-netplan; do
+    if [ $? -eq 0 ]; then
+        echo "##### Test failed #####"
+	break
+    else
+	echo ""
+        echo "##### All OK - re-run until segfault #####"
+    fi
+done
-- 
2.25.1


From 32bac238cbc9ef85ac5bb84a378029e27e356491 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 10:21:00 +0200
Subject: [PATCH 76/78] netplan:test: cleanup formatting

---
 src/settings/plugins/netplan/tests/test-netplan.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/settings/plugins/netplan/tests/test-netplan.c b/src/settings/plugins/netplan/tests/test-netplan.c
index 93a3b48b26dc7099581c48536bca24e4516d9dbf..a32af959dea227201163cc94ecc96e6f7d520a07 100644
--- a/src/settings/plugins/netplan/tests/test-netplan.c
+++ b/src/settings/plugins/netplan/tests/test-netplan.c
@@ -1230,7 +1230,7 @@ test_write_bond_main (void)
 	 * netplan parser happy. Explicitly choose the "bond0" netdef. */
 	reread = _connection_from_file (testfile,
 	                                TEST_NETPLAN_DIR"/add-base-iface.yaml",
-									"bond0",
+	                                "bond0",
 	                                NULL);
 
 	nmtst_assert_connection_equals (connection, TRUE, reread, FALSE);
-- 
2.25.1


From 3dba59270b0f3ca46e85d786175bbf1e9a67bdc6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 10:26:45 +0200
Subject: [PATCH 77/78] netplan:reader: fix out-of-bound memory access in
 make_bond_setting

---
 src/settings/plugins/netplan/nms-netplan-reader.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/settings/plugins/netplan/nms-netplan-reader.c b/src/settings/plugins/netplan/nms-netplan-reader.c
index 7ae8b35df86be7c4b276a4200e23c625454b6b1e..945c81863e842ae9444b5283b8085b5f07504bf2 100644
--- a/src/settings/plugins/netplan/nms-netplan-reader.c
+++ b/src/settings/plugins/netplan/nms-netplan-reader.c
@@ -1488,7 +1488,11 @@ make_bond_setting (NetplanNetDefinition *nd,
 		GString *ip_targets = g_string_sized_new (200);
 		gint i;
 
-		for (i = 0; (ip_target = (char *)g_array_index(nd->bond_params.arp_ip_targets, gpointer, i)) != NULL; i++) {
+		/* Make sure the arp_ip_targets GArray is NULL terminated, to avoid out-of-bound memory access */
+		gchar *end_of_array = NULL;
+		g_array_append_val(nd->bond_params.arp_ip_targets, end_of_array);
+
+		for (i = 0; (ip_target = g_array_index(nd->bond_params.arp_ip_targets, char*, i)) != NULL; i++) {
 			if (i > 0)
 				g_string_append_printf (ip_targets, ",");
 			g_string_append_printf (ip_targets, "%s", ip_target);
@@ -1930,8 +1934,7 @@ IPV6TUNNELIPV4
 		_LOGE ("invalid netdef");
 		return NULL;
 	}
-	_LOGT ("Selected netdef %s : %d", netdef_id ? netdef_id : (char *) key, netdef->type);
-
+	_LOGT ("Selected netdef %s : %d", netdef->id, netdef->type);
 
 	switch (netdef->type) {
 	case NETPLAN_DEF_TYPE_ETHERNET:
@@ -1970,7 +1973,6 @@ IPV6TUNNELIPV4
 		return g_steal_pointer (&connection);
 	}
 
-
 	if (!connection)
 		return NULL;
 
-- 
2.25.1


From ad407afd33be026a6c96e7bf4ce2d721aa23dea9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lukas=20M=C3=A4rdian?= <lukas.maerdian@canonical.com>
Date: Wed, 3 Jun 2020 10:48:36 +0200
Subject: [PATCH 78/78] netplan: add simple WiFi add-modify test script

---
 src/settings/plugins/netplan/tests/add-mod.sh | 29 +++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 src/settings/plugins/netplan/tests/add-mod.sh

diff --git a/src/settings/plugins/netplan/tests/add-mod.sh b/src/settings/plugins/netplan/tests/add-mod.sh
new file mode 100644
index 0000000000000000000000000000000000000000..1a5ff89ddacfaa1b552b158293eab5412f0af880
--- /dev/null
+++ b/src/settings/plugins/netplan/tests/add-mod.sh
@@ -0,0 +1,29 @@
+#!/bin/sh
+killall NetworkManager
+rm /etc/netplan/*
+rm /etc/NetworkManager/system-connections/*
+sleep 1
+#NetworkManager -d -n &
+NetworkManager -n &
+
+sleep 2
+nmcli gen log level trace
+echo
+echo "##### Adding WiFi connection #####"
+nmcli con add type wifi con-name netplan-wifi ssid TEST_SSID ifname wlan0
+nmcli con show
+cat /etc/netplan/*.yaml | grep -A4 wifis:
+
+#add & del again
+echo
+echo "##### Modify PSK #####"
+nmcli con mod netplan-wifi "802-11-wireless-security.key-mgmt" "wpa-psk" "802-11-wireless-security.psk" "s0s3kr3t"
+nmcli con show
+cat /etc/netplan/*.yaml | grep -A7 wifis:
+
+#verify NM is still running and results
+echo
+echo "##### END results #####"
+nmcli con show
+ls -la /etc/netplan/
+ls -la /etc/NetworkManager/system-connections/
-- 
2.25.1

