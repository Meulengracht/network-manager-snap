Index: nm/src/nm-core-utils.c
===================================================================
--- nm.orig/src/nm-core-utils.c
+++ nm/src/nm-core-utils.c
@@ -44,6 +44,7 @@
 #include "nm-setting-ip6-config.h"
 #include "nm-setting-wireless.h"
 #include "nm-setting-wireless-security.h"
+#include "nm-core-utils.h"
 
 /*
  * Some toolchains (E.G. uClibc 0.9.33 and earlier) don't export
@@ -2978,14 +2979,17 @@ guint8 *
 nm_utils_secret_key_read (gsize *out_key_len, GError **error)
 {
 	guint8 *secret_key = NULL;
+	char *secret_key_path = NULL;
 	gsize key_len;
 
 	/* out_key_len is not optional, because without it you cannot safely
 	 * access the returned memory. */
 	*out_key_len = 0;
 
+	secret_key_path = g_strdup_printf("%s/secret_key", nm_utils_get_state_dir());
+
 	/* Let's try to load a saved secret key first. */
-	if (g_file_get_contents (NMSTATEDIR "/secret_key", (char **) &secret_key, &key_len, NULL)) {
+	if (g_file_get_contents (secret_key_path, (char **) &secret_key, &key_len, NULL)) {
 		if (key_len < 16) {
 			g_set_error_literal (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
 			                     "Key is too short to be usable");
@@ -3007,14 +3011,16 @@ nm_utils_secret_key_read (gsize *out_key
 		}
 
 		key_mask = umask (0077);
-		if (!g_file_set_contents (NMSTATEDIR "/secret_key", (char *) secret_key, key_len, error)) {
-			g_prefix_error (error, "Can't write " NMSTATEDIR "/secret_key: ");
+
+		if (!g_file_set_contents (secret_key_path, (char *) secret_key, key_len, error)) {
+			g_prefix_error (error, "Can't write %s/secret_key: ", secret_key_path);
 			key_len = 0;
 		}
 		umask (key_mask);
 	}
 
 out:
+	g_free (secret_key_path);
 	if (key_len) {
 		*out_key_len = key_len;
 		return secret_key;
@@ -3853,6 +3859,74 @@ nm_utils_ip4_address_is_link_local (in_a
 }
 
 /*****************************************************************************/
+
+const char*
+nm_utils_get_state_dir(void)
+{
+	static const char *state_dir = NULL;
+
+	if (!state_dir)
+		state_dir = g_strdup_printf("%s/state", getenv("SNAP_DATA"));
+
+	return state_dir;
+}
+
+const char*
+nm_utils_get_run_dir(void)
+{
+	static const char *run_dir = NULL;
+
+	if (!run_dir)
+		run_dir = g_strdup_printf("%s/run", getenv("SNAP_DATA"));
+
+	return run_dir;
+}
+
+const char*
+nm_utils_get_plugin_dir(void)
+{
+	static const char *plugin_dir = NULL;
+
+	if (!plugin_dir)
+		plugin_dir = g_strdup_printf("%s/%s", getenv("SNAP"), NMPLUGINDIR);
+
+	return plugin_dir;
+}
+
+const char*
+nm_utils_get_conf_dir(void)
+{
+	static const char *conf_dir = NULL;
+
+	if (!conf_dir)
+		conf_dir = g_strdup_printf("%s/conf", getenv("SNAP_DATA"));
+
+	return conf_dir;
+}
+
+const char*
+nm_utils_get_pppd_plugin_dir (void)
+{
+	static const char *pppd_plugin_dir = NULL;
+
+	if (!pppd_plugin_dir)
+		pppd_plugin_dir = g_strdup_printf("%s%s", getenv("SNAP"), PPPD_PLUGIN_DIR);
+
+	return pppd_plugin_dir;
+}
+
+const char*
+nm_utils_get_conf_device_state_dir (void)
+{
+	static const char *conf_device_state_dir = NULL;
+
+	if (!conf_device_state_dir)
+		conf_device_state_dir = g_strdup_printf("%s/devices", nm_utils_get_run_dir());
+
+	return conf_device_state_dir;
+}
+
+/*****************************************************************************/
 
 /**
  * Takes a pair @timestamp and @duration, and returns the remaining duration based
Index: nm/src/nm-core-utils.h
===================================================================
--- nm.orig/src/nm-core-utils.h
+++ nm/src/nm-core-utils.h
@@ -419,6 +419,13 @@ gboolean nm_utils_lifetime_get (guint32
 
 gboolean nm_utils_ip4_address_is_link_local (in_addr_t addr);
 
+const char* nm_utils_get_state_dir (void);
+const char* nm_utils_get_run_dir (void);
+const char* nm_utils_get_plugin_dir (void);
+const char* nm_utils_get_conf_dir (void);
+const char* nm_utils_get_pppd_plugin_dir (void);
+const char* nm_utils_get_conf_device_state_dir (void);
+
 const char *nm_utils_dnsmasq_status_to_string (int status, char *dest, gsize size);
 
 void nm_utils_get_reverse_dns_domains_ip4 (guint32 ip, guint8 plen, GPtrArray *domains);
Index: nm/src/devices/nm-device-factory.c
===================================================================
--- nm.orig/src/devices/nm-device-factory.c
+++ nm/src/devices/nm-device-factory.c
@@ -32,6 +32,7 @@
 #include "nm-utils.h"
 #include "nm-core-internal.h"
 #include "nm-setting-bluetooth.h"
+#include "nm-core-utils.h"
 
 #define PLUGIN_PREFIX "libnm-device-plugin-"
 
@@ -375,7 +376,7 @@ nm_device_factory_manager_load_factories
 	_ADD_INTERNAL (nm_vlan_device_factory_get_type);
 	_ADD_INTERNAL (nm_vxlan_device_factory_get_type);
 
-	paths = nm_utils_read_plugin_paths (NMPLUGINDIR, PLUGIN_PREFIX);
+	paths = nm_utils_read_plugin_paths (nm_utils_get_plugin_dir(), PLUGIN_PREFIX);
 	if (!paths)
 		return;
 
Index: nm/src/dhcp/nm-dhcp-dhclient.c
===================================================================
--- nm.orig/src/dhcp/nm-dhcp-dhclient.c
+++ nm/src/dhcp/nm-dhcp-dhclient.c
@@ -46,6 +46,7 @@
 #include "NetworkManagerUtils.h"
 #include "nm-dhcp-listener.h"
 #include "nm-dhcp-client-logging.h"
+#include "nm-core-utils.h"
 
 /*****************************************************************************/
 
@@ -123,7 +124,8 @@ get_dhclient_leasefile (int addr_family,
 	char *path;
 
 	/* /var/lib/NetworkManager is the preferred leasefile path */
-	path = g_strdup_printf (NMSTATEDIR "/dhclient%s-%s-%s.lease",
+	path = g_strdup_printf ("%s/dhclient%s-%s-%s.lease",
+							nm_utils_get_state_dir(),
 	                        _addr_family_to_path_part (addr_family),
 	                        uuid,
 	                        iface);
@@ -313,7 +315,8 @@ create_dhclient_config (NMDhcpDhclient *
 
 	g_return_val_if_fail (iface != NULL, NULL);
 
-	new = g_strdup_printf (NMSTATEDIR "/dhclient%s-%s.conf", _addr_family_to_path_part (addr_family), iface);
+	new = g_strdup_printf ("%s/dhclient%s-%s.conf", nm_utils_get_state_dir(),
+						   _addr_family_to_path_part (addr_family), iface);
 	_LOGD ("creating composite dhclient config %s", new);
 
 	orig = find_existing_config (self, addr_family, iface, uuid);
Index: nm/src/dhcp/nm-dhcp-systemd.c
===================================================================
--- nm.orig/src/dhcp/nm-dhcp-systemd.c
+++ nm/src/dhcp/nm-dhcp-systemd.c
@@ -445,7 +445,8 @@ lease_to_ip4_config (NMDedupMultiIndex *
 static char *
 get_leasefile_path (int addr_family, const char *iface, const char *uuid)
 {
-	return g_strdup_printf (NMSTATEDIR "/internal%s-%s-%s.lease",
+	return g_strdup_printf ("%s/dhcp/internal%s-%s-%s.lease",
+							nm_utils_get_state_dir(),
 	                        addr_family == AF_INET6 ? "6" : "",
 	                        uuid,
 	                        iface);
Index: nm/src/main-utils.c
===================================================================
--- nm.orig/src/main-utils.c
+++ nm/src/main-utils.c
@@ -34,6 +34,7 @@
 
 #include "main-utils.h"
 #include "NetworkManagerUtils.h"
+#include "nm-core-utils.h"
 #include "nm-config.h"
 
 static gboolean
@@ -118,7 +119,7 @@ nm_main_utils_ensure_statedir ()
 	gs_free char *parent = NULL;
 	int errsv;
 
-	parent = g_path_get_dirname (NMSTATEDIR);
+	parent = g_path_get_dirname (nm_utils_get_state_dir());
 
 	/* Ensure parent state directories exists */
 	if (   parent
@@ -126,13 +127,13 @@ nm_main_utils_ensure_statedir ()
 	    && parent[1] != '\0'
 	    && g_mkdir_with_parents (parent, 0755) != 0) {
 		errsv = errno;
-		fprintf (stderr, "Cannot create parents for '%s': %s", NMSTATEDIR, g_strerror (errsv));
+		fprintf (stderr, "Cannot create parents for '%s': %s", nm_utils_get_state_dir(), g_strerror (errsv));
 		exit (1);
 	}
 	/* Ensure state directory exists */
-	if (g_mkdir_with_parents (NMSTATEDIR, 0700) != 0) {
+	if (g_mkdir_with_parents (nm_utils_get_state_dir(), 0700) != 0) {
 		errsv = errno;
-		fprintf (stderr, "Cannot create '%s': %s", NMSTATEDIR, g_strerror (errsv));
+		fprintf (stderr, "Cannot create '%s': %s", nm_utils_get_state_dir(), g_strerror (errsv));
 		exit (1);
 	}
 }
@@ -143,20 +144,19 @@ nm_main_utils_ensure_rundir ()
 	int errsv;
 
 	/* Setup runtime directory */
-	if (g_mkdir_with_parents (NMRUNDIR, 0755) != 0) {
+	if (g_mkdir_with_parents (nm_utils_get_run_dir(), 0755) != 0) {
 		errsv = errno;
-		fprintf (stderr, _("Cannot create '%s': %s"), NMRUNDIR, g_strerror (errsv));
+		fprintf (stderr, _("Cannot create '%s': %s"), nm_utils_get_run_dir(), g_strerror (errsv));
 		exit (1);
 	}
 
 	/* NM_CONFIG_DEVICE_STATE_DIR is used to determine whether NM is restarted or not.
 	 * It is important to set NMConfigCmdLineOptions.first_start before creating
 	 * the directory. */
-	nm_assert (g_str_has_prefix (NM_CONFIG_DEVICE_STATE_DIR, NMRUNDIR"/"));
-	if (g_mkdir (NM_CONFIG_DEVICE_STATE_DIR, 0755) != 0) {
+	if (g_mkdir (nm_utils_get_conf_device_state_dir(), 0755) != 0) {
 		errsv = errno;
 		if (errsv != EEXIST) {
-			fprintf (stderr, _("Cannot create '%s': %s"), NM_CONFIG_DEVICE_STATE_DIR, g_strerror (errsv));
+			fprintf (stderr, _("Cannot create '%s': %s"), nm_utils_get_conf_device_state_dir(), g_strerror (errsv));
 			exit (1);
 		}
 	}
Index: nm/src/main.c
===================================================================
--- nm.orig/src/main.c
+++ nm/src/main.c
@@ -53,12 +53,15 @@
 #include "dns/nm-dns-manager.h"
 #include "systemd/nm-sd.h"
 #include "nm-netns.h"
+#include "nm-core-utils.h"
 
 #if !defined(NM_DIST_VERSION)
 # define NM_DIST_VERSION VERSION
 #endif
 
 #define NM_DEFAULT_PID_FILE          NMRUNDIR "/NetworkManager.pid"
+
+/* TODO[snap]: this doesn't appear to be used anywhere else? */
 #define NM_DEFAULT_SYSTEM_STATE_FILE NMSTATEDIR "/NetworkManager.state"
 
 #define CONFIG_ATOMIC_SECTION_PREFIXES ((char **) NULL)
@@ -212,7 +215,7 @@ do_early_setup (int *argc, char **argv[]
 	                                _("NetworkManager monitors all network connections and automatically\nchooses the best connection to use.  It also allows the user to\nspecify wireless access points which wireless cards in the computer\nshould associate with.")))
 		exit (1);
 
-	global_opt.pidfile = global_opt.pidfile ? global_opt.pidfile : g_strdup (NM_DEFAULT_PID_FILE);
+	global_opt.pidfile = global_opt.pidfile ? global_opt.pidfile : g_strdup_printf ("%s/NetworkManager.pid", nm_utils_get_run_dir());
 }
 
 /*
@@ -244,7 +247,7 @@ main (int argc, char *argv[])
 
 	/* we determine a first-start (contrary to a restart during the same boot)
 	 * based on the existence of NM_CONFIG_DEVICE_STATE_DIR directory. */
-	config_cli = nm_config_cmd_line_options_new (!g_file_test (NM_CONFIG_DEVICE_STATE_DIR,
+	config_cli = nm_config_cmd_line_options_new (!g_file_test (nm_utils_get_conf_device_state_dir(),
 	                                                           G_FILE_TEST_IS_DIR));
 
 	do_early_setup (&argc, &argv, config_cli);
Index: nm/src/nm-config.c
===================================================================
--- nm.orig/src/nm-config.c
+++ nm/src/nm-config.c
@@ -167,6 +167,16 @@ static void _set_config_data (NMConfig *
 
 /*****************************************************************************/
 
+static const char *get_no_auto_default_file_path()
+{
+	const char *no_auto_default_file = NULL;
+
+	if (!no_auto_default_file)
+		no_auto_default_file = g_strdup_printf("%s/no-auto-default.state", nm_utils_get_state_dir());
+
+	return no_auto_default_file;
+}
+
 gint
 nm_config_parse_boolean (const char *str,
                          gint default_value)
@@ -2052,13 +2062,14 @@ NMConfigDeviceStateData *
 nm_config_device_state_load (int ifindex)
 {
 	NMConfigDeviceStateData *device_state;
-	char path[NM_STRLEN (NM_CONFIG_DEVICE_STATE_DIR) + 60];
+	gsize dev_state_dir_len = strlen (nm_utils_get_conf_device_state_dir ());
+	char path[dev_state_dir_len + 60];
 	gs_unref_keyfile GKeyFile *kf = NULL;
 	const char *nm_owned_str;
 
 	g_return_val_if_fail (ifindex > 0, NULL);
 
-	nm_sprintf_buf (path, "%s/%d", NM_CONFIG_DEVICE_STATE_DIR, ifindex);
+	nm_sprintf_buf (path, "%s/%d", nm_utils_get_conf_device_state_dir(), ifindex);
 
 	kf = nm_config_create_keyfile ();
 	if (!g_key_file_load_from_file (kf, path, G_KEY_FILE_NONE, NULL))
@@ -2102,7 +2113,7 @@ nm_config_device_state_load_all (void)
 
 	states = g_hash_table_new_full (nm_direct_hash, NULL, NULL, g_free);
 
-	dir = g_dir_open (NM_CONFIG_DEVICE_STATE_DIR, 0, NULL);
+	dir = g_dir_open (nm_utils_get_conf_device_state_dir(), 0, NULL);
 	if (!dir)
 		return states;
 
@@ -2134,7 +2145,8 @@ nm_config_device_state_write (int ifinde
                               guint32 route_metric_default_aspired,
                               guint32 route_metric_default_effective)
 {
-	char path[NM_STRLEN (NM_CONFIG_DEVICE_STATE_DIR) + 60];
+	gsize dev_state_dir_len = strlen (nm_utils_get_conf_device_state_dir ());
+	char path[dev_state_dir_len + 60];
 	GError *local = NULL;
 	gs_unref_keyfile GKeyFile *kf = NULL;
 
@@ -2144,7 +2156,7 @@ nm_config_device_state_write (int ifinde
 
 	nm_assert (!perm_hw_addr_fake || nm_utils_hwaddr_valid (perm_hw_addr_fake, -1));
 
-	nm_sprintf_buf (path, "%s/%d", NM_CONFIG_DEVICE_STATE_DIR, ifindex);
+	nm_sprintf_buf (path, "%s/%d", nm_utils_get_conf_device_state_dir(), ifindex);
 
 	kf = nm_config_create_keyfile ();
 	if (NM_IN_SET (managed,
@@ -2209,12 +2221,15 @@ nm_config_device_state_prune_unseen (GHa
 	const char *fn;
 	int ifindex;
 	gsize fn_len;
-	char buf[NM_STRLEN (NM_CONFIG_DEVICE_STATE_DIR"/") + 30 + 3] = NM_CONFIG_DEVICE_STATE_DIR"/";
-	char *buf_p = &buf[NM_STRLEN (NM_CONFIG_DEVICE_STATE_DIR"/")];
+	gsize dev_state_dir_len = strlen (nm_utils_get_conf_device_state_dir ()) + 1;
+	char buf[dev_state_dir_len + 30 + 3];
+	char *buf_p = &buf[dev_state_dir_len];
+
+	g_snprintf(buf, dev_state_dir_len, "%s/", nm_utils_get_conf_device_state_dir ());
 
 	g_return_if_fail (seen_ifindexes);
 
-	dir = g_dir_open (NM_CONFIG_DEVICE_STATE_DIR, 0, NULL);
+	dir = g_dir_open (nm_utils_get_conf_device_state_dir (), 0, NULL);
 	if (!dir)
 		return;
 
@@ -2525,7 +2540,7 @@ init_sync (GInitable *initable, GCancell
 	if (priv->cli.no_auto_default_file)
 		priv->no_auto_default_file = g_strdup (priv->cli.no_auto_default_file);
 	else
-		priv->no_auto_default_file = g_strdup (DEFAULT_NO_AUTO_DEFAULT_FILE);
+		priv->no_auto_default_file = g_strdup (get_no_auto_default_file_path());
 
 	priv->monitor_connection_files = nm_config_keyfile_get_boolean (keyfile, NM_CONFIG_KEYFILE_GROUP_MAIN, "monitor-connection-files", FALSE);
 
Index: nm/src/ppp/nm-ppp-manager.c
===================================================================
--- nm.orig/src/ppp/nm-ppp-manager.c
+++ nm/src/ppp/nm-ppp-manager.c
@@ -57,7 +57,7 @@
 
 #include "introspection/org.freedesktop.NetworkManager.PPP.h"
 
-#define NM_PPPD_PLUGIN PPPD_PLUGIN_DIR "/nm-pppd-plugin.so"
+#define NM_PPPD_PLUGIN "nm-pppd-plugin.so"
 
 static NM_CACHED_QUARK_FCN ("ppp-manager-secret-tries", ppp_manager_secret_tries_quark)
 
@@ -739,6 +739,7 @@ create_pppd_cmd_line (NMPPPManager *self
 	const char *pppd_binary = NULL;
 	NMCmdLine *cmd;
 	gboolean ppp_debug;
+	char *pppd_plugin_dir;
 	static int unit;
 
 	g_return_val_if_fail (setting != NULL, NULL);
@@ -901,8 +902,12 @@ create_pppd_cmd_line (NMPPPManager *self
 	nm_cmd_line_add_string (cmd, "ipparam");
 	nm_cmd_line_add_string (cmd, nm_exported_object_get_path (NM_EXPORTED_OBJECT (self)));
 
+	pppd_plugin_dir = g_strdup_printf ("%s/%s", nm_utils_get_pppd_plugin_dir (), NM_PPPD_PLUGIN);
+
 	nm_cmd_line_add_string (cmd, "plugin");
-	nm_cmd_line_add_string (cmd, NM_PPPD_PLUGIN);
+	nm_cmd_line_add_string (cmd, pppd_plugin_dir);
+
+	g_free (pppd_plugin_dir);
 
 	if (pppoe && nm_setting_pppoe_get_parent (pppoe)) {
 		/* The PPP interface is going to be renamed, so pass a
Index: nm/src/nm-iface-helper.c
===================================================================
--- nm.orig/src/nm-iface-helper.c
+++ nm/src/nm-iface-helper.c
@@ -48,8 +48,6 @@
 # define NM_DIST_VERSION VERSION
 #endif
 
-#define NMIH_PID_FILE_FMT NMRUNDIR "/nm-iface-helper-%d.pid"
-
 /*****************************************************************************/
 
 static struct {
@@ -385,7 +383,7 @@ main (int argc, char *argv[])
 		fprintf (stderr, _("Failed to find interface index for %s (%s)\n"), global_opt.ifname, strerror (errno));
 		return 1;
 	}
-	pidfile = g_strdup_printf (NMIH_PID_FILE_FMT, gl.ifindex);
+	pidfile = g_strdup_printf ("%s/nm-iface-helper-%d.pid", nm_utils_get_run_dir(), gl.ifindex);
 	nm_main_utils_ensure_not_running_pidfile (pidfile);
 
 	nm_main_utils_ensure_rundir ();
Index: nm/src/settings/nm-settings-connection.c
===================================================================
--- nm.orig/src/settings/nm-settings-connection.c
+++ nm/src/settings/nm-settings-connection.c
@@ -41,9 +41,6 @@
 
 #include "introspection/org.freedesktop.NetworkManager.Settings.Connection.h"
 
-#define SETTINGS_TIMESTAMPS_FILE  NMSTATEDIR "/timestamps"
-#define SETTINGS_SEEN_BSSIDS_FILE NMSTATEDIR "/seen-bssids"
-
 #define AUTOCONNECT_RETRIES_UNSET        -2
 #define AUTOCONNECT_RETRIES_FOREVER      -1
 #define AUTOCONNECT_RESET_RETRIES_TIMER 300
@@ -146,6 +143,27 @@ G_DEFINE_TYPE_WITH_CODE (NMSettingsConne
 
 /*****************************************************************************/
 
+static const char *get_settings_timestamps_path()
+{
+	static const char *timestamps_path = NULL;
+
+	if (!timestamps_path)
+		timestamps_path = g_strdup_printf("%s/timestamps", nm_utils_get_state_dir());
+
+	return timestamps_path;
+}
+
+static const char *get_settings_seen_bssids_path()
+{
+	static const char *seen_bssids_path = NULL;
+
+	if (!seen_bssids_path)
+		seen_bssids_path = g_strdup_printf("%s/seen-bssids", nm_utils_get_state_dir());
+	return seen_bssids_path;
+}
+
+/*****************************************************************************/
+
 static void
 _emit_updated (NMSettingsConnection *self, gboolean by_user)
 {
@@ -748,9 +766,9 @@ remove_entry_from_db (NMSettingsConnecti
 	const char *db_file;
 
 	if (strcmp (db_name, "timestamps") == 0)
-		db_file = SETTINGS_TIMESTAMPS_FILE;
+		db_file = get_settings_timestamps_path();
 	else if (strcmp (db_name, "seen-bssids") == 0)
-		db_file = SETTINGS_SEEN_BSSIDS_FILE;
+		db_file = get_settings_seen_bssids_path();
 	else
 		return;
 
@@ -2432,9 +2450,9 @@ nm_settings_connection_update_timestamp
 
 	/* Save timestamp to timestamps database file */
 	timestamps_file = g_key_file_new ();
-	if (!g_key_file_load_from_file (timestamps_file, SETTINGS_TIMESTAMPS_FILE, G_KEY_FILE_KEEP_COMMENTS, &error)) {
+	if (!g_key_file_load_from_file (timestamps_file, get_settings_timestamps_path(), G_KEY_FILE_KEEP_COMMENTS, &error)) {
 		if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
-			_LOGW ("error parsing timestamps file '%s': %s", SETTINGS_TIMESTAMPS_FILE, error->message);
+			_LOGW ("error parsing timestamps file '%s': %s", get_settings_timestamps_path(), error->message);
 		g_clear_error (&error);
 	}
 
@@ -2445,11 +2463,11 @@ nm_settings_connection_update_timestamp
 
 	data = g_key_file_to_data (timestamps_file, &len, &error);
 	if (data) {
-		g_file_set_contents (SETTINGS_TIMESTAMPS_FILE, data, len, &error);
+		g_file_set_contents (get_settings_timestamps_path(), data, len, &error);
 		g_free (data);
 	}
 	if (error) {
-		_LOGW ("error saving timestamp to file '%s': %s", SETTINGS_TIMESTAMPS_FILE, error->message);
+		_LOGW ("error saving timestamp to file '%s': %s", get_settings_timestamps_path(), error->message);
 		g_error_free (error);
 	}
 	g_key_file_free (timestamps_file);
@@ -2475,7 +2493,7 @@ nm_settings_connection_read_and_fill_tim
 	g_return_if_fail (NM_IS_SETTINGS_CONNECTION (self));
 
 	timestamps_file = g_key_file_new ();
-	if (!g_key_file_load_from_file (timestamps_file, SETTINGS_TIMESTAMPS_FILE, G_KEY_FILE_KEEP_COMMENTS, &error)) {
+	if (!g_key_file_load_from_file (timestamps_file, get_settings_timestamps_path(), G_KEY_FILE_KEEP_COMMENTS, &error)) {
 		_LOGD ("failed to read connection timestamp: %s", error->message);
 		return;
 	}
@@ -2585,10 +2603,10 @@ nm_settings_connection_add_seen_bssid (N
 	/* Save BSSID to seen-bssids file */
 	seen_bssids_file = g_key_file_new ();
 	g_key_file_set_list_separator (seen_bssids_file, ',');
-	if (!g_key_file_load_from_file (seen_bssids_file, SETTINGS_SEEN_BSSIDS_FILE, G_KEY_FILE_KEEP_COMMENTS, &error)) {
+	if (!g_key_file_load_from_file (seen_bssids_file, get_settings_seen_bssids_path(), G_KEY_FILE_KEEP_COMMENTS, &error)) {
 		if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT)) {
 			_LOGW ("error parsing seen-bssids file '%s': %s",
-			       SETTINGS_SEEN_BSSIDS_FILE, error->message);
+			       get_settings_seen_bssids_path(), error->message);
 		}
 		g_clear_error (&error);
 	}
@@ -2599,14 +2617,14 @@ nm_settings_connection_add_seen_bssid (N
 
 	data = g_key_file_to_data (seen_bssids_file, &len, &error);
 	if (data) {
-		g_file_set_contents (SETTINGS_SEEN_BSSIDS_FILE, data, len, &error);
+		g_file_set_contents (get_settings_seen_bssids_path(), data, len, &error);
 		g_free (data);
 	}
 	g_key_file_free (seen_bssids_file);
 
 	if (error) {
 		_LOGW ("error saving seen-bssids to file '%s': %s",
-		       SETTINGS_SEEN_BSSIDS_FILE, error->message);
+		       get_settings_seen_bssids_path(), error->message);
 		g_error_free (error);
 	}
 }
@@ -2631,7 +2649,7 @@ nm_settings_connection_read_and_fill_see
 	/* Get seen BSSIDs from database file */
 	seen_bssids_file = g_key_file_new ();
 	g_key_file_set_list_separator (seen_bssids_file, ',');
-	if (g_key_file_load_from_file (seen_bssids_file, SETTINGS_SEEN_BSSIDS_FILE, G_KEY_FILE_KEEP_COMMENTS, NULL)) {
+	if (g_key_file_load_from_file (seen_bssids_file, get_settings_seen_bssids_path(), G_KEY_FILE_KEEP_COMMENTS, NULL)) {
 		connection_uuid = nm_settings_connection_get_uuid (self);
 		tmp_strv = g_key_file_get_string_list (seen_bssids_file, "seen-bssids", connection_uuid, &len, NULL);
 	}
Index: nm/Makefile.am
===================================================================
--- nm.orig/Makefile.am
+++ nm/Makefile.am
@@ -1135,6 +1135,7 @@ src_cppflags = \
 	-DNMRUNDIR=\"$(nmrundir)\" \
 	-DNMSTATEDIR=\"$(nmstatedir)\" \
 	-DNMLIBDIR=\"$(nmlibdir)\" \
+	-DPPPD_PLUGIN_DIR=\"$(PPPD_PLUGIN_DIR)\" \
 	\
 	-DDHCPCANON_PATH=\"$(DHCPCANON_PATH)\" \
 	-DDHCLIENT_PATH=\"$(DHCLIENT_PATH)\" \
Index: nm/src/settings/nm-settings.c
===================================================================
--- nm.orig/src/settings/nm-settings.c
+++ nm/src/settings/nm-settings.c
@@ -76,6 +76,7 @@
 #include "NetworkManagerUtils.h"
 #include "nm-dispatcher.h"
 #include "nm-hostname-manager.h"
+#include "nm-core-utils.h"
 
 #include "introspection/org.freedesktop.NetworkManager.Settings.h"
 
@@ -717,7 +718,7 @@ load_plugin:
 			int errsv;
 
 			full_name = g_strdup_printf ("nm-settings-plugin-%s", pname);
-			path = g_module_build_path (NMPLUGINDIR, full_name);
+			path = g_module_build_path (nm_utils_get_plugin_dir(), full_name);
 
 			if (stat (path, &st) != 0) {
 				errsv = errno;
Index: nm/src/settings/plugins/keyfile/nms-keyfile-utils.c
===================================================================
--- nm.orig/src/settings/plugins/keyfile/nms-keyfile-utils.c
+++ nm/src/settings/plugins/keyfile/nms-keyfile-utils.c
@@ -30,8 +30,6 @@
 #include "nm-setting-wireless-security.h"
 #include "nm-config.h"
 
-#define NM_CONFIG_KEYFILE_PATH_DEFAULT NMCONFDIR "/system-connections"
-
 /*****************************************************************************/
 
 static const char temp_letters[] =
@@ -163,7 +161,8 @@ nms_keyfile_utils_get_path (void)
 		                                 NM_CONFIG_KEYFILE_KEY_KEYFILE_PATH,
 		                                 NM_CONFIG_GET_VALUE_STRIP | NM_CONFIG_GET_VALUE_NO_EMPTY);
 		if (!path)
-			path = g_strdup (""NM_CONFIG_KEYFILE_PATH_DEFAULT"");
+			path = g_strdup_printf ("%s/system-connections", nm_utils_get_conf_dir());
+
 	}
 	return path;
 }
Index: nm/src/dns/nm-dns-dnsmasq.c
===================================================================
--- nm.orig/src/dns/nm-dns-dnsmasq.c
+++ nm/src/dns/nm-dns-dnsmasq.c
@@ -38,9 +38,6 @@
 #include "nm-bus-manager.h"
 #include "NetworkManagerUtils.h"
 
-#define PIDFILE NMRUNDIR "/dnsmasq.pid"
-#define CONFDIR NMCONFDIR "/dnsmasq.d"
-
 #define DNSMASQ_DBUS_SERVICE "org.freedesktop.NetworkManager.dnsmasq"
 #define DNSMASQ_DBUS_PATH "/uk/org/thekelleys/dnsmasq"
 
@@ -480,6 +477,10 @@ start_dnsmasq (NMDnsDnsmasq *self)
 	guint idx = 0;
 	NMBusManager *dbus_mgr;
 	GDBusConnection *connection;
+	char *pidfile = NULL;
+	char *pidfile_arg = NULL;
+	char *confdir = NULL;
+	char *confdir_arg = NULL;
 
 	if (priv->running) {
 		/* the dnsmasq process is running. Nothing to do. */
@@ -498,12 +499,15 @@ start_dnsmasq (NMDnsDnsmasq *self)
 		return;
 	}
 
+	pidfile = g_strdup_printf ("%s/dnsmasq.pid", nm_utils_get_run_dir ());
+	pidfile_arg = g_strdup_printf ("--pid-file=%s", pidfile);
+
 	argv[idx++] = dm_binary;
 	argv[idx++] = "--no-resolv";  /* Use only commandline */
 	argv[idx++] = "--keep-in-foreground";
 	argv[idx++] = "--no-hosts"; /* don't use /etc/hosts to resolve */
 	argv[idx++] = "--bind-interfaces";
-	argv[idx++] = "--pid-file=" PIDFILE;
+	argv[idx++] = pidfile_arg;
 	argv[idx++] = "--listen-address=127.0.1.1"; /* Should work for both 4 and 6 */
 	argv[idx++] = "--cache-size=0";
 	argv[idx++] = "--clear-on-reload"; /* clear cache when dns server changes */
@@ -511,15 +515,24 @@ start_dnsmasq (NMDnsDnsmasq *self)
 	argv[idx++] = "--proxy-dnssec"; /* Allow DNSSEC to pass through */
 	argv[idx++] = "--enable-dbus=" DNSMASQ_DBUS_SERVICE;
 
+	confdir = g_strdup_printf ("%s/dnsmasq.d", nm_utils_get_conf_dir ());
+	confdir_arg = g_strdup_printf ("--pid-file=%s", confdir);
+
 	/* dnsmasq exits if the conf dir is not present */
-	if (g_file_test (CONFDIR, G_FILE_TEST_IS_DIR))
-		argv[idx++] = "--conf-dir=" CONFDIR;
+	if (g_file_test (confdir, G_FILE_TEST_IS_DIR))
+		argv[idx++] = confdir_arg;
 
 	argv[idx++] = NULL;
 	nm_assert (idx <= G_N_ELEMENTS (argv));
 
 	/* And finally spawn dnsmasq */
-	pid = nm_dns_plugin_child_spawn (NM_DNS_PLUGIN (self), argv, PIDFILE, "bin/dnsmasq");
+	pid = nm_dns_plugin_child_spawn (NM_DNS_PLUGIN (self), argv, pidfile, "bin/dnsmasq");
+
+	g_free (pidfile);
+	g_free (pidfile_arg);
+	g_free (confdir);
+	g_free (confdir_arg);
+
 	if (!pid)
 		return;
 
Index: nm/src/dnsmasq/nm-dnsmasq-manager.c
===================================================================
--- nm.orig/src/dnsmasq/nm-dnsmasq-manager.c
+++ nm/src/dnsmasq/nm-dnsmasq-manager.c
@@ -35,8 +35,6 @@
 #include "NetworkManagerUtils.h"
 #include "nm-core-internal.h"
 
-#define CONFDIR NMCONFDIR "/dnsmasq-shared.d"
-
 /*****************************************************************************/
 
 enum {
@@ -161,6 +159,8 @@ create_dm_cmd_line (const char *iface,
 	const char *dm_binary;
 	const NMPlatformIP4Address *listen_address;
 	guint i, n;
+	char *confdir = NULL;
+	char *confdir_arg = NULL;
 
 	listen_address = nm_ip4_config_get_first_address (ip4_config);
 	g_return_val_if_fail (listen_address, NULL);
@@ -254,10 +254,16 @@ create_dm_cmd_line (const char *iface,
 	nm_cmd_line_add_string (cmd, s->str);
 	g_string_truncate (s, 0);
 
+	confdir = g_strdup_printf("%s/dnsmasq-shared.d", nm_utils_get_conf_dir());
+
 	/* dnsmasq exits if the conf dir is not present */
-	if (g_file_test (CONFDIR, G_FILE_TEST_IS_DIR))
-		nm_cmd_line_add_string (cmd, "--conf-dir=" CONFDIR);
+	if (g_file_test (confdir, G_FILE_TEST_IS_DIR)) {
+		confdir_arg = g_strdup_printf("--conf-dir=%s", confdir);
+		nm_cmd_line_add_string (cmd, confdir_arg);
+	}
 
+	g_free (confdir);
+	g_free (confdir_arg);
 	return cmd;
 }
 
@@ -381,7 +387,7 @@ nm_dnsmasq_manager_new (const char *ifac
 
 	priv = NM_DNSMASQ_MANAGER_GET_PRIVATE (manager);
 	priv->iface = g_strdup (iface);
-	priv->pidfile = g_strdup_printf (RUNSTATEDIR "/nm-dnsmasq-%s.pid", iface);
+	priv->pidfile = g_strdup_printf ("%s/nm-dnsmasq-%s.pid", nm_utils_get_run_dir(), iface);
 
 	return manager;
 }
Index: nm/src/nm-config.h
===================================================================
--- nm.orig/src/nm-config.h
+++ nm/src/nm-config.h
@@ -197,8 +197,6 @@ extern char *_nm_config_match_env;
 
 /*****************************************************************************/
 
-#define NM_CONFIG_DEVICE_STATE_DIR ""NMRUNDIR"/devices"
-
 #define NM_CONFIG_DEFAULT_MAIN_AUTH_POLKIT_BOOL     (nm_streq (""NM_CONFIG_DEFAULT_MAIN_AUTH_POLKIT, "true"))
 #define NM_CONFIG_DEFAULT_LOGGING_AUDIT_BOOL        (nm_streq (""NM_CONFIG_DEFAULT_LOGGING_AUDIT, "true"))
 
Index: nm/src/dns/nm-dns-manager.c
===================================================================
--- nm.orig/src/dns/nm-dns-manager.c
+++ nm/src/dns/nm-dns-manager.c
@@ -623,8 +623,6 @@ _read_link_cached (const char *path, gbo
 	return (*cached = g_file_read_link (path, NULL));
 }
 
-#define MY_RESOLV_CONF NMRUNDIR "/resolv.conf"
-#define MY_RESOLV_CONF_TMP MY_RESOLV_CONF ".tmp"
 #define RESOLV_CONF_TMP "/etc/.resolv.conf.NetworkManager"
 
 static SpawnResult
@@ -644,6 +642,11 @@ update_resolv_conf (NMDnsManager *self,
 	nm_auto_free char *rc_path_real = NULL;
 	gboolean resconf_link_cached = FALSE;
 	gs_free char *resconf_link = NULL;
+	gs_free char *my_resolv_conf = NULL;
+	gs_free char *my_resolv_conf_tmp = NULL;
+
+	my_resolv_conf = g_strdup_printf ("%s/resolv.conf", nm_utils_get_run_dir ());
+	my_resolv_conf_tmp = g_strdup_printf ("%s.tmp", my_resolv_conf);
 
 	/* If we are not managing /etc/resolv.conf and it points to
 	 * MY_RESOLV_CONF, don't write the private DNS configuration to
@@ -654,9 +657,9 @@ update_resolv_conf (NMDnsManager *self,
 	 * internal resolv.conf file. */
 	if (rc_manager == NM_DNS_MANAGER_RESOLV_CONF_MAN_UNMANAGED) {
 		if (nm_streq0 (_read_link_cached (_PATH_RESCONF, &resconf_link_cached, &resconf_link),
-		               MY_RESOLV_CONF)) {
-			_LOGD ("update-resolv-conf: not updating " _PATH_RESCONF
-			       " since it points to " MY_RESOLV_CONF);
+		               my_resolv_conf)) {
+			_LOGD ("update-resolv-conf: not updating %s since it points to %s",
+				   _PATH_RESCONF, my_resolv_conf);
 			return SR_SUCCESS;
 		}
 	}
@@ -689,16 +692,16 @@ update_resolv_conf (NMDnsManager *self,
 		}
 	}
 
-	if ((f = fopen (MY_RESOLV_CONF_TMP, "we")) == NULL) {
+	if ((f = fopen (my_resolv_conf_tmp, "we")) == NULL) {
 		errsv = errno;
 		g_set_error (error,
 		             NM_MANAGER_ERROR,
 		             NM_MANAGER_ERROR_FAILED,
 		             "Could not open %s: %s",
-		             MY_RESOLV_CONF_TMP,
+		             my_resolv_conf_tmp,
 		             g_strerror (errsv));
 		_LOGT ("update-resolv-conf: open temporary file %s failed (%s)",
-		       MY_RESOLV_CONF_TMP, g_strerror (errsv));
+		       my_resolv_conf_tmp, g_strerror (errsv));
 		return SR_ERROR;
 	}
 
@@ -706,7 +709,7 @@ update_resolv_conf (NMDnsManager *self,
 	if (!success) {
 		errsv = errno;
 		_LOGT ("update-resolv-conf: write temporary file %s failed (%s)",
-		       MY_RESOLV_CONF_TMP, g_strerror (errsv));
+		       my_resolv_conf_tmp, g_strerror (errsv));
 	}
 
 	if (fclose (f) < 0) {
@@ -719,25 +722,25 @@ update_resolv_conf (NMDnsManager *self,
 			             NM_MANAGER_ERROR,
 			             NM_MANAGER_ERROR_FAILED,
 			             "Could not close %s: %s",
-			             MY_RESOLV_CONF_TMP,
+			             my_resolv_conf_tmp,
 			             g_strerror (errsv));
 			_LOGT ("update-resolv-conf: close temporary file %s failed (%s)",
-			       MY_RESOLV_CONF_TMP, g_strerror (errsv));
+			       my_resolv_conf_tmp, g_strerror (errsv));
 		}
 		return SR_ERROR;
 	} else if (!success)
 		return SR_ERROR;
 
-	if (rename (MY_RESOLV_CONF_TMP, MY_RESOLV_CONF) < 0) {
+	if (rename (my_resolv_conf_tmp, my_resolv_conf) < 0) {
 		errsv = errno;
 		g_set_error (error,
 		             NM_MANAGER_ERROR,
 		             NM_MANAGER_ERROR_FAILED,
 		             "Could not replace %s: %s",
-		             MY_RESOLV_CONF,
+		             my_resolv_conf,
 		             g_strerror (errno));
 		_LOGT ("update-resolv-conf: failed to rename temporary file %s to %s (%s)",
-		       MY_RESOLV_CONF_TMP, MY_RESOLV_CONF, g_strerror (errsv));
+		       my_resolv_conf_tmp, my_resolv_conf, g_strerror (errsv));
 		return SR_ERROR;
 	}
 
@@ -749,14 +752,14 @@ update_resolv_conf (NMDnsManager *self,
 
 	if (   rc_manager != NM_DNS_MANAGER_RESOLV_CONF_MAN_SYMLINK
 	    || !_read_link_cached (_PATH_RESCONF, &resconf_link_cached, &resconf_link)) {
-		_LOGT ("update-resolv-conf: write internal file %s succeeded", MY_RESOLV_CONF);
+		_LOGT ("update-resolv-conf: write internal file %s succeeded", my_resolv_conf);
 		return SR_SUCCESS;
 	}
 
 	if (!nm_streq0 (_read_link_cached (_PATH_RESCONF, &resconf_link_cached, &resconf_link),
-	                MY_RESOLV_CONF)) {
+	                my_resolv_conf)) {
 		_LOGT ("update-resolv-conf: write internal file %s succeeded (don't touch symlink %s linking to %s)",
-		       MY_RESOLV_CONF, _PATH_RESCONF,
+		       my_resolv_conf, _PATH_RESCONF,
 		       _read_link_cached (_PATH_RESCONF, &resconf_link_cached, &resconf_link));
 		return SR_SUCCESS;
 	}
@@ -775,22 +778,22 @@ update_resolv_conf (NMDnsManager *self,
 		             g_strerror (errsv));
 		_LOGT ("update-resolv-conf: write internal file %s succeeded "
 		       "but canot delete temporary file %s: %s",
-		       MY_RESOLV_CONF, RESOLV_CONF_TMP, g_strerror (errsv));
+		       my_resolv_conf, RESOLV_CONF_TMP, g_strerror (errsv));
 		return SR_ERROR;
 	}
 
-	if (symlink (MY_RESOLV_CONF, RESOLV_CONF_TMP) == -1) {
+	if (symlink (my_resolv_conf, RESOLV_CONF_TMP) == -1) {
 		errsv = errno;
 		g_set_error (error,
 		             NM_MANAGER_ERROR,
 		             NM_MANAGER_ERROR_FAILED,
 		             "Could not create symlink %s pointing to %s: %s",
 		             RESOLV_CONF_TMP,
-		             MY_RESOLV_CONF,
+		             my_resolv_conf,
 		             g_strerror (errsv));
 		_LOGT ("update-resolv-conf: write internal file %s succeeded "
 		       "but failed to symlink %s: %s",
-		       MY_RESOLV_CONF, RESOLV_CONF_TMP, g_strerror (errsv));
+		       my_resolv_conf, RESOLV_CONF_TMP, g_strerror (errsv));
 		return SR_ERROR;
 	}
 
@@ -805,12 +808,12 @@ update_resolv_conf (NMDnsManager *self,
 		             g_strerror (errsv));
 		_LOGT ("update-resolv-conf: write internal file %s succeeded "
 		       "but failed to rename temporary symlink %s to %s: %s",
-		       MY_RESOLV_CONF, RESOLV_CONF_TMP, _PATH_RESCONF, g_strerror (errsv));
+		       my_resolv_conf, RESOLV_CONF_TMP, _PATH_RESCONF, g_strerror (errsv));
 		return SR_ERROR;
 	}
 
 	_LOGT ("update-resolv-conf: write internal file %s succeeded and update symlink %s",
-	       MY_RESOLV_CONF, _PATH_RESCONF);
+	       my_resolv_conf, _PATH_RESCONF);
 	return SR_SUCCESS;
 }
 
@@ -1660,6 +1663,8 @@ again:
 			_clear_plugin (self);
 			priv->plugin = nm_dns_systemd_resolved_new ();
 			plugin_changed = TRUE;
+
+			_LOGI ("init: plugin_changed: systemd-resolvd");
 		}
 		mode = "systemd-resolved";
 	} else if (nm_streq0 (mode, "dnsmasq")) {
